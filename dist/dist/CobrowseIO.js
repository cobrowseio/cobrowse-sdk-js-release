/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 20949:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  arrow: () => (/* binding */ floating_ui_dom_esm_arrow),
  autoPlacement: () => (/* binding */ floating_ui_dom_esm_autoPlacement),
  autoUpdate: () => (/* binding */ autoUpdate),
  computePosition: () => (/* binding */ floating_ui_dom_esm_computePosition),
  detectOverflow: () => (/* binding */ floating_ui_dom_esm_detectOverflow),
  flip: () => (/* binding */ floating_ui_dom_esm_flip),
  getOverflowAncestors: () => (/* reexport */ getOverflowAncestors),
  hide: () => (/* binding */ floating_ui_dom_esm_hide),
  inline: () => (/* binding */ floating_ui_dom_esm_inline),
  limitShift: () => (/* binding */ floating_ui_dom_esm_limitShift),
  offset: () => (/* binding */ floating_ui_dom_esm_offset),
  platform: () => (/* binding */ platform),
  shift: () => (/* binding */ floating_ui_dom_esm_shift),
  size: () => (/* binding */ floating_ui_dom_esm_size)
});

;// ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}



;// ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs



function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = getAlignment(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

function getBoundingRect(rects) {
  const minX = min(...rects.map(rect => rect.left));
  const minY = min(...rects.map(rect => rect.top));
  const maxX = max(...rects.map(rect => rect.right));
  const maxY = max(...rects.map(rect => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = evaluate(options, state);
      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === 'y') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = getSide(placement) === 'left';
          const maxRight = max(...clientRects.map(rect => rect.right));
          const minLeft = min(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset, state);
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};



;// ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== 'undefined';
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [':popover-open', ':modal'].some(selector => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  // https://drafts.csswg.org/css-transforms-2/#individual-transforms
  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}



;// ./node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js





function getCssDimensions(element) {
  const css = getComputedStyle(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}

function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
  // RTL <body> scrollbar.
  getWindowScrollBarX(documentElement, htmlRect));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
      // Firefox with layout.scrollbar.side = 3 in about:config to test this.
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function isStaticPositioned(element) {
  return getComputedStyle(element).position === 'static';
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;

  // Firefox returns the <html> element as the offsetParent if it's non-static,
  // while Chrome and Safari return the <body> element. The <body> element must
  // be used to perform the correct calculations even if the <html> element is
  // non-static.
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};

function isRTL(element) {
  return getComputedStyle(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement,
  isRTL
};

function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        // It's possible that even though the ratio is reported as 1, the
        // element is not actually fully within the IntersectionObserver's root
        // area anymore. This can happen under performance constraints. This may
        // be a bug in the browser's IntersectionObserver implementation. To
        // work around this, we compare the element's bounding rect now with
        // what it was at the time we created the IntersectionObserver. If they
        // are not equal then the element moved, so we refresh.
        refresh();
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
const floating_ui_dom_esm_detectOverflow = detectOverflow;

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const floating_ui_dom_esm_offset = offset;

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const floating_ui_dom_esm_autoPlacement = autoPlacement;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const floating_ui_dom_esm_shift = shift;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const floating_ui_dom_esm_flip = flip;

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const floating_ui_dom_esm_size = size;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const floating_ui_dom_esm_hide = hide;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const floating_ui_dom_esm_arrow = arrow;

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const floating_ui_dom_esm_inline = inline;

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const floating_ui_dom_esm_limitShift = limitShift;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const floating_ui_dom_esm_computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};




/***/ }),

/***/ 60565:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EbmlElementId = void 0;
exports.getEbmlElementIdLength = getEbmlElementIdLength;
exports.getEbmlElementLevel = getEbmlElementLevel;
exports.getEbmlElementName = getEbmlElementName;
exports.readEbmlElementId = readEbmlElementId;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class EbmlElementId {}
exports.EbmlElementId = EbmlElementId;
_defineProperty(EbmlElementId, "Ebml", 0x1a45dfa3);
_defineProperty(EbmlElementId, "EbmlVersion", 0x4286);
_defineProperty(EbmlElementId, "EbmlReadVersion", 0x42f7);
_defineProperty(EbmlElementId, "EbmlMaxIdLength", 0x42f2);
_defineProperty(EbmlElementId, "EbmlMaxSizeLength", 0x42f3);
_defineProperty(EbmlElementId, "DocType", 0x4282);
_defineProperty(EbmlElementId, "DocTypeVersion", 0x4287);
_defineProperty(EbmlElementId, "DocTypeReadVersion", 0x4285);
_defineProperty(EbmlElementId, "Void", 0xec);
_defineProperty(EbmlElementId, "Segment", 0x18538067);
_defineProperty(EbmlElementId, "SeekHead", 0x114d9b74);
_defineProperty(EbmlElementId, "Seek", 0x4dbb);
_defineProperty(EbmlElementId, "SeekID", 0x53ab);
_defineProperty(EbmlElementId, "SeekPosition", 0x53ac);
_defineProperty(EbmlElementId, "Info", 0x1549a966);
_defineProperty(EbmlElementId, "TimestampScale", 0x2ad7b1);
_defineProperty(EbmlElementId, "Duration", 0x4489);
_defineProperty(EbmlElementId, "DateUTC", 0x4461);
_defineProperty(EbmlElementId, "Title", 0x7ba9);
_defineProperty(EbmlElementId, "MuxingApp", 0x4d80);
_defineProperty(EbmlElementId, "WritingApp", 0x5741);
_defineProperty(EbmlElementId, "Cluster", 0x1f43b675);
_defineProperty(EbmlElementId, "Timestamp", 0xe7);
_defineProperty(EbmlElementId, "SimpleBlock", 0xa3);
_defineProperty(EbmlElementId, "SegmentUID", 0x73a4);
_defineProperty(EbmlElementId, "Tracks", 0x1654ae6b);
_defineProperty(EbmlElementId, "TrackEntry", 0xae);
_defineProperty(EbmlElementId, "TrackNumber", 0xd7);
_defineProperty(EbmlElementId, "TrackUID", 0x73c5);
_defineProperty(EbmlElementId, "TrackType", 0x83);
_defineProperty(EbmlElementId, "FlagEnabled", 0xb9);
_defineProperty(EbmlElementId, "FlagDefault", 0x88);
_defineProperty(EbmlElementId, "FlagForced", 0x55aa);
_defineProperty(EbmlElementId, "FlagLacing", 0x9c);
_defineProperty(EbmlElementId, "MinCache", 0x6de7);
_defineProperty(EbmlElementId, "MaxBlockAdditionID", 0x55ee);
_defineProperty(EbmlElementId, "CodecID", 0x86);
_defineProperty(EbmlElementId, "CodecDecodeAll", 0xaa);
_defineProperty(EbmlElementId, "SeekPreRoll", 0x56bb);
_defineProperty(EbmlElementId, "Video", 0xe0);
_defineProperty(EbmlElementId, "FlagInterlaced", 0x9a);
_defineProperty(EbmlElementId, "PixelWidth", 0xb0);
_defineProperty(EbmlElementId, "PixelHeight", 0xba);
_defineProperty(EbmlElementId, "DefaultDuration", 0x23e383);
_defineProperty(EbmlElementId, "TrackTimestampScale", 0x23314f);
_defineProperty(EbmlElementId, "CodecName", 0x258688);
_defineProperty(EbmlElementId, "CodecPrivate", 0x63a2);
_defineProperty(EbmlElementId, "Audio", 0xe1);
_defineProperty(EbmlElementId, "SamplingFrequency", 0xb5);
_defineProperty(EbmlElementId, "Channels", 0x9f);
_defineProperty(EbmlElementId, "Cues", 0x1c53bb6b);
_defineProperty(EbmlElementId, "CuePoint", 0xbb);
_defineProperty(EbmlElementId, "CueTime", 0xb3);
_defineProperty(EbmlElementId, "CueTrackPositions", 0xb7);
_defineProperty(EbmlElementId, "CueTrack", 0xf7);
_defineProperty(EbmlElementId, "CueClusterPosition", 0xf1);
_defineProperty(EbmlElementId, "CueRefTime", 0x96);
_defineProperty(EbmlElementId, "CueBlockNumber", 0x5378);
_defineProperty(EbmlElementId, "Position", 0xa7);
_defineProperty(EbmlElementId, "Colour", 0x55b0);
function getEbmlElementIdLength(firstByteOfEbmlElementId) {
  for (var position = 7; position > 3; position--) {
    if (firstByteOfEbmlElementId & 1 << position) {
      return 8 - position;
    }
  }
  throw Error("invalid ebml element id");
}
function getEbmlElementName(ebmlElementId) {
  switch (ebmlElementId) {
    case EbmlElementId.Ebml:
      return "EBML";
    case EbmlElementId.EbmlVersion:
      return "EBMLVersion";
    case EbmlElementId.EbmlReadVersion:
      return "EBMLReadVersion";
    case EbmlElementId.EbmlMaxIdLength:
      return "EBMLMaxIDLength";
    case EbmlElementId.EbmlMaxSizeLength:
      return "EBMLMaxSizeLength";
    case EbmlElementId.DocType:
      return "DocType";
    case EbmlElementId.DocTypeVersion:
      return "DocTypeVersion";
    case EbmlElementId.DocTypeReadVersion:
      return "DocTypeReadVersion";
    case EbmlElementId.Void:
      return "Void";
    case EbmlElementId.Segment:
      return "Segment";
    case EbmlElementId.SeekHead:
      return "SeekHead";
    case EbmlElementId.Seek:
      return "Seek";
    case EbmlElementId.SeekID:
      return "SeekID";
    case EbmlElementId.SeekPosition:
      return "SeekPosition";
    case EbmlElementId.Info:
      return "Info";
    case EbmlElementId.TimestampScale:
      return "TimestampScale";
    case EbmlElementId.Duration:
      return "Duration";
    case EbmlElementId.DateUTC:
      return "DateUTC";
    case EbmlElementId.Title:
      return "Title";
    case EbmlElementId.MuxingApp:
      return "MuxingApp";
    case EbmlElementId.WritingApp:
      return "WritinApp";
    case EbmlElementId.Cluster:
      return "Cluster";
    case EbmlElementId.Timestamp:
      return "Timestamp";
    case EbmlElementId.SimpleBlock:
      return "SimpleBlock";
    case EbmlElementId.SegmentUID:
      return "SegmentUID (unsupported by WebM)";
    case EbmlElementId.Tracks:
      return "Tracks";
    case EbmlElementId.TrackEntry:
      return "TrackEntry";
    case EbmlElementId.TrackNumber:
      return "TrackNumber";
    case EbmlElementId.TrackUID:
      return "TrackUID";
    case EbmlElementId.TrackType:
      return "TrackType";
    case EbmlElementId.FlagEnabled:
      return "FlagEnabled";
    case EbmlElementId.FlagDefault:
      return "FlagDefault";
    case EbmlElementId.FlagForced:
      return "FlagForced";
    case EbmlElementId.FlagLacing:
      return "FlagLacing";
    case EbmlElementId.MinCache:
      return "MinCache";
    case EbmlElementId.MaxBlockAdditionID:
      return "MaxBlockAdditionID";
    case EbmlElementId.CodecID:
      return "CodecID";
    case EbmlElementId.CodecDecodeAll:
      return "CodecDecodeAll";
    case EbmlElementId.SeekPreRoll:
      return "SeekPreRoll";
    case EbmlElementId.Video:
      return "Video";
    case EbmlElementId.FlagInterlaced:
      return "FlagInterlaced";
    case EbmlElementId.PixelWidth:
      return "PixelWidth";
    case EbmlElementId.PixelHeight:
      return "PixelHeight";
    case EbmlElementId.DefaultDuration:
      return "DefaultDuration";
    case EbmlElementId.TrackTimestampScale:
      return "TrackTimestampScale";
    case EbmlElementId.CodecName:
      return "CodecName";
    case EbmlElementId.CodecPrivate:
      return "CodecPrivate";
    case EbmlElementId.Audio:
      return "Audio";
    case EbmlElementId.SamplingFrequency:
      return "SamplingFrequency";
    case EbmlElementId.Channels:
      return "Channels";
    case EbmlElementId.Cues:
      return "Cues";
    case EbmlElementId.CuePoint:
      return "CuePoint";
    case EbmlElementId.CueTime:
      return "CueTime";
    case EbmlElementId.CueTrackPositions:
      return "CueTrackPositions";
    case EbmlElementId.CueTrack:
      return "CueTrack";
    case EbmlElementId.CueClusterPosition:
      return "CueClusterPosition";
    case EbmlElementId.CueRefTime:
      return "CueRefTime";
    case EbmlElementId.CueBlockNumber:
      return "CueBlockNumber";
    case EbmlElementId.Position:
      return "Position";
    case EbmlElementId.Colour:
      return "Colour";
    default:
      return "";
  }
}
function getEbmlElementLevel(ebmlElementId) {
  switch (ebmlElementId) {
    case EbmlElementId.Ebml:
    case EbmlElementId.Segment:
      return 0;
    case EbmlElementId.Cluster:
    case EbmlElementId.Cues:
    case EbmlElementId.DocType:
    case EbmlElementId.DocTypeReadVersion:
    case EbmlElementId.DocTypeVersion:
    case EbmlElementId.EbmlMaxIdLength:
    case EbmlElementId.EbmlMaxSizeLength:
    case EbmlElementId.EbmlReadVersion:
    case EbmlElementId.EbmlVersion:
    case EbmlElementId.Info:
    case EbmlElementId.SeekHead:
    case EbmlElementId.Tracks:
      return 1;
    case EbmlElementId.CuePoint:
    case EbmlElementId.DateUTC:
    case EbmlElementId.Duration:
    case EbmlElementId.MuxingApp:
    case EbmlElementId.Position:
    case EbmlElementId.SegmentUID:
    case EbmlElementId.Seek:
    case EbmlElementId.SimpleBlock:
    case EbmlElementId.Timestamp:
    case EbmlElementId.TimestampScale:
    case EbmlElementId.Title:
    case EbmlElementId.TrackEntry:
    case EbmlElementId.WritingApp:
      return 2;
    case EbmlElementId.Audio:
    case EbmlElementId.CodecDecodeAll:
    case EbmlElementId.CodecID:
    case EbmlElementId.CodecName:
    case EbmlElementId.CodecPrivate:
    case EbmlElementId.CueTime:
    case EbmlElementId.CueTrackPositions:
    case EbmlElementId.DefaultDuration:
    case EbmlElementId.FlagDefault:
    case EbmlElementId.FlagEnabled:
    case EbmlElementId.FlagForced:
    case EbmlElementId.FlagLacing:
    case EbmlElementId.MaxBlockAdditionID:
    case EbmlElementId.MinCache:
    case EbmlElementId.SeekID:
    case EbmlElementId.SeekPosition:
    case EbmlElementId.SeekPreRoll:
    case EbmlElementId.TrackNumber:
    case EbmlElementId.TrackTimestampScale:
    case EbmlElementId.TrackType:
    case EbmlElementId.TrackUID:
    case EbmlElementId.Video:
      return 3;
    case EbmlElementId.Channels:
    case EbmlElementId.CueBlockNumber:
    case EbmlElementId.CueClusterPosition:
    case EbmlElementId.CueTrack:
    case EbmlElementId.FlagInterlaced:
    case EbmlElementId.PixelHeight:
    case EbmlElementId.PixelWidth:
    case EbmlElementId.SamplingFrequency:
    case EbmlElementId.Colour:
      return 4;
    case EbmlElementId.CueRefTime:
      return 5;
    case EbmlElementId.Void:
      return -1;
    default:
      throw Error("cannot determine level of unknown ebml element with id ".concat(ebmlElementId));
  }
}
function readEbmlElementId(uint8ArrayAggregator, ebmlElement) {
  const ebmlElementIdLength = getEbmlElementIdLength(uint8ArrayAggregator.current);
  if (ebmlElementIdLength > uint8ArrayAggregator.bytesAvailable) {
    return false;
  }
  let ebmlElementId = uint8ArrayAggregator.current;
  for (var ebmlElementTrailingByteIndex = 0; ebmlElementTrailingByteIndex < ebmlElementIdLength - 1; ++ebmlElementTrailingByteIndex) {
    ebmlElementId = ebmlElementId << 8 | uint8ArrayAggregator.nextUnsafe();
  }
  uint8ArrayAggregator.nextUnsafe();
  uint8ArrayAggregator.checkBounds();
  ebmlElement.id = ebmlElementId;
  ebmlElement.idLength = ebmlElementIdLength;
  return true;
}

/***/ }),

/***/ 65260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EbmlElementType = void 0;
exports.getEbmlElementType = getEbmlElementType;
var _ebmlElementId = __webpack_require__(60565);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class EbmlElementType {}
exports.EbmlElementType = EbmlElementType;
_defineProperty(EbmlElementType, "Unknown", 0);
_defineProperty(EbmlElementType, "Master", 1);
_defineProperty(EbmlElementType, "UnsignedInteger", 2);
_defineProperty(EbmlElementType, "SignedInteger", 3);
_defineProperty(EbmlElementType, "String", 4);
_defineProperty(EbmlElementType, "Utf8String", 5);
_defineProperty(EbmlElementType, "Binary", 6);
_defineProperty(EbmlElementType, "Float", 7);
_defineProperty(EbmlElementType, "Date", 8);
function getEbmlElementType(ebmlElementId) {
  switch (ebmlElementId) {
    case _ebmlElementId.EbmlElementId.Segment:
    case _ebmlElementId.EbmlElementId.Ebml:
    case _ebmlElementId.EbmlElementId.SeekHead:
    case _ebmlElementId.EbmlElementId.Seek:
    case _ebmlElementId.EbmlElementId.Cluster:
    case _ebmlElementId.EbmlElementId.Info:
    case _ebmlElementId.EbmlElementId.Tracks:
    case _ebmlElementId.EbmlElementId.TrackEntry:
    case _ebmlElementId.EbmlElementId.Video:
    case _ebmlElementId.EbmlElementId.Audio:
    case _ebmlElementId.EbmlElementId.Cues:
    case _ebmlElementId.EbmlElementId.CuePoint:
    case _ebmlElementId.EbmlElementId.CueTrackPositions:
    case _ebmlElementId.EbmlElementId.Colour:
      return EbmlElementType.Master;
    case _ebmlElementId.EbmlElementId.EbmlVersion:
    case _ebmlElementId.EbmlElementId.EbmlReadVersion:
    case _ebmlElementId.EbmlElementId.EbmlMaxIdLength:
    case _ebmlElementId.EbmlElementId.EbmlMaxSizeLength:
    case _ebmlElementId.EbmlElementId.DocTypeVersion:
    case _ebmlElementId.EbmlElementId.DocTypeReadVersion:
    case _ebmlElementId.EbmlElementId.SeekPosition:
    case _ebmlElementId.EbmlElementId.TimestampScale:
    case _ebmlElementId.EbmlElementId.Timestamp:
    case _ebmlElementId.EbmlElementId.TrackNumber:
    case _ebmlElementId.EbmlElementId.TrackUID:
    case _ebmlElementId.EbmlElementId.TrackType:
    case _ebmlElementId.EbmlElementId.FlagEnabled:
    case _ebmlElementId.EbmlElementId.FlagDefault:
    case _ebmlElementId.EbmlElementId.FlagForced:
    case _ebmlElementId.EbmlElementId.FlagLacing:
    case _ebmlElementId.EbmlElementId.MinCache:
    case _ebmlElementId.EbmlElementId.MaxBlockAdditionID:
    case _ebmlElementId.EbmlElementId.CodecDecodeAll:
    case _ebmlElementId.EbmlElementId.SeekPreRoll:
    case _ebmlElementId.EbmlElementId.FlagInterlaced:
    case _ebmlElementId.EbmlElementId.PixelWidth:
    case _ebmlElementId.EbmlElementId.PixelHeight:
    case _ebmlElementId.EbmlElementId.DefaultDuration:
    case _ebmlElementId.EbmlElementId.Channels:
    case _ebmlElementId.EbmlElementId.CueTime:
    case _ebmlElementId.EbmlElementId.CueTrack:
    case _ebmlElementId.EbmlElementId.CueClusterPosition:
    case _ebmlElementId.EbmlElementId.CueRefTime:
    case _ebmlElementId.EbmlElementId.CueBlockNumber:
    case _ebmlElementId.EbmlElementId.Position:
      return EbmlElementType.UnsignedInteger;
    case _ebmlElementId.EbmlElementId.DocType:
    case _ebmlElementId.EbmlElementId.CodecID:
      return EbmlElementType.String;
    case _ebmlElementId.EbmlElementId.Void:
    case _ebmlElementId.EbmlElementId.SeekID:
    case _ebmlElementId.EbmlElementId.SimpleBlock:
    case _ebmlElementId.EbmlElementId.SegmentUID:
    case _ebmlElementId.EbmlElementId.CodecPrivate:
      return EbmlElementType.Binary;
    case _ebmlElementId.EbmlElementId.Duration:
    case _ebmlElementId.EbmlElementId.TrackTimestampScale:
    case _ebmlElementId.EbmlElementId.SamplingFrequency:
      return EbmlElementType.Float;
    case _ebmlElementId.EbmlElementId.DateUTC:
      return EbmlElementType.Date;
    case _ebmlElementId.EbmlElementId.Title:
    case _ebmlElementId.EbmlElementId.MuxingApp:
    case _ebmlElementId.EbmlElementId.WritingApp:
    case _ebmlElementId.EbmlElementId.CodecName:
      return EbmlElementType.Utf8String;
    default:
      throw Error("cannot determine type of unknown ebml element with id ".concat(ebmlElementId));
  }
}

/***/ }),

/***/ 415:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.epochTimestampOffset = exports.EbmlElement = void 0;
exports.getEbmlElementSizeLength = getEbmlElementSizeLength;
exports.getEbmlElementValue = getEbmlElementValue;
exports.readEbmlLementSize = readEbmlLementSize;
var _ebmlElementId = __webpack_require__(60565);
var _ebmlElementType = __webpack_require__(65260);
var _utilities = __webpack_require__(12087);
const epochTimestampOffset = exports.epochTimestampOffset = 978307200;
class EbmlElement {
  get elementSize() {
    return this.idLength + this.sizeLength + this.size;
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this.name = (0, _ebmlElementId.getEbmlElementName)(this._id);
    this.type = (0, _ebmlElementType.getEbmlElementType)(this._id);
  }
}
exports.EbmlElement = EbmlElement;
function getEbmlElementSizeLength(firstByteOfEbmlElementSize) {
  if (firstByteOfEbmlElementSize == 1) return 8;
  for (var position = 7; position > 0; position--) {
    if (firstByteOfEbmlElementSize & 1 << position) {
      return 8 - position;
    }
  }
  throw Error("invalid ebml element size");
}
function readEbmlLementSize(uint8ArrayAggregator, ebmlElement) {
  const ebmlElementSizeLength = getEbmlElementSizeLength(uint8ArrayAggregator.current);
  if (ebmlElementSizeLength > uint8ArrayAggregator.bytesAvailable) {
    return false;
  }
  let ebmlElementSize = uint8ArrayAggregator.current - (1 << 8 - ebmlElementSizeLength);
  for (var ebmlElementSizeTrailingByteIndex = 0; ebmlElementSizeTrailingByteIndex < ebmlElementSizeLength - 1; ++ebmlElementSizeTrailingByteIndex) {
    ebmlElementSize = ebmlElementSize << 8 | uint8ArrayAggregator.nextUnsafe();
  }
  uint8ArrayAggregator.nextUnsafe();
  uint8ArrayAggregator.checkBounds();
  ebmlElement.sizeLength = ebmlElementSizeLength;
  /*
      it does not make sense to use more than a single byte to signal unknown length but still let's
      keep a proper check instead of checking (ebmlElementSizeLength === 1 && ebmlElementSize === 0x7f)
  */
  if (ebmlElementSize === 1 << ebmlElementSizeLength * 8 - 1) ebmlElement.size = -1;else ebmlElement.size = ebmlElementSize;
  return true;
}
function getEbmlElementValue(type, data) {
  switch (type) {
    case _ebmlElementType.EbmlElementType.UnsignedInteger:
    case _ebmlElementType.EbmlElementType.SignedInteger:
      return (0, _utilities.readBigEndianNumber)(data);
    case _ebmlElementType.EbmlElementType.String:
      return String.fromCharCode.apply(null, data);
    case _ebmlElementType.EbmlElementType.Utf8String:
    case _ebmlElementType.EbmlElementType.Float:
      // do not bother with these until they are really needed
      throw new Error("cannot read value of element with type ".concat(type));
    case _ebmlElementType.EbmlElementType.Date:
      return epochTimestampOffset + (0, _utilities.readBigEndianNumber)(data);
    case _ebmlElementType.EbmlElementType.Binary:
      return data;
  }
}

/***/ }),

/***/ 62343:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "MediaInfo", ({
  enumerable: true,
  get: function () {
    return _mediaInfo.MediaInfo;
  }
}));
Object.defineProperty(exports, "MediaPacket", ({
  enumerable: true,
  get: function () {
    return _mediaPacket.MediaPacket;
  }
}));
Object.defineProperty(exports, "MediaRecorderDemuxer", ({
  enumerable: true,
  get: function () {
    return _mediaRecorderDemuxer.MediaRecorderDemuxer;
  }
}));
Object.defineProperty(exports, "MediaRecorderDemuxerEvents", ({
  enumerable: true,
  get: function () {
    return _mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents;
  }
}));
Object.defineProperty(exports, "createMediaRecorderDemuxer", ({
  enumerable: true,
  get: function () {
    return _mediaRecorderDemuxerFactory.createMediaRecorderDemuxer;
  }
}));
var _mediaRecorderDemuxer = __webpack_require__(53142);
var _mediaRecorderDemuxerEvents = __webpack_require__(28538);
var _mediaRecorderDemuxerFactory = __webpack_require__(75457);
var _mediaPacket = __webpack_require__(30440);
var _mediaInfo = __webpack_require__(47472);

/***/ }),

/***/ 47472:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MediaInfo = void 0;
class MediaInfo {
  constructor() {
    this.videoTrack = {};
    this.audioTrack = {};
  }
}
exports.MediaInfo = MediaInfo;

/***/ }),

/***/ 30440:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MediaPacket = void 0;
class MediaPacket {
  constructor(data, ptsMs) {
    this.data = data;
    this.ptsMs = ptsMs;
  }
}
exports.MediaPacket = MediaPacket;

/***/ }),

/***/ 28538:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MediaRecorderDemuxerEvents = void 0;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class MediaRecorderDemuxerEvents {}
exports.MediaRecorderDemuxerEvents = MediaRecorderDemuxerEvents;
_defineProperty(MediaRecorderDemuxerEvents, "Error", 'error');
_defineProperty(MediaRecorderDemuxerEvents, "MediaInfo", 'media-info');
_defineProperty(MediaRecorderDemuxerEvents, "MediaPacket", 'media-packet');

/***/ }),

/***/ 75457:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createMediaRecorderDemuxer = createMediaRecorderDemuxer;
var _webmMediaRecorderDemuxer = __webpack_require__(44112);
var _mediaRecorderDemuxerEvents = __webpack_require__(28538);
// if export default is used then webpack fails to expose the function when used with libraryTarget: 'var'
function createMediaRecorderDemuxer(mediaSource, options) {
  // Check for media recorder support
  let mediaRecorderSupported = typeof MediaRecorder !== 'undefined';
  if (mediaRecorderSupported === false) return null;

  // Choose suitable demuxer depending on supported mime types
  let mediaRecorderDemuxer;
  // Safari currently does not have MediaRecorder.isTypeSupported
  const hasMediaRecorderIsTypeSupported = typeof MediaRecorder.isTypeSupported === 'function';
  if (hasMediaRecorderIsTypeSupported === false || MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
    const mediaRecorderOptions = {
      mimeType: 'video/webm;codecs=h264'
    };
    mediaRecorderDemuxer = new _webmMediaRecorderDemuxer.WebmMediaRecorderDemuxer(new MediaRecorder(mediaSource, mediaRecorderOptions), options);
  }
  return mediaRecorderDemuxer;
}

/***/ }),

/***/ 53142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultMediaRecorderOptions = exports.MediaRecorderDemuxer = void 0;
var _mediaInfo = __webpack_require__(47472);
var _mediaRecorderDemuxerEvents = __webpack_require__(28538);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const EventEmitter = __webpack_require__(37007);
const defaultMediaRecorderOptions = exports.defaultMediaRecorderOptions = {
  timerInterval: 100,
  logCallback: null
};
class MediaRecorderDemuxer extends EventEmitter {
  constructor(mediaRecorder, options) {
    super();
    this.options = options ? _objectSpread(_objectSpread({}, defaultMediaRecorderOptions), options) : defaultMediaRecorderOptions;
    this.mediaRecorder = mediaRecorder;
    this.mediaInfo = new _mediaInfo.MediaInfo();
    this.mediaRecorder.addEventListener('dataavailable', async event => {
      this.addBlob(event.data);
    });
    this.mediaRecorder.addEventListener('error', event => {
      this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.Error, event.error);
    });
  }
  start() {
    this.mediaRecorder.start();
    // Safari emits dataavailable only after stopping, so do a stop/start there
    if (typeof this.mediaRecorder.requestData === 'function') {
      this.timer = window.setInterval(() => {
        this.mediaRecorder.requestData();
      }, this.options.timerInterval);
    } else {
      this.timer = window.setTimeout(() => {
        this.mediaRecorder.stop();
      }, this.options.timerInterval);
    }
  }
  stop() {
    if (this.mediaRecorder.state === "recording") this.mediaRecorder.stop();
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
  static isSupported(mediaType) {
    return typeof MediaRecorder !== 'undefined' /* check if we have MediaRecorder as a type */ && typeof MediaRecorder.prototype.requestData === 'function' /* check if requestData is available */ && typeof MediaRecorder.isTypeSupported === 'function' /* check if isTypeSupported is available */ && MediaRecorder.isTypeSupported(mediaType); /* check if the media is supported */
  }
}
exports.MediaRecorderDemuxer = MediaRecorderDemuxer;

/***/ }),

/***/ 44112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.webmVideoTrackType = exports.webmAudioTrackType = exports.WebmMediaRecorderDemuxer = void 0;
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(42762);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
var _mediaRecorderDemuxer = __webpack_require__(53142);
var _ebmlElementId = __webpack_require__(60565);
var _ebmlElement = __webpack_require__(415);
var _utilities = __webpack_require__(12087);
var _ebmlElementType = __webpack_require__(65260);
var _mediaRecorderDemuxerEvents = __webpack_require__(28538);
var _mediaPacket = __webpack_require__(30440);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const webmVideoTrackType = exports.webmVideoTrackType = 1;
const webmAudioTrackType = exports.webmAudioTrackType = 2;

// https://gist.github.com/hanayashiki/8dac237671343e7f0b15de617b0051bd
function blobToArrayBuffer() {
  // this: Blob
  return new Promise(resolve => {
    let fr = new FileReader();
    fr.onload = () => {
      resolve(fr.result);
    };
    fr.readAsArrayBuffer(this);
  });
}
class WebmMediaRecorderDemuxer extends _mediaRecorderDemuxer.MediaRecorderDemuxer {
  constructor(mediaRecorder, options) {
    super(mediaRecorder, options);
    this.state = WebmMediaRecorderDemuxer.stateParseElementId;
    this.currentEbmlElement = new _ebmlElement.EbmlElement();
    this.uint8ArrayAggregator = new _utilities.Uint8ArrayAggregator();
    this.clusterTimestamp = 0;
    /*
        https://www.matroska.org/technical/elements.html
         TimestampScale is mandatory but still initialize the ms scale and set the default value from the spec,
        the default scale is 1000000, thus pts in the container being expressed in ms, so the ms scale is 1
     */
    this.timestampMsScale = 1;
    this.ebmlElementStack = [];
    Blob.prototype.arrayBuffer = Blob.prototype.arrayBuffer || blobToArrayBuffer;
  }
  async addBlob(blob) {
    try {
      this.uint8ArrayAggregator.addArray(new Uint8Array(await blob.arrayBuffer()));
      while (this.uint8ArrayAggregator.bytesAvailable) {
        switch (this.state) {
          case WebmMediaRecorderDemuxer.stateParseElementId:
            if ((0, _ebmlElementId.readEbmlElementId)(this.uint8ArrayAggregator, this.currentEbmlElement)) {
              this.options.logCallback == null || this.options.logCallback("got new current ebml element (id: ".concat(this.currentEbmlElement.id, ", name: ").concat(this.currentEbmlElement.name, ")"));
            } else {
              break;
            }
            this.state = WebmMediaRecorderDemuxer.stateParseElementLength;
            break;
          case WebmMediaRecorderDemuxer.stateParseElementLength:
            if ((0, _ebmlElement.readEbmlLementSize)(this.uint8ArrayAggregator, this.currentEbmlElement)) {
              this.options.logCallback == null || this.options.logCallback("got size ".concat(this.currentEbmlElement.size, " for current ebml element (id: ").concat(this.currentEbmlElement.id, ", name: ").concat(this.currentEbmlElement.name, ")"));
            } else {
              break;
            }
            if (this.ebmlElementStack.length) {
              if (this.currentEbmlElement.size == -1) {
                // if there is a nested element with size -1 all of the stack logic falls apart so just evict the stack
                this.ebmlElementStack = [];
              }
            }
            this.state = WebmMediaRecorderDemuxer.stateParseElementValue;
            break;
          case WebmMediaRecorderDemuxer.stateParseElementValue:
            const currentEbmlElementType = (0, _ebmlElementType.getEbmlElementType)(this.currentEbmlElement.id);
            let canSkip = currentEbmlElementType !== _ebmlElementType.EbmlElementType.Master || this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.Colour;
            if (currentEbmlElementType === _ebmlElementType.EbmlElementType.Master && this.currentEbmlElement.size !== -1) {
              this.ebmlElementStack.push({
                element: Object.assign(new _ebmlElement.EbmlElement(), this.currentEbmlElement),
                bytesRemaining: this.currentEbmlElement.size
              });
            }
            if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.CodecID) {
              canSkip = false;
              let codecIdBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (codecIdBytes == null) break;
              const codecName = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, codecIdBytes);
              if (this.currentTrackType === webmVideoTrackType) {
                this.mediaInfo.videoTrack.codecName = codecName;
              } else if (this.currentTrackType === webmAudioTrackType) {
                this.mediaInfo.audioTrack.codecName = codecName;
              }
              this.options.logCallback == null || this.options.logCallback("got codec id ".concat(codecName));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.CodecPrivate) {
              canSkip = false;
              let codecExtradataBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (codecExtradataBytes == null) break;
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.TimestampScale) {
              canSkip = false;
              let timestampScaleBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (timestampScaleBytes == null) break;
              this.mediaInfo.timestampScale = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, timestampScaleBytes);
              this.timestampMsScale = this.mediaInfo.timestampScale / 1000000;
              this.options.logCallback == null || this.options.logCallback("got timestamp scale ".concat(this.mediaInfo.timestampScale));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.Timestamp) {
              canSkip = false;
              let timestampBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (timestampBytes == null) break;
              this.clusterTimestamp = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, timestampBytes);
              this.options.logCallback == null || this.options.logCallback("got cluser timestamp ".concat(this.clusterTimestamp));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.TrackType) {
              canSkip = false;
              let trackTypeBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (trackTypeBytes == null) break;
              this.currentTrackType = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, trackTypeBytes);
              this.options.logCallback == null || this.options.logCallback("got track with type ".concat(this.currentTrackType));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.SimpleBlock) {
              canSkip = false;
              let simpleBlockBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (simpleBlockBytes == null) break;
              let uint8ArrayAggregator = new _utilities.Uint8ArrayAggregator();
              uint8ArrayAggregator.addArray(simpleBlockBytes);
              let ebmlElement = {};
              (0, _ebmlElement.readEbmlLementSize)(uint8ArrayAggregator, ebmlElement);
              const trackNumber = ebmlElement.size;
              let relativeTimestamp = (0, _utilities.readBigEndianNumber)(uint8ArrayAggregator.extract(2));
              let flags = uint8ArrayAggregator.current;
              uint8ArrayAggregator.next();
              uint8ArrayAggregator.trim();
              let ptsMs = (this.clusterTimestamp + relativeTimestamp) * this.timestampMsScale;
              this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.MediaPacket, new _mediaPacket.MediaPacket(uint8ArrayAggregator.array, ptsMs));
            }
            canSkip && this.uint8ArrayAggregator.skip(this.currentEbmlElement.size);

            // check if by parsing the current element we have completed any elements up in the stack
            if (currentEbmlElementType !== _ebmlElementType.EbmlElementType.Master && this.ebmlElementStack.length) {
              this.ebmlElementStack[this.ebmlElementStack.length - 1].bytesRemaining -= this.currentEbmlElement.elementSize;
              do {
                if (this.ebmlElementStack[this.ebmlElementStack.length - 1].bytesRemaining === 0) {
                  var entry = this.ebmlElementStack.pop();
                  if (this.ebmlElementStack.length) this.ebmlElementStack[this.ebmlElementStack.length - 1].bytesRemaining -= entry.element.elementSize;
                  if (entry.element.id === _ebmlElementId.EbmlElementId.Tracks) this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.MediaInfo, this.mediaInfo);
                } else {
                  break;
                }
              } while (this.ebmlElementStack.length);
            }
            this.state = WebmMediaRecorderDemuxer.stateParseElementId;
            break;
        }
      }
      this.uint8ArrayAggregator.trim();
    } catch (error) {
      this.stop();
      this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.Error, error);
    }
  }
}
exports.WebmMediaRecorderDemuxer = WebmMediaRecorderDemuxer;
_defineProperty(WebmMediaRecorderDemuxer, "stateParseElementId", 1);
_defineProperty(WebmMediaRecorderDemuxer, "stateParseElementLength", 2);
_defineProperty(WebmMediaRecorderDemuxer, "stateParseElementValue", 3);

/***/ }),

/***/ 12087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Uint8ArrayAggregator = void 0;
exports.readBigEndianNumber = readBigEndianNumber;
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
function readBigEndianNumber(bytes) {
  let number = 0;
  bytes.forEach(byte => {
    number = number << 8 | byte;
  });
  return number;
}
class Uint8ArrayAggregator {
  constructor() {
    this.array = null;
    this.current = null;
    this.offset = 0;
  }
  addArray(array) {
    if (array == null || array.length == 0) return;
    if (this.bytesToSkip >= array.length) {
      this.bytesToSkip -= array.length;
      return;
    } else if (this.bytesToSkip) {
      array = array.slice(this.bytesToSkip);
    }
    if (this.array) {
      let newArray = new Uint8Array(this.array.length - this.offset + array.length);
      newArray.set(this.offset ? this.array.slice(this.offset) : this.array, 0);
      newArray.set(array, this.array.length - this.offset);
      this.array = newArray;
      this.offset = 0;
    } else {
      this.array = array;
    }
    this.current = this.array[0];
  }
  checkBounds() {
    if (this.offset === this.array.length) {
      this.offset = 0;
      this.current = null;
      this.array = null;
    } else if (this.offset < this.array.length) {
      this.current = this.array[this.offset];
    } else {
      throw Error("invalid Uint8ArrayAggregator state, offset (".concat(this.offset, ") is larger than bytes in the current array (").concat(this.array.length, ")"));
    }
  }
  next() {
    if (this.array) {
      this.offset++;
      this.checkBounds();
      return this.current;
    }
    return null;
  }
  nextUnsafe() {
    this.offset++;
    this.current = this.array[this.offset];
    return this.current;
  }
  get bytesAvailable() {
    return this.array ? this.array.length - this.offset : 0;
  }
  trim() {
    if (this.array) {
      if (this.offset < this.array.length) {
        this.array = this.array.slice(this.offset);
        this.offset = 0;
        this.current = this.array[0];
      } else if (this.offset > this.array.length) {
        throw Error("invalid Uint8ArrayAggregator state, offset (".concat(this.offset, ") is larger than bytes in the current array (").concat(this.array.length, ")"));
      } else {
        this.array = null;
        this.offset = 0;
        this.current = null;
      }
    }
  }
  extract(count) {
    if (this.bytesAvailable >= count) {
      const start = this.offset;
      let bytes = this.array.slice(start, start + count);
      this.offset += count;
      this.current = this.array[this.offset];
      this.checkBounds();
      return bytes;
    }
    return null;
  }
  skip(count) {
    if (this.bytesAvailable >= count) {
      this.offset += count;
      this.current = this.array[this.offset];
      this.checkBounds();
      return;
    } else {
      count -= this.bytesAvailable;
      this.array = null;
      this.offset = 0;
      this.current = null;
    }
    this.bytesToSkip = count;
  }
}
exports.Uint8ArrayAggregator = Uint8ArrayAggregator;

/***/ }),

/***/ 57513:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class CompressionError {
  constructor(message, node) {
    this._message = message;
    this._node = node;
  }
  get message() {
    return this._message;
  }
  get node() {
    return this._node;
  }
}
exports["default"] = CompressionError;

/***/ }),

/***/ 2798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
class PropertyObserver {
  constructor(onPropertySet) {
    this.onPropertySet = onPropertySet;
    this._klasses = new Set();
  }
  _trackObserver(Klass) {
    if (!Klass.__cbio_observers) Klass.__cbio_observers = new Set();
    Klass.__cbio_observers.add(this);
  }
  _untrackObserver(Klass) {
    if (Klass.__cbio_observers) {
      Klass.__cbio_observers.delete(this);
    }
  }
  _tap(Klass, property) {
    if (Klass["__cbio_override_".concat(property)]) return;
    const descriptor = Object.getOwnPropertyDescriptor(Klass.prototype, property);
    if (!descriptor) return;
    Klass["__cbio_override_".concat(property)] = true;
    const originalSet = descriptor.set;
    descriptor.set = function (val) {
      originalSet.call(this, val);
      if (Klass.__cbio_observers) {
        Klass.__cbio_observers.forEach(observer => {
          observer.onPropertySet(this, property, val);
        });
      }
    };
    Object.defineProperty(Klass.prototype, property, descriptor);
  }
  observe(Klass, property) {
    this._klasses.add(Klass);
    this._trackObserver(Klass);
    this._tap(Klass, property);
  }
  disconnect() {
    this._klasses.forEach(Klass => this._untrackObserver(Klass));
    this._klasses.clear();
  }
}
exports["default"] = PropertyObserver;

/***/ }),

/***/ 34216:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(62953);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _depthFirst = _interopRequireWildcard(__webpack_require__(80136));
var _CompressionError = _interopRequireDefault(__webpack_require__(57513));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class VirtualDOM {
  constructor(id) {
    this._id = id;
    this._dom = {
      id,
      childNodes: []
    };
    this._mapping = {};
  }
  get id() {
    return this._id;
  }
  get document() {
    return this._dom;
  }
  node(id) {
    return this._mapping[id];
  }
  applyPatch(patch) {
    const {
      dom,
      mapping
    } = VirtualDOM.applyPatch(this._dom, patch);
    this._dom = dom;
    this._mapping = mapping;
    return this;
  }
  static createMapping(node) {
    const mapping = {};
    (0, _depthFirst.default)(node, n => {
      if (!n.id) console.warn('node missing id', n);else mapping[n.id] = n;
    });
    return mapping;
  }
  static applyPatch(document, patch) {
    // first build an index of the nodes id we need to
    // update so we can quickly look them up.
    const nodeIdMap = this.createMapping(document);

    // then apply the diffs to the existing nodes,
    // and also create new node records for discovered
    // nodes if we need to.
    const modifiedNodesMap = {};
    patch.forEach(diff => {
      if (!diff.id) console.warn('diff missing id', diff);else {
        const existing = nodeIdMap[diff.id] || {};
        nodeIdMap[diff.id] = _objectSpread(_objectSpread({}, existing), diff);
        modifiedNodesMap[diff.id] = true;
      }
    });

    // then make sure all the node id's in the childNodes
    // arrays have been expanded into their denormalized form
    // and the childNodes arrays are using the modified nodes
    Object.values(nodeIdMap).forEach(n => {
      n.childNodes = (n.childNodes || []).map(child => {
        const id = child.id || child;
        const node = nodeIdMap[id];
        if (!node) throw new _CompressionError.default("denormalisation failed for child ".concat(id), n);
        return node;
      });
    });

    // for all modified nodes we want to make sure
    // all parent nodes also appear changed on equalty
    // comparison
    const root = nodeIdMap[document.id];
    const result = (0, _depthFirst.depthFirstPostOrder)(root, (n, children) => {
      // make sure we're using any updated nodes returned from
      // our children
      n.childNodes = children;

      // work out of any of our chidren were modified
      const modified = children.map(c => modifiedNodesMap[c.id]);
      const childWasModified = modified.reduce((a, b) => a || b, false);
      if (childWasModified) {
        // if a child was modified, we count as modified too, so make sure
        // the ndoe is marked in the modification table
        modifiedNodesMap[n.id] = true;
        // if the node was modified or a child of the node was modified
        // then we need to ensure the current node will fail equality checks
        const updated = _objectSpread({}, n);
        nodeIdMap[n.id] = updated;
        return updated;
      }
      return n;
    });

    // retain the latest node id mapping for quick lookups
    return {
      dom: result,
      mapping: this.createMapping(result)
    };
  }
}
exports["default"] = VirtualDOM;

/***/ }),

/***/ 80136:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = depthFirstPreOrder;
exports.depthFirstPostOrder = depthFirstPostOrder;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function depthFirstPreOrder(node, visitor) {
  let children = node.childNodes;
  const mapped = visitor(node, function () {
    let replacementChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    children = replacementChildren;
  });
  if (!children || !children.length) return mapped;
  return _objectSpread(_objectSpread({}, mapped), {}, {
    childNodes: Array.from(children).map(child => {
      return depthFirstPreOrder(child, visitor);
    })
  });
}
function depthFirstPostOrder(node, visitor) {
  const children = Array.from(node.childNodes || []);
  const childResults = children.map(child => depthFirstPostOrder(child, visitor));
  return visitor(node, childResults);
}

/***/ }),

/***/ 89501:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(62953);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "CompressionError", ({
  enumerable: true,
  get: function () {
    return _CompressionError.default;
  }
}));
Object.defineProperty(exports, "PropertyObserver", ({
  enumerable: true,
  get: function () {
    return _PropertyObserver.default;
  }
}));
Object.defineProperty(exports, "VirtualDOM", ({
  enumerable: true,
  get: function () {
    return _VirtualDOM.default;
  }
}));
Object.defineProperty(exports, "depthFirst", ({
  enumerable: true,
  get: function () {
    return _depthFirst.default;
  }
}));
Object.defineProperty(exports, "depthFirstPostOrder", ({
  enumerable: true,
  get: function () {
    return _depthFirst.depthFirstPostOrder;
  }
}));
Object.defineProperty(exports, "isxdoc", ({
  enumerable: true,
  get: function () {
    return _isxdoc.default;
  }
}));
Object.defineProperty(exports, "parents", ({
  enumerable: true,
  get: function () {
    return _parents.default;
  }
}));
var _CompressionError = _interopRequireDefault(__webpack_require__(57513));
var _VirtualDOM = _interopRequireDefault(__webpack_require__(34216));
var _depthFirst = _interopRequireWildcard(__webpack_require__(80136));
var _isxdoc = _interopRequireDefault(__webpack_require__(10663));
var _parents = _interopRequireDefault(__webpack_require__(19324));
var _PropertyObserver = _interopRequireDefault(__webpack_require__(2798));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 10663:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isxdoc;
function windowIsXdoc(window) {
  try {
    // try to access a property on the window
    return !window.document && false;
  } catch (e) {
    return true;
  }
}
function isxdoc(node) {
  if (windowIsXdoc(node)) {
    return true;
  } else if (node.tagName === 'IFRAME') {
    if (windowIsXdoc(node.contentWindow)) {
      return true;
    }
  }
  return false;
}

/***/ }),

/***/ 19324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parents;
__webpack_require__(62953);
function parents(node, stopNode) {
  const found = [];
  let current = node;
  while (current.parentNode && current.parentNode !== stopNode) {
    found.push(current.parentNode);
    current = current.parentNode;
  }
  if (current instanceof ShadowRoot) return [...found, current.host, ...parents(current.host, stopNode)];
  const iframe = current.defaultView && current.defaultView.frameElement;
  if (iframe) return [...found, iframe, ...parents(iframe)];
  return found;
}

/***/ }),

/***/ 66009:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(89463);
__webpack_require__(62953);
__webpack_require__(52675);
__webpack_require__(89463);
__webpack_require__(2259);
__webpack_require__(45700);
__webpack_require__(89572);
__webpack_require__(94170);
__webpack_require__(2892);
__webpack_require__(59904);
__webpack_require__(84185);
__webpack_require__(40875);
__webpack_require__(10287);
__webpack_require__(60825);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ActivityDetection = void 0;
__webpack_require__(23792);
__webpack_require__(26099);
__webpack_require__(47764);
__webpack_require__(73772);
__webpack_require__(62953);
__webpack_require__(76031);
var _events = __webpack_require__(37007);
var _throttle = _interopRequireDefault(__webpack_require__(7350));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var debug = (0, _debug["default"])('cbio.ActivityDetection');
var _started = /*#__PURE__*/new WeakMap();
var _active = /*#__PURE__*/new WeakMap();
var _activeTimeout = /*#__PURE__*/new WeakMap();
var _inactiveTime = /*#__PURE__*/new WeakMap();
var _onActivity = /*#__PURE__*/new WeakMap();
var _makeActive = /*#__PURE__*/new WeakMap();
var _makeInactive = /*#__PURE__*/new WeakMap();
var ActivityDetection = exports.ActivityDetection = /*#__PURE__*/function (_EventEmitter) {
  function ActivityDetection(timeout) {
    var _this;
    _classCallCheck(this, ActivityDetection);
    _this = _callSuper(this, ActivityDetection);
    _classPrivateFieldInitSpec(_this, _started, false);
    _classPrivateFieldInitSpec(_this, _active, false);
    _classPrivateFieldInitSpec(_this, _activeTimeout, null);
    _classPrivateFieldInitSpec(_this, _inactiveTime, 15 * 60 * 1000);
    _defineProperty(_this, "start", function () {
      if (_classPrivateFieldGet(_started, _this)) return;
      _classPrivateFieldSet(_started, _this, true);
      debug('started');
      document.addEventListener('mouseenter', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('mouseleave', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('mousemove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchstart', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchend', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchmove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('visibilitychange', _classPrivateFieldGet(_onActivity, _this), {
        capture: true
      });

      // page load counts as possible activity
      _classPrivateFieldGet(_onActivity, _this).call(_this);
    });
    _defineProperty(_this, "stop", function () {
      _classPrivateFieldSet(_active, _this, false);
      _classPrivateFieldSet(_started, _this, false);
      debug('stopped');
      clearTimeout(_classPrivateFieldGet(_activeTimeout, _this));
      _this.removeAllListeners();
      document.removeEventListener('mouseenter', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('mouseleave', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('mousemove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchstart', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchend', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchmove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('visibilitychange', _classPrivateFieldGet(_onActivity, _this), {
        capture: true
      });
    });
    _defineProperty(_this, "isActive", function () {
      return _classPrivateFieldGet(_active, _this);
    });
    _classPrivateFieldInitSpec(_this, _onActivity, (0, _throttle["default"])(function () {
      _classPrivateFieldGet(_makeActive, _this).call(_this);
      clearTimeout(_classPrivateFieldGet(_activeTimeout, _this));
      _classPrivateFieldSet(_activeTimeout, _this, setTimeout(_classPrivateFieldGet(_makeInactive, _this), _classPrivateFieldGet(_inactiveTime, _this)));
      _this.emit('activity');
    }, 500, {
      trailing: false
    }));
    _classPrivateFieldInitSpec(_this, _makeActive, function () {
      // skip if already active
      if (_classPrivateFieldGet(_active, _this)) return;
      // or if the browser thinks it's not visible
      if (document.hidden) {
        debug('window is hidden, not becoming active');
        return;
      }
      // then mark as active and emit event
      _classPrivateFieldSet(_active, _this, true);
      debug('became active');
      _this.emit('active');
    });
    _classPrivateFieldInitSpec(_this, _makeInactive, function () {
      if (_classPrivateFieldGet(_active, _this)) {
        _classPrivateFieldSet(_active, _this, false);
        debug('became inactive');
        _this.emit('inactive');
      }
    });
    if (timeout) _classPrivateFieldSet(_inactiveTime, _this, timeout);
    return _this;
  }
  _inherits(ActivityDetection, _EventEmitter);
  return _createClass(ActivityDetection);
}(_events.EventEmitter);

/***/ }),

/***/ 1055:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(89463);
__webpack_require__(62953);
__webpack_require__(52675);
__webpack_require__(89463);
__webpack_require__(2259);
__webpack_require__(45700);
__webpack_require__(89572);
__webpack_require__(94170);
__webpack_require__(2892);
__webpack_require__(59904);
__webpack_require__(84185);
__webpack_require__(40875);
__webpack_require__(10287);
__webpack_require__(60825);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IFrameBridge = void 0;
__webpack_require__(28706);
__webpack_require__(50113);
__webpack_require__(51629);
__webpack_require__(23418);
__webpack_require__(74423);
__webpack_require__(23792);
__webpack_require__(26099);
__webpack_require__(31415);
__webpack_require__(21699);
__webpack_require__(47764);
__webpack_require__(73772);
__webpack_require__(23500);
__webpack_require__(62953);
var _events = __webpack_require__(37007);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var debug = (0, _debug["default"])('cbio.IFrameBridge');
var _parentSource = /*#__PURE__*/new WeakMap();
var _sources = /*#__PURE__*/new WeakMap();
var _iframes = /*#__PURE__*/new WeakMap();
var _processMessage = /*#__PURE__*/new WeakMap();
var _hasParent = /*#__PURE__*/new WeakMap();
var _isCobrowseMessage = /*#__PURE__*/new WeakMap();
var _isTrustedOrigin = /*#__PURE__*/new WeakMap();
var _iframeForSource = /*#__PURE__*/new WeakMap();
var IFrameBridge = exports.IFrameBridge = /*#__PURE__*/function (_EventEmitter) {
  function IFrameBridge(parent) {
    var _this;
    _classCallCheck(this, IFrameBridge);
    _this = _callSuper(this, IFrameBridge);
    // These are the user defined origins to trust
    _defineProperty(_this, "trustedOrigins", []);
    _defineProperty(_this, "automaticTrustedOrigins", []);
    // Save details about the nearest xdoc parent that we discover
    // We save the window object for the parent.
    _classPrivateFieldInitSpec(_this, _parentSource, null);
    // Keep a mapping from sources to the origins they contain.
    _classPrivateFieldInitSpec(_this, _sources, new WeakMap());
    // Keep a record of our child iframes for broadcast methods
    // and mapping messages back to a sepecific iframe (by contentWindow
    // comparison)
    _classPrivateFieldInitSpec(_this, _iframes, new Set());
    _defineProperty(_this, "start", function () {
      // set up a postMessage listener to handle incoming cobrowse events
      window.removeEventListener('message', _classPrivateFieldGet(_processMessage, _this));
      window.addEventListener('message', _classPrivateFieldGet(_processMessage, _this));

      // send init message to our parent, we might not know the origin of our
      // parent yet, so we should send to all untrusted origins
      if (_classPrivateFieldGet(_parentSource, _this)) _this.send(_classPrivateFieldGet(_parentSource, _this), 'init', null, {
        trustedOnly: false
      });
    });
    _defineProperty(_this, "stop", function () {
      window.removeEventListener('message', _classPrivateFieldGet(_processMessage, _this));
    });
    _classPrivateFieldInitSpec(_this, _processMessage, function (message) {
      // ignore any messages that are definitely not cobrowse messages
      if (!_classPrivateFieldGet(_isCobrowseMessage, _this).call(_this, message)) {
        return debug('ignoring message, not a cobrowse message', message.data);
      }

      // keep a record of the origin associated with each source we recieve
      // messages from
      _this.establishTrust(message.source, message.origin);

      // Deconstruct the message and forward on event
      var _message$data = message.data,
        trustedOnly = _message$data.trustedOnly,
        event = _message$data.event,
        data = _message$data.data;

      // emit locally so we can attach handlers for validated messages
      _this.emit(event, data, {
        source: message.source,
        origin: message.origin,
        trusted: _this.isTrusted(message.source),
        iframe: _classPrivateFieldGet(_iframeForSource, _this).call(_this, message.source),
        fromParent: _classPrivateFieldGet(_hasParent, _this).call(_this, message.source),
        trustedOnly: trustedOnly
      });
    });
    _classPrivateFieldInitSpec(_this, _hasParent, function (target) {
      var current = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.parent;
      if (target === current) return true;
      if (current.parent === current) return false;
      return _classPrivateFieldGet(_hasParent, _this).call(_this, target, current.parent);
    });
    _classPrivateFieldInitSpec(_this, _isCobrowseMessage, function (message) {
      if (!message.data) return false;
      var _message$data2 = message.data,
        cobrowseio = _message$data2.cobrowseio,
        event = _message$data2.event;
      if (!cobrowseio) return false;
      if (!event) return false;
      return true;
    });
    _classPrivateFieldInitSpec(_this, _isTrustedOrigin, function (origin) {
      return _this.automaticTrustedOrigins.includes(origin) || _this.trustedOrigins.includes(origin);
    });
    _defineProperty(_this, "isTrusted", function (source) {
      var origin = _classPrivateFieldGet(_sources, _this).get(source);
      if (!origin) return false;
      return _classPrivateFieldGet(_isTrustedOrigin, _this).call(_this, origin);
    });
    _classPrivateFieldInitSpec(_this, _iframeForSource, function (source) {
      var iframes = Array.from(_classPrivateFieldGet(_iframes, _this));
      return iframes.find(function (i) {
        return i.contentWindow === source;
      });
    });
    _defineProperty(_this, "send", function (w, event, data) {
      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$trustedOnly = _ref.trustedOnly,
        trustedOnly = _ref$trustedOnly === void 0 ? true : _ref$trustedOnly,
        targetOrigin = _ref.targetOrigin;
      // if we have an explcit origin provided we should always try to use that
      // otherwise we'll try to auto-fill the origin from the source tracking
      var origin = targetOrigin || _classPrivateFieldGet(_sources, _this).get(w);
      // check if trust is required, and if the origin is trusted, if not we just bail
      // on sending anything
      if (trustedOnly && !_classPrivateFieldGet(_isTrustedOrigin, _this).call(_this, origin)) {
        return debug("not sending ".concat(event, " as target source is not trusted: ").concat(origin));
      }
      // if trust is not required and we don't have any explcit origin to send to
      // then we should fallback to *
      if (!trustedOnly && !origin) origin = '*';
      w.postMessage({
        trustedOnly: trustedOnly,
        cobrowseio: true,
        event: event,
        data: data
      }, origin);
    });
    _defineProperty(_this, "sendToParent", function (event, data) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$trustedOnly = _ref2.trustedOnly,
        trustedOnly = _ref2$trustedOnly === void 0 ? true : _ref2$trustedOnly;
      if (_classPrivateFieldGet(_parentSource, _this)) _this.send(_classPrivateFieldGet(_parentSource, _this), event, data, {
        trustedOnly: trustedOnly
      });
    });
    _defineProperty(_this, "broadcastToChildren", function (event, data) {
      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref3$trustedOnly = _ref3.trustedOnly,
        trustedOnly = _ref3$trustedOnly === void 0 ? true : _ref3$trustedOnly;
      _classPrivateFieldGet(_iframes, _this).forEach(function (iframe) {
        // when a same origin iframe is reloaded any children iframes
        // can be left orphaned which results in a null contentWindow
        if (iframe.contentWindow) _this.send(iframe.contentWindow, event, data, {
          trustedOnly: trustedOnly
        });
      });
    });
    _defineProperty(_this, "track", function (iframe) {
      if (!_classPrivateFieldGet(_iframes, _this).has(iframe)) {
        _classPrivateFieldGet(_iframes, _this).add(iframe);
        _this.emit('iframe_discovered', iframe);
      }
    });
    _defineProperty(_this, "remove", function (iframe) {
      _classPrivateFieldGet(_iframes, _this)["delete"](iframe);
    });
    _defineProperty(_this, "establishTrust", function (source, origin) {
      if (!source) return;
      _classPrivateFieldGet(_sources, _this).set(source, origin);
    });
    _defineProperty(_this, "breakTrust", function (source) {
      if (_classPrivateFieldGet(_sources, _this).has(source)) _classPrivateFieldGet(_sources, _this).set(source, null);
    });
    _classPrivateFieldSet(_parentSource, _this, parent);
    debug('iframe bridge constructed in', document, 'with parent', _classPrivateFieldGet(_parentSource, _this));
    return _this;
  }
  _inherits(IFrameBridge, _EventEmitter);
  return _createClass(IFrameBridge);
}(_events.EventEmitter);

/***/ }),

/***/ 54203:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(89463);
__webpack_require__(66412);
__webpack_require__(27495);
__webpack_require__(62953);
__webpack_require__(52675);
__webpack_require__(89463);
__webpack_require__(66412);
__webpack_require__(2259);
__webpack_require__(45700);
__webpack_require__(78125);
__webpack_require__(51629);
__webpack_require__(23418);
__webpack_require__(64346);
__webpack_require__(34782);
__webpack_require__(89572);
__webpack_require__(23288);
__webpack_require__(94170);
__webpack_require__(62010);
__webpack_require__(4731);
__webpack_require__(60479);
__webpack_require__(2892);
__webpack_require__(59904);
__webpack_require__(84185);
__webpack_require__(40875);
__webpack_require__(10287);
__webpack_require__(60825);
__webpack_require__(27495);
__webpack_require__(38781);
__webpack_require__(23500);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IFrameRPC = void 0;
__webpack_require__(23792);
__webpack_require__(36033);
__webpack_require__(26099);
__webpack_require__(47764);
__webpack_require__(73772);
__webpack_require__(62953);
__webpack_require__(76031);
var _events = __webpack_require__(37007);
var _uuid = __webpack_require__(65392);
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return r;
  };
  var t,
    r = {},
    e = Object.prototype,
    n = e.hasOwnProperty,
    o = "function" == typeof Symbol ? Symbol : {},
    i = o.iterator || "@@iterator",
    a = o.asyncIterator || "@@asyncIterator",
    u = o.toStringTag || "@@toStringTag";
  function c(t, r, e, n) {
    Object.defineProperty(t, r, {
      value: e,
      enumerable: !n,
      configurable: !n,
      writable: !n
    });
  }
  try {
    c({}, "");
  } catch (t) {
    c = function c(t, r, e) {
      return t[r] = e;
    };
  }
  function h(r, e, n, o) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype);
    return c(a, "_invoke", function (r, e, n) {
      var o = 1;
      return function (i, a) {
        if (3 === o) throw Error("Generator is already running");
        if (4 === o) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var u = n.delegate;
          if (u) {
            var c = d(u, n);
            if (c) {
              if (c === f) continue;
              return c;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (1 === o) throw o = 4, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = 3;
          var h = s(r, e, n);
          if ("normal" === h.type) {
            if (o = n.done ? 4 : 2, h.arg === f) continue;
            return {
              value: h.arg,
              done: n.done
            };
          }
          "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg);
        }
      };
    }(r, n, new Context(o || [])), !0), a;
  }
  function s(t, r, e) {
    try {
      return {
        type: "normal",
        arg: t.call(r, e)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  r.wrap = h;
  var f = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var l = {};
  c(l, i, function () {
    return this;
  });
  var p = Object.getPrototypeOf,
    y = p && p(p(x([])));
  y && y !== e && n.call(y, i) && (l = y);
  var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
  function g(t) {
    ["next", "throw", "return"].forEach(function (r) {
      c(t, r, function (t) {
        return this._invoke(r, t);
      });
    });
  }
  function AsyncIterator(t, r) {
    function e(o, i, a, u) {
      var c = s(t[o], t, i);
      if ("throw" !== c.type) {
        var h = c.arg,
          f = h.value;
        return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) {
          e("next", t, a, u);
        }, function (t) {
          e("throw", t, a, u);
        }) : r.resolve(f).then(function (t) {
          h.value = t, a(h);
        }, function (t) {
          return e("throw", t, a, u);
        });
      }
      u(c.arg);
    }
    var o;
    c(this, "_invoke", function (t, n) {
      function i() {
        return new r(function (r, o) {
          e(t, n, r, o);
        });
      }
      return o = o ? o.then(i, i) : i();
    }, !0);
  }
  function d(r, e) {
    var n = e.method,
      o = r.i[n];
    if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f;
    var i = s(o, r.i, e.arg);
    if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f;
    var a = i.arg;
    return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f);
  }
  function w(t) {
    this.tryEntries.push(t);
  }
  function m(r) {
    var e = r[4] || {};
    e.type = "normal", e.arg = t, r[4] = e;
  }
  function Context(t) {
    this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0);
  }
  function x(r) {
    if (null != r) {
      var e = r[i];
      if (e) return e.call(r);
      if ("function" == typeof r.next) return r;
      if (!isNaN(r.length)) {
        var o = -1,
          a = function e() {
            for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e;
            return e.value = t, e.done = !0, e;
          };
        return a.next = a;
      }
    }
    throw new TypeError(_typeof(r) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), c(GeneratorFunctionPrototype, u, GeneratorFunction.displayName = "GeneratorFunction"), r.isGeneratorFunction = function (t) {
    var r = "function" == typeof t && t.constructor;
    return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name));
  }, r.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t;
  }, r.awrap = function (t) {
    return {
      __await: t
    };
  }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () {
    return this;
  }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(h(t, e, n, o), i);
    return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, g(v), c(v, u, "Generator"), c(v, i, function () {
    return this;
  }), c(v, "toString", function () {
    return "[object Generator]";
  }), r.keys = function (t) {
    var r = Object(t),
      e = [];
    for (var n in r) e.unshift(n);
    return function t() {
      for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t;
      return t.done = !0, t;
    };
  }, r.values = x, Context.prototype = {
    constructor: Context,
    reset: function reset(r) {
      if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0][4];
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(r) {
      if (this.done) throw r;
      var e = this;
      function n(t) {
        a.type = "throw", a.arg = r, e.next = t;
      }
      for (var o = e.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i[4],
          u = this.prev,
          c = i[1],
          h = i[2];
        if (-1 === i[0]) return n("end"), !1;
        if (!c && !h) throw Error("try statement without catch or finally");
        if (null != i[0] && i[0] <= u) {
          if (u < c) return this.method = "next", this.arg = t, n(c), !0;
          if (u < h) return n(h), !1;
        }
      }
    },
    abrupt: function abrupt(t, r) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) {
          var o = n;
          break;
        }
      }
      o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null);
      var i = o ? o[4] : {};
      return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i);
    },
    complete: function complete(t, r) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f;
    },
    finish: function finish(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[2] === t) return this.complete(e[4], e[3]), m(e), f;
      }
    },
    "catch": function _catch(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[0] === t) {
          var n = e[4];
          if ("throw" === n.type) {
            var o = n.arg;
            m(e);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(r, e, n) {
      return this.delegate = {
        i: x(r),
        r: e,
        n: n
      }, "next" === this.method && (this.arg = t), f;
    }
  }, r;
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var _bridge = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _pendingRequests = /*#__PURE__*/new WeakMap();
var _onRpcRequest = /*#__PURE__*/new WeakMap();
var _onRpcResponse = /*#__PURE__*/new WeakMap();
var IFrameRPC = exports.IFrameRPC = /*#__PURE__*/function (_EventEmitter) {
  function IFrameRPC(bridge, target) {
    var _this;
    _classCallCheck(this, IFrameRPC);
    _this = _callSuper(this, IFrameRPC);
    _classPrivateFieldInitSpec(_this, _bridge, void 0);
    _classPrivateFieldInitSpec(_this, _target, void 0);
    _classPrivateFieldInitSpec(_this, _pendingRequests, new Map());
    _defineProperty(_this, "send", function (method, data) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$timeout = _ref.timeout,
        timeout = _ref$timeout === void 0 ? 0 : _ref$timeout,
        _ref$trustedOnly = _ref.trustedOnly,
        trustedOnly = _ref$trustedOnly === void 0 ? true : _ref$trustedOnly;
      return new Promise(function (resolve, reject) {
        var id = (0, _uuid.v4)();
        _classPrivateFieldGet(_pendingRequests, _this).set(id, {
          resolve: resolve,
          reject: reject
        });
        var rpcRequest = {
          id: id,
          method: method,
          data: data
        };
        _classPrivateFieldGet(_bridge, _this).send(_classPrivateFieldGet(_target, _this), 'rpc:request', rpcRequest, {
          trustedOnly: trustedOnly
        });
        if (!timeout) return;
        setTimeout(function () {
          var request = _classPrivateFieldGet(_pendingRequests, _this).get(id);
          if (!request) return;
          request.reject(new Error('Request timed out'));
          _classPrivateFieldGet(_pendingRequests, _this)["delete"](id);
        }, timeout);
      });
    });
    _classPrivateFieldInitSpec(_this, _onRpcRequest, /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(rpcRequest, _ref2) {
        var source, trusted, trustedOnly, id, method, data, listeners, _listeners, listener, res;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              source = _ref2.source, trusted = _ref2.trusted, trustedOnly = _ref2.trustedOnly;
              id = rpcRequest.id, method = rpcRequest.method, data = rpcRequest.data;
              listeners = _this.listeners(method);
              if (!(listeners.length > 1)) {
                _context.next = 5;
                break;
              }
              throw new Error('only a single RPC listener is allowed per event');
            case 5:
              if (!(listeners.length === 0)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return");
            case 7:
              _listeners = _slicedToArray(listeners, 1), listener = _listeners[0];
              _context.prev = 8;
              _context.next = 11;
              return listener(data, {
                trusted: trusted
              });
            case 11:
              res = _context.sent;
              _classPrivateFieldGet(_bridge, _this).send(source, 'rpc:response', {
                id: id,
                data: res
              }, {
                trustedOnly: trustedOnly
              });
              _context.next = 18;
              break;
            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](8);
              _classPrivateFieldGet(_bridge, _this).send(source, 'rpc:response', {
                id: id,
                error: _context.t0
              }, {
                trustedOnly: trustedOnly
              });
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[8, 15]]);
      }));
      return function (_x, _x2) {
        return _ref3.apply(this, arguments);
      };
    }());
    _classPrivateFieldInitSpec(_this, _onRpcResponse, function (rpcResponse, _ref4) {
      var trusted = _ref4.trusted,
        trustedOnly = _ref4.trustedOnly;
      if (trustedOnly && !trusted) return;
      var error = rpcResponse.error,
        id = rpcResponse.id,
        data = rpcResponse.data;
      var request = _classPrivateFieldGet(_pendingRequests, _this).get(id);
      if (request) {
        if (error) request.reject(error);else request.resolve(data);
        _classPrivateFieldGet(_pendingRequests, _this)["delete"](id);
      }
    });
    _classPrivateFieldSet(_bridge, _this, bridge);
    _classPrivateFieldSet(_target, _this, target);
    _classPrivateFieldGet(_bridge, _this).on('rpc:request', _classPrivateFieldGet(_onRpcRequest, _this));
    _classPrivateFieldGet(_bridge, _this).on('rpc:response', _classPrivateFieldGet(_onRpcResponse, _this));
    return _this;
  }
  _inherits(IFrameRPC, _EventEmitter);
  return _createClass(IFrameRPC);
}(_events.EventEmitter);

/***/ }),

/***/ 86817:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(84185);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.closestXdocParent = closestXdocParent;
var _isxdoc = __webpack_require__(636);
function closestXdocParent() {
  var parent = window;
  do {
    parent = parent.parent;
    if ((0, _isxdoc.isxdoc)(parent)) return parent;
  } while (parent !== parent.parent);
  return null;
}

/***/ }),

/***/ 636:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(84185);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isxdoc = isxdoc;
function windowIsXdoc(window) {
  try {
    // try to access a property on the window
    return !window.document && false;
  } catch (e) {
    return true;
  }
}
function isxdoc(node) {
  if (windowIsXdoc(node)) {
    return true;
  } else if (node.tagName === 'IFRAME') {
    if (windowIsXdoc(node.contentWindow)) {
      return true;
    }
  }
  return false;
}

/***/ }),

/***/ 63439:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(84185);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ActivityDetection", ({
  enumerable: true,
  get: function get() {
    return _ActivityDetection.ActivityDetection;
  }
}));
Object.defineProperty(exports, "CBORSocket", ({
  enumerable: true,
  get: function get() {
    return _CBORSocket.CBORSocket;
  }
}));
Object.defineProperty(exports, "IFrameBridge", ({
  enumerable: true,
  get: function get() {
    return _IFrameBridge.IFrameBridge;
  }
}));
Object.defineProperty(exports, "IFrameRPC", ({
  enumerable: true,
  get: function get() {
    return _IFrameRPC.IFrameRPC;
  }
}));
Object.defineProperty(exports, "closestXdocParent", ({
  enumerable: true,
  get: function get() {
    return _closestXdocParent.closestXdocParent;
  }
}));
Object.defineProperty(exports, "isxdoc", ({
  enumerable: true,
  get: function get() {
    return _isxdoc.isxdoc;
  }
}));
var _ActivityDetection = __webpack_require__(66009);
var _CBORSocket = __webpack_require__(39641);
var _IFrameBridge = __webpack_require__(1055);
var _IFrameRPC = __webpack_require__(54203);
var _isxdoc = __webpack_require__(636);
var _closestXdocParent = __webpack_require__(86817);

/***/ }),

/***/ 39641:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(89463);
__webpack_require__(66412);
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(27495);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
__webpack_require__(62953);
__webpack_require__(52675);
__webpack_require__(89463);
__webpack_require__(66412);
__webpack_require__(2259);
__webpack_require__(45700);
__webpack_require__(78125);
__webpack_require__(51629);
__webpack_require__(23418);
__webpack_require__(64346);
__webpack_require__(34782);
__webpack_require__(89572);
__webpack_require__(23288);
__webpack_require__(94170);
__webpack_require__(62010);
__webpack_require__(4731);
__webpack_require__(60479);
__webpack_require__(2892);
__webpack_require__(59904);
__webpack_require__(84185);
__webpack_require__(40875);
__webpack_require__(10287);
__webpack_require__(60825);
__webpack_require__(27495);
__webpack_require__(38781);
__webpack_require__(23500);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CBORSocket = void 0;
__webpack_require__(28706);
__webpack_require__(2008);
__webpack_require__(23792);
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(38309);
__webpack_require__(59089);
__webpack_require__(26099);
__webpack_require__(47764);
__webpack_require__(21489);
__webpack_require__(81630);
__webpack_require__(72170);
__webpack_require__(75044);
__webpack_require__(69539);
__webpack_require__(31694);
__webpack_require__(89955);
__webpack_require__(33206);
__webpack_require__(44496);
__webpack_require__(66651);
__webpack_require__(12887);
__webpack_require__(19369);
__webpack_require__(66812);
__webpack_require__(8995);
__webpack_require__(31575);
__webpack_require__(36072);
__webpack_require__(88747);
__webpack_require__(28845);
__webpack_require__(29423);
__webpack_require__(57301);
__webpack_require__(373);
__webpack_require__(86614);
__webpack_require__(41405);
__webpack_require__(33684);
__webpack_require__(73772);
__webpack_require__(62953);
__webpack_require__(76031);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _indexNoEval = __webpack_require__(29284);
var _events = __webpack_require__(37007);
var _SocketMetrics = __webpack_require__(79400);
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return r;
  };
  var t,
    r = {},
    e = Object.prototype,
    n = e.hasOwnProperty,
    o = "function" == typeof Symbol ? Symbol : {},
    i = o.iterator || "@@iterator",
    a = o.asyncIterator || "@@asyncIterator",
    u = o.toStringTag || "@@toStringTag";
  function c(t, r, e, n) {
    Object.defineProperty(t, r, {
      value: e,
      enumerable: !n,
      configurable: !n,
      writable: !n
    });
  }
  try {
    c({}, "");
  } catch (t) {
    c = function c(t, r, e) {
      return t[r] = e;
    };
  }
  function h(r, e, n, o) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype);
    return c(a, "_invoke", function (r, e, n) {
      var o = 1;
      return function (i, a) {
        if (3 === o) throw Error("Generator is already running");
        if (4 === o) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var u = n.delegate;
          if (u) {
            var c = d(u, n);
            if (c) {
              if (c === f) continue;
              return c;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (1 === o) throw o = 4, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = 3;
          var h = s(r, e, n);
          if ("normal" === h.type) {
            if (o = n.done ? 4 : 2, h.arg === f) continue;
            return {
              value: h.arg,
              done: n.done
            };
          }
          "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg);
        }
      };
    }(r, n, new Context(o || [])), !0), a;
  }
  function s(t, r, e) {
    try {
      return {
        type: "normal",
        arg: t.call(r, e)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  r.wrap = h;
  var f = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var l = {};
  c(l, i, function () {
    return this;
  });
  var p = Object.getPrototypeOf,
    y = p && p(p(x([])));
  y && y !== e && n.call(y, i) && (l = y);
  var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
  function g(t) {
    ["next", "throw", "return"].forEach(function (r) {
      c(t, r, function (t) {
        return this._invoke(r, t);
      });
    });
  }
  function AsyncIterator(t, r) {
    function e(o, i, a, u) {
      var c = s(t[o], t, i);
      if ("throw" !== c.type) {
        var h = c.arg,
          f = h.value;
        return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) {
          e("next", t, a, u);
        }, function (t) {
          e("throw", t, a, u);
        }) : r.resolve(f).then(function (t) {
          h.value = t, a(h);
        }, function (t) {
          return e("throw", t, a, u);
        });
      }
      u(c.arg);
    }
    var o;
    c(this, "_invoke", function (t, n) {
      function i() {
        return new r(function (r, o) {
          e(t, n, r, o);
        });
      }
      return o = o ? o.then(i, i) : i();
    }, !0);
  }
  function d(r, e) {
    var n = e.method,
      o = r.i[n];
    if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f;
    var i = s(o, r.i, e.arg);
    if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f;
    var a = i.arg;
    return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f);
  }
  function w(t) {
    this.tryEntries.push(t);
  }
  function m(r) {
    var e = r[4] || {};
    e.type = "normal", e.arg = t, r[4] = e;
  }
  function Context(t) {
    this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0);
  }
  function x(r) {
    if (null != r) {
      var e = r[i];
      if (e) return e.call(r);
      if ("function" == typeof r.next) return r;
      if (!isNaN(r.length)) {
        var o = -1,
          a = function e() {
            for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e;
            return e.value = t, e.done = !0, e;
          };
        return a.next = a;
      }
    }
    throw new TypeError(_typeof(r) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), c(GeneratorFunctionPrototype, u, GeneratorFunction.displayName = "GeneratorFunction"), r.isGeneratorFunction = function (t) {
    var r = "function" == typeof t && t.constructor;
    return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name));
  }, r.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t;
  }, r.awrap = function (t) {
    return {
      __await: t
    };
  }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () {
    return this;
  }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(h(t, e, n, o), i);
    return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, g(v), c(v, u, "Generator"), c(v, i, function () {
    return this;
  }), c(v, "toString", function () {
    return "[object Generator]";
  }), r.keys = function (t) {
    var r = Object(t),
      e = [];
    for (var n in r) e.unshift(n);
    return function t() {
      for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t;
      return t.done = !0, t;
    };
  }, r.values = x, Context.prototype = {
    constructor: Context,
    reset: function reset(r) {
      if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0][4];
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(r) {
      if (this.done) throw r;
      var e = this;
      function n(t) {
        a.type = "throw", a.arg = r, e.next = t;
      }
      for (var o = e.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i[4],
          u = this.prev,
          c = i[1],
          h = i[2];
        if (-1 === i[0]) return n("end"), !1;
        if (!c && !h) throw Error("try statement without catch or finally");
        if (null != i[0] && i[0] <= u) {
          if (u < c) return this.method = "next", this.arg = t, n(c), !0;
          if (u < h) return n(h), !1;
        }
      }
    },
    abrupt: function abrupt(t, r) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) {
          var o = n;
          break;
        }
      }
      o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null);
      var i = o ? o[4] : {};
      return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i);
    },
    complete: function complete(t, r) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f;
    },
    finish: function finish(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[2] === t) return this.complete(e[4], e[3]), m(e), f;
      }
    },
    "catch": function _catch(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[0] === t) {
          var n = e[4];
          if ("throw" === n.type) {
            var o = n.arg;
            m(e);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(r, e, n) {
      return this.delegate = {
        i: x(r),
        r: e,
        n: n
      }, "next" === this.method && (this.arg = t), f;
    }
  }, r;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var debug = (0, _debug["default"])('cbio.CBORSocket');
var _delegate = /*#__PURE__*/new WeakMap();
var _closed = /*#__PURE__*/new WeakMap();
var _socket = /*#__PURE__*/new WeakMap();
var _attempts = /*#__PURE__*/new WeakMap();
var _maxDelay = /*#__PURE__*/new WeakMap();
var _minDelay = /*#__PURE__*/new WeakMap();
var _pingInterval = /*#__PURE__*/new WeakMap();
var _openSuccessTimeout = /*#__PURE__*/new WeakMap();
var _reconnectTimeout = /*#__PURE__*/new WeakMap();
var _messageId = /*#__PURE__*/new WeakMap();
var _lastMessageAck = /*#__PURE__*/new WeakMap();
var _metrics = /*#__PURE__*/new WeakMap();
var _createSocket = /*#__PURE__*/new WeakMap();
var _resetSocket = /*#__PURE__*/new WeakMap();
var _handleOffline = /*#__PURE__*/new WeakMap();
var _handleOpen = /*#__PURE__*/new WeakMap();
var _handleAck = /*#__PURE__*/new WeakMap();
var _handleMessage = /*#__PURE__*/new WeakMap();
var _reconnectDelay = /*#__PURE__*/new WeakMap();
var _reconnect = /*#__PURE__*/new WeakMap();
var _handleClose = /*#__PURE__*/new WeakMap();
var _handleError = /*#__PURE__*/new WeakMap();
var _sendPing = /*#__PURE__*/new WeakMap();
var CBORSocket = exports.CBORSocket = /*#__PURE__*/function (_EventEmitter) {
  function CBORSocket(delegate) {
    var _this;
    _classCallCheck(this, CBORSocket);
    _this = _callSuper(this, CBORSocket);
    _classPrivateFieldInitSpec(_this, _delegate, void 0);
    _classPrivateFieldInitSpec(_this, _closed, false);
    _classPrivateFieldInitSpec(_this, _socket, void 0);
    _classPrivateFieldInitSpec(_this, _attempts, 0);
    _classPrivateFieldInitSpec(_this, _maxDelay, 60 * 1000);
    _classPrivateFieldInitSpec(_this, _minDelay, 1000 + Math.floor(1000 * Math.random()));
    _classPrivateFieldInitSpec(_this, _pingInterval, void 0);
    _classPrivateFieldInitSpec(_this, _openSuccessTimeout, void 0);
    _classPrivateFieldInitSpec(_this, _reconnectTimeout, void 0);
    // message IDs for flow control
    _classPrivateFieldInitSpec(_this, _messageId, 0);
    _classPrivateFieldInitSpec(_this, _lastMessageAck, 0);
    _classPrivateFieldInitSpec(_this, _metrics, new _SocketMetrics.SocketMetrics());
    _classPrivateFieldInitSpec(_this, _createSocket, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _classPrivateFieldGet2, _classPrivateFieldGet3;
      var url, protocols, socket;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!_classPrivateFieldGet(_socket, _this)) {
              _context.next = 3;
              break;
            }
            console.error('Socket already exists');
            return _context.abrupt("return");
          case 3:
            debug('creating ws');
            // Generate the URL. Important: this might be an
            // asynchronous operation (e.g. getting the server
            // to generate a token). So we need to be careful
            // to re-check the intended state of the socket
            // after a successful url generation
            _context.next = 6;
            return _classPrivateFieldGet(_delegate, _this).getUrl();
          case 6:
            url = _context.sent;
            _context.t0 = ['cbor'];
            _context.t1 = _toConsumableArray;
            _context.next = 11;
            return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(_delegate, _this)).getProtocols) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.call(_classPrivateFieldGet3);
          case 11:
            _context.t2 = _context.sent;
            if (_context.t2) {
              _context.next = 14;
              break;
            }
            _context.t2 = [];
          case 14:
            _context.t3 = _context.t2;
            _context.t4 = (0, _context.t1)(_context.t3);
            protocols = _context.t0.concat.call(_context.t0, _context.t4).filter(Boolean);
            if (url) {
              _context.next = 19;
              break;
            }
            return _context.abrupt("return");
          case 19:
            if (!_classPrivateFieldGet(_closed, _this)) {
              _context.next = 21;
              break;
            }
            return _context.abrupt("return");
          case 21:
            if (!_classPrivateFieldGet(_socket, _this)) {
              _context.next = 23;
              break;
            }
            return _context.abrupt("return");
          case 23:
            // otherwise we have the URL so create the underlying
            // WebSocket instance
            socket = _classPrivateFieldGet(_delegate, _this).createWebSocket ? _classPrivateFieldGet(_delegate, _this).createWebSocket(url, protocols) : new WebSocket(url, protocols);
            socket.binaryType = 'arraybuffer';
            socket.addEventListener('open', _classPrivateFieldGet(_handleOpen, _this));
            socket.addEventListener('message', _classPrivateFieldGet(_handleMessage, _this));
            socket.addEventListener('close', _classPrivateFieldGet(_handleClose, _this));
            socket.addEventListener('error', _classPrivateFieldGet(_handleError, _this));

            // save the socket on the instance
            _classPrivateFieldSet(_socket, _this, socket);
            _classPrivateFieldGet(_metrics, _this).reset();
          case 31:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })));
    _classPrivateFieldInitSpec(_this, _resetSocket, function () {
      if (_classPrivateFieldGet(_socket, _this)) {
        try {
          var _classPrivateFieldGet4;
          (_classPrivateFieldGet4 = _classPrivateFieldGet(_socket, _this)).close.apply(_classPrivateFieldGet4, arguments);
        } catch (e) {
          debug('error closing socket', e);
        }
      }
      _classPrivateFieldSet(_socket, _this, null);
    });
    _classPrivateFieldInitSpec(_this, _handleOffline, function () {
      // If the navigator thinks it goes offline,
      // then we will kill the socket connection to
      // kick it into reconnect mode
      // This is necessary because the websocket
      // might not notify us on some platforms
      debug('navigator went offline');
      _classPrivateFieldGet(_resetSocket, _this).call(_this);
      _classPrivateFieldGet(_reconnect, _this).call(_this);
    });
    _classPrivateFieldInitSpec(_this, _handleOpen, function () {
      debug('ws opened');
      _this.emit('open');
      clearTimeout(_classPrivateFieldGet(_openSuccessTimeout, _this));
      // require socket to be held opne for a little time before
      // resetting the backoff algorithm
      _classPrivateFieldSet(_openSuccessTimeout, _this, setTimeout(function () {
        debug('counting open as success');
        _classPrivateFieldSet(_attempts, _this, 0);
      }, 5 * 1000));
    });
    _classPrivateFieldInitSpec(_this, _handleAck, function (ack) {
      _classPrivateFieldSet(_lastMessageAck, _this, ack);
      _classPrivateFieldGet(_metrics, _this).onReceived(ack);
    });
    _classPrivateFieldInitSpec(_this, _handleMessage, function (message) {
      try {
        var _cborDecode = (0, _indexNoEval.decode)(new Uint8Array(message.data)),
          event = _cborDecode.event,
          data = _cborDecode.data,
          ack = _cborDecode.ack;
        if (ack) return _classPrivateFieldGet(_handleAck, _this).call(_this, ack);
        if (!event) return console.error('Socket received message without event', message);
        return _this.emit('event', event, data);
      } catch (e) {
        return console.error('Error processing message', message.data, e.stack);
      }
    });
    _classPrivateFieldInitSpec(_this, _reconnectDelay, function (attempt) {
      if (attempt === 0) return 0;
      var randomFactor = 1 + 0.5 * Math.random();
      var delay = Math.floor(Math.pow(300 * attempt, 1.2) * randomFactor);
      return Math.min(Math.max(_classPrivateFieldGet(_minDelay, _this), delay), _classPrivateFieldGet(_maxDelay, _this));
    });
    _classPrivateFieldInitSpec(_this, _reconnect, function () {
      // if the socket was destroyed then don't try to reconnect
      if (_classPrivateFieldGet(_closed, _this)) {
        debug('reconnect skipped as socket was closed');
        return;
      }

      // never try to schedule multiple reconnects
      if (_classPrivateFieldGet(_reconnectTimeout, _this)) {
        debug('reconnect skipped as reconnect already scheduled');
        return;
      }

      // if we're offline then don't try to reconnect yet, just wait a bit
      // and try again
      if (typeof navigator !== 'undefined' && navigator.onLine === false) {
        debug('navigator offline');
        _classPrivateFieldSet(_reconnectTimeout, _this, setTimeout(function () {
          _classPrivateFieldSet(_reconnectTimeout, _this, null);
          _classPrivateFieldGet(_reconnect, _this).call(_this);
        }, 1000));
        return;
      }

      // otherwise work out the backoff delay and schedule reconnection
      var delay = _classPrivateFieldGet(_reconnectDelay, _this).call(_this, _classPrivateFieldGet(_attempts, _this));
      debug('reconnecting in', delay, 'attempts', _classPrivateFieldGet(_attempts, _this));
      _classPrivateFieldSet(_reconnectTimeout, _this, setTimeout(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _classPrivateFieldSet(_reconnectTimeout, _this, null);
              if (!_classPrivateFieldGet(_closed, _this)) {
                _context2.next = 5;
                break;
              }
              console.warn('tried to reconnect after close');
              _context2.next = 9;
              break;
            case 5:
              _classPrivateFieldSet(_socket, _this, null);
              _context2.next = 8;
              return _classPrivateFieldGet(_createSocket, _this).call(_this)["catch"](_classPrivateFieldGet(_handleError, _this));
            case 8:
              // if the socket failed to create for some reason, but the
              // we've not been explictly closed then we'll enter the
              // reconnect loop here.
              if (!_classPrivateFieldGet(_socket, _this) && !_classPrivateFieldGet(_closed, _this)) _classPrivateFieldGet(_reconnect, _this).call(_this);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      })), delay));
      _classPrivateFieldSet(_attempts, _this, _classPrivateFieldGet(_attempts, _this) + 1);
    });
    _classPrivateFieldInitSpec(_this, _handleClose, function () {
      debug('ws closed');
      _this.emit('close');
      debug('resetting message acks');
      _classPrivateFieldSet(_messageId, _this, 0);
      _classPrivateFieldSet(_lastMessageAck, _this, 0);
      _classPrivateFieldGet(_metrics, _this).onReceived(0);

      // backoff reconnection
      if (!_classPrivateFieldGet(_closed, _this)) _classPrivateFieldGet(_reconnect, _this).call(_this);

      // cancel pending success timeout
      clearTimeout(_classPrivateFieldGet(_openSuccessTimeout, _this));
    });
    _classPrivateFieldInitSpec(_this, _handleError, function (error) {
      if (_classPrivateFieldGet(_closed, _this)) {
        // when the socket is closed we remove all listeners so we can't emit
        // as that would cause an unhandled error. this should be safe though
        // and probably a consequence of the different catch blocks calling this
        console.info('CobrowseIO: Called error after close.', error);
        return;
      }
      if (_this.listenerCount('error') === 0) {
        // this should never occur and if it does it means means we remove the error
        // listener before we call this method. this is a bug and the stack trace should give us
        // some additional information to fix it
        console.warn('CobrowseIO: Called handleError without listeners. Please report this.', error);
        return;
      }
      _this.emit('error', error);
    });
    _classPrivateFieldInitSpec(_this, _sendPing, function () {
      _this.send('ping');
    });
    _defineProperty(_this, "messageLag", function () {
      // if no ack received at all, then don't count as lagging
      // could mean server doesn't support acks or something
      if (!_classPrivateFieldGet(_lastMessageAck, _this)) return 0;
      return _classPrivateFieldGet(_messageId, _this) - _classPrivateFieldGet(_lastMessageAck, _this);
    });
    _defineProperty(_this, "setMaxReconnectDelay", function (delay) {
      debug('set max delay', delay);
      _classPrivateFieldSet(_maxDelay, _this, delay);
    });
    _defineProperty(_this, "setMinReconnectDelay", function (delay) {
      debug('set min delay', delay);
      _classPrivateFieldSet(_minDelay, _this, delay);
    });
    _defineProperty(_this, "send", function (event, data) {
      if (!_this.connected) return false;
      _classPrivateFieldSet(_messageId, _this, _classPrivateFieldGet(_messageId, _this) + 1);
      _classPrivateFieldGet(_metrics, _this).onSent(_classPrivateFieldGet(_messageId, _this));
      var start = Date.now();
      var payload = (0, _indexNoEval.encode)(data
      // The server attempts to extract event and id from the CBOR payload
      // without having to parse the data, which can be 10's of thousands of
      // JS objects and take up to a minute on really big sites. For this to
      // be possible, the event and id must come before data in insertion
      // order
      ? {
        event: event,
        id: _classPrivateFieldGet(_messageId, _this),
        data: data
      } : {
        event: event
      });
      debug('encoded', event, "".concat(payload.byteLength, " bytes"), 'in', "".concat(Date.now() - start, "ms"));
      _classPrivateFieldGet(_socket, _this).send(payload);
      return true;
    });
    _defineProperty(_this, "close", function () {
      var _classPrivateFieldGet5;
      debug('close');
      _classPrivateFieldSet(_closed, _this, true);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_classPrivateFieldGet5 = _classPrivateFieldGet(_resetSocket, _this)).call.apply(_classPrivateFieldGet5, [_this].concat(args));

      // clear any pending timers before removing listeners
      clearTimeout(_classPrivateFieldGet(_reconnectTimeout, _this));
      clearInterval(_classPrivateFieldGet(_pingInterval, _this));
      _this.removeAllListeners();
      if (typeof window !== 'undefined') {
        window.removeEventListener('unload', _this.close);
        window.addEventListener('offline', _classPrivateFieldGet(_handleOffline, _this));
      }
    });
    debug('created cbor socket');
    _classPrivateFieldSet(_delegate, _this, delegate);
    _classPrivateFieldSet(_pingInterval, _this, setInterval(_classPrivateFieldGet(_sendPing, _this), 60 * 1000));
    if (typeof window !== 'undefined') {
      window.addEventListener('unload', _this.close);
      window.addEventListener('offline', _classPrivateFieldGet(_handleOffline, _this));
    }
    _this.on('error', function (e) {
      return debug('ws errored', e);
    });
    _classPrivateFieldGet(_reconnect, _this).call(_this);
    return _this;
  }
  _inherits(CBORSocket, _EventEmitter);
  return _createClass(CBORSocket, [{
    key: "bufferedAmount",
    get: function get() {
      if (!_classPrivateFieldGet(_socket, this)) return Infinity;
      return _classPrivateFieldGet(_socket, this).bufferedAmount;
    }
  }, {
    key: "connected",
    get: function get() {
      if (_classPrivateFieldGet(_socket, this)) return _classPrivateFieldGet(_socket, this).readyState === _classPrivateFieldGet(_socket, this).OPEN;else return false;
    }
  }, {
    key: "metrics",
    get: function get() {
      return _classPrivateFieldGet(_metrics, this);
    }
  }]);
}(_events.EventEmitter);

/***/ }),

/***/ 79400:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(89463);
__webpack_require__(62953);
__webpack_require__(52675);
__webpack_require__(89463);
__webpack_require__(2259);
__webpack_require__(45700);
__webpack_require__(89572);
__webpack_require__(2892);
__webpack_require__(84185);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SocketMetrics = void 0;
__webpack_require__(23792);
__webpack_require__(59089);
__webpack_require__(26099);
__webpack_require__(47764);
__webpack_require__(73772);
__webpack_require__(62953);
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var LATENCY_FILTERING_SMOOTHING_FACTOR = 0.125;
var smoothen = function smoothen(current, base) {
  if (!base) return current;
  // exponential moving average
  return LATENCY_FILTERING_SMOOTHING_FACTOR * current + (1 - LATENCY_FILTERING_SMOOTHING_FACTOR) * base;
};
var _lastMessage = /*#__PURE__*/new WeakMap();
var _lastMessageTimestamp = /*#__PURE__*/new WeakMap();
var _lastAck = /*#__PURE__*/new WeakMap();
var _lastAckTimestamp = /*#__PURE__*/new WeakMap();
var _filteredLatency = /*#__PURE__*/new WeakMap();
var SocketMetrics = exports.SocketMetrics = /*#__PURE__*/_createClass(function SocketMetrics() {
  var _this = this;
  _classCallCheck(this, SocketMetrics);
  _classPrivateFieldInitSpec(this, _lastMessage, void 0);
  _classPrivateFieldInitSpec(this, _lastMessageTimestamp, void 0);
  _classPrivateFieldInitSpec(this, _lastAck, void 0);
  _classPrivateFieldInitSpec(this, _lastAckTimestamp, void 0);
  _classPrivateFieldInitSpec(this, _filteredLatency, void 0);
  _defineProperty(this, "reset", function () {
    _classPrivateFieldSet(_lastMessage, _this, 0);
    _classPrivateFieldSet(_lastMessageTimestamp, _this, 0);
    _classPrivateFieldSet(_lastAck, _this, 0);
    _classPrivateFieldSet(_lastAckTimestamp, _this, 0);
    _classPrivateFieldSet(_filteredLatency, _this, 0);
  });
  _defineProperty(this, "latency", function () {
    // Nothing has been sent yet
    if (_classPrivateFieldGet(_lastMessage, _this) === 0) return 0;

    // if we're not awaiting an ack then we can just use the filtered latency
    // we're tracking and updating on receiving acks.
    if (_classPrivateFieldGet(_filteredLatency, _this) > 0 && _classPrivateFieldGet(_lastMessage, _this) === _classPrivateFieldGet(_lastAck, _this)) return _classPrivateFieldGet(_filteredLatency, _this);
    var currentLatency = Date.now() - _classPrivateFieldGet(_lastMessageTimestamp, _this);
    if (currentLatency > _classPrivateFieldGet(_filteredLatency, _this)) {
      // we can apply filter to the return value but don't persist it yet!
      // if we get an ACK eventually, the filter will get applied to the persisted value
      // using the regular ack logic.
      return smoothen(currentLatency, _classPrivateFieldGet(_filteredLatency, _this));
    }
    return _classPrivateFieldGet(_filteredLatency, _this);
  });
  _defineProperty(this, "onSent", function (messageId) {
    // track one id / ack pair at a time, i.e. when SEND 1 happens,
    // ignore all other sends until ACK 1 (or a higher ack)
    if (_classPrivateFieldGet(_lastAck, _this) < _classPrivateFieldGet(_lastMessage, _this)) return;
    _classPrivateFieldSet(_lastMessage, _this, messageId);
    _classPrivateFieldSet(_lastMessageTimestamp, _this, Date.now());
  });
  _defineProperty(this, "onReceived", function (ackId) {
    // as soon as we get an ack for an ID we can assume all lower IDs have also been ack'ed
    _classPrivateFieldSet(_lastAck, _this, ackId);
    _classPrivateFieldSet(_lastAckTimestamp, _this, Date.now());
    var currentLatency;
    if (_classPrivateFieldGet(_lastMessage, _this) === 0 || _classPrivateFieldGet(_lastAck, _this) === 0) {
      currentLatency = 0;
    } else if (_classPrivateFieldGet(_lastMessage, _this) === _classPrivateFieldGet(_lastAck, _this)) {
      // The message was sent and received back as ack
      currentLatency = _classPrivateFieldGet(_lastAckTimestamp, _this) - _classPrivateFieldGet(_lastMessageTimestamp, _this);
    } else {
      // Received back a message which is not the one that was recently sent, dropping it
      return;
    }
    _classPrivateFieldSet(_filteredLatency, _this, smoothen(currentLatency, _classPrivateFieldGet(_filteredLatency, _this)));
  });
  this.reset();
});

/***/ }),

/***/ 51227:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(27495);
__webpack_require__(25440);
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
  let warned = false;
  return () => {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
})();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }
  let m;

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  // eslint-disable-next-line no-return-assign
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  const c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, match => {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  let r;
  try {
    r = exports.storage.getItem('debug');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = __webpack_require__(18630)(exports);
const {
  formatters
} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ 18630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(42762);
__webpack_require__(62953);
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(6585);
  createDebug.destroy = destroy;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    let hash = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      const self = debug;

      // Set `diff` timestamp
      const curr = Number(new Date());
      const ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: v => {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
    for (const ns of split) {
      if (ns[0] === '-') {
        createDebug.skips.push(ns.slice(1));
      } else {
        createDebug.names.push(ns);
      }
    }
  }

  /**
   * Checks if the given string matches a namespace template, honoring
   * asterisks as wildcards.
   *
   * @param {String} search
   * @param {String} template
   * @return {Boolean}
   */
  function matchesTemplate(search, template) {
    let searchIndex = 0;
    let templateIndex = 0;
    let starIndex = -1;
    let matchIndex = 0;
    while (searchIndex < search.length) {
      if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
        // Match character or proceed with wildcard
        if (template[templateIndex] === '*') {
          starIndex = templateIndex;
          matchIndex = searchIndex;
          templateIndex++; // Skip the '*'
        } else {
          searchIndex++;
          templateIndex++;
        }
      } else if (starIndex !== -1) {
        // eslint-disable-line no-negated-condition
        // Backtrack to the last '*' and try to match more characters
        templateIndex = starIndex + 1;
        matchIndex++;
        searchIndex = matchIndex;
      } else {
        return false; // No match
      }
    }

    // Handle trailing '*' in template
    while (templateIndex < template.length && template[templateIndex] === '*') {
      templateIndex++;
    }
    return templateIndex === template.length;
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    const namespaces = [...createDebug.names, ...createDebug.skips.map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    for (const skip of createDebug.skips) {
      if (matchesTemplate(name, skip)) {
        return false;
      }
    }
    for (const ns of createDebug.names) {
      if (matchesTemplate(name, ns)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

/***/ }),

/***/ 85620:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.CobrowseIO = void 0;
__webpack_require__(84864);
__webpack_require__(27495);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _throttle = _interopRequireDefault(__webpack_require__(7350));
var _src = __webpack_require__(89501);
var _events = __webpack_require__(37007);
var _activity2 = __webpack_require__(45264);
var _cocom = __webpack_require__(63439);
var _rest = __webpack_require__(18111);
var _device2 = __webpack_require__(21667);
var _sessions = __webpack_require__(72176);
var _ui = __webpack_require__(33035);
var _integrations = _interopRequireDefault(__webpack_require__(75160));
var _checkVersion = _interopRequireDefault(__webpack_require__(40923));
var _iframes = _interopRequireWildcard(__webpack_require__(77966));
var _ua = _interopRequireDefault(__webpack_require__(58973));
var _SessionStorage = __webpack_require__(73531);
var _LocalSessionStorage = __webpack_require__(51312);
var _Locale = _interopRequireDefault(__webpack_require__(77988));
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _NodeTree = _interopRequireDefault(__webpack_require__(32588));
var timers = _interopRequireWildcard(__webpack_require__(58325));
var _TabOverlay = _interopRequireDefault(__webpack_require__(198));
var _Navigation = __webpack_require__(44661);
var _splitNameFromTarget = __webpack_require__(82117);
var _virtualagent = __webpack_require__(13177);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.CobrowseIO');
var _activity = /*#__PURE__*/new WeakMap();
var _currentContext = /*#__PURE__*/new WeakMap();
var _restoredSession = /*#__PURE__*/new WeakMap();
var _started = /*#__PURE__*/new WeakMap();
var _registration = /*#__PURE__*/new WeakMap();
var _localSessionStorage = /*#__PURE__*/new WeakMap();
var _sessionStorageFactory = /*#__PURE__*/new WeakMap();
var _sessionStorage = /*#__PURE__*/new WeakMap();
var _customData = /*#__PURE__*/new WeakMap();
var _capabilities = /*#__PURE__*/new WeakMap();
var _device = /*#__PURE__*/new WeakMap();
var _sessionConsent = /*#__PURE__*/new WeakMap();
var _remoteControlConsent = /*#__PURE__*/new WeakMap();
var _fullDeviceConsent = /*#__PURE__*/new WeakMap();
var _openConsent = /*#__PURE__*/new WeakMap();
var _redactedViews = /*#__PURE__*/new WeakMap();
var _unredactedViews = /*#__PURE__*/new WeakMap();
var _ignoredViews = /*#__PURE__*/new WeakMap();
var _pdfLinks = /*#__PURE__*/new WeakMap();
var _universalLinks = /*#__PURE__*/new WeakMap();
var _acceptedUniversalNavigation = /*#__PURE__*/new WeakMap();
var _destroyIframeBridge = /*#__PURE__*/new WeakMap();
var _virtualAgent = /*#__PURE__*/new WeakMap();
var _open = /*#__PURE__*/new WeakMap();
var _loadSession = /*#__PURE__*/new WeakMap();
var _setCurrentSession = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _onSessionMetricsUpdated = /*#__PURE__*/new WeakMap();
var _showSessionControlsFn = /*#__PURE__*/new WeakMap();
var _throttledCustomDataUpdate = /*#__PURE__*/new WeakMap();
var _applySettingsFrom = /*#__PURE__*/new WeakMap();
var _loadVirtualAgent = /*#__PURE__*/new WeakMap();
class CobrowseIO extends _events.EventEmitter {
  constructor() {
    var _this;
    let {
      sessionStorageFactory = (trustedOrigins, api, _ref) => {
        let {
          localStorage
        } = _ref;
        return _SessionStorage.SessionStorage.create(trustedOrigins, api, {
          localStorage
        });
      }
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super();
    _this = this;
    _classPrivateFieldInitSpec(this, _activity, new _cocom.ActivityDetection());
    _classPrivateFieldInitSpec(this, _currentContext, void 0);
    _classPrivateFieldInitSpec(this, _restoredSession, void 0);
    _classPrivateFieldInitSpec(this, _started, false);
    _classPrivateFieldInitSpec(this, _registration, true);
    _classPrivateFieldInitSpec(this, _localSessionStorage, new _LocalSessionStorage.LocalSessionStorage());
    _classPrivateFieldInitSpec(this, _sessionStorageFactory, void 0);
    _classPrivateFieldInitSpec(this, _sessionStorage, void 0);
    _classPrivateFieldInitSpec(this, _customData, {});
    _classPrivateFieldInitSpec(this, _capabilities, _device2.Device.info.capabilities);
    _classPrivateFieldInitSpec(this, _device, new _device2.Device(this));
    _classPrivateFieldInitSpec(this, _sessionConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _remoteControlConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _fullDeviceConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _openConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _redactedViews, void 0);
    _classPrivateFieldInitSpec(this, _unredactedViews, void 0);
    _classPrivateFieldInitSpec(this, _ignoredViews, void 0);
    _classPrivateFieldInitSpec(this, _pdfLinks, void 0);
    _classPrivateFieldInitSpec(this, _universalLinks, void 0);
    _classPrivateFieldInitSpec(this, _acceptedUniversalNavigation, void 0);
    _classPrivateFieldInitSpec(this, _destroyIframeBridge, void 0);
    _classPrivateFieldInitSpec(this, _virtualAgent, void 0);
    _defineProperty(this, "start", async function () {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      debug('start()', options, 'in', document);

      // Usually headless browsers would not be useful (crawlers etc...)
      // but the tests run in a headless browser, so we need a way to allow
      // them sometimes.
      if (_ua.default.isHeadless() && !options.allowHeadless) {
        console.warn('CobrowseIO: Not starting Cobrowse in a headless browser');
        return;
      }

      // If we're running in an iframe, we need to decide how cobrowse
      // should run, if at all.
      if (window.self !== window.top) {
        // Sometimes we want to force Cobrowse to run as the "main" instance
        // even when in an iframe (for example the demo page)
        if (options.allowIFrameStart) {
          _activity2.WindowTracking.setTracksIframes(true);
        } else if ((0, _src.isxdoc)(window.parent)) {
          // if we're running in a cross document iframe (i.e. the parent page)
          // can't access our content diretly, we run cobrowse in iframe bridge mode
          // which means that content is serialised and sent over postMessage to
          // the parent
          if (_classPrivateFieldGet(_destroyIframeBridge, _this)) _classPrivateFieldGet(_destroyIframeBridge, _this).call(_this);
          _classPrivateFieldSet(_destroyIframeBridge, _this, (0, _iframes.initIframeBridgeAsChild)(_this));
          debug('Starting Cobrowse in Iframe bridge mode with trusted origins:', _iframes.default.trustedOrigins, 'for', document);
          return;
        } else {
          // Most of the time, when we're trying to start in an iframe, the parent
          // page is the one that actually contains the "main" cobrowse snippet, so
          // we don't need to do anything in this iframe.
          debug('Not starting Cobrowse for same-origin iframe', document);
          return;
        }
      }
      if (_classPrivateFieldGet(_destroyIframeBridge, _this)) _classPrivateFieldGet(_destroyIframeBridge, _this).call(_this);
      _classPrivateFieldSet(_destroyIframeBridge, _this, (0, _iframes.initIframeBridgeAsParent)(_this, {
        open: _classPrivateFieldGet(_open, _this)
      }));
      if (!_this.license) {
        console.error('CobrowseIO.license must be set before calling start');
        return;
      }
      if (!_classPrivateFieldGet(_started, _this)) {
        var _this$currentSession;
        // integrations are initialized before #started is set so that
        // any custom data updates made in the integrations don't cause
        // multiple separate PUT requests
        _integrations.default.initialize();
        _activity2.WindowTracking.start();
        (0, _checkVersion.default)(CobrowseIO.version).catch(() => {});
        _classPrivateFieldSet(_sessionStorage, _this, _classPrivateFieldGet(_sessionStorageFactory, _this).call(_this, _this.trustedOrigins, _this.api, {
          localStorage: _classPrivateFieldGet(_localSessionStorage, _this)
        }));
        console.log('CobrowseIO started', CobrowseIO.version);
        _classPrivateFieldSet(_started, _this, true);

        // ensure the new and legacy registration APIs are in sync, this can be
        // removed once the start() options version is removed
        // TODO: options.register is a legacy API and will be removed at some point
        if (typeof options.register === 'boolean') _classPrivateFieldSet(_registration, _this, options.register);

        // start and stop the registration loop based on user activity on the page
        if (_this.registration) {
          _classPrivateFieldGet(_activity, _this).on('active', () => _classPrivateFieldGet(_device, _this).runRegistrationLoop());
          _classPrivateFieldGet(_activity, _this).on('inactive', () => _classPrivateFieldGet(_device, _this).pauseRegistrationLoop());
        }
        _classPrivateFieldGet(_activity, _this).start();

        // Load a restored session if we have it
        debug('attempting to restore session after start');
        await _classPrivateFieldGet(_loadSession, _this).call(_this);
        _classPrivateFieldSet(_restoredSession, _this, null);
        // Once the updated session has been loaded, and the temporary restoredSession cleared
        // we can re-evaluate whether the session control should actually be shown
        // This is a special case as we may call the showSessionControls when the function is first
        // configured by the user (as another special case), so we need to be careful to clean up.
        if (!((_this$currentSession = _this.currentSession) !== null && _this$currentSession !== void 0 && _this$currentSession.isActive())) _this.hideSessionControls();
        timers.mark('start');
        await _classPrivateFieldGet(_loadVirtualAgent, _this).call(_this);
      }
    });
    _defineProperty(this, "stop", async () => {
      var _classPrivateFieldGet2;
      if (this.currentSession && !this.currentSession.isEnded()) {
        await this.currentSession.end().catch(e => {
          console.warn('CobrowseIO: Failed to end session on stop', e);
        });
      }
      _classPrivateFieldGet(_setCurrentSession, this).call(this, null);
      _activity2.WindowTracking.stop();
      _classPrivateFieldGet(_activity, this).stop();
      await _classPrivateFieldGet(_device, this).destroy();
      await ((_classPrivateFieldGet2 = _classPrivateFieldGet(_sessionStorage, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.destroy());
      _classPrivateFieldSet(_sessionStorage, this, undefined);
      _classPrivateFieldSet(_started, this, false);
      if (_classPrivateFieldGet(_destroyIframeBridge, this)) {
        _classPrivateFieldGet(_destroyIframeBridge, this).call(this);
        _classPrivateFieldSet(_destroyIframeBridge, this, null);
      }
      return this;
    });
    _defineProperty(this, "open", function (url, target, windowFeatures) {
      let {
        type
      } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return _classPrivateFieldGet(_open, _this).call(_this, url, target, windowFeatures, {
        type
      });
    });
    _classPrivateFieldInitSpec(this, _open, (url, target, windowFeatures, options) => {
      const go = () => window.open(url, target, windowFeatures);
      if (!_classPrivateFieldGet(_currentContext, this)) return go();
      const {
        target: newTarget,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)(target, '_blank');
      const newOptions = _objectSpread(_objectSpread({}, options), {}, {
        name,
        go
      });
      const {
        rewrittenUrl,
        windowProxy
      } = _classPrivateFieldGet(_currentContext, this).handleNavigation(url, newTarget, windowFeatures, newOptions);
      if (rewrittenUrl) return window.open(rewrittenUrl, target, windowFeatures);
      return windowProxy;
    });
    _classPrivateFieldInitSpec(this, _loadSession, async () => {
      const session = await _classPrivateFieldGet(_sessionStorage, this).load(this);
      if (session) {
        try {
          _classPrivateFieldGet(_setCurrentSession, this).call(this, session, {
            invalidateFrames: true
          });
        } catch (e) {
          console.warn('CobrowseIO: Failed to fetch restored session', e);
        }
      }
      return null;
    });
    _classPrivateFieldInitSpec(this, _setCurrentSession, function (session) {
      var _classPrivateFieldGet3;
      let {
        invalidateFrames = false
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      debug('setting current session', session);

      // updating to same session as current is noop
      if (session && _classPrivateFieldGet(_currentContext, _this)) {
        const currentSession = _classPrivateFieldGet(_currentContext, _this).session;
        if (currentSession.id() === session.id()) return;
      }

      // clean up any default consent prompts that might still be showing
      _classPrivateFieldGet(_sessionConsent, _this).hide();
      _classPrivateFieldGet(_remoteControlConsent, _this).hide();
      _classPrivateFieldGet(_fullDeviceConsent, _this).hide();
      _classPrivateFieldGet(_openConsent, _this).hide();
      const forwardControlEvents = (type, event) => _iframes.default.broadcastToChildren('control', [type, event]);
      const forwardRemoteErrorEvents = data => _iframes.default.broadcastToChildren('remote-error', data);

      // tear down and replace existing context if it exists
      if (_classPrivateFieldGet(_currentContext, _this)) {
        _classPrivateFieldGet(_currentContext, _this).session.off('updated', _classPrivateFieldGet(_onSessionUpdated, _this));
        _classPrivateFieldGet(_currentContext, _this).session.off('ended', _classPrivateFieldGet(_onSessionEnded, _this));
        _classPrivateFieldGet(_currentContext, _this).session.off('control', forwardControlEvents);
        _classPrivateFieldGet(_currentContext, _this).session.off('remote-error', forwardRemoteErrorEvents);
        _classPrivateFieldGet(_currentContext, _this).session.off('metrics.updated', _classPrivateFieldGet(_onSessionMetricsUpdated, _this));
        _classPrivateFieldGet(_currentContext, _this).destroy();
        _classPrivateFieldSet(_currentContext, _this, null);
      }

      // Ensure the session storage is up to date. Note that session might be null here, which
      // will clear the stored session.
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_sessionStorage, _this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.store(session);

      // build new session context
      if (session) {
        _classPrivateFieldSet(_currentContext, _this, new _sessions.SessionContext(session, _this));

        // if the session is loaded (i.e. not still just an id) then emit an update
        // on the main API. If the session is not laoded yet, we'll get another
        // updated event when it is.
        if (session.state()) _classPrivateFieldGet(_onSessionUpdated, _this).call(_this, session);
        session.on('updated', _classPrivateFieldGet(_onSessionUpdated, _this));
        session.once('ended', _classPrivateFieldGet(_onSessionEnded, _this));
        session.on('sync', () => _this.emit('session.sync'));
        session.on('control', forwardControlEvents);
        session.on('remote-error', forwardRemoteErrorEvents);
        session.on('metrics.updated', _classPrivateFieldGet(_onSessionMetricsUpdated, _this));
        if (invalidateFrames) _classPrivateFieldGet(_currentContext, _this).invalidateFrames();
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, session => {
      _classPrivateFieldGet(_sessionStorage, this).store(session);
      if (!session.fullDevice()) _classPrivateFieldGet(_fullDeviceConsent, this).hide();
      if (session.remoteControl() !== 'requested') _classPrivateFieldGet(_remoteControlConsent, this).hide();
      if (!session.isAuthorizing()) _classPrivateFieldGet(_sessionConsent, this).hide();
      this.emit('session.updated', session);
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, session => {
      this.emit('session.ended', session);
      // clear the session context if the session ends
      _classPrivateFieldGet(_setCurrentSession, this).call(this, null);
      _classPrivateFieldSet(_acceptedUniversalNavigation, this, false);
    });
    _classPrivateFieldInitSpec(this, _onSessionMetricsUpdated, session => {
      this.emit('session.metrics.updated', session);
    });
    _classPrivateFieldInitSpec(this, _showSessionControlsFn, void 0);
    _defineProperty(this, "hideSessionControls", () => {
      _ui.SessionStateOverlay.hideSessionControls();
    });
    _classPrivateFieldInitSpec(this, _throttledCustomDataUpdate, (0, _throttle.default)(() => {
      if (_classPrivateFieldGet(_device, this).hasPendingUpdates() && _classPrivateFieldGet(_started, this) && this.registration) {
        _classPrivateFieldGet(_device, this).updateRegistration().catch(e => {
          console.warn('CobrowseIO: updating customData failed', e);
        });
      }
    }, 8 * 1000, {
      leading: true,
      trailing: true
    }));
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmRemoteControl", async () => {
      return _classPrivateFieldGet(_remoteControlConsent, this).show(_Locale.default.tr('REMOTE_CONTROL_REQUEST_TITLE'), _Locale.default.tr('REMOTE_CONTROL_REQUEST_DESCRIPTION'));
    });
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmFullDevice", async () => {
      return _classPrivateFieldGet(_fullDeviceConsent, this).show(_Locale.default.tr('FULL_DEVICE_REQUEST_TITLE'), _Locale.default.tr('FULL_DEVICE_REQUEST_DESCRIPTION'));
    });
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmSession", async () => {
      return _classPrivateFieldGet(_sessionConsent, this).show(_Locale.default.tr('SESSION_REQUEST_TITLE'), _Locale.default.tr('SESSION_REQUEST_DESCRIPTION'));
    });
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmOpen", (url, type) => {
      if (type !== _Navigation.NAVIGATION_TYPE.UNIVERSAL) return true;
      if (_classPrivateFieldGet(_acceptedUniversalNavigation, this)) return true;
      const consentResult = _classPrivateFieldGet(_openConsent, this).show(_Locale.default.tr('UNIVERSAL_PROXY_REQUEST_TITLE'), _Locale.default.tr('UNIVERSAL_PROXY_REQUEST_DESCRIPTION'));
      consentResult.then(accepted => {
        if (accepted) _classPrivateFieldSet(_acceptedUniversalNavigation, this, true);
      });
      return consentResult;
    });
    // this is intended as a hook for people to provide
    // their own UI for Universal Proxy or PDF Viewer if they wish.
    _defineProperty(this, "showDocument", document => {
      if (document.target !== '_blank' && _TabOverlay.default.getTabCount() === 0) {
        _TabOverlay.default.enterFullScreen();
      } else {
        _TabOverlay.default.exitFullScreen();
      }
      const confirmUnload = document.type === _Navigation.NAVIGATION_TYPE.UNIVERSAL;
      const tab = _TabOverlay.default.newTab(document.element, '', document.url, document.isLoading, document.close, confirmUnload);
      if (document.isBlocked) tab.showBanner(_Locale.default.tr('UNIVERSAL_PROXY_BLOCKED'));
      const onDocumentUpdated = () => {
        tab.setIcon(document.icon);
        tab.setTitle(document.title || document.url);
        tab.setIsLoading(document.isLoading);
        tab.setContent(document.element);
        document.isBlocked ? tab.showBanner(_Locale.default.tr('UNIVERSAL_PROXY_BLOCKED')) : tab.hideBanner();
      };
      document.on('updated', onDocumentUpdated);
      document.once('closed', () => {
        document.off('updated', onDocumentUpdated);
        tab.close();
      });
    });
    _defineProperty(this, "getSession", async idOrCode => {
      if (!_classPrivateFieldGet(_started, this)) throw new Error('CobrowseIO not started. Call CobrowseIO.start()');
      // if we've already fetched this session, then update the same object and return it
      if (this.currentSession && (this.currentSession.id() === idOrCode || this.currentSession.code() === idOrCode)) {
        return this.currentSession.fetch();
      }
      const session = new _sessions.Session(this).updateResource({
        id: idOrCode
      });
      _classPrivateFieldGet(_setCurrentSession, this).call(this, session);
      await session.fetch();
      this.emit('session.loaded', session);
      return session;
    });
    _defineProperty(this, "createSession", async () => {
      if (!_classPrivateFieldGet(_started, this)) throw new Error('CobrowseIO not started. Call CobrowseIO.start()');
      if (this.currentSession && (this.currentSession.isActive() || this.currentSession.isAuthorizing())) {
        throw new Error('Already in a session');
      }
      if (timers.delta('load') < 8000) {
        console.warn('Six digit codes have a short expiry time. You should wait to generate a code until it is required! Do not generate codes on page load.');
      }
      const session = new _sessions.Session(this);
      _classPrivateFieldGet(_setCurrentSession, this).call(this, session);
      await session.update({
        custom_data: this.customData,
        device: _device2.Device.info
      });
      this.emit('session.loaded', session);
      return session;
    });
    // also provide a simplified wrapper for just creating a session code
    _defineProperty(this, "createSessionCode", async () => {
      const session = await this.createSession();
      return session.code();
    });
    _defineProperty(this, "client", async () => {
      return this;
    });
    _classPrivateFieldInitSpec(this, _applySettingsFrom, target => {
      if (!target) return;
      ['license', 'api', 'registration', 'customData', 'showSessionControls', 'hideSessionControls', 'confirmSession', 'confirmRemoteControl', 'confirmFullDevice', 'trustedOrigins', 'redactedViews', 'unredactedViews', 'ignoredViews', 'capabilities', 'pdfLinks', 'universalLinks', 'confirmOpen', 'showDocument', 'highlightElement', 'virtualAgent'].forEach(prop => {
        if (target[prop] !== undefined) this[prop] = target[prop];
      });
    });
    _classPrivateFieldInitSpec(this, _loadVirtualAgent, async () => {
      if (_classPrivateFieldGet(_virtualAgent, this)) {
        await (0, _virtualagent.initializeVirtualAgent)(_classPrivateFieldGet(_virtualAgent, this), this);
      }
    });
    debug('interface constructed in', document);
    _classPrivateFieldSet(_sessionStorageFactory, this, sessionStorageFactory);
    this.api = 'https://api.cobrowse.io';

    // The snippet will set up a basic CobrowseIO object
    // before the main JS blob has been loaded. The user might
    // have set some properties on this object that we need to
    // retrospectively apply.
    _classPrivateFieldGet(_applySettingsFrom, this).call(this, window && window.CobrowseIO);

    // Restore any active saved session from localstorage
    // sesisons are saved across pageloads so the same session
    // continues without interuption
    _classPrivateFieldSet(_restoredSession, this, _classPrivateFieldGet(_localSessionStorage, this).load(this));

    // Listen for notifications that contain requests from agents
    // to start a cobrowse session. The push notifications contain
    // the ID of a session which we can load through the regular
    // public getSession API.
    _classPrivateFieldGet(_device, this).on('notification', notification => {
      const code = notification['cobrowseio-code'];
      if (code) this.getSession(code).catch(err => {
        console.warn('CobrowseIO: session fetch failed:', err);
      });
    });
  }
  deviceId() {
    return _device2.Device.deviceId();
  }
  get currentSession() {
    if (_classPrivateFieldGet(_currentContext, this)) return _classPrivateFieldGet(_currentContext, this).session;
    return _classPrivateFieldGet(_restoredSession, this);
  }
  set showSessionControls(fn) {
    _classPrivateFieldSet(_showSessionControlsFn, this, fn);
    _ui.SessionStateOverlay.hideSessionControls();
    if (this.currentSession && this.currentSession.isActive()) {
      _classPrivateFieldGet(_showSessionControlsFn, this).call(this);
    }
  }
  get showSessionControls() {
    if (_classPrivateFieldGet(_showSessionControlsFn, this)) return _classPrivateFieldGet(_showSessionControlsFn, this);else return _ui.SessionStateOverlay.showSessionControls;
  }
  set license(license) {
    if (_classPrivateFieldGet(_started, this) && this.license !== license) throw new Error('Cannot change license once Cobrowse is started');
    _rest.RESTResource.setHeader('X-CobrowseLicense', license);
  }
  get license() {
    return _rest.RESTResource.getHeader('X-CobrowseLicense');
  }
  set api(api) {
    if (_classPrivateFieldGet(_started, this) && _rest.RESTResource.api !== api) throw new Error('Cannot change API once Cobrowse is started');
    _rest.RESTResource.api = api;
  }
  get api() {
    return _rest.RESTResource.api;
  }
  set registration(state) {
    if (_classPrivateFieldGet(_started, this) && _classPrivateFieldGet(_registration, this) !== state) throw new Error('Cannot change auto-registration state once Cobrowse is started');
    _classPrivateFieldSet(_registration, this, state);
  }
  get registration() {
    return !!_classPrivateFieldGet(_registration, this);
  }
  set redactedViews(redactedViews) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set redacted views after Cobrowse is started');
    _classPrivateFieldSet(_redactedViews, this, redactedViews);
  }
  get redactedViews() {
    return _classPrivateFieldGet(_redactedViews, this);
  }
  set unredactedViews(unredactedViews) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set unredacted views after Cobrowse is started');
    _classPrivateFieldSet(_unredactedViews, this, unredactedViews);
  }
  get unredactedViews() {
    return _classPrivateFieldGet(_unredactedViews, this);
  }
  set ignoredViews(ignoredViews) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set ignored views after Cobrowse is started');
    _classPrivateFieldSet(_ignoredViews, this, ignoredViews);
    _NodeTree.default.setIgnoredViews(ignoredViews);
  }
  get ignoredViews() {
    return _classPrivateFieldGet(_ignoredViews, this);
  }
  set capabilities(capabilities) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set capabilities after Cobrowse is started');
    if (!Array.isArray(capabilities)) throw new Error('Capabilities should be an array');
    _classPrivateFieldSet(_capabilities, this, capabilities.filter(capability => {
      if (!_device2.Device.info.capabilities.includes(capability)) {
        console.warn("Capability '".concat(capability, "' not supported. Ignoring..."));
        return false;
      }
      return true;
    }));
  }
  get capabilities() {
    var _this$currentSession$, _this$currentSession2;
    // if there's an active session, return the capabilities from the session
    // otherwise return the capabilities set by the user
    return (_this$currentSession$ = (_this$currentSession2 = this.currentSession) === null || _this$currentSession2 === void 0 ? void 0 : _this$currentSession2.capabilities) !== null && _this$currentSession$ !== void 0 ? _this$currentSession$ : _classPrivateFieldGet(_capabilities, this);
  }
  set customData(customData) {
    if (typeof customData !== 'object') throw new Error('Custom data must be an object');
    _classPrivateFieldSet(_customData, this, _objectSpread(_objectSpread({}, _classPrivateFieldGet(_customData, this)), customData));
    // setTimeout will allow coalescing of multiple custom data setting
    if (_classPrivateFieldGet(_started, this)) setTimeout(_classPrivateFieldGet(_throttledCustomDataUpdate, this), 0);

    // if there's an active session in progress, apply custom data udpates immediately
    if (this.currentSession && this.currentSession.isActive()) {
      const existing = this.currentSession.resource.custom_data;
      const changed = Object.keys(customData).find(key => existing[key] !== customData[key]);
      if (!changed) {
        debug('no changes to session custom data');
        return;
      }
      this.currentSession.update({
        custom_data: customData
      }).catch(() => {
        console.warn('CobrowseIO: failed to update custom data on active session');
      });
    }
  }
  get customData() {
    return _objectSpread(_objectSpread({}, _classPrivateFieldGet(_device, this).customData), _classPrivateFieldGet(_customData, this));
  }
  set trustedOrigins(origins) {
    const validated = origins.map(o => {
      try {
        return new URL(o).origin;
      } catch (e) {
        console.warn('CobrowseIO: Invalid URL in trustedOrigins:', o);
        return null;
      }
    }).filter(v => v);
    _iframes.default.trustedOrigins = validated;
  }
  get trustedOrigins() {
    return _iframes.default.trustedOrigins;
  }
  set pdfLinks(links) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set pdfLinks after Cobrowse is started');
    const validLinks = links.map(link => {
      if (link instanceof RegExp || typeof link === 'string') return link;
      console.warn('CobrowseIO: Invalid link in pdfLinks:', link);
      return null;
    }).filter(link => link);
    _classPrivateFieldSet(_pdfLinks, this, validLinks);
  }
  get pdfLinks() {
    return _classPrivateFieldGet(_pdfLinks, this);
  }
  set universalLinks(links) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set universalLinks after Cobrowse is started');
    const validLinks = links.map(link => {
      if (link instanceof RegExp || typeof link === 'string') return link;
      console.warn('CobrowseIO: Invalid link in universalLinks:', link);
      return null;
    }).filter(link => link);
    _classPrivateFieldSet(_universalLinks, this, validLinks);
  }
  get universalLinks() {
    return _classPrivateFieldGet(_universalLinks, this);
  }
  set virtualAgent(slug) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set virtualAgent after Cobrowse is started');
    _classPrivateFieldSet(_virtualAgent, this, slug);
  }
  get virtualAgent() {
    return _classPrivateFieldGet(_virtualAgent, this);
  }
  static get version() {
    return _device2.Device.info.sdk_version;
  }
  get version() {
    return CobrowseIO.version;
  }
}
exports.CobrowseIO = CobrowseIO;
_rest.RESTResource.setHeader('Content-Type', 'application/json');
_rest.RESTResource.setHeader('X-CobrowsePlatform', 'web');
_rest.RESTResource.setHeader('X-CobrowseSDKVersion', CobrowseIO.version);
_rest.RESTResource.setHeader('X-CobrowseDevice', _device2.Device.deviceId());
_rest.RESTResource.setHeader('X-CobrowseAPIVersion', '1.63.3');
var _default = exports["default"] = new CobrowseIO();

/***/ }),

/***/ 53147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Dynamics');
function swizzle() {
  const deviceId = _CobrowseIO.default.deviceId();
  let hasInitialized = false;
  function setContextProvider(deviceId) {
    window.Microsoft.Omnichannel.LiveChatWidget.SDK.setContextProvider(() => ({
      'cobrowse-device': {
        value: deviceId,
        isDisplayable: true
      }
    }));
    hasInitialized = true;
    debug('Dynamics initialized');
  }
  _CobrowseIO.default.customData = {
    cobrowse_device_id: deviceId
  };

  // The chat context provider can only be set once the SDK has bootstrapped
  // itself.
  window.addEventListener('lcw:ready', () => {
    if (!hasInitialized) {
      setContextProvider(deviceId);
    }
  });

  // It's possible the SDK had already bootstrapped itself, so try immediately
  // here and swallow any errors if it's not ready yet. Don't be tempted to use
  // the lcw:maximize event as there seem to be race conditions on setting the
  // context at that point.
  try {
    setContextProvider(deviceId);
  } catch (_) {}
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 30961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Freshchat');
async function saveCustomData() {
  const deviceId = _CobrowseIO.default.deviceId();
  window.fcWidget.user.setProperties({
    cobrowse_device_id: deviceId
  });
  const userData = await window.fcWidget.user.get();
  if (userData.success) {
    debug('Freshchat initialized');
    const user = userData.data;
    const customData = {
      freshchat_numeric_user_id: user.id + '',
      freshchat_user_id: user.alias,
      cobrowse_device_id: deviceId
    };

    // Freshchat adds a randomly generated name to a new user until either the
    // agent or the user updates it. We don't want to send this name to Cobrowse
    // as it's not the user's real name.
    if (!user.isNameGenerated) {
      customData.freshchat_user_first_name = user.firstName;
      customData.freshchat_user_last_name = user.lastName;
    }
    if (user.email) {
      customData.freshchat_user_email = user.email;
    }
    _CobrowseIO.default.customData = customData;
  }
}
async function swizzle() {
  if (!window.fcWidget) {
    debug('Freshchat not found');
    return;
  }

  // The user:created event is triggered on load as well as when the user
  // sends its first message. It usually fails when it's triggered on load
  // so we need to wait until the next successful trigger occurs.
  window.fcWidget.on('user:created', e => {
    if (!e.success) {
      return;
    }
    saveCustomData();
  });
  window.fcWidget.on('widget:opened', async () => {
    const userExists = await window.fcWidget.user.isExists();
    if (userExists.data === true) {
      await saveCustomData();
    }
  });
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 81809:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.TE = chat;
__webpack_unused_export__ = void 0;
exports.BV = messaging;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Genesys');
async function requestCobrowse(ext) {
  debug('Requesting cobrowse');
  // create a code a display it to the user using your own UI
  const code = await _CobrowseIO.default.createSessionCode();
  debug("Generated session code: ".concat(code));
  ext.command('WebChatService.sendFilteredMessage', {
    message: "Customer requests Cobrowse session with code: ".concat(code.substr(0, 3), " ").concat(code.substr(3)),
    regex: /Customer requests Cobrowse session with code:.*/
  }).done(function (e) {
    debug('CobrowseIOExtension.WebChatService sent filtered message successfully', e);
  }).fail(function (e) {
    debug('CobrowseIOExtension.WebChatService failed to send filtered message', e);
  });
}
function updateUserData(ext) {
  ext.command('WebChatService.updateUserData', {
    cobrowse_device_id: _CobrowseIO.default.deviceId()
  }).done(function (e) {
    debug('CobrowseIOExtension.WebChatService.updateUserData succeeded', e);
  }).fail(function (e) {
    debug('CobrowseIOExtension.WebChatService.updateUserData failed', e);
  });
}
function addCobrowseIOButtons(ext) {
  const cobrowseButton = document.querySelector('.cx-menu .cx-cobrowseio');
  // button is already added, so no-op
  if (cobrowseButton) return;
  const cxMenu = document.getElementsByClassName('cx-menu')[0];
  cxMenu.insertAdjacentHTML('beforeend', '<li role="none"><div class="cx-menu-item cx-cobrowseio cx-icon" role="button" data-icon="cobrowseio" tabindex="0" aria-label="Start Co-browse Opens the Co-browse session" title="Start Co-browse" style="display: block/;"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" viewBox="0 0 100 100" focusable="false" role="img" aria-hidden="true" alt="" data-gcb-service-node="true"><g class="cx-svg-icon-tone1" data-gcb-service-node="true"><path d="M11.5000001,3 L85.4166665,3 L87.6666668,3 C90.2624998,3 97,3.75367965 97,8.36940835 L97,30.4776335 L4.16666671,30.4776335 L4.16666671,70.4963922 C4.16666671,78.8021647 9.0333332,80.6810966 11.3333336,80.6810966 L88.6666664,80.6810966 C90.9625002,80.6810966 92.8333333,78.8021647 92.8333333,76.4963922 L92.8333333,41.8470419 L97,41.8470419 L97,79.5093796 C97,84.1251081 93.2624998,84.8787879 91.6666668,84.8787879 L8.3333332,84.8787879 C3.73750015,84.8787879 1,81.1251081 0,75.5093796 L0,8.36940835 C3,3.75367965 2.73750015,3 8.3333332,3 L8.5000001,3 Z M18.0297398,7.03030303 L5.9962825,7.03030303 C5.79033476,7.03030303 3.99999999,8.59607987 3.99999999,10.5175565 L3.999999,26.1125541 L93,26.1125541 L93,10.5175565 C93,8.59607987 91.2056692,7.03030303 89.0037175,7.03030303 L81.9702602,7.03030303 L18.0297398,7.03030303 Z M42.3451929,54.7727663 L42.3451929,68.6904309 L35,68.6904309 L35,47.7138693 C35,44.657411 37.4676761,42.1818182 40.5082059,42.1818182 L61.3971055,42.1818182 L61.3971055,49.5560425 L47.5394308,49.5560425 L66.3971054,67.9373646 L61.202867,73.154089 L42.3451929,54.7727663 Z" id="Fill-1-Copy""></path></g></svg></div></li>');
  document.getElementsByClassName('cx-cobrowseio')[0].onclick = () => requestCobrowse(ext);
}
let ext;
function chat() {
  if (ext) return;
  try {
    var _window;
    const bus = window.CXBus || ((_window = window) === null || _window === void 0 || (_window = _window._genesys) === null || _window === void 0 || (_window = _window.widgets) === null || _window === void 0 ? void 0 : _window.bus);
    if (!bus) throw new Error('Genesys bus not found');
    ext = bus.registerPlugin('CobrowseIOExtension');
    window.oCobrowseIOExtension = ext;
    debug('CobrowseIOExtension', ext);
    ext.subscribe('WebChat.opened', function (e) {
      debug('CobrowseIOExtension.WebChat.opened', e);
      addCobrowseIOButtons(ext);
      updateUserData(ext);
    });
    ext.subscribe('WebChatService.started', function (e) {
      try {
        debug('CobrowseIOExtension.WebChatService.started', e);
        const customData = {
          cobrowse_device_id: _CobrowseIO.default.deviceId()
        };
        if (e && e.data) {
          if (e.data.data && e.data.data.conversationId) customData.genesys_conversation_id = e.data.data.conversationId;
          if (e.data.userId && e.data.userId !== 'deprecated') customData.genesys_user_id = e.data.userId;
          if (e.data.sessionID && e.data.sessionID !== 'deprecated') customData.genesys_session_id = e.data.sessionID;
        }
        _CobrowseIO.default.customData = customData;
      } catch (error) {
        debug('Error during CobrowseIOExtension.WebChatService.started', error);
      }
    });
    ext.subscribe('WebChatService.agentConnected', function (e) {
      debug('CobrowseIOExtension.WebChatService.agentConnected', e);
    });
    ext.subscribe('WebChatService.clientConnected', function (e) {
      debug('CobrowseIOExtension.WebChatService.clientConnected', e);
    });
    ext.subscribe('WebChatService.restored', function (e) {
      debug('CobrowseIOExtension.WebChatService.restored', e);
    });
    ext.subscribe('WebChatService.ended', function (e) {
      debug('CobrowseIOExtension.WebChatService.ended', e);
      if (_CobrowseIO.default.currentSession && !_CobrowseIO.default.currentSession.isEnded()) {
        _CobrowseIO.default.currentSession.end();
      }
    });
    ext.subscribe('WebChat.started', function (e) {
      try {
        debug('CobrowseIOExtension.WebChat.started', e);
        if (e && e.data && e.data.form) {
          debug('e.data.form', e.data.form);
          const customData = e.data.form || {};
          customData.device_name = e.data.form.firstname ? "".concat(e.data.form.firstname, "'s device") : 'WebChat User\'s Device';
          _CobrowseIO.default.customData = customData;
        }
      } catch (error) {
        debug('Error during CobrowseIOExtension.WebChat.started', error);
      }
    });
    ext.republish('ready');
    ext.ready();
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Genesys, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}
function messaging() {
  try {
    window.Genesys('subscribe', 'Database.ready', () => {
      const deviceId = _CobrowseIO.default.deviceId();
      _CobrowseIO.default.customData = {
        cobrowse_device_id: deviceId
      };
      window.Genesys('command', 'Database.set', {
        messaging: {
          customAttributes: {
            cobrowse_device_id: deviceId
          }
        }
      });
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Genesys, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}
var _default = __webpack_unused_export__ = {
  messaging,
  chat
};

/***/ }),

/***/ 75160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations');
class Integrations {
  static watchProperty(obj, property, onSet) {
    let value = obj[property];
    const watch = () => {
      debug("monitoring changes to ".concat(property), obj);
      Object.defineProperty(obj, property, {
        configurable: true,
        set: newValue => {
          debug('CobrowseIO detected', property, 'as', newValue);
          value = newValue;
          Object.defineProperty(obj, property, {
            configurable: true,
            writable: true,
            value: newValue
          });
          setTimeout(() => onSet(watch), 0);
        },
        get: () => value
      });
    };
    if (value) {
      debug("".concat(property, " already exists as ").concat(obj[property]));
      onSet(watch);
    } else {
      watch();
    }
  }
  static initialize() {
    debug('Initializing integrations');
    this.watchProperty(window, 'Intercom', () => (__webpack_require__(83110)/* ["default"] */ .A)());
    this.watchProperty(window, '$zopim', () => (__webpack_require__(77319).zopim)());
    this.watchProperty(window, 'embedded_svc', () => this.watchProperty(window.embedded_svc, 'liveAgentAPI', () => {
      (__webpack_require__(39278)/* .embeddedSVC */ .th)();
    }));
    this.watchProperty(window, 'embeddedservice_bootstrap', () => (__webpack_require__(39278)/* .embeddedserviceBootstrap */ .MR)());
    this.initializeGenesys((__webpack_require__(81809)/* .messaging */ .BV), (__webpack_require__(81809)/* .chat */ .TE));
    this.initializeZendesk((__webpack_require__(77319).messenger), (__webpack_require__(77319).classic), (__webpack_require__(77319).sunshine));
    this.initializeFreshchat((__webpack_require__(30961)/* .swizzle */ .hA));
    this.initializeNice((__webpack_require__(32532)/* .swizzle */ .hA));
    this.initializeDynamics((__webpack_require__(53147)/* .swizzle */ .hA));
    this.initializeServiceNow((__webpack_require__(24244)/* .swizzle */ .hA));
    this.initializeTalkdesk((__webpack_require__(76726)/* .swizzle */ .hA));
  }
  static initializeGenesys(swizzleMessagingFn, swizzleChatFn) {
    this.watchProperty(window, 'Genesys', () => swizzleMessagingFn());
    this.watchProperty(window, 'CXBus', () => swizzleChatFn());
    this.watchProperty(window, '_genesys', () => this.watchProperty(window._genesys, 'widgets', () => this.watchProperty(window._genesys.widgets, 'bus', () => {
      setTimeout(() => {
        swizzleChatFn();
      }, 0);
    })));
  }
  static initializeFreshchat(swizzleFn) {
    this.watchProperty(window, 'fcWidget', () => swizzleFn());
  }
  static initializeTalkdesk(swizzleFn) {
    this.watchProperty(window, 'TalkdeskChatSDK', () => this.watchProperty(window, 'webchat', () => this.watchProperty(window.webchat, 'setContextParam', () => swizzleFn())));
  }
  static initializeZendesk(swizzleMessengerFn, swizzleClassicFn, swizzleSunshineFn) {
    this.watchProperty(window, 'zE', rewatch => {
      // check if the zendesk snippet is fully loaded or, just the initial zE is set
      if (!window.zE.widget) {
        return rewatch();
      }
      if (window.zE.widget === 'messenger') {
        swizzleMessengerFn();
      } else {
        swizzleClassicFn();
      }
    });
    this.watchProperty(window, 'Smooch', () => swizzleSunshineFn());
  }
  static initializeNice(swizzleFn) {
    this.watchProperty(window, 'cxone', rewatch => {
      if (!window.cxone.guide) {
        this.watchProperty(window.cxone, 'guide', () => swizzleFn());
        return rewatch();
      }
      swizzleFn();
    });
  }
  static initializeDynamics(swizzleFn) {
    this.watchProperty(window, 'Microsoft', () => this.watchProperty(window.Microsoft, 'Omnichannel', () => this.watchProperty(window.Microsoft.Omnichannel, 'LiveChatWidget', () => this.watchProperty(window.Microsoft.Omnichannel.LiveChatWidget, 'SDK', () => {
      swizzleFn();
    }))));
  }
  static initializeServiceNow(swizzleFn) {
    this.watchProperty(window, 'ServiceNowChat', () => swizzleFn());
  }
}
exports["default"] = Integrations;

/***/ }),

/***/ 83110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.A = _default;
var _throttle = _interopRequireDefault(__webpack_require__(7350));
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Intercom');
function update() {
  debug('Updating intercom integration');
  if (!window.intercomSettings) window.intercomSettings = {};
  window.intercomSettings.CobrowseID = _CobrowseIO.default.deviceId();
  window.Intercom('update', {
    CobrowseID: _CobrowseIO.default.deviceId()
  });
  _CobrowseIO.default.on('session.loaded', function (session) {
    window.Intercom('update', {
      CobrowseSessionID: session.id()
    });
  });
}
function _default() {
  try {
    if (window.Intercom && typeof window.Intercom === 'function') {
      debug('Initializing intercom integration');
      update();
      window.Intercom('onShow', (0, _throttle.default)(update, 2 * 60 * 1000, {
        trailing: false
      }));
    } else {
      throw new Error('expected window.Intercom to be a function');
    }
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Intercom, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 32532:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
__webpack_require__(42762);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Nice');
async function swizzle() {
  debug('Swizzling started');
  const deviceId = _CobrowseIO.default.deviceId();

  // Set the cobrowse_device_id custom field (needs to exist in Nice CX first)
  try {
    window.cxone('chat', 'setCustomerCustomField', 'cobrowse_device_id', deviceId);
  } catch (e) {
    console.log('Error setting Nice CX custom field', e);
  }
  window.cxone('chat', 'onAnyPushUpdate', _ref => {
    var _CobrowseIO$currentSe;
    let {
      data,
      eventType
    } = _ref;
    if (eventType === 'CaseCreated') {
      var _caseData$authorEndUs;
      debug('Nice case created');
      const {
        case: caseData
      } = data;
      const caseId = caseData.id + '';
      const userName = (_caseData$authorEndUs = caseData.authorEndUserIdentity.fullName) === null || _caseData$authorEndUs === void 0 ? void 0 : _caseData$authorEndUs.trim();
      const userId = caseData.authorEndUserIdentity.idOnExternalPlatform;
      _CobrowseIO.default.customData = {
        nice_case_id: caseId,
        nice_external_contact_id: userId,
        cobrowse_device_id: deviceId,
        user_name: userName
      };
    } else if (eventType === 'CaseStatusChanged' && data.case.status === 'closed' && (_CobrowseIO$currentSe = _CobrowseIO.default.currentSession) !== null && _CobrowseIO$currentSe !== void 0 && _CobrowseIO$currentSe.isActive()) {
      debug('Nice case closed');
      _CobrowseIO.default.currentSession.end();
    }
  });
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 39278:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.th = embeddedSVC;
exports.MR = embeddedserviceBootstrap;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Salesforce');

// The legacy chat implementation
// https://developer.salesforce.com/docs/atlas.en-us.live_agent_dev.meta/live_agent_dev/live_agent_dev_guide_intro.htm
function embeddedSVC() {
  try {
    if (typeof window.embedded_svc !== 'object') throw new Error('expected window.embedded_svc to a be an object');
    if (window.embedded_svc && !window.embedded_svc.liveAgentAPI) throw new Error('expected liveAgentAPI on embedded_svc');
    debug('Initializing salesforce legacy integration');
    window.embedded_svc.addEventHandler('onChatRequestSuccess', function (data) {
      if (data && data.liveAgentSessionKey) _CobrowseIO.default.customData = {
        salesforce_liveAgentSessionKey: data.liveAgentSessionKey
      };
    });
    window.embedded_svc.addEventHandler('onChatEndedByAgent', function () {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
    window.embedded_svc.addEventHandler('onChatEndedByChasitor', function () {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Salesforce Chat, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

// Convert a case sensitive 15 character id to a 18 character, case insensitve id
// https://help.salesforce.com/s/articleView?id=000385066&type=1
function salesforceEnsureCaseInsensitiveId(input) {
  if (input.length === 18) return input;
  if (input.length !== 15) throw Error("Invalid salesforce id: ".concat(input));
  let addon = '';
  for (let block = 0; block < 3; block++) {
    let loop = 0;
    for (let position = 0; position < 5; position++) {
      const current = input.charAt(block * 5 + position);
      if (current >= 'A' && current <= 'Z') {
        loop += 1 << position;
      }
    }
    addon += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ012345'.charAt(loop);
  }
  return input + addon;
}

// Enhanced messaging integration
// https://developer.salesforce.com/docs/service/messaging-web/guide/event-listeners.html
function embeddedserviceBootstrap() {
  try {
    if (typeof window.embeddedservice_bootstrap !== 'object') throw new Error('expected window.embeddedservice_bootstrap to a be an object');
    debug('Initializing salesforce enhanced messaging integration');
    // Extract the messaging session id from the event
    window.addEventListener('onEmbeddedMessagingConversationRouted', event => {
      var _event$detail;
      const entryPayloadJSON = event === null || event === void 0 || (_event$detail = event.detail) === null || _event$detail === void 0 || (_event$detail = _event$detail.conversationEntry) === null || _event$detail === void 0 ? void 0 : _event$detail.entryPayload;
      if (!entryPayloadJSON) throw new Error('No entry payload found');
      const entryPayload = JSON.parse(entryPayloadJSON);
      const messagingSessionId = entryPayload === null || entryPayload === void 0 ? void 0 : entryPayload.recordId; // this is a 15 character id
      if (!messagingSessionId) throw new Error('No messaging Session Id found in entry payload');
      const caseInsensitiveMessagingId = salesforceEnsureCaseInsensitiveId(messagingSessionId);
      _CobrowseIO.default.customData = {
        salesforce_MessagingSessionId: caseInsensitiveMessagingId
      };
    });
    window.addEventListener('onEmbeddedMessagingConversationClosed', event => {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
    window.addEventListener('onEmbeddedMessagingWindowClosed', event => {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Salesforce Chat, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 24244:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.ServiceNow');
function swizzle() {
  const deviceId = _CobrowseIO.default.deviceId();
  _CobrowseIO.default.customData = {
    cobrowse_device_id: deviceId
  };
  debug('ServiceNow initialized');
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 76726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Talkdesk');
let hasInitialized = false;
function swizzle() {
  if (typeof TalkdeskChatSDK !== 'function') {
    console.warn('TalkdeskChatSDK is not a function, ignoring as Talkdesk widget might not be present.');
    return;
  }
  if (!window.webchat) {
    console.warn('Talkdesk not found in variable "webchat". Please load Talkdesk using:');
    console.warn('window.webchat = TalkdeskChatSDK(node, props)');
    return;
  }
  if (typeof window.webchat.setContextParam !== 'function') {
    console.warn('window.webchat.setContextParam is missing or of an unexpected value. Please load Talkdesk using:');
    console.warn('window.webchat = TalkdeskChatSDK(node, props)');
    return;
  }
  if (!hasInitialized) {
    const customData = {
      cobrowse_device_id: _CobrowseIO.default.deviceId()
    };
    _CobrowseIO.default.customData = customData;
    window.webchat.setContextParam(customData);
    hasInitialized = true;
    debug('Talkdesk initialized');
  }
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 71907:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.classic = classic;
exports.updateCustomData = updateCustomData;
__webpack_require__(62953);
var _ = __webpack_require__(77319);
// eslint-disable-next-line complexity
function updateCustomData(cmd, props) {
  let customData = {};
  if (cmd === 'identify' && props) {
    if (props.name) customData.user_name = props.name;
    if (props.email) customData.user_email = props.email;
    if (props.organization) customData.user_organization = props.organization;
  } else if (cmd === 'prefill' && props) {
    if (props.name && props.name.value) customData.user_name = props.name.value;
    if (props.email && props.email.value) customData.user_email = props.email.value;
    if (props.phone && props.phone.value) customData.user_phone = props.phone.value;
  } else if (cmd === 'logout') {
    customData = {
      user_name: null,
      user_email: null,
      user_organization: null,
      user_phone: null
    };
  }
  (0, _.fillCustomData)(customData);
}
function swizzle() {
  if (window.zE && window.zE.identify) {
    (0, _.swizzlezE)();

    // swizzle zE.identify
    const zEIdentifySuper = window.zE.identify;
    window.zE.identify = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const [props] = args;
      updateCustomData('identify', props);
      return zEIdentifySuper(...args);
    };
  } else {
    throw new Error('missing window.zE or window.zE.identify');
  }
}
function classic() {
  try {
    swizzle();
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk (classic), please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 77319:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.POLLING_INTERVAL = void 0;
Object.defineProperty(exports, "classic", ({
  enumerable: true,
  get: function () {
    return _classic.classic;
  }
}));
exports["default"] = void 0;
exports.fillCustomData = fillCustomData;
Object.defineProperty(exports, "messenger", ({
  enumerable: true,
  get: function () {
    return _messenger.messenger;
  }
}));
Object.defineProperty(exports, "sunshine", ({
  enumerable: true,
  get: function () {
    return _sunshine.sunshine;
  }
}));
exports.swizzlezE = swizzlezE;
Object.defineProperty(exports, "zopim", ({
  enumerable: true,
  get: function () {
    return _zopim.zopim;
  }
}));
__webpack_require__(62953);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _zopim = __webpack_require__(34808);
var _classic = __webpack_require__(71907);
var _messenger = __webpack_require__(96040);
var _sunshine = __webpack_require__(70);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const POLLING_INTERVAL = exports.POLLING_INTERVAL = 2000;
function fillCustomData(customData) {
  if (Object.keys(customData).length) {
    _CobrowseIO.default.customData = customData;
  }
}
function swizzlezE() {
  const zEsuper = window.zE;
  window.zE = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const [tgt, cmd, props] = args;
    if (tgt === 'webWidget') (0, _classic.updateCustomData)(cmd, props);
    if (tgt === 'messenger') (0, _messenger.updateCustomData)(cmd, props);

    // It is possible that some tags are being set externally and currently the
    // zE API does not allow us to get the current tags. We need to catch that
    // external call here and add our own tags to the list. We also need to
    // prevent the tags from being overridden by any subsequent calls we make.
    if (tgt === 'messenger:set' && cmd === 'conversationTags') {
      let tags = props;
      if (tags && tags.length) {
        const deviceId = _CobrowseIO.default.deviceId();
        tags = [...tags, "cobrowseio_deviceid_".concat(deviceId)];
        args[2] = tags;
        window.zE.__cobrowseio_zendesk_tags_set = true;
      }
    }
    return zEsuper(...args);
  };

  // copy all properties of the zE function
  // eslint-disable-next-line guard-for-in,no-restricted-syntax
  for (const k in zEsuper) window.zE[k] = zEsuper[k];
}
var _default = exports["default"] = {
  messenger: _messenger.messenger,
  classic: _classic.classic,
  sunshine: _sunshine.sunshine,
  zopim: _zopim.zopim
};

/***/ }),

/***/ 96040:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.messenger = messenger;
exports.updateCustomData = updateCustomData;
__webpack_require__(27495);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _ = __webpack_require__(77319);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
let storage = window.localStorage;
function updateCustomData(cmd, props) {
  let customData = {};

  // There's no such thing as an `identify` method on the messenger web widget
  // but for our use case it serves for the same purpose
  if (cmd === 'identify' && props) {
    customData = {
      zendesk_web_user_id: props.appUserId,
      cobrowseio_deviceid: props.deviceId
    };
  } else if (cmd === 'logoutUser') {
    // Clear old data possibly set by the classic widget as well as the user ID
    customData = {
      user_name: null,
      user_email: null,
      user_organization: null,
      user_phone: null,
      zendesk_web_user_id: null,
      zendesk_user_id: null,
      zendesk_ticket_id: null
    };
  }
  (0, _.fillCustomData)(customData);
}
function addTags() {
  // The `messenger:set` method was called externally to set the tags and our zE
  // swizzling code should already have added the device ID. We don't want to
  // override any other tags set by the external call.
  if (window.zE.__cobrowseio_zendesk_tags_set) {
    return;
  }
  window.zE('messenger:set', 'conversationTags', ["cobrowseio_deviceid_".concat(_CobrowseIO.default.deviceId())]);
}
function swizzle() {
  // The only user identifying ID present on both the agent and the user side
  // is the App User ID. To retrieve it on this side we need to look for the
  // client ID set by the widget, then find the instance ID and finally
  // retrieve the App User ID. There could be situations where there are more
  // than one set of data stored in the user's local storage so we need to
  // retrieve the currently used one by starting to look at the `ZD-buid` item.

  const clientId = getClientId();
  if (!clientId) {
    throw new Error('Missing client ID (ZD-buid)');
  }
  const instanceId = getInstanceId(clientId);
  if (!instanceId) {
    throw new Error('Instance ID could not be found');
  }
  const appUserId = getMessengerAppUserId(instanceId);
  addTags();
  updateCustomData('identify', {
    appUserId,
    deviceId: _CobrowseIO.default.deviceId()
  });
}
function getClientId() {
  return storage.getItem('ZD-buid');
}
function getInstanceId(clientId) {
  var _Object$keys$find;
  return (_Object$keys$find = Object.keys(storage).find(key => key.match(/\w+\.clientId/) && storage[key] === clientId)) === null || _Object$keys$find === void 0 || (_Object$keys$find = _Object$keys$find.split('.')) === null || _Object$keys$find === void 0 ? void 0 : _Object$keys$find[0];
}
function getMessengerAppUserId(instanceId) {
  return storage.getItem("".concat(instanceId, ".appUserId"));
}

// ZD-widgetOpen is always stored in session storage
function isWidgetOpen() {
  return sessionStorage.getItem('ZD-widgetOpen') === 'true';
}
function setStorageType() {
  if (sessionStorage.getItem('ZD-buid')) {
    storage = window.sessionStorage;
  } else {
    storage = window.localStorage;
  }
}
function pollAppUserId() {
  const checkAppUserId = (resolve, reject) => {
    // Zendesk can be configured to remember or forget chat history when a user
    // comes back to the site. If set to remember, the chat widget will store
    // its data in local storage, otherwise it will use session storage.
    setStorageType();
    const appUserId = getMessengerAppUserId(getInstanceId(getClientId()));
    if (appUserId) {
      resolve(appUserId);
    } else {
      setTimeout(checkAppUserId, _.POLLING_INTERVAL, resolve, reject);
    }
  };
  return new Promise(checkAppUserId);
}
function messenger() {
  (0, _.swizzlezE)();
  try {
    // The local storage key we require to extract the App User ID won't
    // be set on the first page load, it gets set after the chat has begun
    // (when the first messages load in the widget). We can't simply use the
    // `open` event because it fires before this data is made available to
    // us. Additionally, this event won't be triggered if the user had opened
    // the chat previously in this session so we need to start the polling
    // manually in this situation.
    if (isWidgetOpen()) {
      pollAppUserId().then(swizzle);
    } else {
      window.zE('messenger:on', 'open', () => {
        pollAppUserId().then(swizzle);
      });
    }
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk (messenger), please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 70:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.sunshine = sunshine;
var _ = __webpack_require__(77319);
function updateCustomData(props) {
  const customData = {
    zendesk_web_user_id: props.appUserId
  };
  (0, _.fillCustomData)(customData);
}
function swizzle() {
  updateCustomData({
    appUserId: getAppUserId()
  });
}
function getAppUserId() {
  var _window$Smooch$getUse;
  return (_window$Smooch$getUse = window.Smooch.getUser()) === null || _window$Smooch$getUse === void 0 ? void 0 : _window$Smooch$getUse.id;
}
function pollAppUserId() {
  const checkAppUserId = (resolve, reject) => {
    const appUserId = getAppUserId();
    if (appUserId) {
      resolve(appUserId);
    } else {
      setTimeout(checkAppUserId, _.POLLING_INTERVAL, resolve, reject);
    }
  };
  return new Promise(checkAppUserId);
}
function sunshine() {
  try {
    window.Smooch.on('widget:opened', () => {
      pollAppUserId().then(swizzle);
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk (Sunshine Conversations), please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 34808:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.zopim = zopim;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Zendesk');
function zopim() {
  try {
    if (typeof window.$zopim !== 'function') throw new Error('expected window.$zopim to a be a function');
    window.$zopim(function () {
      debug('Initializing zendesk integration');
      window.$zopim.livechat.addTags("cobrowseio_deviceid_".concat(_CobrowseIO.default.deviceId()));
      _CobrowseIO.default.customData = {
        cobrowseio_deviceid: _CobrowseIO.default.deviceId()
      };
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk Chat, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 64033:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _WindowTaps = _interopRequireDefault(__webpack_require__(44153));
var _UniversalHooks = _interopRequireDefault(__webpack_require__(11191));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const getIcon = () => {
  const icons = document.querySelectorAll('link[rel="icon"]');
  if (icons.length > 0) return icons[0].href;
  return '/favicon.ico';
};
var _onChange = /*#__PURE__*/new WeakMap();
var _onPageChange = /*#__PURE__*/new WeakMap();
class DocumentObserver {
  constructor(onChange) {
    _classPrivateFieldInitSpec(this, _onChange, void 0);
    _classPrivateFieldInitSpec(this, _onPageChange, () => {
      const url = _UniversalHooks.default.unproxify(window.location.href);
      const icon = new URL(getIcon(), url).href;
      _classPrivateFieldGet(_onChange, this).call(this, {
        url,
        icon: _UniversalHooks.default.proxify(icon),
        title: document.title,
        isLoading: document.readyState !== 'complete',
        isBlocked: false
      });
    });
    _defineProperty(this, "sendLoading", url => {
      _classPrivateFieldGet(_onChange, this).call(this, {
        url,
        icon: '',
        title: '',
        isLoading: true,
        isBlocked: false
      });
    });
    _defineProperty(this, "sendBlocked", url => {
      _classPrivateFieldGet(_onChange, this).call(this, {
        url,
        icon: '',
        title: '',
        isLoading: false,
        isBlocked: true
      });
    });
    _defineProperty(this, "destroy", () => {
      _WindowTaps.default.off('navigate', _classPrivateFieldGet(_onPageChange, this));
      window.removeEventListener('popstate', _classPrivateFieldGet(_onPageChange, this), {
        capture: true
      });
      document.removeEventListener('readystatechange', _classPrivateFieldGet(_onPageChange, this), {
        capture: true
      });
    });
    _classPrivateFieldSet(_onChange, this, onChange);
    _WindowTaps.default.on('navigate', _classPrivateFieldGet(_onPageChange, this));
    window.addEventListener('popstate', _classPrivateFieldGet(_onPageChange, this), {
      capture: true
    });
    document.addEventListener('readystatechange', _classPrivateFieldGet(_onPageChange, this), {
      capture: true
    });
    _classPrivateFieldGet(_onPageChange, this).call(this);
  }
}
exports["default"] = DocumentObserver;

/***/ }),

/***/ 56913:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _events = __webpack_require__(37007);
var _pick = _interopRequireDefault(__webpack_require__(44383));
var _nodes = __webpack_require__(66938);
const _excluded = ["id", "redaction"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _getNode = /*#__PURE__*/new WeakMap();
var _serializeTarget = /*#__PURE__*/new WeakMap();
var _onClick = /*#__PURE__*/new WeakMap();
var _onChange = /*#__PURE__*/new WeakMap();
class InteractionTracking extends _events.EventEmitter {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "track", node => {
      node.addEventListener('click', _classPrivateFieldGet(_onClick, this), {
        capture: true,
        passive: true
      });
      node.addEventListener('change', _classPrivateFieldGet(_onChange, this), {
        capture: true,
        passive: true
      });
    });
    _defineProperty(this, "untrack", node => {
      node.removeEventListener('click', _classPrivateFieldGet(_onClick, this), {
        capture: true,
        passive: true
      });
      node.removeEventListener('change', _classPrivateFieldGet(_onChange, this), {
        capture: true,
        passive: true
      });
    });
    _classPrivateFieldInitSpec(this, _getNode, target => {
      const nodeId = _nodes.NodeTracker.get(target);
      if (!nodeId) return undefined;
      const serialized = _nodes.NodeSerializer.serialize(target, undefined, {
        skipChildren: true
      });
      if (serialized) return serialized;
      return {
        id: nodeId,
        redaction: true
      };
    });
    _classPrivateFieldInitSpec(this, _serializeTarget, function (target) {
      let includeValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const node = _classPrivateFieldGet(_getNode, _this).call(_this, target);
      if (!node) return node;
      const {
          id,
          redaction
        } = node,
        rest = _objectWithoutProperties(node, _excluded);
      return _objectSpread({
        id,
        redacted: Boolean(redaction)
      }, includeValue && (0, _pick.default)(rest, ['value', 'checked']));
    });
    _classPrivateFieldInitSpec(this, _onClick, event => {
      const serializedTarget = _classPrivateFieldGet(_serializeTarget, this).call(this, event.target);
      this.emit('click', serializedTarget);
    });
    _classPrivateFieldInitSpec(this, _onChange, event => {
      const serializedTarget = _classPrivateFieldGet(_serializeTarget, this).call(this, event.target, true);
      this.emit('change', serializedTarget);
    });
  }
}
var _default = exports["default"] = new InteractionTracking();

/***/ }),

/***/ 86350:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _throttle = _interopRequireDefault(__webpack_require__(7350));
var _src = __webpack_require__(89501);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class MouseTracking {
  constructor() {
    _defineProperty(this, "_mousePosition", {
      x: -1,
      y: -1
    });
    _defineProperty(this, "_mouseIsDown", false);
    _defineProperty(this, "_mouseIsIn", false);
    _defineProperty(this, "track", node => {
      node.addEventListener('mousedown', this._onMouseDown, {
        capture: true,
        passive: true
      });
      node.addEventListener('mouseup', this._onMouseUp, {
        capture: true,
        passive: true
      });
      node.addEventListener('mouseenter', this._onMouseEnter, {
        capture: true,
        passive: true
      });
      node.addEventListener('mouseleave', this._onMouseLeave, {
        capture: true,
        passive: true
      });
      node.addEventListener('mousemove', this._onMouseMove, {
        capture: true,
        passive: true
      });
    });
    _defineProperty(this, "untrack", node => {
      node.removeEventListener('mousedown', this._onMouseDown, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mouseup', this._onMouseUp, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mouseenter', this._onMouseEnter, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mouseleave', this._onMouseLeave, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mousemove', this._onMouseMove, {
        capture: true,
        passive: true
      });
    });
    _defineProperty(this, "isDown", () => {
      return this._mouseIsDown;
    });
    _defineProperty(this, "setDown", down => {
      this._mouseIsDown = down;
      if (this.onChange) this.onChange(this.state());
    });
    _defineProperty(this, "isIn", () => {
      return this._mouseIsIn > 0;
    });
    _defineProperty(this, "position", () => {
      return this._mousePosition;
    });
    _defineProperty(this, "setPosition", (x, y, iframe) => {
      if (iframe) {
        // work out the iframe offset, taking into account iframes can be nested
        const iframes = [iframe, ...(0, _src.parents)(iframe).filter(n => {
          var _n$matches;
          return (_n$matches = n.matches) === null || _n$matches === void 0 ? void 0 : _n$matches.call(n, 'iframe');
        })];
        const offset = iframes.map(n => n.getBoundingClientRect()).reduce((a, b) => {
          return {
            x: a.x + b.x,
            y: a.y + b.y
          };
        }, {
          x: 0,
          y: 0
        });
        x += Math.round(offset.x);
        y += Math.round(offset.y);
      }
      this._mousePosition = {
        x,
        y
      };
      if (this.onChange) this.onChange(this.state());
    });
    _defineProperty(this, "state", () => {
      return _objectSpread(_objectSpread({}, this.position()), {}, {
        down: this.isDown(),
        in: this.isIn()
      });
    });
    _defineProperty(this, "_onMouseDown", e => {
      if (!e.isTrusted) return;
      this.setDown(true);
    });
    _defineProperty(this, "_onMouseUp", e => {
      if (!e.isTrusted) return;
      this.setDown(false);
    });
    _defineProperty(this, "_onMouseEnter", e => {
      if (!e.isTrusted) return;
      this._mouseIsIn += 1;
    });
    _defineProperty(this, "_onMouseLeave", e => {
      if (!e.isTrusted) return;
      if (e.target !== e.currentTarget) return;
      this._mouseIsIn -= 1;
    });
    _defineProperty(this, "_onMouseMove", (0, _throttle.default)(e => {
      if (!e.isTrusted) return;
      const {
        clientX,
        clientY
      } = e;
      const iframe = e.view && e.view.frameElement;
      this.setPosition(clientX, clientY, iframe);
    }, 100));
  }
}
var _default = exports["default"] = new MouseTracking();

/***/ }),

/***/ 27771:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _events = __webpack_require__(37007);
var _uuid = __webpack_require__(65392);
var _storage = _interopRequireDefault(__webpack_require__(86542));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.WindowTracking');
const ActiveWindowPath = '_cobrowse_window_id';
var _id = /*#__PURE__*/new WeakMap();
var _tracksIframes = /*#__PURE__*/new WeakMap();
var _started = /*#__PURE__*/new WeakMap();
var _evaluateActive = /*#__PURE__*/new WeakMap();
class WindowTracking extends _events.EventEmitter {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec(this, _id, _generateId._.call(WindowTracking));
    _classPrivateFieldInitSpec(this, _tracksIframes, false);
    _classPrivateFieldInitSpec(this, _started, false);
    _defineProperty(this, "start", () => {
      if (_classPrivateFieldGet(_started, this)) return;
      _classPrivateFieldSet(_started, this, true);
      debug('started');
      _classPrivateFieldGet(_evaluateActive, this).call(this);
      document.addEventListener('visibilitychange', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
      document.addEventListener('mouseover', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
    });
    _defineProperty(this, "stop", () => {
      debug('stopped');
      this.removeAllListeners();
      _classPrivateFieldSet(_started, this, false);
      document.removeEventListener('visibilitychange', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
      document.removeEventListener('mouseover', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
    });
    _defineProperty(this, "isActive", () => {
      return (0, _storage.default)().getItem(ActiveWindowPath) === this.id;
    });
    _defineProperty(this, "setTracksIframes", trackIframes => {
      _classPrivateFieldSet(_tracksIframes, this, trackIframes);
      _classPrivateFieldGet(_evaluateActive, this).call(this);
    });
    _defineProperty(this, "shouldTrack", () => {
      if (document.hidden) return false;
      const isFrame = window.self !== window.top;
      if (isFrame) return _classPrivateFieldGet(_tracksIframes, this);
      return true;
    });
    _defineProperty(this, "makeActive", () => {
      if (!this.isActive()) {
        debug('making active', window);
        (0, _storage.default)().setItem(ActiveWindowPath, this.id);
        this.emit('activate', window);
      }
    });
    _defineProperty(this, "resignActive", () => {
      if (this.isActive()) {
        debug('resigning active', window);
        (0, _storage.default)().setItem(ActiveWindowPath, null);
      }
    });
    _classPrivateFieldInitSpec(this, _evaluateActive, () => {
      if (this.shouldTrack()) this.makeActive();
      this.emit('updated');
    });
  }
  get id() {
    return _classPrivateFieldGet(_id, this);
  }
}
var _generateId = {
  _: () => {
    document.__cobrowse_window_id = document.__cobrowse_window_id || (0, _uuid.v4)();
    return document.__cobrowse_window_id;
  }
};
var _default = exports["default"] = new WindowTracking();

/***/ }),

/***/ 45264:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "InteractionTracking", ({
  enumerable: true,
  get: function () {
    return _InteractionTracking.default;
  }
}));
Object.defineProperty(exports, "MouseTracking", ({
  enumerable: true,
  get: function () {
    return _MouseTracking.default;
  }
}));
Object.defineProperty(exports, "WindowTracking", ({
  enumerable: true,
  get: function () {
    return _WindowTracking.default;
  }
}));
var _MouseTracking = _interopRequireDefault(__webpack_require__(86350));
var _WindowTracking = _interopRequireDefault(__webpack_require__(27771));
var _InteractionTracking = _interopRequireDefault(__webpack_require__(56913));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 62863:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _mountComponent = __webpack_require__(89103);
var _ui = __webpack_require__(33035);
var _CallSession = _interopRequireDefault(__webpack_require__(4383));
var _MediaSettings = _interopRequireWildcard(__webpack_require__(93646));
var _Signalling = _interopRequireDefault(__webpack_require__(27323));
var _IceServers = _interopRequireDefault(__webpack_require__(93130));
var _MediaPreview = __webpack_require__(94037);
var _activity = __webpack_require__(45264);
var _storage2 = _interopRequireDefault(__webpack_require__(86542));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const MEDIA_SETTINGS_STORAGE_KEY = '_cobrowse_media_settings';

/**
 * CallHandler manages the lifecycle of a CallSession. It is instantiated by SessionContext when
 * the stream socket has opened, this ensures the socket we receive is in the correct state.
 *
 * It coordinates:
 * - Session state changes (e.g. requested, on, rejected, off)
 * - Dynamic mounting / unmounting of UI components (e.g. MediaPreview, CallParticipants)
 * - Media setting changes (e.g. toggle audio / video, change of device, etc)
 * - Client presence events (e.g. join, leave)
 *
 * CallHandler acts as the glue between the Session and Socket implementation in the SDK and the
 * common Calling modules. It is the entry point for Calling.
 */
var _storage = /*#__PURE__*/new WeakMap();
var _mediaPreviewComponent = /*#__PURE__*/new WeakMap();
var _callParticipantsComponent = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
var _clientTracker = /*#__PURE__*/new WeakMap();
var _signalling = /*#__PURE__*/new WeakMap();
var _mediaSettings = /*#__PURE__*/new WeakMap();
var _iceServers = /*#__PURE__*/new WeakMap();
var _calling = /*#__PURE__*/new WeakMap();
var _callSession = /*#__PURE__*/new WeakMap();
var _isCallAccepted = /*#__PURE__*/new WeakMap();
var _saveMediaSettings = /*#__PURE__*/new WeakMap();
var _onWindowActivate = /*#__PURE__*/new WeakMap();
var _onJoin = /*#__PURE__*/new WeakMap();
var _onLeave = /*#__PURE__*/new WeakMap();
var _fetchIceServers = /*#__PURE__*/new WeakMap();
var _onAudioInputSettingsUpdated = /*#__PURE__*/new WeakMap();
var _onVideoInputSettingsUpdated = /*#__PURE__*/new WeakMap();
var _onSessionStateOverlayClick = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _callingOff = /*#__PURE__*/new WeakMap();
var _callingRequested = /*#__PURE__*/new WeakMap();
var _callingOn = /*#__PURE__*/new WeakMap();
var _showMediaPreview = /*#__PURE__*/new WeakMap();
class CallHandler {
  constructor(_session2, clientTracker, socket) {
    _classPrivateFieldInitSpec(this, _storage, (0, _storage2.default)());
    _classPrivateFieldInitSpec(this, _mediaPreviewComponent, void 0);
    _classPrivateFieldInitSpec(this, _callParticipantsComponent, void 0);
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _clientTracker, void 0);
    _classPrivateFieldInitSpec(this, _signalling, void 0);
    _classPrivateFieldInitSpec(this, _mediaSettings, void 0);
    _classPrivateFieldInitSpec(this, _iceServers, void 0);
    _classPrivateFieldInitSpec(this, _calling, void 0);
    _classPrivateFieldInitSpec(this, _callSession, void 0);
    _classPrivateFieldInitSpec(this, _isCallAccepted, false);
    _classPrivateFieldInitSpec(this, _saveMediaSettings, settings => {
      _classPrivateFieldGet(_storage, this).setItem(MEDIA_SETTINGS_STORAGE_KEY, settings);
    });
    _classPrivateFieldInitSpec(this, _onWindowActivate, async () => {
      if (_classPrivateFieldGet(_calling, this) !== 'on') return;
      _classPrivateFieldGet(_mediaSettings, this).update(_classPrivateFieldGet(_storage, this).getItem(MEDIA_SETTINGS_STORAGE_KEY));
      if (_classPrivateFieldGet(_callSession, this)) {
        const remoteParticipants = Array.from(_classPrivateFieldGet(_callSession, this).participants.values()).filter(participant => !participant.isLocal);
        await Promise.all(remoteParticipants.map(participant => _classPrivateFieldGet(_callSession, this).reconnectParticipant(participant.id)));
        return;
      }
      await _classPrivateFieldGet(_callingOn, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onJoin, async _ref => {
      let {
        id,
        agent
      } = _ref;
      if (!_classPrivateFieldGet(_callSession, this)) return;
      await _classPrivateFieldGet(_callSession, this).addParticipant(id, agent);
    });
    _classPrivateFieldInitSpec(this, _onLeave, id => {
      if (!_classPrivateFieldGet(_callSession, this)) return;
      _classPrivateFieldGet(_callSession, this).removeParticipant(id);
    });
    _classPrivateFieldInitSpec(this, _fetchIceServers, async () => {
      try {
        await _classPrivateFieldGet(_iceServers, this).create();
        return _classPrivateFieldGet(_iceServers, this).resource.iceServers;
      } catch (err) {
        console.warn('failed to fetch ice servers', err);
        return [];
      }
    });
    _classPrivateFieldInitSpec(this, _onAudioInputSettingsUpdated, async settings => {
      if (!_classPrivateFieldGet(_callSession, this)) return;
      _ui.SessionStateOverlay.showCallingControls(settings);
      if (!settings.audioEnabled) return _classPrivateFieldGet(_callSession, this).unpublishAudioTrack();
      if (!navigator.mediaDevices) {
        console.warn('CobrowseIO: Failed to start audio, mediaDevices is not available');
        _classPrivateFieldGet(_mediaSettings, this).update({
          audioEnabled: false
        });
        return;
      }
      try {
        const constraints = (0, _MediaSettings.createAudioConstraints)(settings);
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        _classPrivateFieldGet(_callSession, this).publishStreamTracks(stream);
      } catch (err) {
        console.warn('CobrowseIO: Failed to get audio', err);
        _classPrivateFieldGet(_mediaSettings, this).update({
          audioEnabled: false
        });
      }
    });
    _classPrivateFieldInitSpec(this, _onVideoInputSettingsUpdated, async settings => {
      if (!_classPrivateFieldGet(_callSession, this)) return;
      _ui.SessionStateOverlay.showCallingControls(settings);
      if (!settings.videoEnabled) return _classPrivateFieldGet(_callSession, this).unpublishVideoTrack();
      if (!navigator.mediaDevices) {
        console.warn('CobrowseIO: Failed to start video, mediaDevices is not available');
        _classPrivateFieldGet(_mediaSettings, this).update({
          videoEnabled: false
        });
        return;
      }
      try {
        const constraints = (0, _MediaSettings.createVideoConstraints)(settings);
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        _classPrivateFieldGet(_callSession, this).publishStreamTracks(stream);
      } catch (err) {
        console.warn('CobrowseIO: Failed to get video', err);
        _classPrivateFieldGet(_mediaSettings, this).update({
          videoEnabled: false
        });
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionStateOverlayClick, target => {
      if (target === 'audio') _classPrivateFieldGet(_mediaSettings, this).toggleAudio();
      if (target === 'video') _classPrivateFieldGet(_mediaSettings, this).toggleVideo();
      if (target === 'settings') _classPrivateFieldGet(_showMediaPreview, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, (session, prevSession) => {
      _classPrivateFieldSet(_calling, this, session.calling());
      if (_classPrivateFieldGet(_calling, this) !== (prevSession === null || prevSession === void 0 ? void 0 : prevSession.calling())) {
        if (_classPrivateFieldGet(_calling, this) === 'off') _classPrivateFieldGet(_callingOff, this).call(this);
        if (_classPrivateFieldGet(_calling, this) === 'requested' && _activity.WindowTracking.isActive()) _classPrivateFieldGet(_callingRequested, this).call(this);
        if (_classPrivateFieldGet(_calling, this) === 'on' && _activity.WindowTracking.isActive()) _classPrivateFieldGet(_callingOn, this).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, () => {
      _ui.SessionStateOverlay.hideCallingControls();
    });
    _classPrivateFieldInitSpec(this, _callingOff, () => {
      var _classPrivateFieldGet2, _classPrivateFieldGet3, _classPrivateFieldGet4;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_callParticipantsComponent, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      _classPrivateFieldSet(_callParticipantsComponent, this, null);
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_mediaPreviewComponent, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.unmount();
      _classPrivateFieldSet(_mediaPreviewComponent, this, null);
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_callSession, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.destroy();
      _classPrivateFieldSet(_callSession, this, null);
      _ui.SessionStateOverlay.hideCallingControls();
    });
    _classPrivateFieldInitSpec(this, _callingRequested, async () => {
      _classPrivateFieldSet(_isCallAccepted, this, await _classPrivateFieldGet(_showMediaPreview, this).call(this));
      _classPrivateFieldGet(_session, this).update({
        calling: _classPrivateFieldGet(_isCallAccepted, this) ? 'on' : 'rejected'
      });
    });
    _classPrivateFieldInitSpec(this, _callingOn, async () => {
      const {
        videoEnabled,
        audioEnabled
      } = _classPrivateFieldGet(_mediaSettings, this).settings;
      if (!_classPrivateFieldGet(_isCallAccepted, this)) {
        // the browser won't autoplay other participants if there is
        // no getUserMedia or user interaction on refresh. To solve
        // this we show the media preview to force a user interaction
        // if there is no audio or video enabled in the media settings
        if (!videoEnabled && !audioEnabled) {
          const acceptedRejoin = await _classPrivateFieldGet(_showMediaPreview, this).call(this);
          if (!acceptedRejoin) return _classPrivateFieldGet(_session, this).update({
            calling: 'off'
          });
        }
        _classPrivateFieldSet(_isCallAccepted, this, true);
      }
      const iceServers = await _classPrivateFieldGet(_fetchIceServers, this).call(this);
      _classPrivateFieldSet(_callSession, this, new _CallSession.default(_classPrivateFieldGet(_clientTracker, this).id, null, iceServers, _classPrivateFieldGet(_signalling, this)));
      await Promise.all(_classPrivateFieldGet(_clientTracker, this).all().map(_ref2 => {
        let {
          id,
          agent
        } = _ref2;
        return _classPrivateFieldGet(_callSession, this).addParticipant(id, agent);
      }));
      if (videoEnabled || audioEnabled) {
        try {
          const constraints = _objectSpread(_objectSpread({}, (0, _MediaSettings.createAudioConstraints)(_classPrivateFieldGet(_mediaSettings, this).settings)), (0, _MediaSettings.createVideoConstraints)(_classPrivateFieldGet(_mediaSettings, this).settings));
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          _classPrivateFieldGet(_callSession, this).publishStreamTracks(stream);
        } catch (err) {
          console.warn('CobrowseIO: Failed to get media', err);
          _classPrivateFieldGet(_mediaSettings, this).update({
            videoEnabled: false,
            audioEnabled: false
          });
        }
      }
      _ui.SessionStateOverlay.showCallingControls(_classPrivateFieldGet(_mediaSettings, this).settings);
      _classPrivateFieldSet(_callParticipantsComponent, this, (0, _mountComponent.mountComponent)(_ui.CallParticipants, {
        mediaSettings: _classPrivateFieldGet(_mediaSettings, this),
        callSession: _classPrivateFieldGet(_callSession, this)
      }, true, true));
    });
    _classPrivateFieldInitSpec(this, _showMediaPreview, () => {
      return new Promise(resolve => {
        const close = () => {
          var _classPrivateFieldGet5;
          (_classPrivateFieldGet5 = _classPrivateFieldGet(_mediaPreviewComponent, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.unmount();
          _classPrivateFieldSet(_mediaPreviewComponent, this, null);
        };
        const getStatus = () => {
          if (_classPrivateFieldGet(_calling, this) === 'requested') return _MediaPreview.MEDIA_PREVIEW_STATUS.REQUESTED;
          if (_classPrivateFieldGet(_calling, this) === 'on' && !_classPrivateFieldGet(_isCallAccepted, this)) return _MediaPreview.MEDIA_PREVIEW_STATUS.REJOINING;
          return _MediaPreview.MEDIA_PREVIEW_STATUS.UPDATING;
        };
        const initialProps = {
          settings: _classPrivateFieldGet(_mediaSettings, this).settings,
          status: getStatus(),
          isCallAccepted: _classPrivateFieldGet(_isCallAccepted, this),
          accept: settings => {
            _classPrivateFieldGet(_mediaSettings, this).update(settings);
            close();
            resolve(true);
          },
          reject: () => {
            close();
            resolve(false);
          }
        };
        _classPrivateFieldSet(_mediaPreviewComponent, this, (0, _mountComponent.mountComponent)(_ui.MediaPreview, initialProps, true, true));
      });
    });
    _defineProperty(this, "destroy", () => {
      var _classPrivateFieldGet6, _classPrivateFieldGet7, _classPrivateFieldGet8, _classPrivateFieldGet9;
      _activity.WindowTracking.off('activate', _classPrivateFieldGet(_onWindowActivate, this));
      _classPrivateFieldGet(_clientTracker, this).off('leave', _classPrivateFieldGet(_onLeave, this));
      _classPrivateFieldGet(_clientTracker, this).off('join', _classPrivateFieldGet(_onJoin, this));
      _classPrivateFieldGet(_mediaSettings, this).off('videoInputSettings.updated', _classPrivateFieldGet(_onVideoInputSettingsUpdated, this));
      _classPrivateFieldGet(_mediaSettings, this).off('audioInputSettings.updated', _classPrivateFieldGet(_onAudioInputSettingsUpdated, this));
      _ui.SessionStateOverlay.off('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
      _classPrivateFieldGet(_session, this).off('updated', _classPrivateFieldGet(_onSessionUpdated, this));
      _classPrivateFieldGet(_session, this).off('ended', _classPrivateFieldGet(_onSessionEnded, this));
      (_classPrivateFieldGet6 = _classPrivateFieldGet(_callParticipantsComponent, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.unmount();
      _classPrivateFieldSet(_callParticipantsComponent, this, null);
      (_classPrivateFieldGet7 = _classPrivateFieldGet(_mediaPreviewComponent, this)) === null || _classPrivateFieldGet7 === void 0 || _classPrivateFieldGet7.unmount();
      _classPrivateFieldSet(_mediaPreviewComponent, this, null);
      _classPrivateFieldSet(_mediaSettings, this, null);
      (_classPrivateFieldGet8 = _classPrivateFieldGet(_callSession, this)) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.destroy();
      _classPrivateFieldSet(_callSession, this, null);
      (_classPrivateFieldGet9 = _classPrivateFieldGet(_signalling, this)) === null || _classPrivateFieldGet9 === void 0 || _classPrivateFieldGet9.destroy();
      _classPrivateFieldSet(_signalling, this, null);
    });
    _classPrivateFieldSet(_session, this, _session2);
    _classPrivateFieldSet(_clientTracker, this, clientTracker);
    const shouldProcessSignal = _ref3 => {
      let {
        clientId
      } = _ref3;
      return clientTracker.id === clientId && _activity.WindowTracking.isActive();
    };
    _classPrivateFieldSet(_signalling, this, new _Signalling.default(socket, shouldProcessSignal));
    _classPrivateFieldSet(_mediaSettings, this, new _MediaSettings.default(_classPrivateFieldGet(_storage, this).getItem(MEDIA_SETTINGS_STORAGE_KEY), _classPrivateFieldGet(_saveMediaSettings, this)));
    _classPrivateFieldSet(_iceServers, this, new _IceServers.default(_session2));
    _classPrivateFieldGet(_session, this).on('ended', _classPrivateFieldGet(_onSessionEnded, this));
    _classPrivateFieldGet(_session, this).on('updated', _classPrivateFieldGet(_onSessionUpdated, this));
    _classPrivateFieldGet(_onSessionUpdated, this).call(this, _session2);
    _ui.SessionStateOverlay.on('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
    _classPrivateFieldGet(_mediaSettings, this).on('audioInputSettings.updated', _classPrivateFieldGet(_onAudioInputSettingsUpdated, this));
    _classPrivateFieldGet(_mediaSettings, this).on('videoInputSettings.updated', _classPrivateFieldGet(_onVideoInputSettingsUpdated, this));
    _classPrivateFieldGet(_clientTracker, this).on('join', _classPrivateFieldGet(_onJoin, this));
    _classPrivateFieldGet(_clientTracker, this).on('leave', _classPrivateFieldGet(_onLeave, this));
    _activity.WindowTracking.on('activate', _classPrivateFieldGet(_onWindowActivate, this));
  }
}
exports["default"] = CallHandler;

/***/ }),

/***/ 4383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _events = _interopRequireDefault(__webpack_require__(37007));
var _PeerManager = _interopRequireDefault(__webpack_require__(95836));
var _Participant = _interopRequireDefault(__webpack_require__(97354));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * CallSession abstracts the management of individual Peer connections through a higher
 * level Participants interface. It is instantiated when a call becomes active (calling: on),
 * and destroyed when the call ends (calling: off).
 *
 * It coordinates:
 * - Participant addition and removal from ClientTracker (join, leave)
 * - Publishing tracks to a local stream and remote peers
 * - Unpublishing tracks from a local stream and remote peers
 * - Translation of Peer connection and track events into Participants
 *
 * CallSession acts as the glue between a Peer and a Participant.
 */

const debug = (0, _debug.default)('cbio.Calling.CallSession');
var _localPeerId = /*#__PURE__*/new WeakMap();
var _signalling = /*#__PURE__*/new WeakMap();
var _peerManager = /*#__PURE__*/new WeakMap();
var _participants = /*#__PURE__*/new WeakMap();
var _CallSession_brand = /*#__PURE__*/new WeakSet();
var _removeTracksByKind = /*#__PURE__*/new WeakMap();
var _onPeerCreated = /*#__PURE__*/new WeakMap();
var _onPeerConnected = /*#__PURE__*/new WeakMap();
var _onPeerDisconnected = /*#__PURE__*/new WeakMap();
var _onTrackAdded = /*#__PURE__*/new WeakMap();
var _onTrackRemoved = /*#__PURE__*/new WeakMap();
class CallSession extends _events.default {
  constructor(localPeerId, _agent, iceServers, signalling) {
    super();
    _classPrivateMethodInitSpec(this, _CallSession_brand);
    _classPrivateFieldInitSpec(this, _localPeerId, void 0);
    _classPrivateFieldInitSpec(this, _signalling, void 0);
    _classPrivateFieldInitSpec(this, _peerManager, void 0);
    _classPrivateFieldInitSpec(this, _participants, new Map());
    _defineProperty(this, "publishStreamTracks", stream => {
      stream.getTracks().forEach(_classPrivateGetter(_CallSession_brand, this, _get_localParticipant).addTrack);
      _classPrivateFieldGet(_peerManager, this).remotePeerIds.forEach(remotePeerId => {
        _classPrivateFieldGet(_peerManager, this).addStreamToRemotePeer(remotePeerId, _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).stream);
      });
    });
    _defineProperty(this, "unpublishVideoTrack", () => _classPrivateFieldGet(_removeTracksByKind, this).call(this, 'video'));
    _defineProperty(this, "unpublishAudioTrack", () => _classPrivateFieldGet(_removeTracksByKind, this).call(this, 'audio'));
    _defineProperty(this, "addParticipant", async (remotePeerId, agent) => {
      debug('adding participant', remotePeerId);
      if (_classPrivateFieldGet(_participants, this).has(remotePeerId)) return debug('participant already exists', remotePeerId);
      _classPrivateFieldGet(_participants, this).set(remotePeerId, new _Participant.default(remotePeerId, agent));
      const lastOffer = _classPrivateFieldGet(_signalling, this).takeLastOffer(remotePeerId);
      await _classPrivateFieldGet(_peerManager, this).createPeer(_classPrivateFieldGet(_localPeerId, this), remotePeerId, lastOffer);
      this.emit('participants.added', this.participants);
    });
    _defineProperty(this, "removeParticipant", remotePeerId => {
      debug('removing participant', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (!participant) return debug('unknown participant', remotePeerId);
      participant.destroy();
      _classPrivateFieldGet(_participants, this).delete(remotePeerId);
      _classPrivateFieldGet(_peerManager, this).disconnectFromPeer(remotePeerId);
      this.emit('participants.removed', this.participants);
    });
    _defineProperty(this, "reconnectParticipant", async remotePeerId => {
      debug('reconnecting participant', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (!participant) return debug('unknown participant', remotePeerId);
      _classPrivateFieldGet(_peerManager, this).disconnectFromPeer(remotePeerId);
      await _classPrivateFieldGet(_peerManager, this).createPeer(_classPrivateFieldGet(_localPeerId, this), remotePeerId);
    });
    _classPrivateFieldInitSpec(this, _removeTracksByKind, kind => {
      _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).removeTracksByKind(kind);
      _classPrivateFieldGet(_peerManager, this).remotePeerIds.forEach(remotePeerId => {
        _classPrivateFieldGet(_peerManager, this).removeTracksByKindFromRemotePeer(remotePeerId, kind);
      });
    });
    _classPrivateFieldInitSpec(this, _onPeerCreated, remotePeerId => {
      debug('peer created', remotePeerId);
      if (_classPrivateGetter(_CallSession_brand, this, _get_localParticipant).hasVideo || _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).hasAudio) {
        // syncing media will trigger a negotiation of the connection
        _classPrivateFieldGet(_peerManager, this).addStreamToRemotePeer(remotePeerId, _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).stream);
      } else {
        // we trigger a connection so we can receive media
        _classPrivateFieldGet(_peerManager, this).connectToPeer(remotePeerId);
      }
    });
    _classPrivateFieldInitSpec(this, _onPeerConnected, remotePeerId => {
      debug('peer connected', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.isConnected = true;
    });
    _classPrivateFieldInitSpec(this, _onPeerDisconnected, remotePeerId => {
      debug('peer disconnected', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.isConnected = false;
    });
    _classPrivateFieldInitSpec(this, _onTrackAdded, (track, remotePeerId) => {
      debug('track added', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.addTrack(track);
    });
    _classPrivateFieldInitSpec(this, _onTrackRemoved, (track, remotePeerId) => {
      debug('track removed', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.removeTrackById(track.id);
    });
    _defineProperty(this, "destroy", () => {
      _classPrivateFieldGet(_peerManager, this).off('track.removed', _classPrivateFieldGet(_onTrackRemoved, this));
      _classPrivateFieldGet(_peerManager, this).off('track.added', _classPrivateFieldGet(_onTrackAdded, this));
      _classPrivateFieldGet(_peerManager, this).off('peer.disconnected', _classPrivateFieldGet(_onPeerDisconnected, this));
      _classPrivateFieldGet(_peerManager, this).off('peer.connected', _classPrivateFieldGet(_onPeerConnected, this));
      _classPrivateFieldGet(_peerManager, this).off('peer.created', _classPrivateFieldGet(_onPeerCreated, this));
      _classPrivateFieldGet(_participants, this).forEach(participant => participant.destroy());
      _classPrivateFieldGet(_participants, this).clear();
      _classPrivateFieldGet(_peerManager, this).destroy();
      _classPrivateFieldSet(_peerManager, this, null);
      _classPrivateFieldGet(_signalling, this).flushLastOfferCache();
    });
    _classPrivateFieldSet(_localPeerId, this, localPeerId);
    _classPrivateFieldGet(_participants, this).set(localPeerId, new _Participant.default(localPeerId, _agent, true));
    _classPrivateFieldSet(_signalling, this, signalling);
    _classPrivateFieldSet(_peerManager, this, new _PeerManager.default(signalling, iceServers));
    _classPrivateFieldGet(_peerManager, this).on('peer.created', _classPrivateFieldGet(_onPeerCreated, this));
    _classPrivateFieldGet(_peerManager, this).on('peer.connected', _classPrivateFieldGet(_onPeerConnected, this));
    _classPrivateFieldGet(_peerManager, this).on('peer.disconnected', _classPrivateFieldGet(_onPeerDisconnected, this));
    _classPrivateFieldGet(_peerManager, this).on('track.added', _classPrivateFieldGet(_onTrackAdded, this));
    _classPrivateFieldGet(_peerManager, this).on('track.removed', _classPrivateFieldGet(_onTrackRemoved, this));
  }
  get participants() {
    return _classPrivateFieldGet(_participants, this);
  }
}
exports["default"] = CallSession;
function _get_localParticipant(_this) {
  return _classPrivateFieldGet(_participants, _this).get(_classPrivateFieldGet(_localPeerId, _this));
}

/***/ }),

/***/ 93130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _rest = __webpack_require__(18111);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _sessionId = /*#__PURE__*/new WeakMap();
class IceServers extends _rest.RESTResource {
  constructor(session) {
    super();
    _classPrivateFieldInitSpec(this, _sessionId, void 0);
    _classPrivateFieldSet(_sessionId, this, session.id());
    this.setHeader('X-CobrowseDeviceToken', session.getHeader('X-CobrowseDeviceToken'));
  }
  url() {
    return new URL("api/1/sessions/".concat(_classPrivateFieldGet(_sessionId, this), "/ice"), IceServers.api).toString();
  }
}
exports["default"] = IceServers;

/***/ }),

/***/ 93646:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.createVideoConstraints = exports.createAudioConstraints = void 0;
__webpack_require__(62953);
var _events = _interopRequireDefault(__webpack_require__(37007));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * MediaSettings persists the video and audio configuration chosen by the user
 * and synchronises updates to settings.
 *
 * Configurable settings:
 * - Video Enabled
 * - Video Input Device ID (Camera)
 * - Audio Enabled
 * - Audio Input Device ID (Microphone)
 * - Audio Output Device ID (Speaker)
 */

const AUDIO_INPUT_KEYS = ['audioEnabled', 'audioInputDeviceId'];
const AUDIO_OUTPUT_KEYS = ['audioOutputDeviceId'];
const VIDEO_INPUT_KEYS = ['videoEnabled', 'videoInputDeviceId'];
const DEFAULT_SETTINGS = {
  videoEnabled: false,
  videoInputDeviceId: 'default',
  audioEnabled: false,
  audioInputDeviceId: 'default',
  audioOutputDeviceId: 'default'
};
const VIDEO_RESOLUTION = {
  width: {
    ideal: 1280
  },
  height: {
    ideal: 720
  }
};
const createAudioConstraints = _ref => {
  let {
    audioEnabled,
    audioInputDeviceId
  } = _ref;
  const deviceId = audioInputDeviceId || 'default';
  const deviceConstraint = deviceId === 'default' ? 'ideal' : 'exact';
  return {
    audio: audioEnabled ? {
      deviceId: {
        [deviceConstraint]: audioInputDeviceId
      }
    } : false
  };
};
exports.createAudioConstraints = createAudioConstraints;
const createVideoConstraints = _ref2 => {
  let {
    videoEnabled,
    videoInputDeviceId
  } = _ref2;
  const deviceId = videoInputDeviceId || 'default';
  const deviceConstraint = deviceId === 'default' ? 'ideal' : 'exact';
  return {
    video: videoEnabled ? _objectSpread(_objectSpread({}, VIDEO_RESOLUTION), {}, {
      deviceId: {
        [deviceConstraint]: videoInputDeviceId
      }
    }) : false
  };
};
exports.createVideoConstraints = createVideoConstraints;
var _settings = /*#__PURE__*/new WeakMap();
var _save = /*#__PURE__*/new WeakMap();
class MediaSettings extends _events.default {
  constructor(settings, save) {
    super();
    _classPrivateFieldInitSpec(this, _settings, null);
    _classPrivateFieldInitSpec(this, _save, void 0);
    _classPrivateFieldSet(_settings, this, _objectSpread(_objectSpread({}, DEFAULT_SETTINGS), settings));
    _classPrivateFieldSet(_save, this, save);
  }
  get settings() {
    return _objectSpread({}, _classPrivateFieldGet(_settings, this));
  }
  update(settings) {
    var _classPrivateFieldGet2;
    const changedSettings = [];
    for (const [key, value] of Object.entries(settings)) {
      if (value !== undefined && key in _classPrivateFieldGet(_settings, this)) {
        if (_classPrivateFieldGet(_settings, this)[key] !== value) {
          _classPrivateFieldGet(_settings, this)[key] = value;
          changedSettings.push(key);
        }
      }
    }
    if (changedSettings.length === 0) return;
    (_classPrivateFieldGet2 = _classPrivateFieldGet(_save, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this, _classPrivateFieldGet(_settings, this));
    if (changedSettings.some(key => VIDEO_INPUT_KEYS.includes(key))) {
      this.emit('videoInputSettings.updated', this.settings);
    }
    if (changedSettings.some(key => AUDIO_INPUT_KEYS.includes(key))) {
      this.emit('audioInputSettings.updated', this.settings);
    }
    if (changedSettings.some(key => AUDIO_OUTPUT_KEYS.includes(key))) {
      this.emit('audioOutputSettings.updated', this.settings);
    }
  }
  toggleAudio() {
    this.update({
      audioEnabled: !_classPrivateFieldGet(_settings, this).audioEnabled
    });
  }
  toggleVideo() {
    this.update({
      videoEnabled: !_classPrivateFieldGet(_settings, this).videoEnabled
    });
  }
}
exports["default"] = MediaSettings;

/***/ }),

/***/ 37688:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
__webpack_require__(62953);
var _events = __webpack_require__(37007);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const FFT_SIZE = 256;
var _audioContext = /*#__PURE__*/new WeakMap();
var _mediaStreamSource = /*#__PURE__*/new WeakMap();
var _analyser = /*#__PURE__*/new WeakMap();
var _hasNoise = /*#__PURE__*/new WeakMap();
var _requestAnimationFrameHandle = /*#__PURE__*/new WeakMap();
var _isDestroyed = /*#__PURE__*/new WeakMap();
class NoiseAnalyser extends _events.EventEmitter {
  constructor(stream, threshold) {
    super();
    _classPrivateFieldInitSpec(this, _audioContext, void 0);
    _classPrivateFieldInitSpec(this, _mediaStreamSource, void 0);
    _classPrivateFieldInitSpec(this, _analyser, void 0);
    _classPrivateFieldInitSpec(this, _hasNoise, void 0);
    _classPrivateFieldInitSpec(this, _requestAnimationFrameHandle, void 0);
    _classPrivateFieldInitSpec(this, _isDestroyed, false);
    if (!window.AudioContext) return;
    if (!stream || !stream.getAudioTracks().length) return;
    _classPrivateFieldSet(_audioContext, this, new window.AudioContext());
    _classPrivateFieldSet(_mediaStreamSource, this, _classPrivateFieldGet(_audioContext, this).createMediaStreamSource(stream));
    _classPrivateFieldSet(_analyser, this, _classPrivateFieldGet(_audioContext, this).createAnalyser());
    _classPrivateFieldGet(_analyser, this).fftSize = FFT_SIZE;
    _classPrivateFieldGet(_mediaStreamSource, this).connect(_classPrivateFieldGet(_analyser, this));
    const checkVolume = () => {
      if (_classPrivateFieldGet(_isDestroyed, this)) return;
      const frequencyData = new Uint8Array(_classPrivateFieldGet(_analyser, this).frequencyBinCount);
      _classPrivateFieldGet(_analyser, this).getByteFrequencyData(frequencyData);
      const total = frequencyData.reduce((a, b) => a + b, 0);
      const average = total / _classPrivateFieldGet(_analyser, this).frequencyBinCount;
      const hasNoise = average > threshold;
      if (_classPrivateFieldGet(_hasNoise, this) !== hasNoise) {
        _classPrivateFieldSet(_hasNoise, this, hasNoise);
        this.emit('noise.updated', hasNoise);
      }
      if (!_classPrivateFieldGet(_hasNoise, this)) {
        _classPrivateFieldSet(_requestAnimationFrameHandle, this, requestAnimationFrame(checkVolume));
        return;
      }
      setTimeout(() => {
        _classPrivateFieldSet(_requestAnimationFrameHandle, this, requestAnimationFrame(checkVolume));
      }, 250);
    };
    checkVolume();
  }
  get hasNoise() {
    return _classPrivateFieldGet(_hasNoise, this) || false;
  }
  destroy() {
    var _classPrivateFieldGet2, _classPrivateFieldGet3, _classPrivateFieldGet4;
    _classPrivateFieldSet(_isDestroyed, this, true);
    cancelAnimationFrame(_classPrivateFieldGet(_requestAnimationFrameHandle, this));
    (_classPrivateFieldGet2 = _classPrivateFieldGet(_mediaStreamSource, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.disconnect();
    _classPrivateFieldSet(_mediaStreamSource, this, null);
    (_classPrivateFieldGet3 = _classPrivateFieldGet(_analyser, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.disconnect();
    _classPrivateFieldSet(_analyser, this, null);
    (_classPrivateFieldGet4 = _classPrivateFieldGet(_audioContext, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.close();
    _classPrivateFieldSet(_audioContext, this, null);
  }
}
exports["default"] = NoiseAnalyser;

/***/ }),

/***/ 97354:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _events = __webpack_require__(37007);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Participant provides an abstraction over a Peer connection. It relies on its own
 * MediaStream and enforces a single track of a particular kind (e.g. video, audio).
 * This ensures that during the addition and removal of tracks from the Peer
 * connection we don't have to deal with stale or ended tracks.
 */
var _id = /*#__PURE__*/new WeakMap();
var _agent = /*#__PURE__*/new WeakMap();
var _isLocal = /*#__PURE__*/new WeakMap();
var _isConnected = /*#__PURE__*/new WeakMap();
var _stream = /*#__PURE__*/new WeakMap();
var _removeTracksByKind = /*#__PURE__*/new WeakMap();
class Participant extends _events.EventEmitter {
  constructor(_id2, agent) {
    let isLocal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    super();
    _classPrivateFieldInitSpec(this, _id, void 0);
    _classPrivateFieldInitSpec(this, _agent, void 0);
    _classPrivateFieldInitSpec(this, _isLocal, void 0);
    _classPrivateFieldInitSpec(this, _isConnected, void 0);
    _classPrivateFieldInitSpec(this, _stream, void 0);
    _defineProperty(this, "addTrack", track => {
      if (_classPrivateFieldGet(_stream, this).getTrackById(track.id)) return;
      _classPrivateFieldGet(_removeTracksByKind, this).call(this, track.kind);
      _classPrivateFieldGet(_stream, this).addTrack(track);
      this.emit('track.added');
    });
    _defineProperty(this, "removeTrackById", id => {
      const track = _classPrivateFieldGet(_stream, this).getTrackById(id);
      if (!track) return;
      track.stop();
      _classPrivateFieldGet(_stream, this).removeTrack(track);
      this.emit('track.removed');
    });
    _defineProperty(this, "removeTracksByKind", kind => {
      if (_classPrivateFieldGet(_removeTracksByKind, this).call(this, kind)) this.emit('track.removed');
    });
    _classPrivateFieldInitSpec(this, _removeTracksByKind, kind => {
      var _classPrivateFieldGet2;
      const tracksOfKind = ((_classPrivateFieldGet2 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.getTracks().filter(track => track.kind === kind)) || [];
      tracksOfKind.forEach(track => {
        track.stop();
        _classPrivateFieldGet(_stream, this).removeTrack(track);
      });
      return tracksOfKind.length > 0;
    });
    _defineProperty(this, "destroy", () => {
      var _classPrivateFieldGet3;
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.getTracks().forEach(track => {
        track.stop();
        _classPrivateFieldGet(_stream, this).removeTrack(track);
      });
      _classPrivateFieldSet(_stream, this, null);
    });
    _classPrivateFieldSet(_id, this, _id2);
    _classPrivateFieldSet(_agent, this, agent);
    _classPrivateFieldSet(_isLocal, this, isLocal);
    _classPrivateFieldSet(_isConnected, this, isLocal || false);
    _classPrivateFieldSet(_stream, this, new MediaStream());
  }
  get id() {
    return _classPrivateFieldGet(_id, this);
  }
  get isAgent() {
    return !!_classPrivateFieldGet(_agent, this);
  }
  get isLocal() {
    return _classPrivateFieldGet(_isLocal, this);
  }
  get isConnected() {
    return _classPrivateFieldGet(_isConnected, this);
  }
  set isConnected(value) {
    if (_classPrivateFieldGet(_isLocal, this)) return;
    _classPrivateFieldSet(_isConnected, this, value);
    this.emit('connection.changed', _classPrivateFieldGet(_isConnected, this));
  }
  get stream() {
    return _classPrivateFieldGet(_stream, this);
  }
  get hasAudio() {
    var _classPrivateFieldGet4;
    return ((_classPrivateFieldGet4 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.getAudioTracks().some(track => track.readyState === 'live')) || false;
  }
  get hasVideo() {
    var _classPrivateFieldGet5;
    return ((_classPrivateFieldGet5 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.getVideoTracks().some(track => track.readyState === 'live')) || false;
  }
}
exports["default"] = Participant;

/***/ }),

/***/ 95836:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(26910);
__webpack_require__(35874);
__webpack_require__(62953);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _events = __webpack_require__(37007);
var _uuid = __webpack_require__(65392);
var _Signalling = __webpack_require__(27323);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * PeerManager only handles RTCPeerConnections.
 *
 * It's responsible for:
 * - Creating new RTCPeerConnections
 * - Negotiating connections (using SDP offers, SDP answers, ice candidates)
 * - Syncing a local stream to a remote RTCPeerConnection
 * - Syncing remote RTCPeerConnection tracks to a Participant
 *
 * PeerManager uses deterministic glare resolution to avoid offer conflicts by
 * consistently assigning polite / impolite roles based on sorted peer IDs.
 */

const debug = (0, _debug.default)('cbio.Calling.PeerManager');
var _signalling = /*#__PURE__*/new WeakMap();
var _iceServers = /*#__PURE__*/new WeakMap();
var _remotePeers = /*#__PURE__*/new WeakMap();
var _reconnectToPeerUsingOffer = /*#__PURE__*/new WeakMap();
var _onSDP = /*#__PURE__*/new WeakMap();
var _handleOffer = /*#__PURE__*/new WeakMap();
var _handleAnswer = /*#__PURE__*/new WeakMap();
var _onCandidate = /*#__PURE__*/new WeakMap();
class PeerManager extends _events.EventEmitter {
  constructor(signalling, iceServers) {
    super();
    _classPrivateFieldInitSpec(this, _signalling, void 0);
    _classPrivateFieldInitSpec(this, _iceServers, void 0);
    _classPrivateFieldInitSpec(this, _remotePeers, new Map());
    _defineProperty(this, "createPeer", async (localPeerId, remotePeerId, offer) => {
      debug('creating peer', remotePeerId);
      const localEndpoint = {
        clientId: localPeerId,
        connectionId: (0, _uuid.v4)()
      };
      const remoteEndpoint = {
        clientId: remotePeerId,
        connectionId: offer ? offer.from.connectionId : null
      };
      const peer = {
        connection: new RTCPeerConnection({
          iceServers: _classPrivateFieldGet(_iceServers, this)
        }),
        makingOffer: false,
        bePolite: [localPeerId, remotePeerId].sort()[0] === localPeerId,
        iceCandidateQueue: [],
        localEndpoint,
        remoteEndpoint
      };
      peer.connection.onnegotiationneeded = async () => {
        debug('negotiation needed for peer', remotePeerId);
        await this.connectToPeer(remotePeerId);
      };
      const onRemoveTrack = event => {
        debug('removing track with kind', event.track.kind, 'from peer', remotePeerId);
        this.emit('track.removed', event.track, remotePeerId);
      };
      peer.connection.ontrack = event => {
        debug('adding track with kind', event.track.kind, 'from peer', remotePeerId);
        const stream = event.streams[0];
        stream.removeEventListener('removetrack', onRemoveTrack);
        stream.addEventListener('removetrack', onRemoveTrack);
        this.emit('track.added', event.track, remotePeerId);
      };
      peer.connection.onicecandidate = event => {
        if (!event.candidate) return;
        _classPrivateFieldGet(_signalling, this).sendCandidate(localEndpoint, remoteEndpoint, event.candidate);
      };
      peer.connection.oniceconnectionstatechange = () => {
        if (peer.connection.iceConnectionState === 'failed') {
          debug('connection failed for peer', remotePeerId, 'restarting');
          peer.connection.restartIce();
        }
      };
      peer.connection.onconnectionstatechange = () => {
        if (peer.connection.connectionState === 'connected') {
          debug('connected to peer', remotePeerId);
          this.emit('peer.connected', remotePeerId);
        }
        if (peer.connection.connectionState === 'disconnected') {
          debug('disconnected from peer', remotePeerId);
          this.emit('peer.disconnected', remotePeerId);
        }
      };
      _classPrivateFieldGet(_remotePeers, this).set(remotePeerId, peer);
      if (offer) {
        debug('using last offer from peer', remotePeerId);
        await _classPrivateFieldGet(_handleOffer, this).call(this, offer.from, offer.to, offer.sdp);
      }
      this.emit('peer.created', remotePeerId);
    });
    _defineProperty(this, "connectToPeer", async remotePeerId => {
      debug('connecting to peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      try {
        peer.makingOffer = true;
        const offer = await peer.connection.createOffer();
        await peer.connection.setLocalDescription(offer);
        _classPrivateFieldGet(_signalling, this).sendSDP(localEndpoint, remoteEndpoint, peer.connection.localDescription);
      } finally {
        peer.makingOffer = false;
      }
    });
    _defineProperty(this, "disconnectFromPeer", remotePeerId => {
      debug('disconnecting from peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const senders = peer.connection.getSenders();
      senders.forEach(sender => peer.connection.removeTrack(sender));
      peer.connection.close();
      _classPrivateFieldGet(_remotePeers, this).delete(remotePeerId);
    });
    _defineProperty(this, "removeTracksByKindFromRemotePeer", (remotePeerId, kind) => {
      debug('removing tracks with kind', kind, 'from peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const senders = peer.connection.getSenders();
      senders.forEach(sender => {
        var _sender$track;
        if (((_sender$track = sender.track) === null || _sender$track === void 0 ? void 0 : _sender$track.kind) === kind) peer.connection.removeTrack(sender);
      });
    });
    _defineProperty(this, "addStreamToRemotePeer", (remotePeerId, stream) => {
      debug('adding stream to peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const senders = peer.connection.getSenders();
      stream.getTracks().forEach(track => {
        const trackExists = senders.some(sender => {
          var _sender$track2;
          return ((_sender$track2 = sender.track) === null || _sender$track2 === void 0 ? void 0 : _sender$track2.id) === track.id;
        });
        if (!trackExists) {
          debug('adding track with kind', track.kind, 'to peer', remotePeerId);
          peer.connection.addTrack(track, stream);
        }
      });
    });
    _classPrivateFieldInitSpec(this, _reconnectToPeerUsingOffer, async (from, to, sdp) => {
      debug('reconnecting to', from, 'using offer');
      this.disconnectFromPeer(from.clientId);
      await this.createPeer(to.clientId, from.clientId, {
        from,
        to,
        sdp
      });
    });
    _classPrivateFieldInitSpec(this, _onSDP, (from, to, sdp) => {
      if (sdp.type === 'offer') {
        // flush the cached offer since we are handling it
        _classPrivateFieldGet(_signalling, this).takeLastOffer(from.clientId);
        _classPrivateFieldGet(_handleOffer, this).call(this, from, to, sdp);
      }
      if (sdp.type === 'answer') _classPrivateFieldGet(_handleAnswer, this).call(this, from, to, sdp);
    });
    _classPrivateFieldInitSpec(this, _handleOffer, async (from, to, sdp) => {
      debug('receiving offer from', from);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(from.clientId);
      if (!peer) return debug('unknown peer', from.clientId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      if (localEndpoint.connectionId !== to.connectionId && to.connectionId) return debug('offer intended for different connection');
      if (!remoteEndpoint.connectionId) remoteEndpoint.connectionId = from.connectionId;
      if (remoteEndpoint.connectionId !== from.connectionId) {
        debug('offer from', from, 'has a different connection id');
        return await _classPrivateFieldGet(_reconnectToPeerUsingOffer, this).call(this, from, to, sdp);
      }
      const offerCollision = peer.makingOffer || peer.connection.signalingState !== 'stable';
      const ignoreOffer = !peer.bePolite && offerCollision;
      if (ignoreOffer) return debug('offer ignored as the impolite peer');
      await peer.connection.setRemoteDescription(sdp);
      const queuedIceCandidateCount = peer.iceCandidateQueue.length;
      if (queuedIceCandidateCount > 0) {
        debug('adding ice candidates from queue', queuedIceCandidateCount);
        await Promise.allSettled(peer.iceCandidateQueue.map(candidate => peer.connection.addIceCandidate(candidate)));
        peer.iceCandidateQueue.length = 0;
      }
      const answer = await peer.connection.createAnswer();
      await peer.connection.setLocalDescription(answer);
      _classPrivateFieldGet(_signalling, this).sendSDP(localEndpoint, remoteEndpoint, peer.connection.localDescription);
    });
    _classPrivateFieldInitSpec(this, _handleAnswer, async (from, to, sdp) => {
      debug('receiving answer from', from);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(from.clientId);
      if (!peer) return debug('unknown peer', from.clientId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      if (localEndpoint.connectionId !== to.connectionId) return debug('answer intended for different connection');
      if (!remoteEndpoint.connectionId) remoteEndpoint.connectionId = from.connectionId;
      if (remoteEndpoint.connectionId !== from.connectionId) return debug('answer from different connection ignored');
      await peer.connection.setRemoteDescription(sdp);
      const queuedIceCandidateCount = peer.iceCandidateQueue.length;
      if (queuedIceCandidateCount > 0) {
        debug('adding ice candidates from queue', queuedIceCandidateCount);
        await Promise.allSettled(peer.iceCandidateQueue.map(candidate => peer.connection.addIceCandidate(candidate)));
        peer.iceCandidateQueue.length = 0;
      }
    });
    _classPrivateFieldInitSpec(this, _onCandidate, async (from, to, candidate) => {
      debug('receiving ice candidate from', from);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(from.clientId);
      if (!peer) return debug('unknown peer', from.clientId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      if (localEndpoint.connectionId !== to.connectionId) return debug('ice candidate intended for different connection');
      if (remoteEndpoint.connectionId !== from.connectionId) return debug('ice candidate from different connection ignored');
      if (peer.connection.remoteDescription) {
        await peer.connection.addIceCandidate(candidate);
      } else {
        peer.iceCandidateQueue.push(candidate);
      }
    });
    _defineProperty(this, "destroy", () => {
      _classPrivateFieldGet(_signalling, this).off(_Signalling.SIGNAL.CANDIDATE, _classPrivateFieldGet(_onCandidate, this));
      _classPrivateFieldGet(_signalling, this).off(_Signalling.SIGNAL.SDP, _classPrivateFieldGet(_onSDP, this));
      _classPrivateFieldGet(_remotePeers, this).forEach((_, remotePeerId) => this.disconnectFromPeer(remotePeerId));
      _classPrivateFieldGet(_remotePeers, this).clear();
    });
    _classPrivateFieldSet(_signalling, this, signalling);
    _classPrivateFieldSet(_iceServers, this, iceServers);
    _classPrivateFieldGet(_signalling, this).on(_Signalling.SIGNAL.SDP, _classPrivateFieldGet(_onSDP, this));
    _classPrivateFieldGet(_signalling, this).on(_Signalling.SIGNAL.CANDIDATE, _classPrivateFieldGet(_onCandidate, this));
  }
  get remotePeerIds() {
    return [..._classPrivateFieldGet(_remotePeers, this).keys()];
  }
}
exports["default"] = PeerManager;

/***/ }),

/***/ 27323:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.SIGNAL = void 0;
__webpack_require__(62953);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _events = __webpack_require__(37007);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Signalling provides an abstraction over a CBORSocket which
 * handles sending and receiving SDP events and ice candidates,
 * and ensures that incoming events are filtered based on the
 * intended peer.
 *
 * These events are used during the negotiation process
 * of an RTCPeerConnection:
 * - sdp (with a type of either offer or answer)
 * - icecandidate
 *
 * Signalling has a lifecycle close to that of the CBORSocket that
 * it abstracts. This means that offers could be processed by Signalling
 * before the CallSession has instantiated. To mitigate this, Signalling
 * keeps the last offer from each peer in a cache in case it is missed.
 */

const debug = (0, _debug.default)('cbio.Calling.Signalling');
const SIGNAL = exports.SIGNAL = {
  SDP: 'sdp',
  CANDIDATE: 'icecandidate'
};
var _socket = /*#__PURE__*/new WeakMap();
var _shouldProcessSignal = /*#__PURE__*/new WeakMap();
var _lastOfferCache = /*#__PURE__*/new WeakMap();
var _onEvent = /*#__PURE__*/new WeakMap();
var _handleSDP = /*#__PURE__*/new WeakMap();
var _handleCandidate = /*#__PURE__*/new WeakMap();
class Signalling extends _events.EventEmitter {
  constructor(socket, shouldProcessSignal) {
    super();
    _classPrivateFieldInitSpec(this, _socket, void 0);
    _classPrivateFieldInitSpec(this, _shouldProcessSignal, void 0);
    _classPrivateFieldInitSpec(this, _lastOfferCache, new Map());
    _defineProperty(this, "sendSDP", (from, to, sdp) => {
      debug('sending sdp with type', sdp.type, 'to', to);
      _classPrivateFieldGet(_socket, this).send(SIGNAL.SDP, {
        from,
        to,
        sdp: JSON.stringify(sdp)
      });
    });
    _defineProperty(this, "sendCandidate", (from, to, candidate) => {
      debug('sending ice candidate', 'to', to);
      _classPrivateFieldGet(_socket, this).send(SIGNAL.CANDIDATE, {
        from,
        to,
        candidate: JSON.stringify(candidate)
      });
    });
    _defineProperty(this, "takeLastOffer", clientId => {
      const lastOffer = _classPrivateFieldGet(_lastOfferCache, this).get(clientId);
      _classPrivateFieldGet(_lastOfferCache, this).delete(clientId);
      return lastOffer;
    });
    _defineProperty(this, "flushLastOfferCache", () => {
      _classPrivateFieldGet(_lastOfferCache, this).clear();
    });
    _classPrivateFieldInitSpec(this, _onEvent, (event, data) => {
      if (event === SIGNAL.SDP) _classPrivateFieldGet(_handleSDP, this).call(this, data);
      if (event === SIGNAL.CANDIDATE) _classPrivateFieldGet(_handleCandidate, this).call(this, data);
    });
    _classPrivateFieldInitSpec(this, _handleSDP, _ref => {
      let {
        from,
        to,
        sdp
      } = _ref;
      if (!_classPrivateFieldGet(_shouldProcessSignal, this).call(this, to)) return;
      const sdpObject = JSON.parse(sdp);
      debug('receiving sdp with type', sdpObject.type, 'from', from);
      if (sdpObject.type === 'offer') _classPrivateFieldGet(_lastOfferCache, this).set(from.clientId, {
        from,
        to,
        sdp: sdpObject
      });
      this.emit(SIGNAL.SDP, from, to, sdpObject);
    });
    _classPrivateFieldInitSpec(this, _handleCandidate, _ref2 => {
      let {
        from,
        to,
        candidate
      } = _ref2;
      if (!_classPrivateFieldGet(_shouldProcessSignal, this).call(this, to)) return;
      debug('receiving ice candidate', 'from', from);
      this.emit(SIGNAL.CANDIDATE, from, to, JSON.parse(candidate));
    });
    _defineProperty(this, "destroy", () => {
      _classPrivateFieldGet(_socket, this).off('event', _classPrivateFieldGet(_onEvent, this));
      this.flushLastOfferCache();
    });
    _classPrivateFieldSet(_socket, this, socket);
    _classPrivateFieldSet(_shouldProcessSignal, this, shouldProcessSignal);
    _classPrivateFieldGet(_socket, this).on('event', _classPrivateFieldGet(_onEvent, this));
  }
}
exports["default"] = Signalling;

/***/ }),

/***/ 24719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "CallHandler", ({
  enumerable: true,
  get: function () {
    return _CallHandler.default;
  }
}));
var _CallHandler = _interopRequireDefault(__webpack_require__(62863));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 61789:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.RegistrationPath = exports.DeviceIdPath = void 0;
__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(12041);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _uuid = __webpack_require__(65392);
var _rest = __webpack_require__(18111);
var _cocom = __webpack_require__(63439);
var _storage = _interopRequireDefault(__webpack_require__(86542));
var _makeSocketUrl = _interopRequireDefault(__webpack_require__(56851));
var _RateLimiter = _interopRequireDefault(__webpack_require__(18781));
var _SessionCapabilityTypes = __webpack_require__(57089);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.Device');
const DeviceIdPath = exports.DeviceIdPath = '_cobrowse_device_id';
const RegistrationPath = exports.RegistrationPath = '_cobrowse_device_registration';
var _socket = /*#__PURE__*/new WeakMap();
var _rateLimiter = /*#__PURE__*/new WeakMap();
var _registrationTimeout = /*#__PURE__*/new WeakMap();
var _registrationLoaded = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _storageKey = /*#__PURE__*/new WeakMap();
var _loop = /*#__PURE__*/new WeakMap();
var _socketUrl = /*#__PURE__*/new WeakMap();
var _socketProtocols = /*#__PURE__*/new WeakMap();
var _openNotificationSocket = /*#__PURE__*/new WeakMap();
var _closeNotificationSocket = /*#__PURE__*/new WeakMap();
var _updateNotificationSocket = /*#__PURE__*/new WeakMap();
class Device extends _rest.RESTResource {
  constructor(delegate) {
    var _this;
    super();
    _this = this;
    _classPrivateFieldInitSpec(this, _socket, void 0);
    _classPrivateFieldInitSpec(this, _rateLimiter, void 0);
    _classPrivateFieldInitSpec(this, _registrationTimeout, void 0);
    _classPrivateFieldInitSpec(this, _registrationLoaded, false);
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _defineProperty(this, "url", () => {
      return new URL("api/1/devices/".concat(this.id()), Device.api).toString();
    });
    _defineProperty(this, "reset", function () {
      let preserveRegistration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      debug('resetting device');

      // prevent the registration loop triggering
      clearTimeout(_classPrivateFieldGet(_registrationTimeout, _this));
      _classPrivateFieldSet(_registrationTimeout, _this, null);
      // wipe any pending custom data changes unless
      // it's requested that these should be retained
      if (!preserveRegistration) {
        // clear the saved registration information
        (0, _storage.default)().removeItem(RegistrationPath);
      }
      // stop the socket updates
      if (_classPrivateFieldGet(_socket, _this)) {
        _classPrivateFieldGet(_socket, _this).close();
        _classPrivateFieldSet(_socket, _this, null);
      }
    });
    _defineProperty(this, "destroy", async () => {
      debug('destroying device');

      // reset all the state, including wiping any locally stored custom data
      this.reset();
      // destroy the server record too
      return super.destroy();
    });
    _defineProperty(this, "hasPendingUpdates", () => {
      const existing = this.field('custom_data') || {};
      const modifications = _classPrivateFieldGet(_delegate, this).customData || {};
      const changed = Object.keys(modifications).find(key => existing[key] !== modifications[key]);
      return !!changed;
    });
    _classPrivateFieldInitSpec(this, _storageKey, () => {
      if (!_classPrivateFieldGet(_delegate, this).license) throw new Error('License required to generate storage key');
      return "".concat(_classPrivateFieldGet(_delegate, this).license, ":").concat(Device.api);
    });
    _defineProperty(this, "_saveRegistration", () => {
      const nextUpdateIn = this.field('next_registration') || 60 * 60;
      const time = new Date().getTime();
      // sanity checking date return values
      // believe it or not, some people override these things to return weird values
      if (typeof Date.now() !== 'number') console.error("Unexpected type returned for Date.now(), expecting number got ".concat(typeof Date.now()));
      if (typeof time !== 'number') console.error("Unexpected type for getTime() of Date, expecting number got ".concat(typeof time));
      const reg = {
        notification_url: this.field('notification_url'),
        notification_token: this.field('notification_token'),
        custom_data: this.field('custom_data'),
        next_registration_time: time + nextUpdateIn * 1000
      };
      // next registration time isn't a field the server sends, it's generated
      // as part of the local resource only, so need to update it manually
      this.cache({
        next_registration_time: reg.next_registration_time
      });
      (0, _storage.default)(_classPrivateFieldGet(_storageKey, this).call(this)).setItem(RegistrationPath, reg);
      return this;
    });
    _defineProperty(this, "_loadRegistration", () => {
      if (_classPrivateFieldGet(_registrationLoaded, this)) return;
      _classPrivateFieldSet(_registrationLoaded, this, true);
      const storedRegistration = (0, _storage.default)(_classPrivateFieldGet(_storageKey, this).call(this)).getItem(RegistrationPath);
      // restore the last known url and token so we can try to
      // connect a socket before a re-registration isn't due yet
      if (storedRegistration) {
        debug('restoring registration', storedRegistration);
        this.cache(storedRegistration);
      }
    });
    _defineProperty(this, "updateRegistration", async query => {
      if (_classPrivateFieldGet(_rateLimiter, this).limit()) throw new Error('Cobrowse update rate limit exceeded. Maybe you\'re updating custom data too often?');
      debug('updating registration');
      await this.update({
        device: Device.info,
        custom_data: _classPrivateFieldGet(_delegate, this).customData
      }, query);
      _classPrivateFieldGet(_updateNotificationSocket, this).call(this);
      this._saveRegistration();
      this.emit('register');
      return this;
    });
    _defineProperty(this, "runRegistrationLoop", async () => {
      debug('starting registrations');

      // on the first load we need to load some state into the
      // device resource from local storage
      this._loadRegistration();

      // disconnect any active socket and stop any registration
      // loop that might still be running, but leave in place any
      // existing saved registration data, or pending custom data
      this.reset(true);

      // pending updates to custom data can short circuit the
      // registration loop to force an immediate (re)registration
      // but only on the first registration attempt after a page load
      if (this.hasPendingUpdates() || this.nextRegistration() <= 0) {
        await this.updateRegistration().catch(() => {});
      }

      // ensure any tokens we have stored have been used to try and reconnect
      // the sockets immediately. This will also be done on a sucessful registration
      _classPrivateFieldGet(_updateNotificationSocket, this).call(this);

      // kick off the background loop
      _classPrivateFieldGet(_loop, this).call(this);
    });
    _defineProperty(this, "pauseRegistrationLoop", async () => {
      debug('pausing registrations');

      // stop the loop and disconnect the socket but keep the
      // registration data in case the loop is restarted later on
      this.reset(true);
    });
    _defineProperty(this, "nextRegistration", () => {
      // We cache registrations to storage, so we can re-load the last registration,
      // if there has been one. If it was recent, we don't need to re-register.
      // We also store the last known notification url and token so we can attempt
      // to connect the socket immeditately
      const nextRegistrationDue = this.field('next_registration_time');
      return (nextRegistrationDue || 0) - new Date().getTime();
    });
    _defineProperty(this, "clone", () => {
      const copy = new Device(_classPrivateFieldGet(_delegate, this));
      super.clone(copy);
      return copy;
    });
    _defineProperty(this, "_nextUpdate", function () {
      let attemptNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // apply backoff
      return Math.max(Math.min(60 * 1000 * attemptNumber, 60 * 60 * 1000), _this.nextRegistration());
    });
    _classPrivateFieldInitSpec(this, _loop, function () {
      let attemptNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // prevent multiple loops running in parallel
      if (_classPrivateFieldGet(_registrationTimeout, _this)) {
        console.error('CobrowseIO: tried to schedule registration while already scheduled');
        return;
      }

      // set up the registration loop timeout, with a bacoff based on
      // number of unsuccesful attempts since the last registration
      const timeout = _this._nextUpdate(attemptNumber);
      _classPrivateFieldSet(_registrationTimeout, _this, setTimeout(async () => {
        if (!_classPrivateFieldGet(_registrationTimeout, _this)) return console.error('Registration loop cancelled');
        try {
          await _this.updateRegistration();
          _classPrivateFieldSet(_registrationTimeout, _this, false);
          return _classPrivateFieldGet(_loop, _this).call(_this);
        } catch (e) {
          console.warn('CobrowseIO: registration failed', e);
          _classPrivateFieldSet(_registrationTimeout, _this, false);
          return _classPrivateFieldGet(_loop, _this).call(_this, attemptNumber + 1);
        }
      }, Math.max(1000, timeout)));
    });
    _classPrivateFieldInitSpec(this, _socketUrl, () => {
      const url = this.field('notification_url');
      return (0, _makeSocketUrl.default)(url);
    });
    _classPrivateFieldInitSpec(this, _socketProtocols, () => {
      const token = this.field('notification_token');
      return ["cbio.http.headers.authorization.bearer.".concat(window.btoa(token).replaceAll('=', ''))];
    });
    _classPrivateFieldInitSpec(this, _openNotificationSocket, () => {
      if (_classPrivateFieldGet(_socket, this)) return;
      _classPrivateFieldSet(_socket, this, new _cocom.CBORSocket({
        getUrl: _classPrivateFieldGet(_socketUrl, this),
        getProtocols: _classPrivateFieldGet(_socketProtocols, this)
      }));
      _classPrivateFieldGet(_socket, this).setMaxReconnectDelay(60 * 1000);
      _classPrivateFieldGet(_socket, this).on('error', err => {
        if (err) console.warn('CobrowseIO notification socket error:', err);
      });
      _classPrivateFieldGet(_socket, this).on('event', (event, data) => {
        if (event === 'notification') this.emit('notification', data);else if (event === 'probe') _classPrivateFieldGet(_socket, this).send('alive', data);
      });
      _classPrivateFieldGet(_socket, this).on('open', () => {
        _classPrivateFieldGet(_socket, this).send('filter', {
          events: ['probe', 'notification']
        });
      });
    });
    _classPrivateFieldInitSpec(this, _closeNotificationSocket, () => {
      if (_classPrivateFieldGet(_socket, this)) {
        console.log('CobrowseIO: Closing socket');
        _classPrivateFieldGet(_socket, this).close();
        _classPrivateFieldSet(_socket, this, null);
      }
    });
    _classPrivateFieldInitSpec(this, _updateNotificationSocket, () => {
      const url = this.field('notification_url');
      const token = this.field('notification_token');
      if (url && token) _classPrivateFieldGet(_openNotificationSocket, this).call(this);else _classPrivateFieldGet(_closeNotificationSocket, this).call(this);
    });
    debug('constructed');
    if (!delegate) throw new Error('Device delegate is required');
    _classPrivateFieldSet(_delegate, this, delegate);

    // allow 10 requests per 2 minutes
    _classPrivateFieldSet(_rateLimiter, this, new _RateLimiter.default(10, 2 * 60 * 1000));
  }
  id() {
    return Device.deviceId();
  }
  get customData() {
    return this.field('custom_data') || {};
  }
  static deviceCredentials() {
    let credentials = (0, _storage.default)().getItem(DeviceIdPath) || {};
    // previously we just stored the id as a string, so migrate that
    if (typeof credentials === 'string') credentials = {
      id: credentials
    };
    if (typeof credentials !== 'object') credentials = {};
    if (!credentials.id) credentials.id = (0, _uuid.v4)();
    if (!credentials.token) credentials.token = (0, _uuid.v4)();
    (0, _storage.default)().setItem(DeviceIdPath, credentials);
    return credentials;
  }
  static deviceId() {
    return this.deviceCredentials().id;
  }
  static deviceToken() {
    return this.deviceCredentials().token;
  }
  static get info() {
    if (false) {}
    const capabilities = [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SCROLL, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SELECT, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DRAWING, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_ARROWS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_RECTANGLES, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_LASER, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_CURSOR, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_UNIVERSAL, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_HIGHLIGHT, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_CALLING];
    if (!/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(window.navigator.userAgent)) {
      capabilities.push(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_FULL_DEVICE);
    }
    return {
      platform: 'web',
      device: window.navigator.userAgent,
      device_locale: window.navigator.language,
      device_timezone: window.Intl.DateTimeFormat().resolvedOptions().timeZone,
      os_version: window.navigator.platform,
      app_id: window.location.origin,
      app_name: window.document.title,
      app_build_configuration: 'release',
      // eslint-disable-next-line
      sdk_version: '3.13.0',
      capabilities
    };
  }
}
exports["default"] = Device;

/***/ }),

/***/ 21667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Device", ({
  enumerable: true,
  get: function () {
    return _Device.default;
  }
}));
var _Device = _interopRequireDefault(__webpack_require__(61789));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 71260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _events = _interopRequireDefault(__webpack_require__(37007));
var _parseWindowFeatures = __webpack_require__(18567);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _target = /*#__PURE__*/new WeakMap();
var _url = /*#__PURE__*/new WeakMap();
var _element = /*#__PURE__*/new WeakMap();
var _type = /*#__PURE__*/new WeakMap();
var _icon = /*#__PURE__*/new WeakMap();
var _title = /*#__PURE__*/new WeakMap();
var _isLoading = /*#__PURE__*/new WeakMap();
var _isBlocked = /*#__PURE__*/new WeakMap();
var _isClosed = /*#__PURE__*/new WeakMap();
class Document extends _events.default {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _classPrivateFieldInitSpec(this, _target, void 0);
    _classPrivateFieldInitSpec(this, _url, void 0);
    _classPrivateFieldInitSpec(this, _element, void 0);
    _classPrivateFieldInitSpec(this, _type, void 0);
    _classPrivateFieldInitSpec(this, _icon, void 0);
    _classPrivateFieldInitSpec(this, _title, void 0);
    _classPrivateFieldInitSpec(this, _isLoading, void 0);
    _classPrivateFieldInitSpec(this, _isBlocked, void 0);
    _classPrivateFieldInitSpec(this, _isClosed, false);
    _defineProperty(this, "load", function (url, target, windowFeatures) {
      let {
        element,
        type
      } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      _classPrivateFieldSet(_url, _this, url);
      const features = (0, _parseWindowFeatures.parseWindowFeatures)(windowFeatures);
      _classPrivateFieldSet(_target, _this, features.popup ? '_blank' : target);
      _classPrivateFieldSet(_element, _this, element);
      _classPrivateFieldSet(_type, _this, type);
      _classPrivateFieldSet(_icon, _this, '');
      _classPrivateFieldSet(_title, _this, '');
      _classPrivateFieldSet(_isLoading, _this, true);
      _classPrivateFieldSet(_isBlocked, _this, false);
      _this.emit('updated', _this);
    });
    _defineProperty(this, "close", () => {
      if (_classPrivateFieldGet(_isClosed, this)) return;
      _classPrivateFieldSet(_isClosed, this, true);
      this.emit('closed', this);
    });
    _defineProperty(this, "serialize", () => ({
      url: this.url,
      icon: this.icon,
      title: this.title,
      isLoading: this.isLoading,
      isBlocked: this.isBlocked,
      isClosed: this.isClosed
    }));
  }
  get target() {
    return _classPrivateFieldGet(_target, this);
  }
  get url() {
    return _classPrivateFieldGet(_url, this);
  }
  set url(state) {
    if (this.url === state) return;
    _classPrivateFieldSet(_url, this, state);
    this.emit('updated', this);
  }
  get element() {
    return _classPrivateFieldGet(_element, this);
  }
  get type() {
    return _classPrivateFieldGet(_type, this);
  }
  get icon() {
    return _classPrivateFieldGet(_icon, this);
  }
  set icon(state) {
    if (_classPrivateFieldGet(_icon, this) === state) return;
    _classPrivateFieldSet(_icon, this, state);
    this.emit('updated', this);
  }
  get title() {
    return _classPrivateFieldGet(_title, this);
  }
  set title(state) {
    if (_classPrivateFieldGet(_title, this) === state) return;
    _classPrivateFieldSet(_title, this, state);
    this.emit('updated', this);
  }
  get isLoading() {
    return _classPrivateFieldGet(_isLoading, this);
  }
  set isLoading(state) {
    if (_classPrivateFieldGet(_isLoading, this) === state) return;
    _classPrivateFieldSet(_isLoading, this, state);
    this.emit('updated', this);
  }
  get isBlocked() {
    return _classPrivateFieldGet(_isBlocked, this);
  }
  set isBlocked(state) {
    if (_classPrivateFieldGet(_isBlocked, this) === state) return;
    _classPrivateFieldSet(_isBlocked, this, state);
    this.emit('updated', this);
  }
  get isClosed() {
    return _classPrivateFieldGet(_isClosed, this);
  }
  get windowProxy() {
    const instance = this;
    return {
      close: () => this.close(),
      get closed() {
        return _classPrivateFieldGet(_isClosed, instance);
      }
    };
  }
}
exports["default"] = Document;

/***/ }),

/***/ 68756:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _uuid = __webpack_require__(65392);
var _iframes = _interopRequireDefault(__webpack_require__(77966));
var _Document = _interopRequireDefault(__webpack_require__(71260));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _handleDocumentMap = /*#__PURE__*/new WeakMap();
var _documentHandleMap = /*#__PURE__*/new WeakMap();
var _nameHandleMap = /*#__PURE__*/new WeakMap();
var _handleNameMap = /*#__PURE__*/new WeakMap();
var _onDocumentAdded = /*#__PURE__*/new WeakMap();
var _onDocument = /*#__PURE__*/new WeakMap();
var _removeDocument = /*#__PURE__*/new WeakMap();
var _trackDocument = /*#__PURE__*/new WeakMap();
class DocumentCollection {
  constructor(_ref) {
    let {
      onDocumentAdded
    } = _ref;
    _classPrivateFieldInitSpec(this, _handleDocumentMap, new Map());
    _classPrivateFieldInitSpec(this, _documentHandleMap, new Map());
    _classPrivateFieldInitSpec(this, _nameHandleMap, new Map());
    _classPrivateFieldInitSpec(this, _handleNameMap, new Map());
    _classPrivateFieldInitSpec(this, _onDocumentAdded, void 0);
    _classPrivateFieldInitSpec(this, _onDocument, (_ref2, _ref3) => {
      let {
        handle,
        document
      } = _ref2;
      let {
        trusted
      } = _ref3;
      if (!trusted) return;
      const existingDocument = this.getDocumentByHandle(handle);
      if (!existingDocument) return;
      if (!existingDocument.isClosed && document.isClosed) {
        existingDocument.close(true);
      }
    });
    _classPrivateFieldInitSpec(this, _removeDocument, document => {
      const handle = _classPrivateFieldGet(_documentHandleMap, this).get(document);
      _classPrivateFieldGet(_handleDocumentMap, this).delete(handle);
      _classPrivateFieldGet(_documentHandleMap, this).delete(document);
      const name = _classPrivateFieldGet(_handleNameMap, this).get(handle);
      _classPrivateFieldGet(_handleNameMap, this).delete(handle);
      if (name) _classPrivateFieldGet(_nameHandleMap, this).delete(name);
    });
    _classPrivateFieldInitSpec(this, _trackDocument, (handle, document) => {
      const onDocumentUpdated = () => {
        const payload = {
          handle,
          document: document.serialize()
        };
        if (document.element) {
          _iframes.default.broadcastToChildren('document', payload);
        } else {
          _iframes.default.sendToParent('document', payload);
        }
      };
      document.on('updated', onDocumentUpdated);
      onDocumentUpdated();
      document.once('closed', () => {
        document.off('updated', onDocumentUpdated);
        onDocumentUpdated();
        _classPrivateFieldGet(_removeDocument, this).call(this, document);
      });
    });
    _defineProperty(this, "addDocument", (handle, name, document) => {
      var _classPrivateFieldGet2;
      if (_classPrivateFieldGet(_handleDocumentMap, this).has(handle)) return;
      if (document.isClosed) return;
      _classPrivateFieldGet(_handleDocumentMap, this).set(handle, document);
      _classPrivateFieldGet(_documentHandleMap, this).set(document, handle);
      if (name) {
        _classPrivateFieldGet(_nameHandleMap, this).set(name, handle);
        _classPrivateFieldGet(_handleNameMap, this).set(handle, name);
      }
      _classPrivateFieldGet(_trackDocument, this).call(this, handle, document);
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_onDocumentAdded, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this, document);
    });
    _defineProperty(this, "closeAllDocuments", () => {
      for (const [, document] of _classPrivateFieldGet(_handleDocumentMap, this)) {
        document.close();
        _classPrivateFieldGet(_removeDocument, this).call(this, document);
      }
    });
    _defineProperty(this, "getDocumentByHandle", handle => _classPrivateFieldGet(_handleDocumentMap, this).get(handle));
    _defineProperty(this, "resolveDocumentHandle", name => {
      const existingHandle = _classPrivateFieldGet(_nameHandleMap, this).get(name);
      if (existingHandle) return existingHandle;
      return (0, _uuid.v4)();
    });
    _defineProperty(this, "resolveDocument", (handle, name) => {
      const resolvedHandle = handle || this.resolveDocumentHandle(name);
      const resolvedDocument = this.getDocumentByHandle(resolvedHandle);
      return {
        handle: resolvedHandle,
        document: resolvedDocument || new _Document.default()
      };
    });
    _defineProperty(this, "destroy", () => {
      _iframes.default.off('document', _classPrivateFieldGet(_onDocument, this));
    });
    _classPrivateFieldSet(_onDocumentAdded, this, onDocumentAdded);
    _iframes.default.on('document', _classPrivateFieldGet(_onDocument, this));
  }
}
exports["default"] = DocumentCollection;

/***/ }),

/***/ 89689:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Document", ({
  enumerable: true,
  get: function () {
    return _Document.default;
  }
}));
Object.defineProperty(exports, "DocumentCollection", ({
  enumerable: true,
  get: function () {
    return _DocumentCollection.default;
  }
}));
var _Document = _interopRequireDefault(__webpack_require__(71260));
var _DocumentCollection = _interopRequireDefault(__webpack_require__(68756));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 48374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _src = __webpack_require__(89501);
var _activity = __webpack_require__(45264);
var _WindowTaps = _interopRequireDefault(__webpack_require__(44153));
var _unpolyfill = __webpack_require__(79883);
var _navigation = __webpack_require__(49715);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class MutatingEventObserver {
  constructor(onModification) {
    var _this = this;
    _defineProperty(this, "_init", () => {
      if (!this._propertyWatcher) {
        this._propertyWatcher = new _src.PropertyObserver(this._onPropertySet);
        _WindowTaps.default.on('stylechange', this._onStyleSheetChange);
        _WindowTaps.default.on('navigate', this._onNavigation);
        _WindowTaps.default.on('canvaschange', this._onCanvasChange);
      }
    });
    _defineProperty(this, "observe", root => {
      if (this._observing.has(root)) return;

      // some handlers only get attached once globally after the first observe()
      this._init();

      // lightning components will not bubble events, when they happen on the fake shadow root
      const {
        value: addEventListener = root.addEventListener
      } = Object.getOwnPropertyDescriptor(_unpolyfill.EventTarget.prototype, 'addEventListener');
      addEventListener.call(root, 'scroll', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'focus', this._onFocusChange, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'blur', this._onFocusChange, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'change', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'keydown', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'keyup', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'keypress', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'selectionchange', this._onSelectionEvent, {
        capture: true,
        passive: true
      });

      // input and textarea elements selection behaves different than regular text selection
      // so we subscribe to the selection event as well to handle these scenarios
      addEventListener.call(root, 'select', this._onSelectionEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mouseenter', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mouseleave', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mousedown', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mouseup', this._onEvent, {
        capture: true,
        passive: true
      });
      _activity.MouseTracking.track(root);
      _activity.InteractionTracking.track(root);
      _navigation.NavigationTracking.track(root);
      this._observing.add(root);
      const window = (root.ownerDocument || root).defaultView;
      if (window && !this._windows.has(window)) {
        this._windows.add(window);
        _WindowTaps.default.tap(window);
        _navigation.NavigationTracking.tap(window);
        this._propertyWatcher.observe(window.HTMLInputElement, 'value');
        this._propertyWatcher.observe(window.HTMLInputElement, 'checked');
        this._propertyWatcher.observe(window.HTMLTextAreaElement, 'value');
        this._propertyWatcher.observe(window.ShadowRoot, 'adoptedStyleSheets');
        this._propertyWatcher.observe(window.Document, 'adoptedStyleSheets');
        if (window.addEventListener) {
          window.addEventListener('hashchange', this._onEvent, {
            capture: true,
            passive: true
          });
          window.addEventListener('resize', this._onEvent, {
            capture: true,
            passive: true
          });
        }
      }
    });
    _defineProperty(this, "disconnect", () => {
      this._observing.forEach(root => {
        const {
          value: removeEventListener = root.removeEventListener
        } = Object.getOwnPropertyDescriptor(_unpolyfill.EventTarget.prototype, 'removeEventListener');
        removeEventListener.call(root, 'scroll', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'focus', this._onFocusChange, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'blur', this._onFocusChange, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'change', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'keydown', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'keyup', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'keypress', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'selectionchange', this._onSelectionEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'select', this._onSelectionEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mouseenter', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mouseleave', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mousedown', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mouseup', this._onEvent, {
          capture: true,
          passive: true
        });
        _activity.MouseTracking.untrack(root);
        _activity.InteractionTracking.untrack(root);
        _navigation.NavigationTracking.untrack(root);
      });
      this._observing.clear();
      this._windows.forEach(window => {
        _WindowTaps.default.untap(window);
        _navigation.NavigationTracking.untap(window);
        if (window && !(0, _src.isxdoc)(window) && window.removeEventListener) {
          window.removeEventListener('hashchange', this._onEvent, {
            capture: true,
            passive: true
          });
          window.removeEventListener('resize', this._onEvent, {
            capture: true,
            passive: true
          });
        }
      });
      this._windows.clear();
      if (this._propertyWatcher) {
        this._propertyWatcher.disconnect();
        this._propertyWatcher = null;
        _WindowTaps.default.off('stylechange', this._onStyleSheetChange);
        _WindowTaps.default.off('navigate', this._onNavigation);
        _WindowTaps.default.off('canvaschange', this._onCanvasChange);
      }
    });
    // Salesforce Lightning overwrites the Event target getter so we need to use the unpollyfilled version
    _defineProperty(this, "_getActualTarget", e => {
      const {
        get: target
      } = Object.getOwnPropertyDescriptor(_unpolyfill.Event.prototype, 'target');
      return target.apply(e);
    });
    _defineProperty(this, "_target", e => {
      const eventTarget = this._getActualTarget(e);
      return eventTarget && eventTarget.document || eventTarget;
    });
    _defineProperty(this, "_onEvent", function (e) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _this._onModification(_this._target(e), _objectSpread(_objectSpread({}, options), {}, {
        type: e.type
      }));
    });
    _defineProperty(this, "_onSelectionEvent", e => {
      var _eventTarget$ownerDoc;
      const eventTarget = this._getActualTarget(e);
      const parentDoc = (_eventTarget$ownerDoc = eventTarget.ownerDocument) !== null && _eventTarget$ownerDoc !== void 0 ? _eventTarget$ownerDoc : eventTarget;

      // if there's been an agent selection less than 100ms ago then we skip the event to prevent text
      // selection loops
      if (parentDoc.__last_agent_selection_ts > Date.now() - 100) return;

      // When a user unselects text within an input/textarea elements we only get a `selectionchange`
      // event on the document level which doesn't contain enough information to understand which input
      // has had text unselected.
      // As such, when we receive an event of type `selectionchange`, we check if the focused element
      // is of type input/textarea and if so serialize that element selection as well
      // and input/textarea
      if (e.type === 'selectionchange') {
        var _parentDoc$activeElem;
        if (['INPUT', 'TEXTAREA'].includes((_parentDoc$activeElem = parentDoc.activeElement) === null || _parentDoc$activeElem === void 0 ? void 0 : _parentDoc$activeElem.tagName)) {
          parentDoc.activeElement.__cobrowse_user_selection_timestamp = Date.now();
          this._onModification(parentDoc.activeElement, {
            type: e.type
          });
        } else {
          eventTarget.__cobrowse_user_selection_timestamp = Date.now();
          this._onModification(eventTarget, {
            type: e.type
          });
        }
      }
      if (e.type === 'select') {
        eventTarget.__cobrowse_user_selection_timestamp = Date.now();
        this._onModification(eventTarget, {
          type: e.type
        });
      }
    });
    _defineProperty(this, "_onStyleSheetChange", sheet => {
      // for <style> tags, we can trigger a modification on the ownerNode
      if (sheet.ownerNode) this._onModification(sheet.ownerNode, {
        type: 'stylesheet'
      });
      // but for constucted style sheets (those using new CSSStyleSheet())
      // we need to be a bit more thorough as they can be shared in multiple places
      for (const root of this._observing) {
        var _root$adoptedStyleShe;
        if ((_root$adoptedStyleShe = root.adoptedStyleSheets) !== null && _root$adoptedStyleShe !== void 0 && _root$adoptedStyleShe.includes(sheet)) {
          this._onModification(root, {
            type: 'adoptedstylesheet'
          });
        }
      }
    });
    _defineProperty(this, "_onNavigation", window => {
      this._onModification(window.document, {
        type: 'navigation'
      });
    });
    _defineProperty(this, "_onCanvasChange", canvas => {
      this._onModification(canvas, {
        type: 'canvas'
      });
    });
    _defineProperty(this, "_onFocusChange", e => {
      const eventTarget = this._getActualTarget(e);
      if (eventTarget == null) {
        return;
      }
      // We serialise the target to ensure that input text selections gets unselected when the user
      // unselects it
      this._onModification(eventTarget, {
        type: e.type
      });
      if (eventTarget.ownerDocument) {
        this._onModification(eventTarget.ownerDocument, {
          type: e.type
        });
      }
    });
    _defineProperty(this, "_onInputEvent", e => {
      const eventTarget = this._getActualTarget(e);
      if (eventTarget.tagName === 'SELECT' || eventTarget.tagName === 'TEXTAREA') {
        this._onModification(this._target(e), {
          recursive: true,
          type: e.type
        });
      } else if (eventTarget.tagName === 'INPUT') {
        if (eventTarget.type === 'radio' && eventTarget.name) {
          const container = eventTarget.closest('form') || eventTarget.ownerDocument;
          const radiogroup = container.querySelectorAll("input[type=radio][name=".concat(eventTarget.name, "]"));
          radiogroup.forEach(el => this._onModification(el, {
            type: e.type
          }));
        } else this._onModification(this._target(e), {
          recursive: true,
          type: e.type
        });
      }
    });
    _defineProperty(this, "_onPropertySet", target => {
      this._onModification(target, {
        type: 'property'
      });
    });
    // most of the events here are caught in the capture phase, so any synchronous effect
    // of handlers in user code likely will not have been applied, so we delay to the next
    // tick to capture them
    this._onModification = function () {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      return setTimeout(() => onModification(...params), 0);
    };
    this._observing = new Set();
    this._windows = new Set();
  }
}
exports["default"] = MutatingEventObserver;

/***/ }),

/***/ 25596:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _fastDeepEqual = _interopRequireDefault(__webpack_require__(32017));
var _src = __webpack_require__(89501);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class PatchCompressor {
  constructor(id) {
    _defineProperty(this, "_difference", (object, base) => {
      if (!base) return _objectSpread({}, object);
      const changes = Object.keys(object).map(key => {
        if ((0, _fastDeepEqual.default)(object[key], base[key])) return false;
        return {
          [key]: object[key]
        };
      }).filter(v => v);
      // reduce back into an object
      return changes.reduce((a, b) => {
        return _objectSpread(_objectSpread({}, a), b);
      }, {});
    });
    _defineProperty(this, "compress", () => {
      // then work out what's actually changed since the last state was persisted
      const compressed = Object.values(this.modified).map(modified => {
        const state = this.state.node(modified.id);
        const diff = this._difference(modified, this._flatten(state || {}));
        const changed = _objectSpread({
          id: modified.id
        }, diff);
        if (Object.keys(changed).length === 1) return false;
        return changed;
      }).filter(v => v);
      return compressed;
    });
    _defineProperty(this, "mark", () => {
      this.state.applyPatch(Object.values(this.modified));
      this.modified = {};
      return this;
    });
    _defineProperty(this, "_flatten", node => {
      return node.childNodes ? _objectSpread(_objectSpread({}, node), {}, {
        childNodes: node.childNodes.map(n => ({
          id: n.id
        }))
      }) : node;
    });
    _defineProperty(this, "push", patch => {
      if (!(patch && patch.modified)) {
        console.error('invalid patch', patch);
        return this;
      }
      patch.modified.filter(v => v).forEach(diff => {
        (0, _src.depthFirst)(diff, node => {
          this.modified[node.id] = _objectSpread(_objectSpread({}, this.modified[node.id]), this._flatten(node));
        });
      });
      return this;
    });
    _defineProperty(this, "reset", newState => {
      this.state = new _src.VirtualDOM(this._id);
      this.modified = {};
      if (newState) this.push({
        _t: 'reset',
        modified: [newState]
      });
      return this;
    });
    this._id = id;
    this.reset();
  }
}
exports["default"] = PatchCompressor;

/***/ }),

/***/ 23221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _events = __webpack_require__(37007);
var _src = __webpack_require__(89501);
var _redaction = __webpack_require__(16566);
var _nodes = __webpack_require__(66938);
var _MutatingEventObserver = _interopRequireDefault(__webpack_require__(48374));
var _unpolyfill = __webpack_require__(79883);
var _iframes = _interopRequireDefault(__webpack_require__(77966));
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _discoverNodes = __webpack_require__(38091);
var _WindowTaps = _interopRequireDefault(__webpack_require__(44153));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.PatchStream');
class PatchStream extends _events.EventEmitter {
  constructor(_root) {
    var _this;
    super();
    _this = this;
    _defineProperty(this, "start", () => {
      debug('starting patch stream for', this._root);

      // create a collection to track which document we're subscribed observers to
      this._documents = new Set();
      // listen for cross doc messages from third party iframes that support cobrowse
      this._iframeBridge.on('patch', this._onXDocIframeUpdate);
      // discover the nodes, track iframe etc...
      this._observe(this._root);
      // discover shadowRoots that are attached after the host is tracked
      _WindowTaps.default.on('attachshadow', this._onAttachShadow);
    });
    _defineProperty(this, "forceUpdate", () => {
      debug('forcing entire state update from', this._root);
      this.emit('patch', {
        _t: 'pre-force',
        flush: true,
        modified: [_objectSpread(_objectSpread({}, _nodes.NodeSerializer.serialize(this._root)), {}, {
          // If we're not sending the body, we should also suppress the scroll position as
          // the page content won't be large enough to be scrollable yet.
          scroll: undefined,
          childNodes: [_objectSpread(_objectSpread({}, _nodes.NodeSerializer.serialize(this._root.documentElement)), {}, {
            childNodes: [_nodes.NodeTree.depthFirst(this._root.head, _nodes.NodeSerializer.serialize)]
          })]
        })]
      });
      const serializerOptions = {
        rasterizeCanvas: true
      };
      this.emit('patch', {
        _t: 'forced',
        modified: [_nodes.NodeTree.depthFirst(this._root, (root, overrideChildren) => _nodes.NodeSerializer.serialize(root, overrideChildren, serializerOptions))]
      });
    });
    _defineProperty(this, "partialSync", nodeId => {
      const node = _nodes.NodeTracker.getById(nodeId);
      if (!node) return;
      this.emit('patch', {
        _t: 'partialsync',
        modified: [_nodes.NodeSerializer.serialize(node)]
      });
    });
    _defineProperty(this, "stop", () => {
      debug('stopping patch stream for', this._root);
      this._eventObserver.disconnect();
      this._mutationObserver.disconnect();
      this._iframeBridge.removeListener('patch', this._onXDocIframeUpdate);
      if (this._documents) this._documents.clear();
      this._documents = null;
      _WindowTaps.default.off('attachshadow', this._onAttachShadow);
    });
    _defineProperty(this, "destroy", () => {
      debug('destroying patch stream for', this._root);
      this.stop();
      this.removeAllListeners();
      _nodes.NodeTree.depthFirst(this._root, this._untrack);
      this._mutationObserver = null;
      this._eventObserver = null;
      this._iframeBridge = null;
      this._root = null;
    });
    // we need to track all the nodes that have been added or removed from the
    // DOM at any point. This is because we get some events for nodes that may
    // not have been passed to the mutation observer yet (due to batching done
    // by the browser). So we need to know when we should ignore those changes.
    // They'll get picked up later when the node is found by the DOM observation.
    _defineProperty(this, "_track", node => {
      if (!_nodes.NodeUtils.isDOMNode(node)) return;
      _nodes.NodeTracker.track(node);

      // top level document nodes (including those in accessible
      // iframes should be added to the various observers)
      if (node.nodeType === window.Node.DOCUMENT_NODE) {
        this._observe(node);
      }
      if (node.nodeType === window.Node.DOCUMENT_FRAGMENT_NODE) {
        this._observe(node);
      }

      // attach a load listener to iframes so we know when to
      // re-serialize its content on navigation or reload
      if (node.tagName === 'IFRAME') {
        this._iframeBridge.track(node);
        node.removeEventListener('load', this._onIframeLoad, {
          capture: true
        });
        node.addEventListener('load', this._onIframeLoad, {
          capture: true
        });
      }
    });
    _defineProperty(this, "_untrack", node => {
      _nodes.NodeTracker.forget(node);
      if (_nodes.NodeUtils.isDOMNode(node) && node.tagName === 'IFRAME') {
        node.removeEventListener('load', this._onIframeLoad, {
          capture: true
        });
        this._iframeBridge.remove(node);
      }
    });
    _defineProperty(this, "_observe", node => {
      if (node.nodeType !== window.Node.DOCUMENT_NODE && node.nodeType !== window.Node.DOCUMENT_FRAGMENT_NODE) {
        throw new Error("CobrowseIO: observed a non-document or fragment node (type=".concat(node.nodeType, ")"));
      } else {
        if (this._documents.has(node)) return;
        debug('starting observation of', node);
        this._documents.add(node);
        debug('doing initial node tracking on observe for', node);
        _nodes.NodeTree.depthFirst(node, this._track);
        this._eventObserver.observe(node);
        try {
          this._mutationObserver.observe(node, {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
          });
        } catch (e) {
          console.error('CobrowseIO failed to start mutation observer for', node);
        }
      }
    });
    _defineProperty(this, "_onAttachShadow", shadowRoot => {
      var _RedactionIndexProvid;
      const host = shadowRoot.host;

      // if the host isn't tracked yet we let the
      // mutation observer handle the node & corresponding
      // shadowRoot once it is added into the DOM
      if (!_nodes.NodeTracker.get(host)) return;
      if ((_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid !== void 0 && _RedactionIndexProvid.isRedacted(host)) return;
      this._observe(shadowRoot);
      if (_nodes.NodeTree.isIgnored(host)) return;

      // serialize the host of the shadowRoot and the shadowRoot itself
      this.emit('patch', {
        _t: 'attachshadow',
        modified: [_nodes.NodeSerializer.serialize(host), _nodes.NodeTree.depthFirst(shadowRoot, _nodes.NodeSerializer.serialize)]
      });
    });
    _defineProperty(this, "_onXDocIframeUpdate", (patch, _ref) => {
      var _RedactionIndexProvid2;
      let {
        iframe
      } = _ref;
      debug('xdoc iframe updated', iframe, patch);

      // if the message didn't come from an iframe in the page
      // then we should ignore it
      if (!iframe) return;
      if ((_RedactionIndexProvid2 = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid2 !== void 0 && _RedactionIndexProvid2.isRedacted(iframe)) return;
      if (_nodes.NodeTree.isIgnored(iframe)) return;

      // Embeded pages will send up patch events when their content changes
      // We will build these back into a VirtualDOM for eahc iframe that the
      // serialiser of this document can then access to read the (pre-
      // serialized) contents of the xdoc iframe.
      iframe.__document_id = patch.document_id;
      this.emit('patch', {
        _t: 'xdociframeupdate',
        modified: [
        // Make sure we always serialize the containing iframe. This catches cases
        // where the document id has changed and we'll need to recreate the whole
        // content from scratch.
        _nodes.NodeSerializer.serialize(iframe),
        // then just include the patches from inside the iframe verbatum
        ...patch.patch]
      });
    });
    _defineProperty(this, "_onIframeLoad", _ref2 => {
      var _RedactionIndexProvid3;
      let {
        target
      } = _ref2;
      debug('iframe loaded', target);
      if ((_RedactionIndexProvid3 = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid3 !== void 0 && _RedactionIndexProvid3.isRedacted(target)) return;

      // watch the iframe content for changes using our mutation observer
      if (!(0, _src.isxdoc)(target)) this._observe(target.contentWindow.document);

      // ensure the bridge is aware of this iframe
      this._iframeBridge.track(target);
      if (_nodes.NodeTree.isIgnored(target)) return;

      // and always send the content for compression and transmission
      this.emit('patch', {
        _t: 'iframeupdate',
        modified: [_nodes.NodeTree.depthFirst(target, _nodes.NodeSerializer.serialize)]
      });
    });
    _defineProperty(this, "_onEventMutation", function (target) {
      var _RedactionIndexProvid4;
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // this is called within a setTimeout, so we need to check if we're still running
      // the mutation observer before we do anything
      if (_this._mutationObserver) {
        // Force processing of any outstanding changes the mutation observer has queued up.
        // This should let us discover and track all new nodes that the event might have targeted
        _this._onDOMChange(_this._mutationObserver.takeRecords());
      }

      // IE 11 textareas don't trigger mutation events, so we might end up with new
      // text nodes that aren't tracked yet
      if (target.tagName === 'TEXTAREA') _nodes.NodeTree.depthFirst(target, _this._track);

      // Problem: we can get events for nodes that we might not know about yet through the
      //          mutation observer. This mean those nodes might not yet have a parent in our
      //          virtual dom, so sending state changes for them would lead to orphaned trees
      //          and cause things to blow up on the agent side
      //          To get around this we statefully track which nodes we currently know about
      //          and if we get events for nodes outside that set we can safely ignore the events
      //          Currently this state tracking is done globally via the NodeTracker class
      //    TODO: Find a better place to track the node discovery state
      if (!_nodes.NodeTracker.get(target)) return;
      if ((_RedactionIndexProvid4 = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid4 !== void 0 && _RedactionIndexProvid4.isRedacted(target)) return;
      if (_nodes.NodeTree.isIgnored(target)) return;
      const serializerOptions = {
        rasterizeCanvas: options.type === 'canvas'
      };
      const s = options.recursive ? _nodes.NodeTree.depthFirst(target, (root, overrideChildren) => _nodes.NodeSerializer.serialize(root, overrideChildren, serializerOptions)) : _nodes.NodeSerializer.serialize(target, undefined, serializerOptions);
      _this.emit('patch', {
        _t: "eventmutation:".concat(options.type),
        modified: [s]
      });
    });
    _defineProperty(this, "_getModifications", changes => {
      // build a summary across all changes of which nodes are added
      // and removed (note: a node might be removed then re-added in
      // the same group of changes, or it's parent might be removed)
      const removed = new Set();
      const modified = new Set();
      const added = new Set();

      // traverse the list of changes building a picture of the overall nodes that
      // have been modified
      changes.forEach(change => {
        // we re-use the mutation observer to watch for shadow dom changes too
        // it appears we can get shadow dom changes for trees not actually attached
        // to the main DOM, so we filter those out before applying the changes
        //
        // IE 11 text nodes seem to get randomly replaced and fail equality
        // checks, so we assume all character data changes are valid
        // if the nodes aren't actually in the DOM they'll get ignored
        const valid = change.type === 'characterData' || modified.has(change.target) || _nodes.NodeTracker.get(change.target);
        if (valid) (0, _discoverNodes.discoverNodes)(change, modified, added, removed);
      });

      // nodes that have been removed can be forgotten
      removed.forEach(node => this._untrack(node));

      // we need to make sure all the newly added nodes are being tracked (i.e. they have IDs)
      // IE 11 can change the node references in the DOM of modified nodes, so
      // we should count the modified nodes as if they were just added
      modified.forEach(node => {
        return this._track(node);
      });
      return {
        added,
        modified,
        removed
      };
    });
    _defineProperty(this, "_onDOMChange", changes => {
      var _RedactionIndexProvid5, _RedactionIndexProvid6;
      const {
        added,
        modified,
        removed
      } = this._getModifications(changes);

      // The redaction system is aware of changes that may need to take place in
      // nodes that expand beyond the direct nodes that were changed. Collect
      // those here
      const redactionChanges = (_RedactionIndexProvid5 = (_RedactionIndexProvid6 = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid6 === void 0 ? void 0 : _RedactionIndexProvid6.notifyChanges(changes, added, modified, removed)) !== null && _RedactionIndexProvid5 !== void 0 ? _RedactionIndexProvid5 : [];
      const allModified = new Set([...modified, ...redactionChanges]);
      debug('DOM changed', allModified);

      // serialise nodes that have been added or updated and
      // convert nodes that have been removed to a list of id only nodes
      const serialized = [...allModified].map(node => _nodes.NodeSerializer.serialize(node)).filter(Boolean);
      debug('DOM changes serialized', serialized);
      this.emit('patch', {
        _t: 'domchange',
        modified: serialized
      });
    });
    this._root = _root;
    this._mutationObserver = new _unpolyfill.MutationObserver(this._onDOMChange);
    this._eventObserver = new _MutatingEventObserver.default(this._onEventMutation);
    this._iframeBridge = _iframes.default;
  }
}
exports["default"] = PatchStream;

/***/ }),

/***/ 72847:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "PatchCompressor", ({
  enumerable: true,
  get: function () {
    return _PatchCompressor.default;
  }
}));
Object.defineProperty(exports, "PatchStream", ({
  enumerable: true,
  get: function () {
    return _PatchStream.default;
  }
}));
var _PatchStream = _interopRequireDefault(__webpack_require__(23221));
var _PatchCompressor = _interopRequireDefault(__webpack_require__(25596));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 53071:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _throttle = _interopRequireDefault(__webpack_require__(7350));
var _dompatches = __webpack_require__(72847);
var _nodes = __webpack_require__(66938);
var _activity = __webpack_require__(45264);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.DOMFrameSource');
class DOMFrameSource {
  constructor(onUpdate) {
    _defineProperty(this, "_throttleCompressAndEmitFrame", (0, _throttle.default)(() => this._compressAndEmitFrame(), 110));
    _defineProperty(this, "_compressAndEmitFrame", () => {
      // check if we've been destroyed before throttle ends
      // as throttles aren't cancelable
      if (!this._compression) return;

      // check the document we were attached to is still being tracked
      if (!document || !_nodes.NodeTracker.get(document)) return;

      // get a compressed version of the state so far (this won't alter the
      // state of the compression yet)
      const patch = this._compression.compress();
      if (!patch.length) return;

      // call the update callback. update callbacks may return falsy values
      // to indicate the update couldn't be handled for some reason, e.g. the
      // socket was disconencted or under too much backpressure
      if (this._onUpdate({
        document_id: _nodes.NodeTracker.get(document),
        patch
      })) {
        // mark this part of compressed state as used
        // so the next state will continue from here
        this._compression.mark();
      }
    });
    _defineProperty(this, "capturingWillStart", () => {
      debug('capturingWillStart for DOMFrameSource in', document);
      if (this._sendInterval) throw new Error('DOMFrameSource already running');
      if (!this._compression) this._compression = new _dompatches.PatchCompressor(_nodes.NodeTracker.track(document));
      if (!this._patchStream) this._patchStream = new _dompatches.PatchStream(document);
      _activity.WindowTracking.on('activate', this.reset);

      // sends are triggered both immediately on changes (with some rate
      // limiting) and on a regular tick to retry failed sends (e.g. if the
      // socket is temporarily disconnected)
      this._patchStream.on('patch', patch => {
        this._compression.push(patch);
        if (patch.flush) {
          this._compressAndEmitFrame();
        } else {
          this._throttleCompressAndEmitFrame();
        }
      });
      this._sendInterval = setInterval(() => this._compressAndEmitFrame(), 500);
      this._patchStream.start();
    });
    _defineProperty(this, "capturingWillStop", () => {
      debug('capturingWillStop for DOMFrameSource in', document);
      _activity.WindowTracking.removeListener('activate', this.reset);
      if (this._sendInterval) {
        clearInterval(this._sendInterval);
        this._sendInterval = null;
      }
      if (this._patchStream) {
        this._patchStream.destroy();
        this._patchStream = null;
      }
      if (this._compression) {
        this._compression.reset();
        this._compression = null;
      }
    });
    _defineProperty(this, "setCodecs", codecs => {
      // TODO: should we actually check this in any way
    });
    _defineProperty(this, "reset", () => {
      debug('resetting DOMFrameSource in', document);
      // we use a setTimeout to ensure that any DOM mutations are first
      // recorded in the async callback of the mutation observer
      setTimeout(() => {
        var _this$_compression, _this$_patchStream;
        (_this$_compression = this._compression) === null || _this$_compression === void 0 || _this$_compression.reset();
        (_this$_patchStream = this._patchStream) === null || _this$_patchStream === void 0 || _this$_patchStream.forceUpdate();
      }, 0);
    });
    _defineProperty(this, "destroy", () => {
      debug('destroying DOMFrameSource in', document);
      this.capturingWillStop();
      this._onUpdate = null;
    });
    _defineProperty(this, "partialSync", nodeId => {
      this._patchStream.partialSync(nodeId);
    });
    debug('DOMFrameSource constructed in', document);
    this._onUpdate = onUpdate;
  }
}
exports["default"] = DOMFrameSource;

/***/ }),

/***/ 42668:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.FrameLoop');
class FrameLoop {
  constructor() {
    _defineProperty(this, "isRunning", () => {
      return this._running;
    });
    _defineProperty(this, "setSource", async source => {
      if (source.constructor === (this.source && this.source.constructor)) {
        debug('frame source type not changed');
        return;
      }
      if (this.isRunning()) {
        if (this.source) this.source.capturingWillStop();
        this.source = source;
        try {
          await this.source.capturingWillStart();
          // when switching between frame source while already
          // running we should force a new "keyframe" of the
          // underlying frame source in case the remote side doesn't
          // have the full state
          this.invalidateFrame();
        } catch (e) {
          console.error(e);
        }
      } else {
        this.source = source;
      }
    });
    _defineProperty(this, "getSource", () => {
      return this.source;
    });
    _defineProperty(this, "start", async () => {
      debug('starting frame loop in', document);
      if (!this.isRunning()) {
        this._running = true;
        this.source.capturingWillStart();
      }
    });
    _defineProperty(this, "stop", () => {
      if (this.isRunning()) {
        this.source.capturingWillStop();
        this._running = false;
      }
    });
    _defineProperty(this, "invalidateFrame", () => {
      if (!this.isRunning()) throw new Error('FrameLoop was destroyed');
      debug('invalidate frame in', document);
      if (this.source) this.source.reset();
    });
    _defineProperty(this, "destroy", () => {
      debug('destroying frame loop in', document);
      this.stop();
      if (this.source) {
        this.source.destroy();
        this.source = null;
      }
    });
    debug('FrameLoop constructed in', document);
    this._running = false;
  }
}
exports["default"] = FrameLoop;

/***/ }),

/***/ 16999:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _src = __webpack_require__(62343);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.H264Encoder');
var _delegate = /*#__PURE__*/new WeakMap();
var _media = /*#__PURE__*/new WeakMap();
var _demuxer = /*#__PURE__*/new WeakMap();
var _sinceLastKeyframe = /*#__PURE__*/new WeakMap();
class H264Encoder {
  constructor(media, delegate) {
    // delegate to handle fraems and provide some parameters (e.g. scale)
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    // media stream track
    _classPrivateFieldInitSpec(this, _media, void 0);
    // we demux web to extract the h264 stream
    _classPrivateFieldInitSpec(this, _demuxer, void 0);
    // we cache all the h264 data since the last keyframe, then when we get
    // a sync (reset) request we can immediately send keyframe data and any
    // subsequent updates
    _classPrivateFieldInitSpec(this, _sinceLastKeyframe, []);
    _defineProperty(this, "reset", () => {
      debug('resetting H264Encoder');
      // we need to force a new keyframe
      _classPrivateFieldGet(_sinceLastKeyframe, this).forEach(data => {
        _classPrivateFieldGet(_delegate, this).handleFrame(data, H264Encoder.MIME_TYPE, Infinity);
      });
    });
    _defineProperty(this, "destroy", () => {
      debug('destroy H264Encoder');
      if (_classPrivateFieldGet(_demuxer, this)) {
        _classPrivateFieldGet(_demuxer, this).stop();
        _classPrivateFieldSet(_demuxer, this, null);
      }
      _classPrivateFieldSet(_sinceLastKeyframe, this, null);
    });
    debug('H264Encoder constructed');
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_media, this, media);
    _classPrivateFieldSet(_demuxer, this, (0, _src.createMediaRecorderDemuxer)(media));
    if (!_classPrivateFieldGet(_demuxer, this)) throw new Error('Failed to create MediaRecorderDemuxer');
    _classPrivateFieldGet(_demuxer, this).on('media-packet', _ref => {
      let {
        data
      } = _ref;
      if (_classPrivateFieldGet(_demuxer, this) === null) return;

      // we need to remeber all the video data sent since the previous keyframe, so that
      // when a new client joins, we don't have to wait an unknown amount of time until
      // the browser decides to give us a new one
      let details;
      // look for H264 block delimeter, either 0 0 0 1 or 0 0 0 1
      if (data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 1) {
        details = data[4];
      } else if (data[0] === 0 && data[1] === 0 && data[2] === 1) {
        details = data[3];
      }
      // Look for keyframe NALs and reset the buffer each time we see one
      const nalType = details & 0x1f;
      if (nalType === 7) _classPrivateFieldSet(_sinceLastKeyframe, this, []);
      _classPrivateFieldGet(_sinceLastKeyframe, this).push(data);
      _classPrivateFieldGet(_delegate, this).handleFrame(data, H264Encoder.MIME_TYPE, Infinity);
    });
    return _classPrivateFieldGet(_demuxer, this).start();
  }
  static isSupported() {
    return _src.MediaRecorderDemuxer.isSupported('video/webm;codecs=h264');
  }
}
exports["default"] = H264Encoder;
_defineProperty(H264Encoder, "MIME_TYPE", 'video/avc');

/***/ }),

/***/ 77601:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
__webpack_require__(62953);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.JPEGEncoder');
var _video = /*#__PURE__*/new WeakMap();
var _canvas = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _emitUpdate = /*#__PURE__*/new WeakMap();
class JPEGEncoder {
  constructor(media, delegate) {
    // the video showing the media stream track, used for rendering to a canvas
    _classPrivateFieldInitSpec(this, _video, void 0);
    // the canvas we're drawing to, passed as an output to the delegate
    _classPrivateFieldInitSpec(this, _canvas, void 0);
    // delegate to handle fraems and provide some parameters (e.g. scale)
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    // frame rate interval
    _classPrivateFieldInitSpec(this, _interval, void 0);
    _classPrivateFieldInitSpec(this, _emitUpdate, () => {
      if (!_classPrivateFieldGet(_delegate, this)) return;
      const scale = _classPrivateFieldGet(_delegate, this).scale();
      // scale and video size can change dynamically, so make sure
      // the canvas reflects the latest parameters
      _classPrivateFieldGet(_canvas, this).width = _classPrivateFieldGet(_video, this).videoWidth * scale;
      _classPrivateFieldGet(_canvas, this).height = _classPrivateFieldGet(_video, this).videoHeight * scale;
      // draw the latest video frame to fill the current canvas size
      const ctx = _classPrivateFieldGet(_canvas, this).getContext('2d');
      ctx.drawImage(_classPrivateFieldGet(_video, this), 0, 0, _classPrivateFieldGet(_canvas, this).width, _classPrivateFieldGet(_canvas, this).height);

      // encode to JPEG and send to delegate
      _classPrivateFieldGet(_canvas, this).toBlob(async blob => {
        // check if encoder was destroyed while waiting for canvas
        if (!_classPrivateFieldGet(_delegate, this)) return;
        const data = new Uint8Array(await new Response(blob).arrayBuffer());
        _classPrivateFieldGet(_delegate, this).handleFrame(data, JPEGEncoder.MIME_TYPE, 1);
      }, JPEGEncoder.MIME_TYPE, 0.5);
    });
    _defineProperty(this, "reset", () => {
      // noop, just wait for next frame loop
    });
    _defineProperty(this, "destroy", () => {
      debug('destroy JPEGEncoder');
      if (_classPrivateFieldGet(_interval, this)) {
        clearInterval(_classPrivateFieldGet(_interval, this));
        _classPrivateFieldSet(_interval, this, null);
      }
      _classPrivateFieldSet(_delegate, this, null);
      _classPrivateFieldSet(_video, this, null);
      _classPrivateFieldSet(_canvas, this, null);
    });
    debug('JPEGEncoder constructed');
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_video, this, document.createElement('video'));
    _classPrivateFieldSet(_canvas, this, document.createElement('canvas'));

    // feed into a video element so we can render it to a canvas
    _classPrivateFieldGet(_video, this).srcObject = media;
    _classPrivateFieldGet(_video, this).play();

    // start frame loop
    _classPrivateFieldSet(_interval, this, setInterval(_classPrivateFieldGet(_emitUpdate, this), 100));
  }
}
exports["default"] = JPEGEncoder;
_defineProperty(JPEGEncoder, "MIME_TYPE", 'image/jpeg');

/***/ }),

/***/ 94911:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _H264Encoder = _interopRequireDefault(__webpack_require__(16999));
var _JPEGEncoder = _interopRequireDefault(__webpack_require__(77601));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _toSetter(t, e, n) { e || (e = []); var r = e.length++; return Object.defineProperty({}, "_", { set: function (o) { e[r] = o, t.apply(n, e); } }); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.MediaStreamFrameSource');
var _track = /*#__PURE__*/new WeakMap();
var _media = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _encoder = /*#__PURE__*/new WeakMap();
var _allowedCodecs = /*#__PURE__*/new WeakMap();
var _pickEncoderClass = /*#__PURE__*/new WeakMap();
var _setupEncoder = /*#__PURE__*/new WeakMap();
class MediaStreamFrameSource {
  constructor(delegate) {
    // media stream track
    _classPrivateFieldInitSpec(this, _track, void 0);
    // media object from the browser
    _classPrivateFieldInitSpec(this, _media, void 0);
    // delegate to handle fraems and provide some parameters (e.g. scale)
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _encoder, null);
    _classPrivateFieldInitSpec(this, _allowedCodecs, []);
    _classPrivateFieldInitSpec(this, _pickEncoderClass, () => {
      const h264allowed = !_classPrivateFieldGet(_allowedCodecs, this).length || _classPrivateFieldGet(_allowedCodecs, this).includes(_H264Encoder.default.MIME_TYPE);
      if (h264allowed && _H264Encoder.default.isSupported()) return _H264Encoder.default;else return _JPEGEncoder.default;
    });
    _classPrivateFieldInitSpec(this, _setupEncoder, async media => {
      const Encoder = _classPrivateFieldGet(_pickEncoderClass, this).call(this);
      if (!(_classPrivateFieldGet(_encoder, this) instanceof Encoder)) {
        var _classPrivateFieldGet2;
        debug('Changing encoder to', Encoder);
        (_classPrivateFieldGet2 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.destroy();
        _classPrivateFieldSet(_encoder, this, new Encoder(media, _classPrivateFieldGet(_delegate, this)));
      }
      return _classPrivateFieldGet(_encoder, this);
    });
    _defineProperty(this, "setCodecs", codecs => {
      _classPrivateFieldSet(_allowedCodecs, this, codecs || []);
      if (_classPrivateFieldGet(_media, this)) _classPrivateFieldGet(_setupEncoder, this).call(this, _classPrivateFieldGet(_media, this));
    });
    _defineProperty(this, "capturingWillStart", async () => {
      debug('capturingWillStart for MediaStreamFrameSource');

      // we need to show a prompt before requesting the display media as
      // some browsers need the display media to be triggered by a user action
      const result = await _classPrivateFieldGet(_delegate, this).requestPermission();
      if (!result) return;
      try {
        if (result instanceof MediaStream) {
          _classPrivateFieldSet(_media, this, result);
        } else {
          // start the media stream from the browser
          _classPrivateFieldSet(_media, this, await navigator.mediaDevices.getDisplayMedia({
            video: {
              cursor: 'always',
              width: {
                ideal: 1400
              },
              height: {
                ideal: 1000
              },
              frameRate: {
                max: 10
              }
            },
            audio: false,
            // encourage the browser to include the current tab in the list of tabs they can share
            selfBrowserSurface: 'include'
          }));
        }

        // handle track ending (e.g. user presses browser end stream button)
        [_toSetter(_classPrivateFieldSet, [_track, this])._] = _classPrivateFieldGet(_media, this).getVideoTracks();
        if (!_classPrivateFieldGet(_track, this)) throw new Error('failed to get display media track');
        _classPrivateFieldGet(_track, this).onended = () => {
          debug('track ended');
          _classPrivateFieldSet(_track, this, null);
          _classPrivateFieldGet(_delegate, this).captureEnded();
          this.destroy();
        };
        _classPrivateFieldGet(_setupEncoder, this).call(this, _classPrivateFieldGet(_media, this));
        _classPrivateFieldGet(_delegate, this).captureStarted(_classPrivateFieldGet(_media, this));
      } catch (e) {
        _classPrivateFieldGet(_delegate, this).captureEnded(e);
      }
    });
    _defineProperty(this, "capturingWillStop", () => {
      var _classPrivateFieldGet3;
      debug('capturingWillStop for MediaStreamFrameSource');
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.destroy();
      _classPrivateFieldSet(_encoder, this, null);
      _classPrivateFieldSet(_media, this, null);
      if (_classPrivateFieldGet(_track, this)) {
        _classPrivateFieldGet(_track, this).stop();
        _classPrivateFieldSet(_track, this, null);
        _classPrivateFieldGet(_delegate, this).captureEnded();
      }
    });
    _defineProperty(this, "reset", () => {
      var _classPrivateFieldGet4;
      debug('resetting MediaStreamFrameSource');
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.reset();
    });
    _defineProperty(this, "destroy", () => {
      var _classPrivateFieldGet5;
      debug('destroying MediaStreamFrameSource');
      this.capturingWillStop();
      _classPrivateFieldSet(_delegate, this, null);
      (_classPrivateFieldGet5 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.destroy();
      _classPrivateFieldSet(_encoder, this, null);
    });
    debug('MediaStreamFrameSource constructed');
    _classPrivateFieldSet(_delegate, this, delegate);
  }
}
exports["default"] = MediaStreamFrameSource;

/***/ }),

/***/ 8647:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "DOMFrameSource", ({
  enumerable: true,
  get: function () {
    return _DOMFrameSource.default;
  }
}));
Object.defineProperty(exports, "FrameLoop", ({
  enumerable: true,
  get: function () {
    return _FrameLoop.default;
  }
}));
Object.defineProperty(exports, "MediaStreamFrameSource", ({
  enumerable: true,
  get: function () {
    return _MediaStreamFrameSource.default;
  }
}));
var _FrameLoop = _interopRequireDefault(__webpack_require__(42668));
var _DOMFrameSource = _interopRequireDefault(__webpack_require__(53071));
var _MediaStreamFrameSource = _interopRequireDefault(__webpack_require__(94911));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 1149:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IFrameContext = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _navigation2 = __webpack_require__(49715);
var _pdf = __webpack_require__(11065);
var _universal = __webpack_require__(91834);
var _XDocHandler = _interopRequireDefault(__webpack_require__(6900));
var _redaction = __webpack_require__(16566);
var _frames = __webpack_require__(8647);
var _protected = _interopRequireDefault(__webpack_require__(37609));
var _Navigation = __webpack_require__(44661);
var _UniversalHooks = _interopRequireDefault(__webpack_require__(11191));
var _documents = __webpack_require__(89689);
var _DocumentObserver = _interopRequireDefault(__webpack_require__(64033));
var _InteractionTracking = _interopRequireDefault(__webpack_require__(56913));
var _WindowTaps = _interopRequireDefault(__webpack_require__(44153));
var _NodeContent = __webpack_require__(49931);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _session = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _sendEventToParent = /*#__PURE__*/new WeakMap();
var _frameLoop = /*#__PURE__*/new WeakMap();
var _documentCollection = /*#__PURE__*/new WeakMap();
var _documentObserver = /*#__PURE__*/new WeakMap();
var _navigation = /*#__PURE__*/new WeakMap();
var _shouldNavigate = /*#__PURE__*/new WeakMap();
var _iframeNavigate = /*#__PURE__*/new WeakMap();
var _universalNavigate = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _startFrameLoop = /*#__PURE__*/new WeakMap();
var _stopFrameLoop = /*#__PURE__*/new WeakMap();
var _onNavigate = /*#__PURE__*/new WeakMap();
var _updateRedaction = /*#__PURE__*/new WeakMap();
var _onClick = /*#__PURE__*/new WeakMap();
var _onChange = /*#__PURE__*/new WeakMap();
class IFrameContext {
  constructor(_session2, delegate, sendEventToParent) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _sendEventToParent, void 0);
    _classPrivateFieldInitSpec(this, _frameLoop, void 0);
    _classPrivateFieldInitSpec(this, _documentCollection, void 0);
    _classPrivateFieldInitSpec(this, _documentObserver, void 0);
    _classPrivateFieldInitSpec(this, _navigation, void 0);
    _classPrivateFieldInitSpec(this, _shouldNavigate, type => {
      var _classPrivateFieldGet2;
      if (!((_classPrivateFieldGet2 = _classPrivateFieldGet(_session, this)) !== null && _classPrivateFieldGet2 !== void 0 && _classPrivateFieldGet2.isActive())) return false;
      // when an xdoc iframe is not trusted by its parent it only receives
      // a sanitised session which does not include a proxyToken
      if (!_classPrivateFieldGet(_session, this)[_protected.default].proxyToken()) return false;
      return true;
    });
    _defineProperty(this, "handleNavigation", (url, target, windowFeatures, options) => {
      const {
        name,
        go,
        e,
        type,
        block
      } = options;
      const {
        handle,
        document
      } = _classPrivateFieldGet(_documentCollection, this).resolveDocument(options.handle, name);
      const {
        windowProxy
      } = document;
      const currentWindow = e.view || window;
      const inNestedIFrame = currentWindow !== window;
      const isTargetSelf = !target || target === '_self';
      const nav = {
        block: () => {
          if (e.eventPhase === Event.CAPTURING_PHASE) return {
            windowProxy
          };
          block();
          if (!inNestedIFrame) _classPrivateFieldGet(_documentObserver, this).sendBlocked(url);
          return {
            windowProxy
          };
        },
        parent: overrideType => {
          document.load(url, target, windowFeatures, {
            type: overrideType || type
          });
          if (e.eventPhase === Event.CAPTURING_PHASE) return {
            windowProxy
          };
          _classPrivateFieldGet(_documentCollection, this).addDocument(handle, name, document);
          _classPrivateFieldGet(_delegate, this).open(url, target, windowFeatures, {
            type: overrideType || type,
            handle
          });
          return {
            windowProxy
          };
        },
        continue: () => {
          const handlerResult = _classPrivateFieldGet(_navigation, this).runHandler(url, target, windowFeatures, {
            type,
            document
          });
          if (handlerResult.rewrittenUrl) return {
            rewrittenUrl: handlerResult.rewrittenUrl
          };
          if (handlerResult.document) _classPrivateFieldGet(_documentCollection, this).addDocument(handle, name, handlerResult.document);
          return {
            windowProxy
          };
        },
        replay: () => go()
      };
      const dependencies = {
        url,
        target,
        windowFeatures,
        type,
        nav,
        getConsent: () => _classPrivateFieldGet(_delegate, this).confirmOpen(url, type),
        windowProxy,
        setLoading: () => !inNestedIFrame && isTargetSelf && _classPrivateFieldGet(_documentObserver, this).sendLoading(url)
      };
      const navigate = _UniversalHooks.default.inUniversalProxy ? _classPrivateFieldGet(_universalNavigate, this) : _classPrivateFieldGet(_iframeNavigate, this);
      return navigate(dependencies);
    });
    _classPrivateFieldInitSpec(this, _iframeNavigate, _ref => {
      let {
        target,
        type,
        nav,
        getConsent,
        windowProxy
      } = _ref;
      if (!type) return nav.continue();

      // XDoc navigations don't require consent
      if (type === _Navigation.NAVIGATION_TYPE.XDOC) return nav.continue();

      // prevent sending the confirmation if we can't navigate
      if (!_classPrivateFieldGet(_shouldNavigate, this).call(this, type)) return nav.continue();
      getConsent().then(_ref2 => {
        let {
          accepted
        } = _ref2;
        if (!accepted) return nav.replay();
        if (target === '_blank') return nav.parent();
        nav.continue();
      });
      return {
        windowProxy
      };
    });
    _classPrivateFieldInitSpec(this, _universalNavigate, _ref3 => {
      let {
        url,
        target,
        type,
        nav,
        getConsent,
        windowProxy,
        setLoading
      } = _ref3;
      const currentOrigin = new URL(_UniversalHooks.default.unproxify(window.location.href)).origin;
      const requiresConsent = currentOrigin !== new URL(url, currentOrigin).origin;
      if (!type) {
        // we rely on the Universal Handler in the parent to block
        if (target === '_blank') return nav.parent(_Navigation.NAVIGATION_TYPE.UNIVERSAL);
        return nav.block();
      }
      if (!requiresConsent) {
        if (target === '_blank') return nav.parent();
        if (type === _Navigation.NAVIGATION_TYPE.PDF) return nav.continue();
        setLoading();
        return {
          rewrittenUrl: url
        };
      }

      // prevent sending the confirmation if we can't navigate
      if (!_classPrivateFieldGet(_shouldNavigate, this).call(this, type)) return nav.continue();
      getConsent().then(_ref4 => {
        let {
          accepted
        } = _ref4;
        if (!accepted) return nav.block();
        if (target === '_blank') return nav.parent();
        if (type === _Navigation.NAVIGATION_TYPE.PDF) return nav.continue();
        setLoading();
        nav.replay();
      });
      return {
        windowProxy
      };
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, session => {
      _classPrivateFieldGet(_updateRedaction, this).call(this, session);
      if (session.isActive() && !_classPrivateFieldGet(_frameLoop, this)) _classPrivateFieldGet(_startFrameLoop, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, () => {
      _classPrivateFieldGet(_stopFrameLoop, this).call(this);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).closeAllDocuments();
    });
    _classPrivateFieldInitSpec(this, _startFrameLoop, () => {
      var _classPrivateFieldGet3;
      if ((_classPrivateFieldGet3 = _classPrivateFieldGet(_frameLoop, this)) !== null && _classPrivateFieldGet3 !== void 0 && _classPrivateFieldGet3.isRunning()) return;
      _classPrivateFieldSet(_frameLoop, this, new _frames.FrameLoop());
      _classPrivateFieldGet(_frameLoop, this).setSource(new _frames.DOMFrameSource(patch => {
        _classPrivateFieldGet(_sendEventToParent, this).call(this, 'patch', patch);
        return true;
      }));
      _classPrivateFieldGet(_frameLoop, this).start();
      _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _classPrivateFieldInitSpec(this, _stopFrameLoop, () => {
      if (_classPrivateFieldGet(_frameLoop, this)) _classPrivateFieldGet(_frameLoop, this).destroy();
      _classPrivateFieldSet(_frameLoop, this, null);
    });
    _classPrivateFieldInitSpec(this, _onNavigate, (_window, previousUrl) => {
      _classPrivateFieldGet(_updateRedaction, this).call(this, _classPrivateFieldGet(_session, this));

      // avoid an expensive operation if there are no changes in redaction selectors
      if (_redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_delegate, this).redactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_delegate, this).unredactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_session, this).redactionSelectors(), previousUrl) || _redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_session, this).unredactionSelectors(), previousUrl)) {
        // this is triggered from a synchronous event, we use a setTimeout to
        // ensure that any DOM mutations that occurred before the event are
        // first recorded in the async callback of the mutation observer
        setTimeout(() => {
          this.invalidateFrame();
        }, 0);
      }
    });
    _defineProperty(this, "invalidateFrame", () => {
      var _classPrivateFieldGet4;
      if ((_classPrivateFieldGet4 = _classPrivateFieldGet(_frameLoop, this)) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.isRunning()) _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _defineProperty(this, "partialSync", async nodeId => {
      var _classPrivateFieldGet5;
      if (!((_classPrivateFieldGet5 = _classPrivateFieldGet(_frameLoop, this)) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isRunning())) return;
      const current = _classPrivateFieldGet(_frameLoop, this).getSource();
      if (!(current instanceof _frames.DOMFrameSource)) return;
      await (0, _NodeContent.applyContentCache)(nodeId);
      current.partialSync(nodeId);
    });
    _classPrivateFieldInitSpec(this, _updateRedaction, session => {
      _redaction.RedactionIndexProvider.instance = new _redaction.RedactionIndex(_redaction.TargetedRedaction.filterSelectors(_classPrivateFieldGet(_delegate, this).redactedViews), _redaction.TargetedRedaction.filterSelectors(_classPrivateFieldGet(_delegate, this).unredactedViews), _redaction.TargetedRedaction.filterSelectors(session.redactionSelectors()), _redaction.TargetedRedaction.filterSelectors(session.unredactionSelectors()));
    });
    _classPrivateFieldInitSpec(this, _onClick, target => _classPrivateFieldGet(_sendEventToParent, this).call(this, 'click', target));
    _classPrivateFieldInitSpec(this, _onChange, target => _classPrivateFieldGet(_sendEventToParent, this).call(this, 'change', target));
    _defineProperty(this, "destroy", () => {
      if (_classPrivateFieldGet(_session, this)) {
        _classPrivateFieldGet(_session, this).removeListener('update', _classPrivateFieldGet(_onSessionUpdated, this));
        _classPrivateFieldGet(_session, this).removeListener('ended', _classPrivateFieldGet(_onSessionEnded, this));
      }
      _classPrivateFieldSet(_session, this, null);
      if (_classPrivateFieldGet(_navigation, this)) _classPrivateFieldGet(_navigation, this).destroy();
      _classPrivateFieldSet(_navigation, this, null);
      _WindowTaps.default.off('navigate', _classPrivateFieldGet(_onNavigate, this));
      _InteractionTracking.default.off('click', _classPrivateFieldGet(_onClick, this));
      _InteractionTracking.default.off('change', _classPrivateFieldGet(_onChange, this));
      if (_classPrivateFieldGet(_documentObserver, this)) _classPrivateFieldGet(_documentObserver, this).destroy();
      _classPrivateFieldSet(_documentObserver, this, null);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).destroy();
      _classPrivateFieldSet(_documentCollection, this, null);
    });
    _classPrivateFieldSet(_session, this, _session2);
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_sendEventToParent, this, sendEventToParent);
    _classPrivateFieldGet(_onSessionUpdated, this).call(this, _session2);
    _session2.on('updated', _classPrivateFieldGet(_onSessionUpdated, this));
    _session2.on('ended', _classPrivateFieldGet(_onSessionEnded, this));
    if (_UniversalHooks.default.inUniversalProxy) {
      _classPrivateFieldSet(_documentObserver, this, new _DocumentObserver.default(document => _classPrivateFieldGet(_sendEventToParent, this).call(this, 'document', {
        document
      })));
    }
    _classPrivateFieldSet(_documentCollection, this, new _documents.DocumentCollection({
      onDocumentAdded: document => {
        if (document.element) _classPrivateFieldGet(_delegate, this).showDocument(document);
      }
    }));
    const pdfHandler = new _pdf.PDFHandler(_session2, delegate);
    const universalHandler = new _universal.UniversalHandler(_session2, delegate);
    const xdocHandler = new _XDocHandler.default(_session2, delegate);
    _classPrivateFieldSet(_navigation, this, new _navigation2.Navigation({
      shouldNavigate: _classPrivateFieldGet(_shouldNavigate, this),
      handlers: [pdfHandler, universalHandler, xdocHandler],
      handleNavigation: this.handleNavigation
    }));
    _WindowTaps.default.on('navigate', _classPrivateFieldGet(_onNavigate, this));
    _InteractionTracking.default.on('click', _classPrivateFieldGet(_onClick, this));
    _InteractionTracking.default.on('change', _classPrivateFieldGet(_onChange, this));
  }
  navigate(url, target, _ref5) {
    let {
      type
    } = _ref5;
    const result = _classPrivateFieldGet(_navigation, this).navigate(url, target, {
      type
    });
    if (typeof result === 'string') return window.open(result, target);
  }
}
exports.IFrameContext = IFrameContext;

/***/ }),

/***/ 20342:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
__webpack_require__(62953);
var _activity = __webpack_require__(45264);
var _remotecontrol = __webpack_require__(83672);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.iframes.control');
function configure(bridge) {
  bridge.on('sync', (_, _ref) => {
    let {
      trusted
    } = _ref;
    if (!trusted) return debug('Ignoring untrusted sync event');
    _activity.MouseTracking.onChange = state => bridge.sendToParent('mouse', state);
    _activity.MouseTracking.track(window);
  });

  // Mouse events will also be sent up from cross document iframes as
  // the parent page is not allowed events obscured by xdoc iframes.
  bridge.on('mouse', (mouse, _ref2) => {
    let {
      iframe
    } = _ref2;
    debug('Received mouse event in', mouse, document, 'from', iframe);
    // if the message didn't come from an iframe in the page
    // then we should ignore it
    if (!iframe) return;
    _activity.MouseTracking.setPosition(mouse.x, mouse.y, iframe);
    _activity.MouseTracking.setDown(mouse.down);
  });

  // Control events will be sent down from the parent page and should
  // be applied by the iframe that contains the relevant DOM nodes
  bridge.on('control', (control, _ref3) => {
    let {
      trusted,
      trustedOnly
    } = _ref3;
    debug('Received control event in', document);
    if (!trusted) return debug('Ignoring untrusted control event');else _remotecontrol.ControlEvents.applyEvent(...control);

    // Forward control events down into child iframes
    bridge.broadcastToChildren('control', control, {
      trustedOnly
    });
  });
}

/***/ }),

/***/ 73350:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _protected = _interopRequireDefault(__webpack_require__(37609));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.iframes.sessions');
function configure(bridge, delegate) {
  function publish(session) {
    const serializedSanitizedSession = session[_protected.default].serializeSanitized();
    bridge.broadcastToChildren('session', serializedSanitizedSession, {
      trustedOnly: false
    });
    // if we have the full session we need to send it out to trusted
    // children only
    if (session.id()) {
      const serializedSession = session[_protected.default].serialize();
      bridge.broadcastToChildren('session', serializedSession, {
        trustedOnly: true
      });
    }
  }

  // When we know if we can trust an iframe or not, we can then share the
  // session state. Untrusted iframes get a sanitized version of the session.
  function onTrust(_, _ref) {
    let {
      iframe,
      trusted
    } = _ref;
    if (!iframe) return;
    const currentSession = delegate.currentSession;

    // xdoc iframes which haven't established a trusted relationship
    // will receive a sanitized variant of the session
    if (currentSession) {
      const serializedSession = trusted ? currentSession[_protected.default].serialize() : currentSession[_protected.default].serializeSanitized();
      bridge.send(iframe.contentWindow, 'session', serializedSession, {
        trustedOnly: trusted
      });
    }
  }
  bridge.on('trust', onTrust);

  // Session events are sent down from the parent page. Untrusted
  // xdoc iframes will receive a sanitized variant of the session
  function onSession(serializedSession, _ref2) {
    let {
      trusted,
      fromParent
    } = _ref2;
    if (!trusted) return debug('Ignoring untrusted session event');
    if (!fromParent) return;
    // we'll update the currentSession in place which will trigger a session
    // update event
    delegate.currentSession[_protected.default].deserialize(serializedSession);

    // we can then re-publish the event to our children so they're updated too
    publish(delegate.currentSession);
  }
  bridge.on('session', onSession);
  return {
    publish,
    unsubscribe: () => {
      bridge.off('trust', onTrust);
      bridge.off('session', onSession);
    }
  };
}

/***/ }),

/***/ 78232:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
__webpack_require__(62953);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _Deferred = __webpack_require__(63976);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.iframes.sync');
function configure(bridge, delegate) {
  let {
    waitForParentSync
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let syncDataReceived = waitForParentSync ? new _Deferred.Deferred() : true;
  let syncData;
  function config(data) {
    return {
      redactedViews: [...((data === null || data === void 0 ? void 0 : data.redactedViews) || []), ...(delegate.redactedViews || [])],
      unredactedViews: [...((data === null || data === void 0 ? void 0 : data.unredactedViews) || []), ...(delegate.unredactedViews || [])],
      universalLinks: (data === null || data === void 0 ? void 0 : data.universalLinks) || delegate.universalLinks || [],
      pdfLinks: (data === null || data === void 0 ? void 0 : data.pdfLinks) || delegate.pdfLinks || [],
      api: (data === null || data === void 0 ? void 0 : data.api) || delegate.api
    };
  }
  function configForSync(data) {
    const cfg = config(data);
    return _objectSpread(_objectSpread({}, cfg), {}, {
      // string selectors are only applied to the current domain
      redactedViews: cfg.redactedViews.filter(selector => typeof selector !== 'string'),
      unredactedViews: cfg.unredactedViews.filter(selector => typeof selector !== 'string')
    });
  }

  // Init events are sent up from the xdoc iframe
  // if we get an init message from an iframe we're tracking,
  // then we probably need to force a sync as the snippet was possibly
  // loaded in a delayed fashion in the iframe
  async function onInit(_, _ref) {
    let {
      iframe
    } = _ref;
    if (!iframe) return;

    // child iframes can publish init messages before the parent
    // iframe has recieved a sync form it's parent. We need to wait
    // until the sync event from the parent has completed before
    // we can send any sync events to our children
    await syncDataReceived.promise;

    // note: for top level frames the syncData will be undefined, config
    // will be read directly from the main delegate.
    bridge.send(iframe.contentWindow, 'sync', configForSync(syncData), {
      trustedOnly: false
    });
  }
  bridge.on('init', onInit);

  // Discovery events will be sent from the bridge when the track()
  // method is invoked, either from the observer or init event
  function onIframeDiscovered(iframe) {
    debug('iframe available', iframe, 'issuing sync');
    if (iframe) onInit(null, {
      iframe
    });
  }
  bridge.on('iframe_discovered', onIframeDiscovered);

  // Sync events will be sent from the parent page to setup config data
  function onSync(data, _ref2) {
    let {
      source,
      origin,
      trusted
    } = _ref2;
    if (!trusted) return debug('Ignoring untrusted sync event');

    // store the sync data for forwarding to child iframes on discovery
    syncData = data;
    syncDataReceived.resolve();

    // forward sync event to all children
    bridge.broadcastToChildren('sync', configForSync(data), {
      trustedOnly: false
    });
  }
  bridge.on('sync', onSync);
  return {
    getSyncedConfig: async () => {
      await syncDataReceived.promise;
      return config(syncData);
    },
    unsubscribe: () => {
      syncData = null;
      syncDataReceived = waitForParentSync ? new _Deferred.Deferred() : true;
      bridge.off('init', onInit);
      bridge.off('iframe_discovered', onIframeDiscovered);
      bridge.off('sync', onSync);
    },
    sendSync: async () => {
      await syncDataReceived.promise;
      bridge.broadcastToChildren('sync', configForSync(syncData), {
        trustedOnly: false
      });
    }
  };
}

/***/ }),

/***/ 38109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.iframes.trust');
function configure(bridge) {
  // Child iframes will response to sync events with a trust event, this allows
  // the parent to know the child frames origin and determine whether it is
  // trusted ro not.
  bridge.on('sync', (_, _ref) => {
    let {
      trusted
    } = _ref;
    if (!trusted) return debug('Ignoring untrusted sync event');
    // send trust state immediately
    bridge.sendToParent('trust', null, {
      trustedOnly: false
    });
    // but also send it again after the page is fully loaded
    // as the iframe load event in our parent that breaks the
    // trust only triggers on fully loaded pages
    if (document.readyState !== 'complete') {
      window.addEventListener('load', () => {
        bridge.sendToParent('trust', null, {
          trustedOnly: false
        });
      }, {
        once: true,
        capture: true
      });
    }
  });

  // if a child iframe navigates we need to stop trusting it
  // until it re-reports it's origin via a new trust event
  const breakTrustRelationship = _ref2 => {
    let {
      target
    } = _ref2;
    bridge.breakTrust(target.contentWindow);
  };

  // Trust events are sent up from the xdoc iframe after
  // it receives a sync event. Trust events are used to attempt to
  // associate a particular iframe to an origin which we trust
  bridge.on('trust', (_, _ref3) => {
    let {
      iframe,
      origin
    } = _ref3;
    if (!iframe) return;

    // each time an iframe loads we must remove the trusted
    // origin and wait for a new trust event from the iframe
    iframe.removeEventListener('load', breakTrustRelationship, {
      capture: true
    });
    iframe.addEventListener('load', breakTrustRelationship, {
      capture: true
    });

    // this marks an iframe as trusted, so when we need to broadcast
    // messages only to trusted iframes we can determine the list easily
    bridge.establishTrust(iframe.contentWindow, origin);
  });
}

/***/ }),

/***/ 77966:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.initIframeBridgeAsChild = initIframeBridgeAsChild;
exports.initIframeBridgeAsParent = initIframeBridgeAsParent;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _cocom = __webpack_require__(63439);
var _IFrameContext = __webpack_require__(1149);
var _Session = _interopRequireDefault(__webpack_require__(52404));
var trust = _interopRequireWildcard(__webpack_require__(38109));
var control = _interopRequireWildcard(__webpack_require__(20342));
var sessions = _interopRequireWildcard(__webpack_require__(73350));
var sync = _interopRequireWildcard(__webpack_require__(78232));
var _protected = _interopRequireDefault(__webpack_require__(37609));
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _Highlight = _interopRequireDefault(__webpack_require__(76575));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.iframes');
const parent = (0, _cocom.closestXdocParent)();
const bridge = new _cocom.IFrameBridge(parent);

// common modules with no config differences for parent vs child usage
const rpc = new _cocom.IFrameRPC(bridge, parent);
trust.configure(bridge);
control.configure(bridge);
const trustProxy = api => session => {
  const sessionProxyUrl = session[_protected.default].proxyUrl();
  const proxyUrl = new URL(sessionProxyUrl, api);
  debug('trusting', proxyUrl.origin);
  bridge.automaticTrustedOrigins = [proxyUrl.origin];
};
function initIframeBridgeAsParent(delegate, _ref) {
  let {
    open
  } = _ref;
  // When the session in the top level parent changes we need
  // to pass this down to the child iframes.
  const sessionModule = sessions.configure(bridge, delegate);
  delegate.on('session.loaded', sessionModule.publish);
  delegate.on('session.updated', sessionModule.publish);

  // The page needs to trust the proxy origin automatically to
  // receive messages it needs to trust (e.g. rpc requests)
  const trustProxyForAPI = trustProxy(delegate.api);
  delegate.on('session.loaded', trustProxyForAPI);
  delegate.on('session.updated', trustProxyForAPI);

  // we need to pass config down to the iframes as they should
  // inherit settings from the top level page, e.g. universalLinks,
  // redaction settings etc...
  // We alos need to re-trigger a sync event if the agent side
  // re-requests the whole state of the page as we need the xdoc
  // iframes to re-serialise themselves
  const syncModule = sync.configure(bridge, delegate);
  delegate.on('session.sync', syncModule.sendSync);

  // The top level page is responsible for handling various RPC
  // calls like navigation confirmations and opening new tabs
  const onConfirmOpen = async _ref2 => {
    let {
      url,
      type
    } = _ref2;
    return {
      accepted: await delegate.confirmOpen(url, type)
    };
  };
  rpc.on('confirmOpen', onConfirmOpen);
  const onOpen = _ref3 => {
    let {
      url,
      target,
      windowFeatures,
      options
    } = _ref3;
    open(url, target, windowFeatures, options);
  };
  rpc.on('open', onOpen);
  bridge.start();
  return () => {
    sessionModule.unsubscribe();
    syncModule.unsubscribe();
    delegate.off('session.loaded', sessionModule.publish);
    delegate.off('session.updated', sessionModule.publish);
    delegate.off('session.loaded', trustProxyForAPI);
    delegate.off('session.updated', trustProxyForAPI);
    delegate.off('session.sync', syncModule.sendSync);
    rpc.off('confirmOpen', onConfirmOpen);
    rpc.off('open', onOpen);
  };
}
async function initIframeBridgeAsChild(delegate) {
  // create a placeholder session object for iframe contexts
  // as we wont have access to the "real" session object, that
  // lives in the root
  const currentSession = new _Session.default(delegate);
  const sessionModule = sessions.configure(bridge, {
    currentSession
  });

  // setup sync logic for passing config and content requests
  // down to child frames
  const syncModule = sync.configure(bridge, delegate, {
    waitForParentSync: true
  });
  bridge.start();

  // Get the config that is a merge of the iframes delegate config
  // and the ocnfig that is sent via postMessage. We might need to
  // wait for the sync event, hence getSyncedConfig() is async
  const config = await syncModule.getSyncedConfig();
  debug('synced config', config);
  let iframeContext;
  const updateContext = () => {
    // create a new context each time a new session starts
    if (currentSession.isActive() && !iframeContext) {
      debug('creating iframe context', iframeContext);
      trustProxy(config.api)(currentSession);
      iframeContext = new _IFrameContext.IFrameContext(currentSession, _objectSpread(_objectSpread({}, config), {}, {
        trustedOrigins: delegate.trustedOrigins,
        version: delegate.version,
        showDocument: delegate.showDocument,
        confirmOpen: (url, type) => rpc.send('confirmOpen', {
          url,
          type
        }),
        open: (url, target, windowFeatures, options) => rpc.send('open', {
          url,
          target,
          windowFeatures,
          options
        })
      }), bridge.sendToParent);

      // when the session ends we shoudl destroy the context so we're
      // in a clean state for the next session
      currentSession.once('ended', () => {
        debug('destroying iframe context', iframeContext);
        iframeContext.destroy();
        iframeContext = null;
      });
    }
  };
  bridge.on('session', updateContext);

  // we might be in an intermediate iframe so we need to
  // forward requests and responses up and down the tree
  // as only the SDK running as parent can respond
  const forwardReq = (req, _ref4) => {
    let {
      trustedOnly
    } = _ref4;
    return bridge.sendToParent('rpc:request', req, {
      trustedOnly
    });
  };
  bridge.on('rpc:request', forwardReq);
  // responses broadcast downwards to children
  const forwardRes = (res, _ref5) => {
    let {
      trustedOnly
    } = _ref5;
    return bridge.broadcastToChildren('rpc:response', res, {
      trustedOnly
    });
  };
  bridge.on('rpc:response', forwardRes);

  // force a re-send of frame data on agent sync messages
  const invalidateFrame = () => {
    var _iframeContext;
    return (_iframeContext = iframeContext) === null || _iframeContext === void 0 ? void 0 : _iframeContext.invalidateFrame();
  };
  bridge.on('sync', invalidateFrame);

  // force a re-send of node data on load-error messages
  const onRemoteError = (data, _ref6) => {
    var _iframeContext2;
    let {
      trustedOnly
    } = _ref6;
    const {
      target,
      error: {
        cause
      }
    } = data;
    // TODO: remove backwards compatibility when frontend sends target as an object
    const nodeId = typeof target === 'string' ? target : target.id;
    if (cause === 'load-error') (_iframeContext2 = iframeContext) === null || _iframeContext2 === void 0 || _iframeContext2.partialSync(nodeId);
    bridge.broadcastToChildren('remote-error', data, {
      trustedOnly
    });
  };
  bridge.on('remote-error', onRemoteError);
  const onHighlight = async event => _Highlight.default.highlight(delegate, event);
  bridge.on('highlight', onHighlight);
  return () => {
    syncModule.unsubscribe();
    sessionModule.unsubscribe();
    bridge.off('highlight', onHighlight);
    bridge.off('remote-error', onRemoteError);
    bridge.off('sync', invalidateFrame);
    bridge.off('session', updateContext);
    bridge.off('rpc:request', forwardReq);
    bridge.off('rpc:response', forwardRes);
  };
}
var _default = exports["default"] = bridge;

/***/ }),

/***/ 77988:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(62953);
// Import all locale JSON files in the current directory
const context = __webpack_require__(56277);
const Translations = context.keys().reduce((translations, file) => {
  const lang = file.replace('./', '').replace('.json', '');
  translations[lang] = context(file);
  return translations;
}, {});
const rightToLeftLocales = ['ar', 'he', 'fa', 'ur'];
class Locale {
  static getLocale() {
    for (const l of navigator.languages) {
      if (Translations[l]) return new Locale(l);
      if (l.includes('-')) {
        const major = l.split('-')[0].toLowerCase();
        if (Translations[major]) return new Locale(major);
      }
    }
    return new Locale('en');
  }
  static tr(key) {
    return this.getLocale().translate(key);
  }
  static direction() {
    return this.getLocale().direction;
  }
  constructor(language) {
    this.language = language;
    this.direction = rightToLeftLocales.includes(language) ? 'rtl' : 'ltr';
  }
  translate(key) {
    return Translations[this.language][key] || Translations.en[key] || key;
  }
}
exports["default"] = Locale;

/***/ }),

/***/ 44661:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.NAVIGATION_TYPE = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _NavigationTracking = _interopRequireDefault(__webpack_require__(26356));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const NAVIGATION_TYPE = exports.NAVIGATION_TYPE = {
  PDF: 'pdf',
  XDOC: 'xdoc',
  UNIVERSAL: 'universal'
};
var _shouldNavigate = /*#__PURE__*/new WeakMap();
var _handlers = /*#__PURE__*/new WeakMap();
var _handleNavigation = /*#__PURE__*/new WeakMap();
var _beforeNavigate = /*#__PURE__*/new WeakMap();
var _navigateToBlockedScreen = /*#__PURE__*/new WeakMap();
class Navigation {
  constructor(delegate) {
    _classPrivateFieldInitSpec(this, _shouldNavigate, void 0);
    _classPrivateFieldInitSpec(this, _handlers, void 0);
    _classPrivateFieldInitSpec(this, _handleNavigation, void 0);
    _defineProperty(this, "findHandlerByUrl", u => {
      if (!u) return null;
      try {
        const url = new URL(u, window.location.origin);
        return _classPrivateFieldGet(_handlers, this).find(h => h.shouldHandle(url));
      } catch (err) {
        console.warn('CobrowseIO: Failed to infer navigation type', err);
        return null;
      }
    });
    _defineProperty(this, "findHandlerByType", type => _classPrivateFieldGet(_handlers, this).find(h => h.type === type));
    _classPrivateFieldInitSpec(this, _beforeNavigate, (url, target, windowFeatures, _ref) => {
      let {
        name,
        go,
        e
      } = _ref;
      const handler = this.findHandlerByUrl(url);
      if (handler && !handler.shouldHandleEvent(e)) {
        if (e.eventPhase === Event.BUBBLING_PHASE) console.warn('CobrowseIO: Inferred navigation type but event is already handled');
        return {
          rewrittenUrl: url
        };
      }
      const currentWindow = e.view || window;
      const block = () => _classPrivateFieldGet(_navigateToBlockedScreen, this).call(this, currentWindow, e);
      return _classPrivateFieldGet(_handleNavigation, this).call(this, url, target, windowFeatures, {
        name,
        go,
        e,
        type: handler === null || handler === void 0 ? void 0 : handler.type,
        block
      });
    });
    _classPrivateFieldInitSpec(this, _navigateToBlockedScreen, (currentWindow, e) => {
      if (e.eventPhase === Event.CAPTURING_PHASE) return;
      const root = currentWindow.document;
      const overlayElement = root.createElement('div');
      overlayElement.style.position = 'fixed';
      overlayElement.style.top = 0;
      overlayElement.style.left = 0;
      overlayElement.style.width = '100vw';
      overlayElement.style.height = '100vh';
      overlayElement.style.backgroundColor = 'black';
      overlayElement.style.zIndex = '2147483647';
      overlayElement.style.margin = 0;
      overlayElement.style.padding = 0;
      overlayElement.style.border = 0;
      overlayElement.style.borderRadius = 0;
      const originalOverflow = root.body.style.overflow;
      root.body.style.overflow = 'hidden';
      root.body.appendChild(overlayElement);
      const restore = () => {
        if (root.body.contains(overlayElement)) root.body.removeChild(overlayElement);
        root.body.style.overflow = originalOverflow;
        currentWindow.removeEventListener('popstate', restore);
      };
      currentWindow.addEventListener('popstate', restore);
      currentWindow.history.pushState({}, '');
    });
    _defineProperty(this, "destroy", () => {
      _NavigationTracking.default.beforeNavigate = null;
    });
    _classPrivateFieldSet(_shouldNavigate, this, delegate.shouldNavigate);
    _classPrivateFieldSet(_handlers, this, delegate.handlers);
    _classPrivateFieldSet(_handleNavigation, this, delegate.handleNavigation);
    _NavigationTracking.default.beforeNavigate = _classPrivateFieldGet(_beforeNavigate, this);
  }
  runHandler(url, target, windowFeatures, options) {
    if (!url) return {
      rewrittenUrl: url
    };
    const handler = options.type != null ? this.findHandlerByType(options.type) : this.findHandlerByUrl(url);
    if (!handler) return {
      rewrittenUrl: url
    };
    if (!_classPrivateFieldGet(_shouldNavigate, this).call(this, handler.type)) return {
      rewrittenUrl: url
    };
    return handler.handle(url, target, windowFeatures, options);
  }
}
exports["default"] = Navigation;

/***/ }),

/***/ 79301:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class NavigationHandler {
  get type() {
    throw new Error("Getter 'type' must be implemented.");
  }
  shouldHandleEvent(e) {
    throw new Error("Method 'shouldHandleEvent()' must be implemented.");
  }
  shouldHandle(url) {
    throw new Error("Method 'shouldHandle()' must be implemented.");
  }
  handle(url, target, windowFeatures, options) {
    throw new Error("Method 'handle()' must be implemented.");
  }
}
exports["default"] = NavigationHandler;

/***/ }),

/***/ 26356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _splitNameFromTarget = __webpack_require__(82117);
var _formAttributes = __webpack_require__(10000);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
class CustomViewEvent extends Event {
  constructor(type, options) {
    super(type, options);
    this._view = options.view;
  }
  get view() {
    return this._view;
  }
}
var _windows = /*#__PURE__*/new WeakMap();
var _handleClickEvent = /*#__PURE__*/new WeakMap();
var _handleSubmitEvent = /*#__PURE__*/new WeakMap();
var _handleWindowOpenTap = /*#__PURE__*/new WeakMap();
var _handleFormSubmitTap = /*#__PURE__*/new WeakMap();
class NavigationTracking {
  constructor() {
    var _this = this;
    _defineProperty(this, "beforeNavigate", void 0);
    _classPrivateFieldInitSpec(this, _windows, new Set());
    _defineProperty(this, "track", root => {
      root.addEventListener('click', _classPrivateFieldGet(_handleClickEvent, this), {
        capture: true
      });
      root.addEventListener('click', _classPrivateFieldGet(_handleClickEvent, this));
      root.addEventListener('submit', _classPrivateFieldGet(_handleSubmitEvent, this));
    });
    _defineProperty(this, "untrack", root => {
      root.removeEventListener('click', _classPrivateFieldGet(_handleClickEvent, this), {
        capture: true
      });
      root.removeEventListener('click', _classPrivateFieldGet(_handleClickEvent, this));
      root.removeEventListener('submit', _classPrivateFieldGet(_handleSubmitEvent, this));
    });
    _defineProperty(this, "tap", window => {
      if (_classPrivateFieldGet(_windows, this).has(window)) return;
      const self = this;
      const {
        open
      } = window;
      window.open = function () {
        for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
          rest[_key] = arguments[_key];
        }
        return _classPrivateFieldGet(_handleWindowOpenTap, self).call(self, this, open, ...rest);
      };
      const {
        submit
      } = window.HTMLFormElement.prototype;
      window.HTMLFormElement.prototype.submit = function () {
        for (var _len2 = arguments.length, rest = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          rest[_key2] = arguments[_key2];
        }
        return _classPrivateFieldGet(_handleFormSubmitTap, self).call(self, this, submit, ...rest);
      };
      _classPrivateFieldGet(_windows, this).add(window);
    });
    _defineProperty(this, "untap", _window => {
      // we can't safely remove the patches applied
      // to the window so we leave these in place
    });
    _classPrivateFieldInitSpec(this, _handleClickEvent, e => {
      var _e$target;
      if (!this.beforeNavigate) return;
      const anchor = e === null || e === void 0 || (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest('a');
      if (!anchor) return;
      if (!anchor.href) return;
      if (anchor.__cbio_forceDefaultNavigation) return;
      const go = () => {
        anchor.__cbio_forceDefaultNavigation = true;
        anchor.click();
        delete anchor.__cbio_forceDefaultNavigation;
      };
      const {
        target,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)(anchor.target, '_self');
      const {
        rewrittenUrl,
        windowProxy
      } = this.beforeNavigate(anchor.href, target, '', {
        name,
        go,
        e
      });

      // preserve relative or absolute URLs if they aren't rewritten
      const isRewrittenUrl = rewrittenUrl && rewrittenUrl !== anchor.href;
      if (isRewrittenUrl) anchor.href = rewrittenUrl;
      if (windowProxy) e.preventDefault();
    });
    _classPrivateFieldInitSpec(this, _handleSubmitEvent, e => {
      var _e$target2;
      if (!this.beforeNavigate) return;
      const form = e === null || e === void 0 || (_e$target2 = e.target) === null || _e$target2 === void 0 ? void 0 : _e$target2.closest('form');
      if (!form) return;
      if (!(0, _formAttributes.getFormAttribute)(form, 'action')) return;
      if (form.__cbio_forceDefaultNavigation) return;
      const go = () => {
        form.__cbio_forceDefaultNavigation = true;
        form.submit();
        delete form.__cbio_forceDefaultNavigation;
      };
      const {
        target,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)((0, _formAttributes.getFormAttribute)(form, 'target'), '_self');
      const {
        rewrittenUrl,
        windowProxy
      } = this.beforeNavigate((0, _formAttributes.getFormAttribute)(form, 'action'), target, '', {
        name,
        go,
        e
      });
      if (rewrittenUrl) (0, _formAttributes.setFormAttribute)(form, 'action', rewrittenUrl);
      if (windowProxy) e.preventDefault();
    });
    _classPrivateFieldInitSpec(this, _handleWindowOpenTap, (ctx, windowOpen, url, target, windowFeatures) => {
      if (!this.beforeNavigate) return windowOpen.call(ctx, url, target, windowFeatures);
      const go = () => windowOpen.call(ctx, url, target, windowFeatures);
      const e = new CustomViewEvent('WindowOpen', {
        view: ctx
      });
      const {
        target: newTarget,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)(target, '_blank');
      const {
        rewrittenUrl,
        windowProxy
      } = this.beforeNavigate(url, newTarget, windowFeatures, {
        name,
        go,
        e
      });
      if (rewrittenUrl) return windowOpen.call(ctx, rewrittenUrl, target, windowFeatures);
      if (windowProxy) return windowProxy;
    });
    _classPrivateFieldInitSpec(this, _handleFormSubmitTap, function (ctx, formSubmit) {
      for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        rest[_key3 - 2] = arguments[_key3];
      }
      if (!_this.beforeNavigate) return formSubmit.call(ctx, ...rest);
      const parent = ctx.parentElement;
      const go = () => {
        // form submission can be asynchronous when using the go() method, we need
        // to ensure the form is still attached when we come back to submit it
        const requiresReattachment = document.contains(parent) && !document.contains(ctx);
        if (requiresReattachment) parent.appendChild(ctx);
        const result = formSubmit.call(ctx, ...rest);

        // make sure the form is removed after submission as that is the intended state
        if (requiresReattachment) ctx.remove();
        return result;
      };
      const e = new CustomViewEvent('FormSubmit', {
        view: ctx.ownerDocument.defaultView
      });
      const {
        target,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)((0, _formAttributes.getFormAttribute)(ctx, 'target'), '_self');
      const {
        rewrittenUrl,
        windowProxy
      } = _this.beforeNavigate((0, _formAttributes.getFormAttribute)(ctx, 'action'), target, '', {
        name,
        go,
        e
      });
      if (rewrittenUrl) (0, _formAttributes.setFormAttribute)(ctx, 'action', rewrittenUrl);
      if (windowProxy) return null;
      return formSubmit.call(ctx, ...rest);
    });
  }
}
var _default = exports["default"] = new NavigationTracking();

/***/ }),

/***/ 49715:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(62953);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "NAVIGATION_TYPE", ({
  enumerable: true,
  get: function () {
    return _Navigation.NAVIGATION_TYPE;
  }
}));
Object.defineProperty(exports, "Navigation", ({
  enumerable: true,
  get: function () {
    return _Navigation.default;
  }
}));
Object.defineProperty(exports, "NavigationHandler", ({
  enumerable: true,
  get: function () {
    return _NavigationHandler.default;
  }
}));
Object.defineProperty(exports, "NavigationTracking", ({
  enumerable: true,
  get: function () {
    return _NavigationTracking.default;
  }
}));
var _Navigation = _interopRequireWildcard(__webpack_require__(44661));
var _NavigationTracking = _interopRequireDefault(__webpack_require__(26356));
var _NavigationHandler = _interopRequireDefault(__webpack_require__(79301));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

/***/ }),

/***/ 49931:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getCacheContent = exports.applyContentCache = void 0;
var _NodeTracker = _interopRequireDefault(__webpack_require__(34822));
var _getCssText = __webpack_require__(37387);
var _DataUrl = _interopRequireDefault(__webpack_require__(31762));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const fetchCrossOriginImage = url => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = url;
    img.onload = () => {
      try {
        const dataUrl = _DataUrl.default.fromImage(img);
        resolve(dataUrl);
      } catch (error) {
        reject(error);
      }
    };
    img.onerror = reject;
  });
};
const fetchCrossOriginLink = url => {
  return new Promise((resolve, reject) => {
    const link = document.createElement('link');
    link.crossOrigin = 'anonymous';
    link.rel = 'stylesheet';
    link.href = url;
    link.setAttribute('class', '__cbio_ignored');
    link.onload = () => {
      try {
        const cssText = (0, _getCssText.getCssText)(link.sheet);
        resolve(cssText);
      } catch (error) {
        reject(error);
      } finally {
        link.remove();
      }
    };
    link.onerror = err => {
      link.remove();
      reject(err);
    };
    document.head.appendChild(link);
  });
};
const getUrlForNode = node => {
  if (node.tagName === 'IMG') return node.src;
  if (node.tagName === 'LINK') return node.href;
  return null;
};
const updateCacheContent = (node, content) => {
  const url = getUrlForNode(node);
  node.__cbio_content_cache = node.__cbio_content_cache || {};
  node.__cbio_content_cache[url] = content;
};
const cacheImgContent = async node => {
  if (getCacheContent(node)) return;
  const url = getUrlForNode(node);
  const getDataUrl = async () => {
    try {
      return _DataUrl.default.fromImage(node);
    } catch (_error) {}
    try {
      return await fetchCrossOriginImage(url);
    } catch (_error) {}
  };
  const dataUrl = await getDataUrl();
  if (dataUrl) updateCacheContent(node, dataUrl);
};
const cacheLinkContent = async node => {
  if (getCacheContent(node)) return;
  const url = getUrlForNode(node);
  const getCss = async () => {
    try {
      if (node.sheet) return (0, _getCssText.getCssText)(node.sheet);
    } catch (_error) {}
    try {
      return await fetchCrossOriginLink(url);
    } catch (_error) {}
  };
  const css = await getCss();
  if (css) updateCacheContent(node, css);
};
const getCacheContent = node => {
  var _node$__cbio_content_;
  const url = getUrlForNode(node);
  return (_node$__cbio_content_ = node.__cbio_content_cache) === null || _node$__cbio_content_ === void 0 ? void 0 : _node$__cbio_content_[url];
};
exports.getCacheContent = getCacheContent;
const applyContentCache = async nodeId => {
  const node = _NodeTracker.default.getById(nodeId);
  if (!node) return;
  if (node.tagName === 'IMG') return cacheImgContent(node);
  if (node.tagName === 'LINK' && node.rel === 'stylesheet') return cacheLinkContent(node);
};
exports.applyContentCache = applyContentCache;

/***/ }),

/***/ 48708:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(27495);
__webpack_require__(62953);
var _src = __webpack_require__(89501);
var _redaction = __webpack_require__(16566);
var _NodeTracker = _interopRequireDefault(__webpack_require__(34822));
var _NodeUtils = _interopRequireDefault(__webpack_require__(18571));
var _NodeTree = _interopRequireDefault(__webpack_require__(32588));
var _DataUrl = _interopRequireDefault(__webpack_require__(31762));
var _getScrollBarSize = __webpack_require__(97384);
var _getCssText = __webpack_require__(37387);
var _NodeContent = __webpack_require__(49931);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class NodeSerializer {
  constructor() {
    var _this = this;
    _defineProperty(this, "isLocalResource", url => {
      if (/^https?:\/\/localhost/.test(url)) return true;
      if (/^https?:\/\/127.0.0.1/.test(url)) return true;
      if (/^file:\/\//.test(url)) return true;
      if (/^blob:/.test(url)) return true;
      if (/^ionic:/.test(url)) return true;
      return false;
    });
    _defineProperty(this, "serializeAdoptedStyleSheets", node => {
      try {
        // the try here is because some shadow DOM polyfills (looking at you salesforce)
        // are broken and throw errors when calling adoptedStyleSheets
        let rules = [];
        [...(node.adoptedStyleSheets || [])].forEach(sheet => {
          rules = rules.concat([].slice.call(sheet.cssRules));
        });
        return (0, _getCssText.getCssText)({
          cssRules: rules
        });
      } catch (e) {
        console.warn('CobrowseIO: AdoptedStyleSheets serialize failed:', e.message, 'for', node);
        return '';
      }
    });
    _defineProperty(this, "_serializeAttributes", (node, serialized) => {
      if (node.nodeType === window.Node.ELEMENT_NODE && node.attributes) {
        const valueMap = {};
        Array.from(node.attributes || []).forEach(attr => {
          if (attr.nodeName === 'href' || attr.nodeName === 'src') {
            valueMap[attr.nodeName] = typeof node[attr.nodeName] === 'string'
            // use the node property for an absolute path if it's a string type
            ? node[attr.nodeName]
            // otherwise use the value as is (some nodes like <image> in <svg> act
            // differently and return objects)
            // TODO: these could be relative URLs which will then not get proxied, so
            //       we liekly need some way to convert them to absolute URLs before
            //       we send them
            : attr.nodeValue;
          } else {
            valueMap[attr.nodeName] = attr.nodeValue;
          }
        });
        serialized.attributes = valueMap;
      }
    });
    _defineProperty(this, "_serializeSelection", (node, serialized) => {
      var _node$activeElement;
      let serializedSelection = null;
      const selection = node.getSelection();
      if (selection && selection.type === 'Range' && !selection.isCollapsed && selection.rangeCount > 0) {
        try {
          // gecko browsers support multiple selections.
          // see: https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount
          serializedSelection = [...Array(selection.rangeCount)].reduce((acc, _, idx) => {
            var _RedactionIndexProvid, _RedactionIndexProvid2;
            const range = selection.getRangeAt(idx);
            const {
              startOffset,
              endOffset
            } = range;

            // if an element is redacted by another than the element being selected won't
            // be available on the agent view. As such we find the element which causes the
            // redaction and use that instead
            const startRedactedBy = (_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid === void 0 ? void 0 : _RedactionIndexProvid.getRedactedBy(range.startContainer);
            const endRedactedBy = (_RedactionIndexProvid2 = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid2 === void 0 ? void 0 : _RedactionIndexProvid2.getRedactedBy(range.endContainer);
            const start = _NodeTracker.default.get(startRedactedBy !== null && startRedactedBy !== void 0 ? startRedactedBy : range.startContainer);
            const end = _NodeTracker.default.get(endRedactedBy !== null && endRedactedBy !== void 0 ? endRedactedBy : range.endContainer);
            acc.push({
              start,
              end,
              // if the element is redacted by a parent than we need to use offset 0 instead
              // of the actually selected offset
              startOffset: startRedactedBy ? 0 : startOffset,
              endOffset: endRedactedBy ? 0 : endOffset
            });
            return acc;
          }, []);
        } catch (err) {
          console.warn('CobrowseIO: Could not serialize text selection', err);
        }
      } else if (['INPUT', 'TEXTAREA'].includes((_node$activeElement = node.activeElement) === null || _node$activeElement === void 0 ? void 0 : _node$activeElement.tagName) && node.activeElement.selectionStart !== node.activeElement.selectionEnd) {
        // when an input has a selection we set it to false to tell the frontend application to not reset the selection as
        // it's being handled on the input level
        serializedSelection = false;
      }
      serialized.selection = serializedSelection;
    });
    _defineProperty(this, "_serializeDocument", (node, serialized) => {
      if (node.nodeType === window.Node.DOCUMENT_NODE) {
        var _node$defaultView$vis, _node$defaultView, _node$defaultView2, _node$documentElement, _node$defaultView3, _node$documentElement2;
        serialized.url = node.location && node.location.href;

        // viewport scaling is not supported yet so we default
        // to client dimensions if the viewport is scaled
        const isViewportUnscaled = ((_node$defaultView$vis = (_node$defaultView = node.defaultView) === null || _node$defaultView === void 0 || (_node$defaultView = _node$defaultView.visualViewport) === null || _node$defaultView === void 0 ? void 0 : _node$defaultView.scale) !== null && _node$defaultView$vis !== void 0 ? _node$defaultView$vis : 1) === 1;
        const useInnerDimensions = (0, _getScrollBarSize.getScrollBarSize)() === 0 && isViewportUnscaled;
        const width = useInnerDimensions ? (_node$defaultView2 = node.defaultView) === null || _node$defaultView2 === void 0 ? void 0 : _node$defaultView2.innerWidth : (_node$documentElement = node.documentElement) === null || _node$documentElement === void 0 ? void 0 : _node$documentElement.clientWidth;
        const height = useInnerDimensions ? (_node$defaultView3 = node.defaultView) === null || _node$defaultView3 === void 0 ? void 0 : _node$defaultView3.innerHeight : (_node$documentElement2 = node.documentElement) === null || _node$documentElement2 === void 0 ? void 0 : _node$documentElement2.clientHeight;
        serialized.size = {
          width,
          height
        };
        serialized.focus = _NodeTracker.default.get(node.activeElement);
        const serializeDoctype = doctype => ({
          name: doctype.name,
          publicId: doctype.publicId,
          systemId: doctype.systemId
        });
        serialized.doctype = node.doctype != null ? serializeDoctype(node.doctype) : null;
        serialized.css = this.serializeAdoptedStyleSheets(node);
        this._serializeSelection(node, serialized);
      }
    });
    _defineProperty(this, "_serializeInput", (node, serialized) => {
      if (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA' || node.tagName === 'OPTION') {
        serialized.value = node.value;
        if ((node.type === 'radio' || node.type === 'checkbox') && typeof node.checked !== 'undefined') {
          serialized.checked = node.checked;
        }
        serialized.selection = null;
        try {
          const {
            selectionStart,
            selectionEnd,
            selectionDirection
          } = node;

          // this should be on a try catch and only appled to the correct input.type as
          // defined under https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
          if (selectionStart !== selectionEnd && node === node.ownerDocument.activeElement) {
            serialized.selection = {
              start: selectionStart,
              end: selectionEnd,
              direction: selectionDirection
            };
          }
        } catch (err) {
          console.warn('Failed to serialise text selection for the input', node);
        }
      }
    });
    _defineProperty(this, "_serializeSelect", (node, serialized) => {
      if (node.tagName === 'SELECT' && (!node.size || node.size === 1) && !node.multiple) {
        // selects are handled by our NativeSelect component
        serialized.preventDefault = true;
      }
    });
    _defineProperty(this, "_serializeOption", (node, serialized) => {
      if (node.tagName === 'OPTION') {
        serialized.selected = node.selected;
      }
    });
    _defineProperty(this, "_serializeShadowRoot", (node, serialized) => {
      if (node.nodeType === window.Node.DOCUMENT_FRAGMENT_NODE) {
        serialized.css = this.serializeAdoptedStyleSheets(node);
      }
    });
    _defineProperty(this, "_serializeStyle", (node, serialized) => {
      var _node$tagName;
      // note: SVG style tags can have lowercase names
      if (((_node$tagName = node.tagName) === null || _node$tagName === void 0 ? void 0 : _node$tagName.toUpperCase()) === 'STYLE') {
        try {
          if (node.sheet) serialized.css = (0, _getCssText.getCssText)(node.sheet);
        } catch (e) {
          console.warn('CobrowseIO: CSS serialize failed:', e.message, 'for', node);
        }
      }
    });
    _defineProperty(this, "_serializeLinkStyleSheet", (node, serialized) => {
      if (node.tagName === 'LINK' && node.rel === 'stylesheet') {
        const cachedContent = (0, _NodeContent.getCacheContent)(node);
        if (cachedContent) {
          serialized.css = cachedContent;
          return;
        }
        if (this.isLocalResource(node.href)) {
          try {
            if (node.sheet) serialized.css = (0, _getCssText.getCssText)(node.sheet);
          } catch (e) {
            console.warn('CobrowseIO: CSS serialize failed:', e.message, 'for', node);
          }
        }
      }
    });
    _defineProperty(this, "_serializeCanvas", (node, serialized, options) => {
      if (node.tagName === 'CANVAS' && !options.isRedacted && options.rasterizeCanvas) {
        try {
          var _node$attributes;
          const quality = parseFloat((_node$attributes = node.attributes) === null || _node$attributes === void 0 || (_node$attributes = _node$attributes['data-cbio-quality']) === null || _node$attributes === void 0 ? void 0 : _node$attributes.value) || 0.8;
          serialized.data = _DataUrl.default.fromCanvas(node, quality);
        } catch (e) {
          if (!node._cb_serialize_warned) {
            console.warn('Cobrowse failed to serialize canvas', node, 'due to error', e);
            node._cb_serialize_warned = true;
          }
        }
      }
    });
    _defineProperty(this, "_serializeImage", (node, serialized, options) => {
      if (node.tagName === 'IMG' && !options.isRedacted) {
        const cachedContent = (0, _NodeContent.getCacheContent)(node);
        if (cachedContent) {
          serialized.attributes.src = cachedContent;
          delete serialized.attributes.srcset;
          return;
        }
        if (this.isLocalResource(node.src)) {
          try {
            serialized.attributes.src = _DataUrl.default.fromImage(node);
            delete serialized.attributes.srcset;
          } catch (e) {
            console.warn('CobrowseIO: Failed to serialize image', node);
          }
        }
      }
    });
    _defineProperty(this, "_serializeScroll", (node, serialized) => {
      if ((0, _src.isxdoc)(node)) return;

      // IE11 is completely borked so we need to test document nodes
      // differently from everything else that scrolls
      if (node.nodeType === window.Node.DOCUMENT_NODE) {
        var _node$defaultView4, _node$defaultView5;
        serialized.scroll = {
          x: ((_node$defaultView4 = node.defaultView) === null || _node$defaultView4 === void 0 ? void 0 : _node$defaultView4.pageXOffset) || 0,
          y: ((_node$defaultView5 = node.defaultView) === null || _node$defaultView5 === void 0 ? void 0 : _node$defaultView5.pageYOffset) || 0
        };
      } else if (
      // we don't want to serialize the scroll on the HTML element as it's already
      // serialized on the document element
      node.tagName !== 'HTML' && (node.scrollWidth > node.clientWidth || node.scrollHeight > node.clientHeight)) {
        serialized.scroll = {
          x: node.scrollLeft || 0,
          y: node.scrollTop || 0
        };
      }
    });
    _defineProperty(this, "_serializeRedaction", (node, serialized, options) => {
      if (options.isRedacted) {
        delete serialized.value;

        // Get the visual size of the node
        const size = this._getSize(node);
        if (node.nodeType === 1) {
          // A regular element should have its display set to inline-block if it
          // were inline. This ensures that width/height from redaction will be
          // respected
          const style = window.getComputedStyle(node);

          // If this element has size and is inline, we cast it to inline-block so
          // it can accept size styling on the agent
          const display = style.display === 'inline' && size.height > 0 ? 'inline-block' : style.display;
          serialized.attributes = serialized.attributes && _objectSpread({
            id: serialized.attributes.id,
            class: serialized.attributes.class,
            // flex-basis: 0 will colapse the elements that do have any content which is the
            // case fo the redacted elements. We unset it to prevent this behaviour.
            // see: https://github.com/cobrowseio/cobrowse-sdk-js/pull/23
            // Regarding flex-shrink, it ensures that the calculated size is actually respected
            // and the size doesn't automatically colapse when flex is laying out the content
            style: "".concat(serialized.attributes.style || '', "; display: ").concat(display, " !important;flex-basis: unset !important;flex-shrink: 0;z-index:").concat(style.zIndex, ";")
          }, node.nodeName === 'EMBED' ? {
            src: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
          } : {});
        } else if (node.nodeType === 3) {
          // A redacted text node needs to be able to be given width and height on
          // the server side. So we convert it to a span
          serialized.nodeType = 1;
          serialized.tagName = 'SPAN';

          // Make it display: inline-block if we have to give it size, since
          // if it remains inline then it can't take styled size
          serialized.attributes = {
            style: size.height > 0 ? 'display: inline-block !important' : undefined
          };
        }
        serialized.redaction = {
          height: "".concat(size.height, "px"),
          width: "".concat(size.width, "px")
        };
      } else {
        serialized.redaction = undefined;
      }
    });
    _defineProperty(this, "_serializePseudoSelectors", (node, serialized) => {
      var _serialized$attribute, _serialized$attribute2, _serialized$attribute3;
      if (typeof node.matches !== 'function') return;
      (_serialized$attribute = serialized.attributes) === null || _serialized$attribute === void 0 || delete _serialized$attribute.__cbio_pseudo_hover;
      (_serialized$attribute2 = serialized.attributes) === null || _serialized$attribute2 === void 0 || delete _serialized$attribute2.__cbio_pseudo_active;
      (_serialized$attribute3 = serialized.attributes) === null || _serialized$attribute3 === void 0 || delete _serialized$attribute3.__cbio_pseudo_focus;
      serialized.attributes = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, serialized.attributes), node.matches(':hover') ? {
        __cbio_pseudo_hover: ''
      } : {}), node.matches(':active') ? {
        __cbio_pseudo_active: ''
      } : {}), node.matches(':focus') ? {
        __cbio_pseudo_focus: ''
      } : {});
    });
    _defineProperty(this, "_serializeVisibility", (node, serialized) => {
      delete serialized.hidden;
      if (!node.tagName) return;
      if (node.hidden || node.getAttribute('aria-hidden') === 'true' || !node.checkVisibility({
        visibilityProperty: true
      })) {
        serialized.hidden = true;
      }
    });
    _defineProperty(this, "_getSize", node => {
      const nodeType = node === null || node === void 0 ? void 0 : node.nodeType;
      if (nodeType == null) {
        return {
          height: 0,
          width: 0
        };
      } else if (nodeType === Node.ELEMENT_NODE) {
        return node.getBoundingClientRect();
      } else {
        const range = document.createRange();
        range.selectNodeContents(node);
        return range.getBoundingClientRect();
      }
    });
    _defineProperty(this, "_serialize", (node, options) => {
      if (!_NodeTracker.default.get(node)) {
        console.error('node missing id', node, node.parentNode);
        throw new Error('node missing id', node);
      }

      // check if this node looks like it's already been serialized
      // in which case we can skip it
      if (!_NodeUtils.default.isDOMNode(node)) return node;
      if (!node.nodeType) throw new Error('node missing type', node);
      const serialized = {
        id: _NodeTracker.default.get(node),
        nodeType: node.nodeType
      };
      this._serializeShadowRoot(node, serialized);
      this._serializeAttributes(node, serialized);
      this._serializeImage(node, serialized, options);
      this._serializeDocument(node, serialized);
      this._serializeScroll(node, serialized);
      this._serializeInput(node, serialized);
      this._serializeSelect(node, serialized);
      this._serializeOption(node, serialized);
      this._serializeStyle(node, serialized);
      this._serializeLinkStyleSheet(node, serialized);
      this._serializeCanvas(node, serialized, options);
      this._serializeRedaction(node, serialized, options);
      this._serializePseudoSelectors(node, serialized);
      this._serializeVisibility(node, serialized);
      if (node.tagName) serialized.tagName = node.tagName;
      if (node.nodeValue) serialized.content = node.nodeValue;
      return serialized;
    });
    _defineProperty(this, "serialize", function (root) {
      var _RedactionIndexProvid3;
      let overrideChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => undefined;
      let serializerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const redactedBy = (_RedactionIndexProvid3 = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid3 === void 0 ? void 0 : _RedactionIndexProvid3.getRedactedBy(root);

      // we ignore any nodes that are a child of a redacted node, so we should
      // not allow the serilizer to return anything for those nodes
      const ignored = redactedBy && redactedBy !== root || [root, ...(0, _src.parents)(root)].find(n => _NodeTree.default.isIgnored(n));
      if (ignored) return null;

      // We're ready to serialize the target node now, we'll do that first then work out
      // what to do aout serilizing its children.
      const serialized = _this._serialize(root, _objectSpread({
        isRedacted: Boolean(redactedBy)
      }, serializerOptions));
      if (serializerOptions.skipChildren) return serialized;

      // If this ndoe is the root of a redacted area, then we should not be serializing
      // any of it's children,so we'll short-circuit the tree traversal here. We'll also
      // make sure to return an emtpy list for the child nodes to wipe any children from
      // the serilized state.
      if (redactedBy) {
        overrideChildren([]);
        return _objectSpread(_objectSpread({}, serialized), {}, {
          childNodes: []
        });
      }

      // Fetch the child nodes based on the node type etc...
      const children = _NodeTree.default.children(root);
      // Some special cases (xdoc iframes) may not return any children information. This doesn't mean
      // that the nodes do not have children, but rather we can't determine the state of the children
      // right now.  In these cases we should not assume that there are no children, instead we should
      // also not return any children information (i.e. we must be careful not to send an empty childNodes
      // array by mistake asthis would imply that there are no children.
      if (children) {
        // convert DOM nodes to IDs, or use already serialized elements (from xdoc iframes)
        const childNodes = children.map(child => {
          if (!_NodeUtils.default.isDOMNode(child)) return _objectSpread({}, child);
          const nodeId = _NodeTracker.default.get(child);
          if (!nodeId) console.warn('child node missing id', child);
          return {
            id: nodeId
          };
        });
        return _objectSpread(_objectSpread({}, serialized), {}, {
          childNodes
        });
      }

      // Otherwise, just return the serilized state.
      return serialized;
    });
  }
}
var _default = exports["default"] = new NodeSerializer();

/***/ }),

/***/ 34822:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _randomString = _interopRequireDefault(__webpack_require__(78981));
var _NodeUtils = _interopRequireDefault(__webpack_require__(18571));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class NodeTracker {
  constructor() {
    _defineProperty(this, "_idMap", new Map());
    _defineProperty(this, "_nodeMap", new Map());
    _defineProperty(this, "_currentId", 0);
    _defineProperty(this, "_nextId", () => {
      this._currentId += 1;
      return this._currentId;
    });
    _defineProperty(this, "track", node => {
      if (!node) return null;
      if (!_NodeUtils.default.isDOMNode(node)) return node.id;
      if (!this.get(node)) {
        const isDocument = node.nodeType === window.Node.DOCUMENT_NODE;
        const id = isDocument ? (0, _randomString.default)(5) : "".concat(this.track(document), "-").concat(this._nextId());
        this._idMap.set(id, node);
        this._nodeMap.set(node, id);
      }
      return this._nodeMap.get(node);
    });
    _defineProperty(this, "get", node => {
      if (!node) return null;
      if (!_NodeUtils.default.isDOMNode(node)) return node.id;
      return this._nodeMap.get(node) || null;
    });
    _defineProperty(this, "getById", id => {
      if (!id) return null;
      return this._idMap.get(id) || null;
    });
    _defineProperty(this, "forget", node => {
      this._idMap.delete(this.get(node));
      this._nodeMap.delete(node);
    });
  }
}
var _default = exports["default"] = new NodeTracker();

/***/ }),

/***/ 32588:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _src = __webpack_require__(89501);
var _NodeUtils = _interopRequireDefault(__webpack_require__(18571));
var _unpolyfill = __webpack_require__(79883);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.NodeTree');
var _ignoredViews = /*#__PURE__*/new WeakMap();
class NodeTree {
  constructor() {
    _classPrivateFieldInitSpec(this, _ignoredViews, '.__cbio_ignored');
    _defineProperty(this, "isIgnored", target => {
      var _parent$tagName;
      // ignore any elements specifically marked with a class to be ignored
      if (target && target.matches && target.matches(_classPrivateFieldGet(_ignoredViews, this))) {
        debug('ignoring', target, 'because child of classes');
        return true;
      }

      // ignore a whole bunch of specific node types that don't
      // actually add visible content to the DOM, or aren't supported
      if ([window.Node.COMMENT_NODE, window.Node.CDATA_SECTION_NODE, window.Node.ENTITY_REFERENCE_NODE, window.Node.ENTITY_NODE, window.Node.PROCESSING_INSTRUCTION_NODE, window.Node.NOTATION_NODE, window.Node.DOCUMENT_TYPE_NODE].includes(target.nodeType)) {
        debug('ignoring', target, 'because of nodeType');
        return true;
      }

      // ignore script tags
      if (target.tagName === 'SCRIPT') {
        debug('ignoring', target, 'because of SCRIPT');
        return true;
      }
      const parent = target.parentNode || target.defaultView && target.defaultView.frameElement;

      // ignore content of style nodes, we use JS APIs to serialise their
      // content separaetly. SVG style nodes can have lowercase tag names
      if (parent && ((_parent$tagName = parent.tagName) === null || _parent$tagName === void 0 ? void 0 : _parent$tagName.toUpperCase()) === 'STYLE') {
        debug('ignoring', target, 'because child of STYLE');
        return true;
      }
      return false;
    });
    _defineProperty(this, "children", node => {
      // Salesforce lightning components screw with browser APIs significantly
      // so we need to use the unpolyfil'd versions to access some properties
      const {
        get: childNodes
      } = Object.getOwnPropertyDescriptor(_unpolyfill.Node.prototype, 'childNodes');
      const {
        get: shadowRoot
      } = Object.getOwnPropertyDescriptor(_unpolyfill.Element.prototype, 'shadowRoot');
      if (!_NodeUtils.default.isDOMNode(node)) return node.childNodes;
      if (node.tagName === 'IFRAME' && (0, _src.isxdoc)(node)) {
        // For cross doc iframes we create a fake document node once we know the id
        // of the document inside the iframe (sent over the bridge). Patches can then be
        // applied on top of this id.
        if (node.__document_id) return [{
          id: node.__document_id,
          nodeType: 9
        }];else return [];
      } else if (node.tagName === 'IFRAME' && !(0, _src.isxdoc)(node)) {
        // include IFRAME content we can access
        // if the iframe is still loading, then we don't serilise it's content. We'll reserialise again
        // once the load event triggers indicating the full content is available
        if (node.contentWindow.document.readyState !== 'complete') return [];
        return [node.contentWindow.document].filter(n => !this.isIgnored(n));
      } else if (node.nodeType === window.Node.ELEMENT_NODE && shadowRoot.apply(node)) {
        // Also traverse shadow roots
        return [shadowRoot.apply(node), ...Array.from(childNodes.apply(node))].filter(n => !this.isIgnored(n));
      } else {
        // and just regular nodes with children
        return Array.from(childNodes.apply(node)).filter(n => !this.isIgnored(n));
      }
    });
    _defineProperty(this, "depthFirst", (root, visitor) => {
      return (0, _src.depthFirst)(root, (node, overrideChildren) => {
        // override children to make sure iframe content and shadow DOM content is included
        overrideChildren(this.children(node));
        // also allow visitor to override children again if it wishes as this is useful
        // for skipping entire subtrees
        return visitor(node, overrideChildren);
      });
    });
  }
  setIgnoredViews(ignored) {
    if (Array.isArray(ignored)) {
      _classPrivateFieldSet(_ignoredViews, this, ['.__cbio_ignored', ...ignored].filter(Boolean).join(','));
      debug('set ignored view selectors', _classPrivateFieldGet(_ignoredViews, this));
      return;
    }
    debug('not updating #ignoredViews due to arg to being an array', ignored);
  }
}
var _default = exports["default"] = new NodeTree();

/***/ }),

/***/ 18571:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class NodeUtils {
  constructor() {
    _defineProperty(this, "isDOMNode", node => {
      if (!node) return false;
      // quack quack
      return !!(node.childNodes && typeof node.appendChild === 'function' && typeof node.nodeType !== 'undefined');
    });
  }
}
var _default = exports["default"] = new NodeUtils();

/***/ }),

/***/ 66938:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "NodeSerializer", ({
  enumerable: true,
  get: function () {
    return _NodeSerializer.default;
  }
}));
Object.defineProperty(exports, "NodeTracker", ({
  enumerable: true,
  get: function () {
    return _NodeTracker.default;
  }
}));
Object.defineProperty(exports, "NodeTree", ({
  enumerable: true,
  get: function () {
    return _NodeTree.default;
  }
}));
Object.defineProperty(exports, "NodeUtils", ({
  enumerable: true,
  get: function () {
    return _NodeUtils.default;
  }
}));
var _NodeTracker = _interopRequireDefault(__webpack_require__(34822));
var _NodeUtils = _interopRequireDefault(__webpack_require__(18571));
var _NodeTree = _interopRequireDefault(__webpack_require__(32588));
var _NodeSerializer = _interopRequireDefault(__webpack_require__(48708));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 51099:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(27495);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _convertLinkToRegExp = __webpack_require__(50048);
var _navigation = __webpack_require__(49715);
var _Navigation = __webpack_require__(44661);
var _PDFViewer = _interopRequireDefault(__webpack_require__(97005));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _pdfLinkRegExps = /*#__PURE__*/new WeakMap();
var _pdfViewer = /*#__PURE__*/new WeakMap();
var _getPdfName = /*#__PURE__*/new WeakMap();
var _loadPdfDocument = /*#__PURE__*/new WeakMap();
class PDFHandler extends _navigation.NavigationHandler {
  constructor(session, delegate) {
    var _delegate$pdfLinks;
    super();
    _classPrivateFieldInitSpec(this, _pdfLinkRegExps, void 0);
    _classPrivateFieldInitSpec(this, _pdfViewer, void 0);
    _classPrivateFieldInitSpec(this, _getPdfName, rawUrl => {
      const url = new URL(rawUrl, window.location.href);
      return url.pathname.split('/').pop();
    });
    _classPrivateFieldInitSpec(this, _loadPdfDocument, (url, target, windowFeatures, options) => {
      const {
        document: pdfDocument
      } = options;
      const container = document.createElement('div');
      container.style.width = '100%';
      container.style.height = '100%';
      pdfDocument.load(url, target, windowFeatures, {
        element: container,
        type: this.type
      });
      _classPrivateFieldGet(_pdfViewer, this).openPdfViewer(url, container, () => {
        const pdfName = _classPrivateFieldGet(_getPdfName, this).call(this, url);
        pdfDocument.icon = '';
        pdfDocument.title = pdfName;
        pdfDocument.isLoading = false;
      });
    });
    _classPrivateFieldSet(_pdfLinkRegExps, this, ((_delegate$pdfLinks = delegate.pdfLinks) === null || _delegate$pdfLinks === void 0 ? void 0 : _delegate$pdfLinks.map(_convertLinkToRegExp.convertLinkToRegExp)) || []);
    _classPrivateFieldSet(_pdfViewer, this, new _PDFViewer.default(session, delegate.api));
  }
  get type() {
    return _Navigation.NAVIGATION_TYPE.PDF;
  }
  shouldHandleEvent(e) {
    // only watch for events that have started bubbling
    if (e.eventPhase === Event.CAPTURING_PHASE) return false;
    // we need to honor the defaultPrevented flag for PDF
    // navigations as this can cause a double navigation to occur
    return !e.defaultPrevented;
  }
  shouldHandle(u) {
    const urlWithoutQueryParams = new URL(u, window.location.origin);
    urlWithoutQueryParams.search = '';
    return _classPrivateFieldGet(_pdfLinkRegExps, this).some(regExp => regExp.test(urlWithoutQueryParams));
  }
  handle(url, target, windowFeatures, options) {
    _classPrivateFieldGet(_loadPdfDocument, this).call(this, url, target, windowFeatures, options);
    return {
      document: options.document
    };
  }
}
exports["default"] = PDFHandler;

/***/ }),

/***/ 97005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.GLOBAL_OPEN_PDF_KEY = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _protected = _interopRequireDefault(__webpack_require__(37609));
var _proxy = __webpack_require__(9147);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const GLOBAL_OPEN_PDF_KEY = exports.GLOBAL_OPEN_PDF_KEY = '__cobrowse_io_openPdf';
var _session = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _createUrlRewriter = /*#__PURE__*/new WeakMap();
class PDFViewer {
  constructor(_session2, api) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _api, void 0);
    _classPrivateFieldInitSpec(this, _createUrlRewriter, session => {
      const proxyToken = session[_protected.default].proxyToken();
      const sessionProxyUrl = session[_protected.default].proxyUrl();
      const proxyUrl = new URL(sessionProxyUrl, _classPrivateFieldGet(_api, this));
      return new _proxy.URLRewriter(proxyUrl, _proxy.PROXY_PREFIX.UNIVERSAL, proxyToken, window.location);
    });
    _defineProperty(this, "openPdfViewer", (url, container, onLoadComplete) => {
      const globalOpenPdf = window[GLOBAL_OPEN_PDF_KEY];
      const open = openPdf => {
        const {
          setPdfUrl
        } = openPdf(url, {
          container,
          onLoadError: failedUrl => {
            const urlRewriter = _classPrivateFieldGet(_createUrlRewriter, this).call(this, _classPrivateFieldGet(_session, this));
            const proxiedUrl = urlRewriter.proxify(url);
            if (failedUrl === proxiedUrl) {
              onLoadComplete();
              return;
            }
            console.warn('CobrowseIO: Failed to fetch PDF document, attempting to proxy it');
            setPdfUrl(proxiedUrl);
          },
          onLoadSuccess: onLoadComplete,
          preventClose: true
        });
      };

      // check if we have a global viewer defined, this would exist
      // when a consumer has an unnamed import for the pdf-viewer
      if (typeof globalOpenPdf === 'function') {
        open(globalOpenPdf);
        return;
      }

      // we only bundle and chunk the PDF viewer for script builds
      // eslint-disable-next-line
      if (true) {
        __webpack_require__.e(/* import() | pdf-viewer */ 246).then(__webpack_require__.t.bind(__webpack_require__, 70825, 23)).then(pdf => {
          open(pdf.open);
        });
        return;
      }
      console.warn('CobrowseIO: No PDF Viewer included');
    });
    _classPrivateFieldSet(_session, this, _session2);
    _classPrivateFieldSet(_api, this, api);
  }
}
exports["default"] = PDFViewer;

/***/ }),

/***/ 11065:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(62953);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "GLOBAL_OPEN_PDF_KEY", ({
  enumerable: true,
  get: function () {
    return _PDFViewer.GLOBAL_OPEN_PDF_KEY;
  }
}));
Object.defineProperty(exports, "PDFHandler", ({
  enumerable: true,
  get: function () {
    return _PDFHandler.default;
  }
}));
Object.defineProperty(exports, "PDFViewer", ({
  enumerable: true,
  get: function () {
    return _PDFViewer.default;
  }
}));
var _PDFViewer = _interopRequireWildcard(__webpack_require__(97005));
var _PDFHandler = _interopRequireDefault(__webpack_require__(51099));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

/***/ }),

/***/ 168:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URLRewriter = void 0;
__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _unproxifyPath = __webpack_require__(79444);
var _proxifyUrl = __webpack_require__(76925);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _shouldIgnore = /*#__PURE__*/new WeakMap();
var _isProxyUrl = /*#__PURE__*/new WeakMap();
var _getPathWithoutPrefix = /*#__PURE__*/new WeakMap();
class URLRewriter {
  constructor(proxyApiUrl, proxyPrefix, proxyToken, baseUrl, _queryParams, getOrigin) {
    var _this = this;
    _defineProperty(this, "ALLOWED_PROTOCOLS", ['http:', 'https:']);
    _classPrivateFieldInitSpec(this, _shouldIgnore, urlString => {
      return urlString.startsWith('#');
    });
    _classPrivateFieldInitSpec(this, _isProxyUrl, url => {
      return url.hostname === this.proxyApiUrl.hostname;
    });
    _classPrivateFieldInitSpec(this, _getPathWithoutPrefix, url => {
      const path = "".concat(url.pathname).concat(url.search).concat(url.hash);
      return path.replace(/^.*?\/proxy\/1\/[^/]+/i, '');
    });
    _defineProperty(this, "proxify", function (rawUrl) {
      let additionalQueryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!rawUrl) return rawUrl;
      if (_classPrivateFieldGet(_shouldIgnore, _this).call(_this, rawUrl.toString())) return rawUrl;
      const queryParams = _objectSpread(_objectSpread(_objectSpread({}, _this.queryParams), _this.getOrigin ? {
        origin: _this.getOrigin()
      } : {}), additionalQueryParams);
      try {
        const url = new URL(rawUrl, _this.baseUrl);
        if (!_this.ALLOWED_PROTOCOLS.includes(url.protocol)) return rawUrl;
        const urlString = _classPrivateFieldGet(_isProxyUrl, _this).call(_this, url) ? _this.unproxify(url.toString()) : url.toString();
        const targetPath = (0, _proxifyUrl.proxifyUrl)(urlString, queryParams);
        const targetUrl = new URL(".".concat(targetPath), _this.proxyApiUrl);
        return targetUrl.toString();
      } catch (err) {
        return rawUrl;
      }
    });
    _defineProperty(this, "unproxify", rawUrl => {
      if (!rawUrl) return rawUrl;
      if (_classPrivateFieldGet(_shouldIgnore, this).call(this, rawUrl.toString())) return rawUrl;
      try {
        const url = new URL(rawUrl, this.baseUrl);
        if (!this.ALLOWED_PROTOCOLS.includes(url.protocol)) return rawUrl;
        if (!_classPrivateFieldGet(_isProxyUrl, this).call(this, url)) return rawUrl;
        const pathWithoutPrefix = _classPrivateFieldGet(_getPathWithoutPrefix, this).call(this, url);
        const targetUrl = (0, _unproxifyPath.unproxifyPath)(pathWithoutPrefix);
        return targetUrl.toString();
      } catch (err) {
        return rawUrl;
      }
    });
    this.proxyApiUrl = new URL(proxyPrefix, proxyApiUrl);
    this.queryParams = _queryParams ? _objectSpread({}, _queryParams) : {};
    if (proxyToken) this.queryParams.access_token = proxyToken;
    this.baseUrl = baseUrl;
    this.getOrigin = getOrigin;
  }
}
exports.URLRewriter = URLRewriter;

/***/ }),

/***/ 9147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "PROXY_PREFIX", ({
  enumerable: true,
  get: function () {
    return _proxyPrefix.PROXY_PREFIX;
  }
}));
Object.defineProperty(exports, "URLRewriter", ({
  enumerable: true,
  get: function () {
    return _URLRewriter.URLRewriter;
  }
}));
var _URLRewriter = __webpack_require__(168);
var _proxyPrefix = __webpack_require__(42859);

/***/ }),

/***/ 76925:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.reverseHost = exports.proxifyUrl = void 0;
__webpack_require__(94490);
__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
const reverseHost = host => host.split('.').reverse().map(encodeURIComponent).join('/');
exports.reverseHost = reverseHost;
const proxifyUrl = (url, queryParams) => {
  const {
    hostname,
    protocol,
    pathname,
    search,
    port,
    username,
    password,
    hash
  } = new URL(url);
  const targetHost = reverseHost(hostname);
  const targetPath = "".concat(targetHost, "/").concat(protocol).concat(pathname).concat(hash);
  const targetUrl = new URL(targetPath, 'http://placeholder.base');
  if (search) targetUrl.searchParams.set('search', search.replace('?', ''));
  if (port) targetUrl.searchParams.set('port', port);
  if (username) targetUrl.searchParams.set('username', username);
  if (password) targetUrl.searchParams.set('password', password);
  for (const [key, value] of Object.entries(queryParams || {})) {
    targetUrl.searchParams.set(key, value);
  }
  return "".concat(targetUrl.pathname).concat(targetUrl.search).concat(targetUrl.hash);
};
exports.proxifyUrl = proxifyUrl;

/***/ }),

/***/ 42859:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PROXY_PREFIX = void 0;
const PROXY_PREFIX = exports.PROXY_PREFIX = {
  UNIVERSAL: './proxy/1/universal/'
};

/***/ }),

/***/ 79444:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.unproxifyPath = void 0;
__webpack_require__(94490);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
const unproxifyPath = path => {
  const {
    pathname,
    hash,
    searchParams
  } = new URL(path, 'http://placeholder.base');
  const parts = pathname.split('/');
  const protocolIndex = parts.findIndex(part => part === 'http:' || part === 'https:');
  const protocol = parts[protocolIndex];
  const hostParts = parts.slice(1, protocolIndex).reverse().map(decodeURIComponent);
  const pathParts = parts.slice(protocolIndex + 1, parts.length);
  const search = searchParams.get('search');
  const port = searchParams.get('port');
  const username = searchParams.get('username');
  const password = searchParams.get('password');
  const targetHost = hostParts.join('.');
  const targetPath = pathParts.join('/');
  const searchWithPrefix = search ? "?".concat(search) : '';
  const portWithPrefix = port ? ":".concat(port) : '';
  const credentials = username && password ? "".concat(username, ":").concat(password, "@") : '';
  return new URL("".concat(protocol, "//").concat(credentials).concat(targetHost).concat(portWithPrefix, "/").concat(targetPath).concat(searchWithPrefix).concat(hash));
};
exports.unproxifyPath = unproxifyPath;

/***/ }),

/***/ 2615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RedactionIndex = void 0;
__webpack_require__(78350);
__webpack_require__(30237);
__webpack_require__(62953);
var _NodeTree = _interopRequireDefault(__webpack_require__(32588));
var _src = __webpack_require__(89501);
var _unpolyfill = __webpack_require__(79883);
var _nodes = __webpack_require__(66938);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * An index cache that tracks element redaction state and can be efficiently
 * queried for node redaction state.
 *
 * The logistics behind what is able to be redacted takes on a complex
 * consideration that even though an element is supposed to be redacted, it may
 * not be able to be redacted because it has a descendant that is explicitly
 * unredacted. To accomodate this requirement, there is a concept of
 * "projection" worked into the algorithm:
 *
 *  * A redacted element "projects" redaction down to its descendants. This
 *    projection ends as soon as it hits another node that has direct redaction/
 *    unredaction set; and
 *  * An unredacted element "projects" unredaction up to its ancestors. This
 *    projection does not end when an ancestor has a direct redaction state.
 *
 * Given this distinction, every element in the DOM can have the following
 * direct and projected characteristics:
 *
 *  1. Direct unredaction. A node is indexed with `setRedacted(node, false)`
 *  2. Projected unredaction. All nodes that are ancestors of a direct
 *     unredaction node are projected unredaction.
 *  3. Direct redaction. A node is indexed with `setRedacted(node, true)`
 *  4. Projected redaction. All nodes that are descendants of a direct
 *     redaction node are projected redaction.
 *
 * With the concept of projection in mind, determining if a node is redacted
 * boils down to the following logic:
 *
 *  1. A direct or projected unredacted node must not be redacted
 *  2. A direct redacted node is redacted only if it is not projected unredacted
 *  3. A projected redacted node is redacted only if its direct parent is
 *     projected unredacted
 *  4. Any node that has no other redaction state is not redacted
 */
var _redactedSelector = /*#__PURE__*/new WeakMap();
var _unredactedSelector = /*#__PURE__*/new WeakMap();
var _redactedTagNames = /*#__PURE__*/new WeakMap();
var _unredactedCache = /*#__PURE__*/new WeakMap();
var _redactedCache = /*#__PURE__*/new WeakMap();
var _RedactionIndex_brand = /*#__PURE__*/new WeakSet();
class RedactionIndex {
  constructor() {
    let redactedSelectors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let unredactedSelectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let sessionRedactionSelectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let sessionUnredactionSelectors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    let {
      document = window.document
    } = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    _classPrivateMethodInitSpec(this, _RedactionIndex_brand);
    _classPrivateFieldInitSpec(this, _redactedSelector, void 0);
    _classPrivateFieldInitSpec(this, _unredactedSelector, void 0);
    _classPrivateFieldInitSpec(this, _redactedTagNames, ['OBJECT', 'EMBED']);
    _classPrivateFieldInitSpec(this, _unredactedCache, new Set());
    _classPrivateFieldInitSpec(this, _redactedCache, new Set());
    _classPrivateFieldSet(_redactedSelector, this, _assertClassBrand(_RedactionIndex_brand, this, _combineSelectors).call(this, ..._classPrivateFieldGet(_redactedTagNames, this), ...redactedSelectors, ...sessionRedactionSelectors));
    _classPrivateFieldSet(_unredactedSelector, this, _assertClassBrand(_RedactionIndex_brand, this, _combineSelectors).call(this, ...unredactedSelectors, ...sessionUnredactionSelectors));
    for (const n of _assertClassBrand(_RedactionIndex_brand, this, _findDescendants).call(this, document, _classPrivateFieldGet(_redactedSelector, this))) {
      _classPrivateFieldGet(_redactedCache, this).add(n);
    }
    for (const n of _assertClassBrand(_RedactionIndex_brand, this, _findDescendants).call(this, document, _classPrivateFieldGet(_unredactedSelector, this))) {
      _classPrivateFieldGet(_unredactedCache, this).add(n);
    }
  }

  /**
   * Determine which node, if any, the specified node is redacted by.
   *
   * If this node is not redacted (e.g., it is not redacted directly or
   * indirectly by a selector, or it has been unredacted by a selector), then
   * `null` is returned.
   *
   * Otherwise, if any ancestor of the specified node is determined to be
   * directly redacted (i.e., the specified node is "indirectly" redacted), then
   * that ancestor node will be returned.
   *
   * Otherwise, if the specified node is directly redacted, then the node itself
   * will be returned.
   *
   * Redacted nodes that match a selector set in the admin interface will take
   * precende over any other redaction/unredaction.
   */
  getRedactedBy(node) {
    // if redacted by session selector or parent is redacted by session selector
    const redactedByPriority = _assertClassBrand(_RedactionIndex_brand, this, _getRedactedByPriority).call(this, node);
    if (redactedByPriority) {
      return redactedByPriority;
    }
    if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, node) || _assertClassBrand(_RedactionIndex_brand, this, _isProjectedUnredaction).call(this, node)) {
      // A direct or projected unredacted node must not be redacted
      return null;
    }

    // First determine if this node is projected redaction from an ancestor
    const projectedRedactionBy = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedRedactionBy).call(this, node);
    if (projectedRedactionBy) {
      // A projected redaction node is directly redacted only if its direct parent
      // is projected unredacted. Otherwise, it is indirectly redacted
      return _assertClassBrand(_RedactionIndex_brand, this, _isProjectedUnredaction).call(this, node.parentNode) ? node : projectedRedactionBy;
    }
    if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectRedaction).call(this, node)) {
      // A direct redacted node that is not projected unredacted is redacted
      return node;
    }
    return null;
  }
  notifyChanges(records, addedNodes, modifiedNodes, removedNodes) {
    const modified = new Set();
    const expandUnredaction = new Set();

    // performance optimisation so we can update the cache as we go and in the end compare the
    // elements removed from the cache so those can be added to the changeset
    const previousRedactedCache = new Set([..._classPrivateFieldGet(_redactedCache, this)]);
    for (const record of records) {
      if (_NodeTree.default.isIgnored(record.target) || removedNodes.has(record.target)) {
        continue;
      }
      const redactedBy = this.getRedactedBy(record.target);

      // If an element is modified that is a descendent of a direct redacted node,
      // we want to propagate a change for the redacted node to pick up potential
      // changes in size
      if (redactedBy && redactedBy !== record.target) {
        modified.add(redactedBy);
      }
      if (record.type === 'attributes') {
        const projectedUnredaction = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedUnredaction).call(this, record.target);
        // If this node is projected unredaction, we have to account for the
        // possibility that this change resulted in projected redaction to
        // change, on the ancestors of all those elements, which would change
        // which state children of projected unredaction nodes have.
        //
        // If this node became redacted, then children of all projected
        // unredaction nodes are now direct redaction.
        //
        // If this node became non-redacted, then children of projected
        // unredaction nodes are now no longer redacted
        for (const node of projectedUnredaction) {
          expandUnredaction.add(node);
        }
        const isDirectUnredaction = _assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, record.target);
        if (_classPrivateFieldGet(_unredactedCache, this).has(record.target) !== !!isDirectUnredaction) {
          // If this nodes unredaction state changed, we need to propagate
          // modifications through its unredaction chain
          expandUnredaction.add(record.target.parentNode);
        }
      } else if (record.type === 'childList') {
        const hasRemovedUnredacted = _assertClassBrand(_RedactionIndex_brand, this, _hasUnredacted).call(this, record.removedNodes);
        const hasAddedUnredacted = _assertClassBrand(_RedactionIndex_brand, this, _hasUnredacted).call(this, record.addedNodes);
        if (!expandUnredaction.has(record.target)) {
          const projectedUnredaction = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedUnredaction).call(this, record.target);
          const isProjectedUnredaction = projectedUnredaction.length > 0;
          const potentiallyBecameProjectedUnredaction = isProjectedUnredaction && hasAddedUnredacted;

          // We possibly became non-"projected unredaction" if we are now not
          // projected unredaction AND one of our descendants are unredacted
          const potentiallyBecameNotProjectedUnredaction = !isProjectedUnredaction && hasRemovedUnredacted;
          if (potentiallyBecameProjectedUnredaction || potentiallyBecameNotProjectedUnredaction) {
            expandUnredaction.add(record.target);
          }
        }
      }
    }

    // Expand out the nodes that are potentially modified from a potential
    // unredaction modification
    const potentiallyAffectedUnredactionNodes = _assertClassBrand(_RedactionIndex_brand, this, _expandAffectedUnredaction).call(this, expandUnredaction);
    for (const node of potentiallyAffectedUnredactionNodes) {
      if (!_NodeTree.default.isIgnored(node)) {
        modified.add(node);
      }
    }
    _assertClassBrand(_RedactionIndex_brand, this, _updateCaches).call(this, addedNodes, new Set([...modified, ...modifiedNodes]), removedNodes);

    // If the modified element contains redacted children, we need to propagate a change
    // for each of the redacted children as the parent size can affect the children size
    for (const node of modifiedNodes) {
      for (const redactedNode of _classPrivateFieldGet(_redactedCache, this)) {
        if (node.contains(redactedNode)) {
          modified.add(redactedNode);
        }
      }
    }

    // if the element was modified in a way that it is no longer redacted, we
    // appended to the list of added nodes
    for (const node of previousRedactedCache) {
      if (!_classPrivateFieldGet(_redactedCache, this).has(node) && !removedNodes.has(node)) {
        _NodeTree.default.depthFirst(node, n => {
          modified.add(n);
        });
      }
    }
    return modified;
  }
  isRedacted(node) {
    return Boolean(this.getRedactedBy(node));
  }
}
exports.RedactionIndex = RedactionIndex;
function _hasUnredacted(list) {
  const nodes = [...list];
  return nodes.find(n => !_NodeTree.default.isIgnored(n) && _assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, n)) || nodes.find(n => _assertClassBrand(_RedactionIndex_brand, this, _getProjectedUnredaction).call(this, n).length > 0);
}
function _updateCaches(addedNodes, modifiedNodes, removedNodes) {
  _assertClassBrand(_RedactionIndex_brand, this, _updateUnredactedCache).call(this, addedNodes, modifiedNodes, removedNodes);
  _assertClassBrand(_RedactionIndex_brand, this, _updateRedactedCache).call(this, modifiedNodes, removedNodes);
}
function _updateUnredactedCache(addedNodes, modifiedNodes, removedNodes) {
  for (const removed of _assertClassBrand(_RedactionIndex_brand, this, _processUnredactionCache).call(this, removedNodes)) {
    _classPrivateFieldGet(_unredactedCache, this).delete(removed);
  }
  for (const added of _assertClassBrand(_RedactionIndex_brand, this, _processUnredactionCache).call(this, addedNodes)) {
    _classPrivateFieldGet(_unredactedCache, this).add(added);
  }
  for (const modified of modifiedNodes) {
    // added nodes are included in modified nodes, but there's more expensive calculations
    // for those. As a result we can skip them here.
    if (!addedNodes.has(modified)) {
      if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, modified)) {
        _classPrivateFieldGet(_unredactedCache, this).add(modified);
      } else {
        _classPrivateFieldGet(_unredactedCache, this).delete(modified);
      }
    }
  }
}
function _updateRedactedCache(modifiedNodes, removedNodes) {
  for (const removed of removedNodes) {
    _classPrivateFieldGet(_redactedCache, this).delete(removed);
  }

  // the modified nodes are the ones that were added or modified
  // this is a result of the handling of mutations within the PatchStream._domChange
  for (const modified of modifiedNodes) {
    _assertClassBrand(_RedactionIndex_brand, this, _updateRedactionCache).call(this, modified);
  }
}
function* _processUnredactionCache(nodes) {
  for (const node of nodes) {
    if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, node)) {
      yield node;
    }
  }
}
/**
 * Returns the element that redacts the passed node through an admin selector
 * or an always redacted HTML tag. Both this selectors are always redacted.
 * It returns the node itself if directly redacted or a parent node that is
 * directly redacted
 */
function _getRedactedByPriority(node) {
  const selectors = [..._classPrivateFieldGet(_redactedTagNames, this)];
  if (_assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, node, selectors)) {
    return node;
  }
  return [...(0, _src.parents)(node)].find(n => _assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, n, selectors));
}
/**
 * Given a list of modified elements updates the redaction cache accordingly
 * if any of the nodes modified has stopped or became redacted
 */
function _updateRedactionCache(node) {
  const hasRedacted = _classPrivateFieldGet(_redactedCache, this).has(node);
  if (hasRedacted && this.getRedactedBy(node) !== node) {
    _classPrivateFieldGet(_redactedCache, this).delete(node);
  } else if (!hasRedacted && this.getRedactedBy(node) === node) {
    _classPrivateFieldGet(_redactedCache, this).add(node);
  }
}
function _expandAffectedUnredaction(nodes) {
  const ancestors = new Set([...nodes].flatMap(n => [n, ...(0, _src.parents)(n)]));
  return [...ancestors].flatMap(a => [...(a.childNodes || [])]);
}
function _isDirectRedaction(node) {
  return _assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, node, _classPrivateFieldGet(_redactedSelector, this));
}
function _isDirectUnredaction(node) {
  return _assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, node, _classPrivateFieldGet(_unredactedSelector, this));
}
/**
 * Find the closest ancestor that is directly redacted, if any.
 *
 * This takes into consideration:
 *
 *  - Nodes that are directly redacted by a redaction selector; and
 *  - Nodes that are directly redacted because they are projected redaction
 *    AND their parent is projected unredaction
 */
function _getProjectedRedactionBy(node) {
  const projectedRedactionBy = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedRedactionBySelector).call(this, node);
  if (projectedRedactionBy) {
    return (0, _src.parents)(node, projectedRedactionBy).find(a => _assertClassBrand(_RedactionIndex_brand, this, _isProjectedUnredaction).call(this, a.parentNode)) || projectedRedactionBy;
  } else {
    return null;
  }
}
/**
 * Find the closest ancestor that matches either a redaction or unredaction
 * selector, and return it only if it matches the redaction selector.
 *
 * If no ancestor matches a selector, or the closest ancestor that does is
 * marked unredacted, then this returns `null`.
 *
 * The reason for using a combination of the redacted and unredacted selectors
 * to find the closest ancestor is because when a redacted node projects
 * redaction to its descendants, that projection ends at a node that is
 * unredacted. For example:
 *
 * ```
 * <div id="a" redacted>
 *   <div id="b" unredacted>
 *     <div id="c"></div>
 *   </div>
 *   <div id="d"></div>
 * </div>
 * ```
 *
 * In this example, `#c` is not projected redaction by selector, because there
 * is an `[unredacted]` as its closest ancestor that matches either
 * redacted/unredacted. `#d` is projected redaction by selector.
 *
 * Note: This will accurately tell you if a node is projected redaction, but
 * it won't accurately tell you the closest ancestor that is directly
 * redacted (as opposed to indirectly redacted). Use #getProjectedRedactionBy
 * for that.
 */
function _getProjectedRedactionBySelector(node) {
  // this might be called with a serialized object from the NodeSerializer when parsing xdoc iframe messages
  if (!_nodes.NodeUtils.isDOMNode(node)) return null;
  const {
    get: parentNode
  } = Object.getOwnPropertyDescriptor(_unpolyfill.Node.prototype, 'parentNode');
  const combinedSelectors = _assertClassBrand(_RedactionIndex_brand, this, _combineSelectors).call(this, _classPrivateFieldGet(_redactedSelector, this), _classPrivateFieldGet(_unredactedSelector, this));
  // Salesforce lightning components mess with the parent node API so we use the unpolyfil'd version
  // to ensure we can get the correct parentNode
  const parentElem = node && node.nodeType === _unpolyfill.Node.ELEMENT_NODE && parentNode.call(node);
  const closestElem = parentElem && parentElem.nodeType === _unpolyfill.Node.ELEMENT_NODE && combinedSelectors && parentElem.closest(combinedSelectors);
  if (_assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, closestElem, _classPrivateFieldGet(_redactedSelector, this))) {
    // Before we return the node that is projecting redaction, we have to
    // first consider that there is an intermediary ancestor that is redacted
    // as a result of having a parent that is projected unredaction
    return closestElem;
  } else {
    return null;
  }
}
/** Determine if the node has any descendent that matches an unredaction selector. */
function _isProjectedUnredaction(node) {
  // TODO: This does not project across iframe boundaries, which is a known issue but outscoped
  return _classPrivateFieldGet(_unredactedSelector, this) && node && node.tagName !== 'HTML' && node.querySelector && node.querySelector(_classPrivateFieldGet(_unredactedSelector, this));
}
function _getProjectedUnredaction(node) {
  return _assertClassBrand(_RedactionIndex_brand, this, _findDescendants).call(this, node, _classPrivateFieldGet(_unredactedSelector, this));
}
/** Find all descendents that match the provided selector. */
function _findDescendants(node, selectors) {
  if (selectors && node.querySelectorAll) {
    // TODO: This does not project across iframe boundaries, which is a known issue but outscoped
    // Get all unredacted nodes projecting unredaction to the specified node
    return node.querySelectorAll(selectors);
  } else {
    return [];
  }
}
/** Determine if the specified node matches a CSS selector. */
function _matches(node, selector) {
  return node && selector && node.matches && node.matches(selector);
}
function _combineSelectors() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }
  return selectors.filter(Boolean).join(',');
}

/***/ }),

/***/ 39702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.RedactionIndexProvider');
var _index = /*#__PURE__*/new WeakMap();
class RedactionIndexProvider {
  constructor() {
    _classPrivateFieldInitSpec(this, _index, void 0);
  }
  set instance(redactionIndex) {
    _classPrivateFieldSet(_index, this, redactionIndex);
    debug('set new redaction index');
  }
  get instance() {
    return _classPrivateFieldGet(_index, this);
  }
}
var _default = exports["default"] = new RedactionIndexProvider();

/***/ }),

/***/ 8111:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(46449);
__webpack_require__(26910);
__webpack_require__(93514);
__webpack_require__(27495);
__webpack_require__(62953);
var _globToRegexp = _interopRequireDefault(__webpack_require__(37047));
var _UniversalHooks = _interopRequireDefault(__webpack_require__(11191));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _getRedactionUrl = /*#__PURE__*/new WeakMap();
var _getSelectorsByUrl = /*#__PURE__*/new WeakMap();
class TargetedRedaction {
  constructor() {
    _classPrivateFieldInitSpec(this, _getRedactionUrl, () => _UniversalHooks.default.unproxify(window.location.href));
    _classPrivateFieldInitSpec(this, _getSelectorsByUrl, (selectors, url) => {
      if (!selectors) return selectors;
      const filteredSelectors = selectors.map(selector => {
        if (typeof selector === 'string') return selector;
        if (typeof selector === 'object') {
          return Object.entries(selector).filter(_ref => {
            let [key] = _ref;
            const urlRegExp = (0, _globToRegexp.default)(key, {
              flags: 'i'
            });
            return urlRegExp.test(url);
          }).map(_ref2 => {
            let [_, value] = _ref2;
            return value;
          });
        }
        return null;
      }).filter(Boolean).flat(2);
      return [...new Set(filteredSelectors)];
    });
    _defineProperty(this, "filterSelectors", selectors => {
      const redactionUrl = _classPrivateFieldGet(_getRedactionUrl, this).call(this);
      return _classPrivateFieldGet(_getSelectorsByUrl, this).call(this, selectors, redactionUrl);
    });
    _defineProperty(this, "hasChange", (selectors, previousRedactionUrl) => {
      if (!selectors) return false;
      if (!previousRedactionUrl) return true;
      const previousSelectors = _classPrivateFieldGet(_getSelectorsByUrl, this).call(this, selectors, previousRedactionUrl);
      const currentSelectors = _classPrivateFieldGet(_getSelectorsByUrl, this).call(this, selectors, _classPrivateFieldGet(_getRedactionUrl, this).call(this));
      if (previousSelectors.length !== currentSelectors.length) return true;
      const sortedPreviousSelectors = [...previousSelectors].sort();
      const sortedCurrentSelectors = [...currentSelectors].sort();
      return !sortedPreviousSelectors.every((value, index) => value === sortedCurrentSelectors[index]);
    });
  }
}
var _default = exports["default"] = new TargetedRedaction();

/***/ }),

/***/ 16566:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "RedactionIndex", ({
  enumerable: true,
  get: function () {
    return _RedactionIndex.RedactionIndex;
  }
}));
Object.defineProperty(exports, "RedactionIndexProvider", ({
  enumerable: true,
  get: function () {
    return _RedactionIndexProvider.default;
  }
}));
Object.defineProperty(exports, "TargetedRedaction", ({
  enumerable: true,
  get: function () {
    return _TargetedRedaction.default;
  }
}));
var _RedactionIndex = __webpack_require__(2615);
var _RedactionIndexProvider = _interopRequireDefault(__webpack_require__(39702));
var _TargetedRedaction = _interopRequireDefault(__webpack_require__(8111));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 32976:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _dompurify = _interopRequireDefault(__webpack_require__(25454));
var _nodes = __webpack_require__(66938);
var _redaction = __webpack_require__(16566);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.ControlEvents');
class ControlEvents {
  constructor() {
    _defineProperty(this, "_applyScroll", (target, event) => {
      const tgt = target.defaultView || target;
      if (tgt.scrollTo) tgt.scrollTo(event.x, event.y);else {
        tgt.scrollTop = event.y;
        tgt.scrollLeft = event.x;
      }
    });
    _defineProperty(this, "_updateCheckbox", (target, _ref) => {
      let {
        checked
      } = _ref;
      if (typeof checked !== 'undefined' && target.tagName === 'INPUT' && typeof target.checked !== 'undefined') {
        const descriptor = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'checked');
        if (descriptor) descriptor.set.call(target, checked);
      }
    });
    _defineProperty(this, "_updateInnerHTML", (target, _ref2) => {
      let {
        innerHTML
      } = _ref2;
      if (typeof innerHTML !== 'undefined') {
        const parser = new DOMParser();
        const html = parser.parseFromString(_dompurify.default.sanitize(innerHTML), 'text/html');
        target.replaceChildren(...html.body.children);
      }
    });
    _defineProperty(this, "_updateValue", (target, _ref3) => {
      let {
        value,
        selectedOptions
      } = _ref3;
      // some frameworks (e.g. react) wrap the value setter, so we need
      // to make sure we're calling the browsers version without those wrappers
      // https://github.com/assaf/zombie/issues/1123
      if (typeof value !== 'undefined') {
        const descriptor = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
        if (descriptor) descriptor.set.call(target, value);
      }
      // IE 11 hack: textarea text node gets replaced when it's udpated, but the mutation
      // observer doesn't get an event, so we need to manually force the tracking of the
      // new node
      if (target.tagName === 'TEXTAREA') {
        _nodes.NodeTracker.track(target.childNodes[0]);
      }
      if (target.tagName === 'SELECT' && selectedOptions != null) {
        [...target.options].forEach(opt => {
          opt.selected = selectedOptions.includes(opt.value);
        });
      }
    });
    _defineProperty(this, "_updateTarget", (target, event) => {
      this._updateValue(target, event.target);
      this._updateCheckbox(target, event.target);
      this._updateInnerHTML(target, event.target);
    });
    _defineProperty(this, "_generateMouse", (target, event) => {
      return new MouseEvent(event.state, {
        clientX: event.x * window.innerWidth,
        clientY: event.y * window.innerHeight,
        bubbles: true,
        cancelable: true,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generatePointer", (target, event) => {
      return new PointerEvent(event.state, {
        clientX: event.x * window.innerWidth,
        clientY: event.y * window.innerHeight,
        pointerId: event.pointerId,
        width: event.width,
        height: event.height,
        pressure: event.pressure,
        tangentialPressure: event.tangentialPressure,
        tiltX: event.tiltX,
        tiltY: event.tiltY,
        twist: event.twist,
        pointerType: event.pointerType,
        isPrimary: event.isPrimary,
        bubbles: true,
        cancelable: true,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateKeypress", (target, event) => {
      return new KeyboardEvent(event.state, {
        key: event.key,
        code: event.code,
        ctrlKey: event.ctrlKey,
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        metaKey: event.metaKey,
        charCode: event.charCode,
        keyCode: event.keyCode,
        which: event.which,
        bubbles: true,
        cancelable: true,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateFocus", (target, event) => {
      return new FocusEvent(event.state, {
        bubbles: ['focusin', 'focusout'].includes(event.state),
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateChange", (target, event) => {
      return new CustomEvent(event.state, {
        bubbles: true,
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateInput", (target, event) => {
      return new CustomEvent(event.state, {
        bubbles: true,
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window,
        inputType: event.inputType,
        data: event.data
      });
    });
    _defineProperty(this, "_generateSelection", (target, event) => {
      return new CustomEvent('selection', {
        bubbles: true,
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window,
        selection: event.selection
      });
    });
    _defineProperty(this, "_generateEvent", (type, target, event) => {
      if (event.state.includes('move')) debug('generate', event, 'on', target);
      switch (type) {
        case 'keypress':
          return this._generateKeypress(target, event);
        case 'mouse':
          return this._generateMouse(target, event);
        case 'pointer':
          return this._generatePointer(target, event);
        case 'change':
          return this._generateChange(target, event);
        case 'input':
          return this._generateInput(target, event);
        case 'focus':
          return this._generateFocus(target, event);
        case 'select':
          return this._generateSelection(target, event);
        default:
          {
            console.warn('CobrowseIO: unknown event type', type, event);
            return null;
          }
      }
    });
    _defineProperty(this, "_setSelection", (target, _ref4) => {
      let {
        selection
      } = _ref4;
      if (target.__cobrowse_user_selection_timestamp > Date.now() - 100) {
        return;
      }

      // input elements can emit Select events with a state of selectionchange but
      // they don't support getSelection, so we ignore the set selection in this case
      if (!target.getSelection) {
        return;
      }

      // Firefox can return null while calling getSelection https://bugzilla.mozilla.org/show_bug.cgi?id=827585
      if (!target.getSelection()) {
        return;
      }
      try {
        // if the selection didn't change, skip
        if (selection) {
          // clear any existing selection
          target.__last_agent_selection_ts = Date.now();
          target.getSelection().removeAllRanges();

          // firefox supports multiple selections
          // see: https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount
          selection.forEach(serializedRange => {
            const {
              start,
              startOffset,
              end,
              endOffset
            } = serializedRange;
            const range = document.createRange();
            const startNode = _nodes.NodeTracker.getById(start);
            const endNode = _nodes.NodeTracker.getById(end);
            range.setStart(startNode, startOffset);
            range.setEnd(endNode, endOffset);
            target.getSelection().addRange(range);
          });
        } else {
          target.getSelection().removeAllRanges();
        }
      } catch (err) {
        console.warn('Failed to apply selection', selection, err);
      }
    });
    _defineProperty(this, "_setInputSelection", (target, _ref5) => {
      let {
        selection
      } = _ref5;
      if (target.ownerDocument.__cobrowse_user_selection_timestamp > Date.now() - 100) {
        return;
      }
      const hasTextSelectionSupport = ['text', 'textarea', 'search', 'url'].includes(target.type);
      if (!hasTextSelectionSupport) {
        return;
      }
      try {
        target.ownerDocument.__last_agent_selection_ts = Date.now();
        if (selection) {
          const {
            start,
            end,
            direction
          } = selection;
          target.focus();
          target.setSelectionRange(start, end, direction);
        } else if (target.getRootNode({
          composed: true
        }).activeElement === target) {
          target.setSelectionRange(null, null);
        }
      } catch (err) {
        console.warn('Failed to select text', err);
      }
    });
    _defineProperty(this, "applyEvent", (type, event) => {
      var _RedactionIndexProvid;
      if (!event.target) return null;
      const target = _nodes.NodeTracker.getById(event.target.id);
      if (!target) return null;
      if ((_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid !== void 0 && _RedactionIndexProvid.isRedacted(target)) return null;
      try {
        var _target$_cobrowse_sup;
        if (type === 'scroll') return this._applyScroll(target, event);

        // Allow for supressing some events when preceeding events are cancelled.
        // See comment below for more detail.
        if ((_target$_cobrowse_sup = target._cobrowse_suppress_events) !== null && _target$_cobrowse_sup !== void 0 && _target$_cobrowse_sup.has(event.state)) {
          target._cobrowse_suppress_events.delete(event.state);
          if (target._cobrowse_suppress_events.size === 0) delete target._cobrowse_suppress_events.size;
          return null;
        }
        const evt = this._generateEvent(type, target, event);
        if (evt) {
          if (target.dispatchEvent(evt)) {
            if (['keydown', 'keypress', 'input'].includes(event.state)) this._updateTarget(target, event);
            if (['selectionchange'].includes(event.state)) this._setSelection(target, event);
            if (['select'].includes(event.state)) this._setInputSelection(target, event);
          } else {
            // If the event is cancelled (i.e. a user side JS handler called preventDefault())
            // we should try to respect that. On the agent side, we have no knowledge
            // of what JS event handlers might do, so the agent side will send ALL
            // events in a sequence that the browser generated.
            // For example, pressing a key in an <input> might generate
            //    keydown -> keypress -> input -> change -> keyup
            // However if the keydown is cancelled, many of those events would not actually
            // be triggered by the browser as there will be no change in input value.
            // This means we need some way to track when events have been cancelled and
            // ignore them here so they're not injected by cobrowse.
            // We do this by setting a flag on the target that will allow later event
            // generators to check if a previous event in the chain was cancelled.
            // This is a long way from perfect, but it's good enough for now.
            if (event.state === 'keydown') {
              target._cobrowse_suppress_events = new Set(['keypress', 'input']);
            } else if (event.state === 'keypress') {
              target._cobrowse_suppress_events = new Set(['input']);
            }
          }
        }
        return evt;
      } catch (e) {
        console.warn('Error while injecting event', type, e);
        return null;
      }
    });
  }
  isTypingInput(event) {
    if (event.target) {
      const target = _nodes.NodeTracker.getById(event.target.id);
      if (['text', 'email', 'number', 'password', 'search', 'tel', 'url', 'datetime', 'textarea'].includes(target === null || target === void 0 ? void 0 : target.type)) {
        return true;
      }
    }
    return false;
  }
}
var _default = exports["default"] = new ControlEvents();

/***/ }),

/***/ 83672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ControlEvents", ({
  enumerable: true,
  get: function () {
    return _ControlEvents.default;
  }
}));
var _ControlEvents = _interopRequireDefault(__webpack_require__(32976));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 42109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _HTTPError = _interopRequireDefault(__webpack_require__(82701));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class APIError extends _HTTPError.default {
  constructor(id, status, message) {
    super(status, message);
    this.id = id;
    this.name = 'APIError';
  }
}
exports["default"] = APIError;

/***/ }),

/***/ 82701:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class HTTPError extends Error {
  constructor(status, message) {
    super(message);
    this.status = status;
    this.name = 'HTTPError';
  }
}
exports["default"] = HTTPError;

/***/ }),

/***/ 53469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(35874);
__webpack_require__(62953);
var _events = __webpack_require__(37007);
var _isMatchWith = _interopRequireDefault(__webpack_require__(1045));
var _omit = _interopRequireDefault(__webpack_require__(90179));
var _isEqual = _interopRequireDefault(__webpack_require__(2404));
var _APIError = _interopRequireDefault(__webpack_require__(42109));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _headers = /*#__PURE__*/new WeakMap();
var _resource = /*#__PURE__*/new WeakMap();
var _createPromise = /*#__PURE__*/new WeakMap();
var _updatePromise = /*#__PURE__*/new WeakMap();
var _destroyPromise = /*#__PURE__*/new WeakMap();
var _parseResponse = /*#__PURE__*/new WeakMap();
class RESTResource extends _events.EventEmitter {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec(this, _headers, {});
    _classPrivateFieldInitSpec(this, _resource, {});
    _classPrivateFieldInitSpec(this, _createPromise, null);
    _classPrivateFieldInitSpec(this, _updatePromise, null);
    _classPrivateFieldInitSpec(this, _destroyPromise, null);
    _classPrivateFieldInitSpec(this, _parseResponse, async res => {
      if (res.status >= 400) {
        const err = await res.json();
        throw new _APIError.default(err.id, res.status, err.message);
      }
      if (!res.ok) {
        throw new Error('Failed to parse response, response not ok');
      }
      if (res.status === 204) return null;
      return await res.json();
    });
  }
  get _resource() {
    console.warn('The _resource property is private and should not be accessed directly. It will soon be removed entirely. Please update your implementation to use only the public APIs.');
    return _classPrivateFieldGet(_resource, this);
  }
  get resource() {
    return _classPrivateFieldGet(_resource, this);
  }
  url() {
    throw new Error('url() must be implemented');
  }
  id() {
    return this.field('id');
  }
  field(field) {
    return (_classPrivateFieldGet(_resource, this) || {})[field];
  }
  cache(fields) {
    _classPrivateFieldSet(_resource, this, _objectSpread(_objectSpread({}, _classPrivateFieldGet(_resource, this)), fields));
  }
  async fetch() {
    // if there's a request in progress wait for it, ignoring
    // any error as they are handled by the original caller
    await Promise.allSettled([_classPrivateFieldGet(_createPromise, this), _classPrivateFieldGet(_updatePromise, this), _classPrivateFieldGet(_destroyPromise, this)]);
    const res = await fetch(this.url(), {
      headers: (0, _omit.default)(this.headers(), ['Content-Type'])
    });
    return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
  }
  async create() {
    const performCreate = async () => {
      const res = await fetch(this.url(), {
        method: 'POST',
        headers: this.headers()
      });
      return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
    };
    _classPrivateFieldSet(_createPromise, this, performCreate());
    try {
      return await _classPrivateFieldGet(_createPromise, this);
    } finally {
      _classPrivateFieldSet(_createPromise, this, null);
    }
  }
  async update(newState) {
    const performUpdate = async newState => {
      if (newState && Object.keys(newState).length > 0 && (0, _isMatchWith.default)(_classPrivateFieldGet(_resource, this), newState, _isEqual.default)) return this;
      const res = await fetch(this.url(), {
        method: this.id() ? 'PUT' : 'POST',
        headers: this.headers(),
        body: JSON.stringify(newState)
      });
      return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
    };

    // if there's an in-flight update request wait to complete
    await Promise.allSettled([_classPrivateFieldGet(_updatePromise, this)]);
    _classPrivateFieldSet(_updatePromise, this, performUpdate(newState));
    try {
      return await _classPrivateFieldGet(_updatePromise, this);
    } finally {
      _classPrivateFieldSet(_updatePromise, this, null);
    }
  }
  async destroy() {
    const performDestroy = async () => {
      const res = await fetch(this.url(), {
        method: 'DELETE',
        headers: this.headers()
      });
      return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
    };
    _classPrivateFieldSet(_destroyPromise, this, performDestroy());
    try {
      return await _classPrivateFieldGet(_destroyPromise, this);
    } finally {
      _classPrivateFieldSet(_destroyPromise, this, null);
    }
  }
  updateResource(resource) {
    const copy = this.clone();
    _classPrivateFieldSet(_resource, this, resource || {});
    this.emit('updated', this, copy);
    return this;
  }
  clone(copy) {
    // ensure we have a copy in case there
    // is no clone method on the subclass
    if (copy) _classPrivateFieldSet(_resource, copy, _objectSpread({}, _classPrivateFieldGet(_resource, this)));
  }
  headers() {
    return _objectSpread(_objectSpread({}, RESTResource.headers()), _classPrivateFieldGet(_headers, this));
  }
  setHeader(header, value) {
    _classPrivateFieldGet(_headers, this)[header] = value;
  }
  getHeader(header) {
    return this.headers()[header];
  }
  static headers() {
    return _assertClassBrand(RESTResource, this, _globalHeaders)._;
  }
  static setHeader(header, value) {
    _globalHeaders._[header] = value;
  }
  static getHeader(header) {
    return _globalHeaders._[header];
  }
  static set api(api) {
    _api._ = api;
  }
  static get api() {
    return _api._;
  }
}
exports["default"] = RESTResource;
var _globalHeaders = {
  _: {}
};
var _api = {
  _: void 0
};

/***/ }),

/***/ 18111:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "RESTResource", ({
  enumerable: true,
  get: function () {
    return _RESTResource.default;
  }
}));
var _RESTResource = _interopRequireDefault(__webpack_require__(53469));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 52404:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _uuid = __webpack_require__(65392);
var _protected = __webpack_require__(37609);
var _SessionCapabilities = _interopRequireDefault(__webpack_require__(60086));
var _rest = __webpack_require__(18111);
var _device = __webpack_require__(21667);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.Session');
var _delegate = /*#__PURE__*/new WeakMap();
var _capabilities = /*#__PURE__*/new WeakMap();
var _metrics = /*#__PURE__*/new WeakMap();
var _setAuthToken = /*#__PURE__*/new WeakMap();
var _authToken = /*#__PURE__*/new WeakMap();
var _setMetrics = /*#__PURE__*/new WeakMap();
var _serialize = /*#__PURE__*/new WeakMap();
var _serializeSanitized = /*#__PURE__*/new WeakMap();
var _deserialize = /*#__PURE__*/new WeakMap();
var _compress = /*#__PURE__*/new WeakMap();
var _decompress = /*#__PURE__*/new WeakMap();
var _proxyToken = /*#__PURE__*/new WeakMap();
var _proxyUrl = /*#__PURE__*/new WeakMap();
class Session extends _rest.RESTResource {
  constructor(delegate) {
    var _this;
    super();
    _this = this;
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _capabilities, void 0);
    _classPrivateFieldInitSpec(this, _metrics, {});
    _classPrivateFieldInitSpec(this, _setAuthToken, token => {
      this.setHeader('X-CobrowseDeviceToken', token);
    });
    _classPrivateFieldInitSpec(this, _authToken, () => {
      return this.getHeader('X-CobrowseDeviceToken');
    });
    _defineProperty(this, "activate", () => {
      debug('activate session');
      return this.update({
        state: 'active',
        device: _device.Device.info,
        custom_data: _classPrivateFieldGet(_delegate, this).customData
      });
    });
    _defineProperty(this, "end", () => {
      debug('end session');
      return this.update({
        state: 'ended'
      });
    });
    _defineProperty(this, "code", () => {
      return this.field('code');
    });
    _defineProperty(this, "state", () => {
      return this.field('state');
    });
    _defineProperty(this, "isActive", () => {
      return this.state() === 'active';
    });
    _defineProperty(this, "isAuthorizing", () => {
      return this.state() === 'authorizing';
    });
    _defineProperty(this, "isPending", () => {
      return this.state() === 'pending';
    });
    _defineProperty(this, "isEnded", () => {
      return this.state() === 'ended';
    });
    _defineProperty(this, "redactionSelectors", () => {
      const selectors = this.field('redaction_selectors');
      if (Array.isArray(selectors)) return selectors;
      return [];
    });
    _defineProperty(this, "unredactionSelectors", () => {
      const selectors = this.field('unredaction_selectors');
      if (Array.isArray(selectors)) return selectors;
      return [];
    });
    _defineProperty(this, "agent", () => {
      return this.field('agent') || false;
    });
    _defineProperty(this, "requireConsent", () => {
      return this.field('require_consent');
    });
    _defineProperty(this, "endedReason", () => {
      return this.field('ended_reason');
    });
    _defineProperty(this, "fullDevice", () => {
      return this.field('full_device') === true || this.field('full_device') === 'on' || this.field('full_device') === 'requested';
    });
    _defineProperty(this, "setFullDevice", state => {
      const capabilitiesToToggle = ['laser', 'drawing', 'disappearing_ink', 'arrows', 'rectangles', 'pointer', 'scroll', 'select', 'keypress', 'cursor'];
      _classPrivateFieldGet(_capabilities, this).toggle(capabilitiesToToggle, state !== 'on');
      return this.update({
        full_device: state
      });
    });
    _defineProperty(this, "update", properties => {
      return super.update(_objectSpread({
        capabilities: _classPrivateFieldGet(_capabilities, this).toArray()
      }, properties));
    });
    _defineProperty(this, "scale", () => {
      return this.field('scale') || 0.5;
    });
    _defineProperty(this, "remoteControl", () => {
      // must default to "on" for remote control as older
      // server versions (<= 1.2) did not set this property
      // TODO: default to "off" when its feasilble to drop
      //       support for old servers
      return this.field('remote_control') || 'on';
    });
    _defineProperty(this, "setRemoteControl", state => {
      return this.update({
        remote_control: state
      });
    });
    _defineProperty(this, "allowRemoteControl", () => {
      return this.remoteControl() === 'on';
    });
    _defineProperty(this, "calling", () => {
      return this.field('calling');
    });
    _defineProperty(this, "setCalling", state => {
      return this.update({
        calling: state
      });
    });
    _defineProperty(this, "updateResource", resource => {
      const wasEnded = this.isEnded();
      super.updateResource(resource);
      if (this.isEnded() && !wasEnded) {
        this.emit('ended', this);
        this.removeAllListeners();
      }
      return this;
    });
    _defineProperty(this, "clone", () => {
      const copy = new Session(_classPrivateFieldGet(_delegate, this));
      super.clone(copy);
      return copy;
    });
    _classPrivateFieldInitSpec(this, _setMetrics, (0, _protected.protect)(this, 'setMetrics', function () {
      let metrics = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classPrivateFieldSet(_metrics, _this, _objectSpread(_objectSpread({}, _classPrivateFieldGet(_metrics, _this)), metrics));
      _this.emit('metrics.updated', _this);
    }));
    _classPrivateFieldInitSpec(this, _serialize, (0, _protected.protect)(this, 'serialize', () => {
      return _objectSpread(_objectSpread({}, this.resource), {}, {
        _locals: {
          token: _classPrivateFieldGet(_authToken, this).call(this)
        }
      });
    }));
    _classPrivateFieldInitSpec(this, _serializeSanitized, (0, _protected.protect)(this, 'serializeSanitized', () => {
      return {
        state: this.resource.state,
        redaction_selectors: this.resource.redaction_selectors
      };
    }));
    _classPrivateFieldInitSpec(this, _deserialize, (0, _protected.protect)(this, 'deserialize', serialized => {
      const meta = serialized._locals || {};
      delete serialized._locals;
      _classPrivateFieldGet(_setAuthToken, this).call(this, meta.token);
      this.updateResource(serialized);
      return this;
    }));
    _classPrivateFieldInitSpec(this, _compress, (0, _protected.protect)(this, 'compress', () => {
      return "".concat(this.resource.id, ":").concat(_classPrivateFieldGet(_authToken, this).call(this));
    }));
    _classPrivateFieldInitSpec(this, _decompress, (0, _protected.protect)(this, 'decompress', compressed => {
      const parsed = compressed.split(':');
      _classPrivateFieldGet(_deserialize, this).call(this, {
        _locals: {
          token: parsed[parsed.length - 1]
        },
        id: parsed.slice(0, -1).join(':')
      });
      return this;
    }));
    _classPrivateFieldInitSpec(this, _proxyToken, (0, _protected.protect)(this, 'proxyToken', () => {
      return this.field('proxy_token');
    }));
    _classPrivateFieldInitSpec(this, _proxyUrl, (0, _protected.protect)(this, 'proxyUrl', () => {
      return this.field('proxy_url');
    }));
    if (!delegate) throw new Error('Session delegate is required');
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_capabilities, this, new _SessionCapabilities.default(delegate.capabilities));
    // Make sure we've assigned a token for this session
    // The session auth tokens may be exposed in URLs, but we
    // don't want to expose the device token directly, so we
    // derive a token from the device token for this purpose
    const salt = Math.ceil(Date.now() / (60 * 60 * 1000));
    _classPrivateFieldGet(_setAuthToken, this).call(this, (0, _uuid.v5)(salt + '', _device.Device.deviceToken()));
  }
  get capabilities() {
    const capabilities = this.field('capabilities');
    if (capabilities == null) return _classPrivateFieldGet(_capabilities, this).toArray();
    return _classPrivateFieldGet(_capabilities, this).toArray().filter(capability => capabilities === null || capabilities === void 0 ? void 0 : capabilities.includes(capability));
  }
  url() {
    const id = this.id() || this.code();
    return new URL("api/1/sessions".concat(id ? "/".concat(id) : ''), Session.api).toString();
  }
  get created() {
    return new Date(this.field('created'));
  }
  get expires() {
    return new Date(this.field('expires'));
  }
  get activated() {
    return this.field('activated') ? new Date(this.field('activated')) : null;
  }
  get updated() {
    return this.field('updated') ? new Date(this.field('updated')) : null;
  }
  get ended() {
    return this.field('ended') ? new Date(this.field('ended')) : null;
  }
  get metrics() {
    return _classPrivateFieldGet(_metrics, this);
  }
}
exports["default"] = Session;

/***/ }),

/***/ 60086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _capabilities = /*#__PURE__*/new WeakMap();
class SessionCapabilities {
  constructor(capabilities) {
    _classPrivateFieldInitSpec(this, _capabilities, {});
    this.fill(capabilities);
  }
  fill(capabilities) {
    _classPrivateFieldSet(_capabilities, this, capabilities.reduce((accumulator, capability) => {
      accumulator[capability] = true;
      return accumulator;
    }, {}));
    return this;
  }
  all() {
    return _classPrivateFieldGet(_capabilities, this);
  }
  toArray() {
    return Object.keys(_classPrivateFieldGet(_capabilities, this)).filter(key => _classPrivateFieldGet(_capabilities, this)[key]);
  }
  toggle(capabilities, state) {
    if (!Array.isArray(capabilities)) {
      capabilities = [capabilities];
    }
    capabilities.filter(capability => capability in _classPrivateFieldGet(_capabilities, this)).forEach(capability => {
      _classPrivateFieldGet(_capabilities, this)[capability] = state;
    });
    return this;
  }
}
exports["default"] = SessionCapabilities;

/***/ }),

/***/ 57089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.SESSION_CAPABILITY_TYPE_UNIVERSAL = exports.SESSION_CAPABILITY_TYPE_SELECT = exports.SESSION_CAPABILITY_TYPE_SCROLL = exports.SESSION_CAPABILITY_TYPE_RECTANGLES = exports.SESSION_CAPABILITY_TYPE_POINTER = exports.SESSION_CAPABILITY_TYPE_LASER = exports.SESSION_CAPABILITY_TYPE_KEYPRESS = exports.SESSION_CAPABILITY_TYPE_HIGHLIGHT = exports.SESSION_CAPABILITY_TYPE_FULL_DEVICE = exports.SESSION_CAPABILITY_TYPE_DRAWING = exports.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK = exports.SESSION_CAPABILITY_TYPE_CURSOR = exports.SESSION_CAPABILITY_TYPE_CALLING = exports.SESSION_CAPABILITY_TYPE_ARROWS = void 0;
const SESSION_CAPABILITY_TYPE_POINTER = exports.SESSION_CAPABILITY_TYPE_POINTER = 'pointer';
const SESSION_CAPABILITY_TYPE_SCROLL = exports.SESSION_CAPABILITY_TYPE_SCROLL = 'scroll';
const SESSION_CAPABILITY_TYPE_SELECT = exports.SESSION_CAPABILITY_TYPE_SELECT = 'select';
const SESSION_CAPABILITY_TYPE_KEYPRESS = exports.SESSION_CAPABILITY_TYPE_KEYPRESS = 'keypress';
const SESSION_CAPABILITY_TYPE_DRAWING = exports.SESSION_CAPABILITY_TYPE_DRAWING = 'drawing';
const SESSION_CAPABILITY_TYPE_ARROWS = exports.SESSION_CAPABILITY_TYPE_ARROWS = 'arrows';
const SESSION_CAPABILITY_TYPE_RECTANGLES = exports.SESSION_CAPABILITY_TYPE_RECTANGLES = 'rectangles';
const SESSION_CAPABILITY_TYPE_LASER = exports.SESSION_CAPABILITY_TYPE_LASER = 'laser';
const SESSION_CAPABILITY_TYPE_DISAPPEARING_INK = exports.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK = 'disappearing_ink';
const SESSION_CAPABILITY_TYPE_FULL_DEVICE = exports.SESSION_CAPABILITY_TYPE_FULL_DEVICE = 'full_device';
const SESSION_CAPABILITY_TYPE_CURSOR = exports.SESSION_CAPABILITY_TYPE_CURSOR = 'cursor';
const SESSION_CAPABILITY_TYPE_UNIVERSAL = exports.SESSION_CAPABILITY_TYPE_UNIVERSAL = 'universal';
const SESSION_CAPABILITY_TYPE_HIGHLIGHT = exports.SESSION_CAPABILITY_TYPE_HIGHLIGHT = 'highlight';
const SESSION_CAPABILITY_TYPE_CALLING = exports.SESSION_CAPABILITY_TYPE_CALLING = 'calling';
var _default = exports["default"] = [SESSION_CAPABILITY_TYPE_POINTER, SESSION_CAPABILITY_TYPE_SCROLL, SESSION_CAPABILITY_TYPE_SELECT, SESSION_CAPABILITY_TYPE_KEYPRESS, SESSION_CAPABILITY_TYPE_DRAWING, SESSION_CAPABILITY_TYPE_ARROWS, SESSION_CAPABILITY_TYPE_RECTANGLES, SESSION_CAPABILITY_TYPE_DISAPPEARING_INK, SESSION_CAPABILITY_TYPE_LASER, SESSION_CAPABILITY_TYPE_FULL_DEVICE, SESSION_CAPABILITY_TYPE_CURSOR, SESSION_CAPABILITY_TYPE_UNIVERSAL, SESSION_CAPABILITY_TYPE_HIGHLIGHT, SESSION_CAPABILITY_TYPE_CALLING];

/***/ }),

/***/ 30729:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _isEqual = _interopRequireDefault(__webpack_require__(2404));
var _uuid = __webpack_require__(65392);
var _SessionSockets = _interopRequireDefault(__webpack_require__(90324));
var _frames = __webpack_require__(8647);
var _activity = __webpack_require__(45264);
var _ui = __webpack_require__(33035);
var _remotecontrol = __webpack_require__(83672);
var _redaction = __webpack_require__(16566);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _SessionCapabilityTypes = __webpack_require__(57089);
var _SessionEventTypes = __webpack_require__(68325);
var _navigation2 = __webpack_require__(49715);
var _pdf = __webpack_require__(11065);
var _universal = __webpack_require__(91834);
var _XDocHandler = _interopRequireDefault(__webpack_require__(6900));
var _Navigation = __webpack_require__(44661);
var _documents = __webpack_require__(89689);
var _WindowTaps = _interopRequireDefault(__webpack_require__(44153));
var _NodeContent = __webpack_require__(49931);
var _SessionStateOverlay = _interopRequireDefault(__webpack_require__(94340));
var _ClientTracker = __webpack_require__(14162);
var _getPersistentId = __webpack_require__(37195);
var _calling = __webpack_require__(24719);
var _iframes = _interopRequireDefault(__webpack_require__(77966));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.SessionContext');
const debugEvents = (0, _debug.default)('cbio.SessionContext.events');
var _sockets = /*#__PURE__*/new WeakMap();
var _frameId = /*#__PURE__*/new WeakMap();
var _frameLoop = /*#__PURE__*/new WeakMap();
var _lastSyncId = /*#__PURE__*/new WeakMap();
var _confirmingSession = /*#__PURE__*/new WeakMap();
var _documentCollection = /*#__PURE__*/new WeakMap();
var _navigation = /*#__PURE__*/new WeakMap();
var _clientTracker = /*#__PURE__*/new WeakMap();
var _callHandler = /*#__PURE__*/new WeakMap();
var _onStreamOpen = /*#__PURE__*/new WeakMap();
var _onSessionStateOverlayClick = /*#__PURE__*/new WeakMap();
var _shouldNavigate = /*#__PURE__*/new WeakMap();
var _SessionContext_brand = /*#__PURE__*/new WeakSet();
var _onNavigate = /*#__PURE__*/new WeakMap();
var _onRemoteErrorEvent = /*#__PURE__*/new WeakMap();
var _onSyncEvent = /*#__PURE__*/new WeakMap();
var _onLaserEvent = /*#__PURE__*/new WeakMap();
var _onHighlightEvent = /*#__PURE__*/new WeakMap();
var _onDrawingEvent = /*#__PURE__*/new WeakMap();
var _onControlEvent = /*#__PURE__*/new WeakMap();
var _onClientEvent = /*#__PURE__*/new WeakMap();
var _updateSessionControls = /*#__PURE__*/new WeakMap();
var _updateRedaction = /*#__PURE__*/new WeakMap();
var _hasRedactionChanges = /*#__PURE__*/new WeakMap();
var _runConfirmSession = /*#__PURE__*/new WeakMap();
var _requestRemoteControl = /*#__PURE__*/new WeakMap();
var _requestFullDevice = /*#__PURE__*/new WeakMap();
var _pickFrameSource = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _sendEvent = /*#__PURE__*/new WeakMap();
var _sendFocusEvent = /*#__PURE__*/new WeakMap();
var _sendScreenEvent = /*#__PURE__*/new WeakMap();
var _sendDOMFrame = /*#__PURE__*/new WeakMap();
var _sendFrame = /*#__PURE__*/new WeakMap();
var _sendClickEvent = /*#__PURE__*/new WeakMap();
var _sendChangeEvent = /*#__PURE__*/new WeakMap();
var _sendMouseEvent = /*#__PURE__*/new WeakMap();
var _startFrames = /*#__PURE__*/new WeakMap();
class SessionContext {
  constructor(_session, delegate) {
    _classPrivateMethodInitSpec(this, _SessionContext_brand);
    _classPrivateFieldInitSpec(this, _sockets, void 0);
    _classPrivateFieldInitSpec(this, _frameId, void 0);
    _classPrivateFieldInitSpec(this, _frameLoop, new _frames.FrameLoop());
    _classPrivateFieldInitSpec(this, _lastSyncId, void 0);
    _classPrivateFieldInitSpec(this, _confirmingSession, void 0);
    _classPrivateFieldInitSpec(this, _documentCollection, void 0);
    _classPrivateFieldInitSpec(this, _navigation, void 0);
    _classPrivateFieldInitSpec(this, _clientTracker, void 0);
    _classPrivateFieldInitSpec(this, _callHandler, void 0);
    _classPrivateFieldInitSpec(this, _onStreamOpen, () => {
      _classPrivateFieldGet(_sendFocusEvent, this).call(this);
      if (!_classPrivateFieldGet(_clientTracker, this)) {
        _classPrivateFieldSet(_clientTracker, this, new _ClientTracker.ClientTracker((0, _getPersistentId.getPersistentId)('_cobrowse_client_id'), (0, _uuid.v4)()));
        _classPrivateFieldGet(_clientTracker, this).on('ping', data => _classPrivateFieldGet(_sockets, this).stream.send('client', data));
        this.session.on('client', _classPrivateFieldGet(_onClientEvent, this));
      }
      if (!_classPrivateFieldGet(_callHandler, this)) _classPrivateFieldSet(_callHandler, this, new _calling.CallHandler(this.session, _classPrivateFieldGet(_clientTracker, this), _classPrivateFieldGet(_sockets, this).stream));
      _classPrivateFieldGet(_clientTracker, this).ping();
    });
    _classPrivateFieldInitSpec(this, _onSessionStateOverlayClick, target => {
      var _this$session;
      if (target === 'session-end' && (_this$session = this.session) !== null && _this$session !== void 0 && _this$session.isActive()) this.session.end();
      if (target === 'call-end') this.session.update({
        calling: 'off'
      });
    });
    _classPrivateFieldInitSpec(this, _shouldNavigate, type => {
      var _this$session2;
      if (!((_this$session2 = this.session) !== null && _this$session2 !== void 0 && _this$session2.isActive())) return false;
      if (type === _Navigation.NAVIGATION_TYPE.UNIVERSAL && !this.session.capabilities.includes(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_UNIVERSAL)) return false;
      return true;
    });
    _defineProperty(this, "handleNavigation", (url, target, windowFeatures, options) => {
      var _consentResult$then;
      const {
        name,
        go,
        type
      } = options;
      const {
        handle,
        document
      } = _classPrivateFieldGet(_documentCollection, this).resolveDocument(options.handle, name);
      const {
        windowProxy
      } = document;
      const nav = {
        continue: overrideTarget => {
          const handlerResult = _classPrivateFieldGet(_navigation, this).runHandler(url, overrideTarget || target, windowFeatures, _objectSpread(_objectSpread({}, options), {}, {
            document
          }));
          if (handlerResult.rewrittenUrl) return {
            rewrittenUrl: handlerResult.rewrittenUrl
          };
          if (handlerResult.document) _classPrivateFieldGet(_documentCollection, this).addDocument(handle, name, handlerResult.document);
          return {
            windowProxy
          };
        },
        replay: () => {
          go();
          return {
            windowProxy
          };
        }
      };
      if (!type) return nav.continue();

      // XDoc navigations don't require consent
      if (type === _Navigation.NAVIGATION_TYPE.XDOC) return nav.continue();
      const consentResult = this.delegate.confirmOpen(url, type);

      // handle sync consent result, no need to replay
      if (!consentResult) return {
        rewrittenUrl: url
      };
      if (consentResult === true) return nav.continue('_blank');

      // handle async consent result
      (_consentResult$then = consentResult.then) === null || _consentResult$then === void 0 || _consentResult$then.call(consentResult, accepted => {
        if (!accepted) return nav.replay();
        nav.continue('_blank');
      });
      return {
        windowProxy
      };
    });
    _defineProperty(this, "invalidateFrames", () => {
      if (_classPrivateFieldGet(_frameLoop, this).isRunning()) _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _defineProperty(this, "destroy", () => {
      debug('destroy session context');
      _classPrivateFieldGet(_onSessionEnded, this).call(this);
      _SessionStateOverlay.default.off('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
      if (_classPrivateFieldGet(_navigation, this)) _classPrivateFieldGet(_navigation, this).destroy();
      _classPrivateFieldSet(_navigation, this, null);
      _WindowTaps.default.off('navigate', _classPrivateFieldGet(_onNavigate, this));
      if (_classPrivateFieldGet(_sockets, this)) _classPrivateFieldGet(_sockets, this).close();
      _classPrivateFieldSet(_sockets, this, null);
      if (_classPrivateFieldGet(_frameLoop, this)) _classPrivateFieldGet(_frameLoop, this).destroy();
      _classPrivateFieldSet(_frameLoop, this, null);
      if (_classPrivateFieldGet(_callHandler, this)) _classPrivateFieldGet(_callHandler, this).destroy();
      _classPrivateFieldSet(_callHandler, this, null);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).destroy();
      _classPrivateFieldSet(_documentCollection, this, null);
      if (_classPrivateFieldGet(_clientTracker, this)) _classPrivateFieldGet(_clientTracker, this).destroy();
      _classPrivateFieldSet(_clientTracker, this, null);
      _activity.WindowTracking.off('activate', _classPrivateFieldGet(_sendFocusEvent, this));
      window.removeEventListener('focus', _classPrivateFieldGet(_sendFocusEvent, this), {
        capture: true,
        passive: true
      });
      window.removeEventListener('hashchange', _classPrivateFieldGet(_sendScreenEvent, this), {
        capture: true,
        passive: true
      });
      if (_activity.MouseTracking.onChange === _classPrivateFieldGet(_sendMouseEvent, this)) _activity.MouseTracking.onChange = null;
      _activity.InteractionTracking.off('click', _classPrivateFieldGet(_sendClickEvent, this));
      _activity.InteractionTracking.off('change', _classPrivateFieldGet(_sendChangeEvent, this));
      _iframes.default.off('click', _classPrivateFieldGet(_sendClickEvent, this));
      _iframes.default.off('change', _classPrivateFieldGet(_sendChangeEvent, this));
      if (this.session) {
        this.session.removeListener('update', _classPrivateFieldGet(_onSessionUpdated, this));
        this.session.removeListener('ended', _classPrivateFieldGet(_onSessionEnded, this));
        this.session.removeListener('sync', _classPrivateFieldGet(_onSyncEvent, this));
        this.session.removeListener('drawing', _classPrivateFieldGet(_onDrawingEvent, this));
        this.session.removeListener('laser', _classPrivateFieldGet(_onLaserEvent, this));
        this.session.removeListener('control', _classPrivateFieldGet(_onControlEvent, this));
        this.session.removeListener('remote-error', _classPrivateFieldGet(_onRemoteErrorEvent, this));
        this.session.removeListener('client', _classPrivateFieldGet(_onClientEvent, this));
      }
      document.removeEventListener('DOMContentLoaded', _classPrivateFieldGet(_updateSessionControls, this), {
        once: true
      });
      this.session = null;
    });
    _classPrivateFieldInitSpec(this, _onNavigate, (_window, previousUrl) => {
      _classPrivateFieldGet(_updateRedaction, this).call(this, this.session);
      _ui.Highlight.hide();

      // avoid an expensive operation if there are no changes in redaction selectors
      if (_redaction.TargetedRedaction.hasChange(this.delegate.redactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(this.delegate.unredactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(this.session.redactionSelectors(), previousUrl) || _redaction.TargetedRedaction.hasChange(this.session.unredactionSelectors(), previousUrl)) {
        this.invalidateFrames();
      }
    });
    _classPrivateFieldInitSpec(this, _onRemoteErrorEvent, async event => {
      const current = _classPrivateFieldGet(_frameLoop, this).getSource();
      if (!(current instanceof _frames.DOMFrameSource)) return;
      const {
        target,
        error: {
          cause
        }
      } = event;
      if (cause !== 'load-error') return;
      // TODO: remove backwards compatibility when frontend sends target as an object
      const nodeId = typeof target === 'string' ? target : target.id;
      await (0, _NodeContent.applyContentCache)(nodeId);
      current.partialSync(nodeId);
    });
    _classPrivateFieldInitSpec(this, _onSyncEvent, _ref => {
      let {
        id
      } = _ref;
      if (id && _classPrivateFieldGet(_lastSyncId, this) === id) return;
      _classPrivateFieldSet(_lastSyncId, this, id);
      _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _classPrivateFieldInitSpec(this, _onLaserEvent, event => {
      if (!_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) {
        return;
      }
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      _ui.LaserOverlay.update(event);
    });
    _classPrivateFieldInitSpec(this, _onHighlightEvent, async event => {
      debugEvents('on(highlight)', event);
      if (!_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) return;
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      await _ui.Highlight.highlight(this.delegate, event);
    });
    _classPrivateFieldInitSpec(this, _onDrawingEvent, event => {
      if (!_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) {
        return;
      }
      if (!event.image) _ui.AnnotationOverlay.hide(event.agent);
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      _ui.AnnotationOverlay.update(event);
    });
    _classPrivateFieldInitSpec(this, _onControlEvent, (type, event) => {
      if (type === 'focus' && !event.agent) {
        _activity.WindowTracking.resignActive();
      }
      if (!event.agent) return;
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      if (this.session.allowRemoteControl()) {
        if (this.session.capabilities.includes(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_CURSOR)) {
          _ui.RemoteCursor.update(type, event);
        }
        if (_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) {
          _remotecontrol.ControlEvents.applyEvent(type, event);
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onClientEvent, data => {
      _classPrivateFieldGet(_clientTracker, this).track(data);
    });
    _classPrivateFieldInitSpec(this, _updateSessionControls, session => {
      // check if context was destroyed while waiting for DOM
      if (!this.session) return;

      // then evaluate control state
      if (session.isActive()) {
        // if the body is available, show the controls right away
        if (document.body) this.delegate.showSessionControls(session);
        // otherwise wait for the dom content and then try
        else document.addEventListener('DOMContentLoaded', _classPrivateFieldGet(_updateSessionControls, this), {
          once: true
        });
      } else this.delegate.hideSessionControls(session);
    });
    _classPrivateFieldInitSpec(this, _updateRedaction, session => {
      _redaction.RedactionIndexProvider.instance = new _redaction.RedactionIndex(_redaction.TargetedRedaction.filterSelectors(this.delegate.redactedViews), _redaction.TargetedRedaction.filterSelectors(this.delegate.unredactedViews), _redaction.TargetedRedaction.filterSelectors(session.redactionSelectors()), _redaction.TargetedRedaction.filterSelectors(session.unredactionSelectors()));
    });
    _classPrivateFieldInitSpec(this, _hasRedactionChanges, (session, prevSession) => {
      const hasRedactionSelectorChanges = !(0, _isEqual.default)(session.redactionSelectors(), (prevSession === null || prevSession === void 0 ? void 0 : prevSession.redactionSelectors()) || []);
      const hasUnredactionSelectorChanges = !(0, _isEqual.default)(session.unredactionSelectors(), (prevSession === null || prevSession === void 0 ? void 0 : prevSession.unredactionSelectors()) || []);
      return hasRedactionSelectorChanges || hasUnredactionSelectorChanges;
    });
    _classPrivateFieldInitSpec(this, _runConfirmSession, async session => {
      // wait until an agent has actually joined the session and the
      // user has passed through the confirmSession flow before actually
      // activiating the session (starts stream sockets & frame loop)
      if (!session.agent() || session.isActive() || session.isEnded()) return null;

      // only try to confirm session acceptance once per context
      if (_classPrivateFieldGet(_confirmingSession, this)) return null;
      _classPrivateFieldSet(_confirmingSession, this, true);

      // skip auth prompt if the sessions allows
      if (!session.requireConsent()) return session.activate();
      try {
        // move state to authorizing
        debug('authorizing session');
        await session.update({
          state: 'authorizing'
        });

        // open confirmation dialog if context was not destroyed during async update
        if (!this.session || !session.isAuthorizing()) return null;

        // returning false from session confirmations will prevent session activiation
        // we accept null or udnefined or anything truthy as acceptance
        const accepted = await this.delegate.confirmSession(session);

        // check if context was destroyed while waiting for user confirmation
        if (!this.session) return null;
        if (accepted === false) {
          debug('user rejected session request');
          return session.end();
        } else {
          debug('session accepted');
          return session.activate();
        }
      } catch (e) {
        if (e) console.warn('CobrowseIO: error caught during confirmation', e);
        if (this.session) return session.end();
        return null;
      }
    });
    _classPrivateFieldInitSpec(this, _requestRemoteControl, async session => {
      if (session.remoteControl() !== 'requested') return null;
      try {
        // anything except false will allow remote control
        if ((await this.delegate.confirmRemoteControl()) === false) {
          debug('user rejeted remote control');
          return session.update({
            remote_control: 'rejected'
          });
        } else {
          debug('user accepted remote control');
          return session.update({
            remote_control: 'on'
          });
        }
      } catch (e) {
        if (e) console.warn('CobrowseIO: error caught during confirmation', e);
        return session.update({
          remote_control: 'rejected'
        });
      }
    });
    _classPrivateFieldInitSpec(this, _requestFullDevice, async () => {
      // prevent full device consent from being reprompted
      // legacy full_device is a boolean value
      const fullDevice = this.session.resource.full_device;
      if (fullDevice !== true && fullDevice !== 'requested') return false;
      if (!_activity.WindowTracking.isActive()) return false;
      if (!this.session.capabilities.includes(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_FULL_DEVICE)) {
        return;
      }
      try {
        const accepted = await this.delegate.confirmFullDevice();
        debug('full device request', accepted);
        if (!accepted) await this.session.setFullDevice('rejected');
        return accepted;
      } catch (_unused) {
        await this.session.setFullDevice('off');
        return false;
      }
    });
    _classPrivateFieldInitSpec(this, _pickFrameSource, async session => {
      if (session.isEnded() || !_classPrivateFieldGet(_frameLoop, this)) return null;
      const current = _classPrivateFieldGet(_frameLoop, this).getSource();
      if (session.fullDevice()) {
        if (!(current instanceof _frames.MediaStreamFrameSource)) {
          await _classPrivateFieldGet(_frameLoop, this).setSource(new _frames.MediaStreamFrameSource({
            handleFrame: _classPrivateFieldGet(_sendFrame, this),
            scale: session.scale,
            captureStarted: media => {
              session.setFullDevice('on');
              session.emit('media', media);
            },
            captureEnded: e => {
              if (e) console.warn('Full device mode failed: ', e);
              session.setFullDevice(e ? 'rejected' : 'off');
            },
            requestPermission: _classPrivateFieldGet(_requestFullDevice, this)
          }));
        }
      } else {
        if (!(current instanceof _frames.DOMFrameSource)) {
          _classPrivateFieldGet(_frameLoop, this).setSource(new _frames.DOMFrameSource(_classPrivateFieldGet(_sendDOMFrame, this)));
        }
      }
      _classPrivateFieldGet(_frameLoop, this).getSource().setCodecs(session.resource.video_codecs);
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, (session, prevSession) => {
      // check if context has been destroyed
      if (!this.session) {
        debug('onSessionUpdated called after destroy()');
        return;
      }
      _classPrivateFieldGet(_runConfirmSession, this).call(this, session);
      _classPrivateFieldGet(_updateSessionControls, this).call(this, session);
      _classPrivateFieldGet(_updateRedaction, this).call(this, session);
      if (_classPrivateFieldGet(_hasRedactionChanges, this).call(this, session, prevSession)) this.invalidateFrames();
      _classPrivateFieldGet(_requestRemoteControl, this).call(this, session);
      _classPrivateFieldGet(_pickFrameSource, this).call(this, session);
      if (session.isActive()) _classPrivateFieldGet(_startFrames, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, () => {
      _ui.AnnotationOverlay.hide();
      _ui.RemoteCursor.hide();
      _ui.LaserOverlay.hide();
      _ui.Highlight.hide();
      this.delegate.hideSessionControls(this.session);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).closeAllDocuments();
    });
    _classPrivateFieldInitSpec(this, _sendEvent, (event, data) => {
      if (!this.session || !this.session.isActive()) return false;
      if (!this.session.fullDevice() && !_activity.WindowTracking.isActive()) return false;
      if (!_classPrivateFieldGet(_sockets, this)) return false;
      if (!_classPrivateFieldGet(_sockets, this).stream) return false;
      if (!_classPrivateFieldGet(_sockets, this).stream.connected) return false;
      if (!_classPrivateFieldGet(_sockets, this).stream.bufferedAmount > 100) return false;
      _classPrivateFieldGet(_sockets, this).stream.send(event, data);
      return true;
    });
    _classPrivateFieldInitSpec(this, _sendFocusEvent, () => {
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'focus', {
        type: 'Focus',
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _sendScreenEvent, () => {
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'screen', {
        type: 'Screen',
        timestamp: new Date(),
        url: window.location.href,
        title: document.title
      });
    });
    _classPrivateFieldInitSpec(this, _sendDOMFrame, dom => {
      _classPrivateFieldSet(_frameId, this, (_classPrivateFieldGet(_frameId, this) || 0) + 1);
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'frame', {
        type: 'Frame',
        id: _classPrivateFieldGet(_frameId, this),
        data: dom,
        timestamp: new Date(),
        mime_type: 'application/x-cbio-vdom-patch'
      });
    });
    _classPrivateFieldInitSpec(this, _sendFrame, (data, mimeType, maxInFlight) => {
      if (_classPrivateFieldGet(_sockets, this).stream.messageLag() >= maxInFlight) {
        debug('dropped frame due to message lag', _classPrivateFieldGet(_sockets, this).stream.messageLag());
        return;
      }
      _classPrivateFieldSet(_frameId, this, (_classPrivateFieldGet(_frameId, this) || 0) + 1);
      _classPrivateFieldGet(_sendEvent, this).call(this, 'frame', {
        type: 'Frame',
        id: _classPrivateFieldGet(_frameId, this),
        data,
        timestamp: new Date(),
        mime_type: mimeType
      });
    });
    _classPrivateFieldInitSpec(this, _sendClickEvent, serializedTarget => {
      const position = _activity.MouseTracking.position();
      _classPrivateFieldGet(_sendEvent, this).call(this, 'mouse', {
        type: _SessionEventTypes.SESSION_EVENT_TYPE_MOUSE,
        x: position.x / window.innerWidth,
        y: position.y / window.innerHeight,
        target: serializedTarget,
        state: 'click',
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _sendChangeEvent, serializedTarget => {
      _classPrivateFieldGet(_sendEvent, this).call(this, 'change', {
        type: _SessionEventTypes.SESSION_EVENT_TYPE_CHANGE,
        target: serializedTarget,
        state: 'change',
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _sendMouseEvent, mouse => {
      let state = 'mouseout';
      if (mouse.in) state = mouse.down ? 'mousedown' : 'mouseup';
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'mouse', {
        type: _SessionEventTypes.SESSION_EVENT_TYPE_MOUSE,
        x: mouse.x / window.innerWidth,
        y: mouse.y / window.innerHeight,
        state,
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _startFrames, () => {
      if (!_classPrivateFieldGet(_frameLoop, this).isRunning()) {
        debug('start frames');
        _classPrivateFieldGet(_frameLoop, this).start();
      }
      return this;
    });
    debug('session context constructed');
    this.session = _session;
    this.delegate = delegate;
    _classPrivateFieldSet(_sockets, this, new _SessionSockets.default(_session));
    _activity.WindowTracking.on('activate', _classPrivateFieldGet(_sendFocusEvent, this));
    window.addEventListener('focus', _classPrivateFieldGet(_sendFocusEvent, this), {
      capture: true,
      passive: true
    });
    window.addEventListener('hashchange', _classPrivateFieldGet(_sendScreenEvent, this), {
      capture: true,
      passive: true
    });
    _activity.MouseTracking.onChange = _classPrivateFieldGet(_sendMouseEvent, this);
    _activity.InteractionTracking.on('click', _classPrivateFieldGet(_sendClickEvent, this));
    _activity.InteractionTracking.on('change', _classPrivateFieldGet(_sendChangeEvent, this));
    _iframes.default.on('click', _classPrivateFieldGet(_sendClickEvent, this));
    _iframes.default.on('change', _classPrivateFieldGet(_sendChangeEvent, this));
    _classPrivateFieldGet(_onSessionUpdated, this).call(this, _session);
    _session.on('updated', _classPrivateFieldGet(_onSessionUpdated, this));
    _session.on('ended', _classPrivateFieldGet(_onSessionEnded, this));
    _session.on('sync', _classPrivateFieldGet(_onSyncEvent, this));
    _session.on('highlight', _classPrivateFieldGet(_onHighlightEvent, this));
    _session.on('drawing', _classPrivateFieldGet(_onDrawingEvent, this));
    _session.on('laser', _classPrivateFieldGet(_onLaserEvent, this));
    _session.on('control', _classPrivateFieldGet(_onControlEvent, this));
    _session.on('remote-error', _classPrivateFieldGet(_onRemoteErrorEvent, this));
    _session.once('stream-open', _classPrivateFieldGet(_onStreamOpen, this));
    _classPrivateFieldSet(_documentCollection, this, new _documents.DocumentCollection({
      onDocumentAdded: document => this.delegate.showDocument(document)
    }));
    const pdfHandler = new _pdf.PDFHandler(_session, delegate);
    const universalHandler = new _universal.UniversalHandler(_session, delegate);
    const xdocHandler = new _XDocHandler.default(_session, delegate);
    _classPrivateFieldSet(_navigation, this, new _navigation2.Navigation({
      shouldNavigate: _classPrivateFieldGet(_shouldNavigate, this),
      handlers: [pdfHandler, universalHandler, xdocHandler],
      handleNavigation: this.handleNavigation
    }));
    _WindowTaps.default.on('navigate', _classPrivateFieldGet(_onNavigate, this));
    _SessionStateOverlay.default.on('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
  }
}
exports["default"] = SessionContext;
function _allowsEvent(event) {
  const events = {
    [_SessionEventTypes.SESSION_EVENT_TYPE_MOUSE]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_TOUCH]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_POINTER]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_FOCUS]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_KEYPRESS]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS],
    [_SessionEventTypes.SESSION_EVENT_TYPE_SCROLL]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SCROLL],
    [_SessionEventTypes.SESSION_EVENT_TYPE_CHANGE]: _remotecontrol.ControlEvents.isTypingInput(event) ? [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS] : [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_INPUT]: _remotecontrol.ControlEvents.isTypingInput(event) ? [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS] : [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_LASER]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_LASER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_HIGHLIGHT]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_HIGHLIGHT],
    [_SessionEventTypes.SESSION_EVENT_TYPE_DRAWING]: event.disappears_in != null ? [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK] : [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DRAWING, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_RECTANGLES, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_ARROWS],
    [_SessionEventTypes.SESSION_EVENT_TYPE_SELECT]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SELECT]
  };
  return events[event.type].some(capability => this.session.capabilities.includes(capability));
}

/***/ }),

/***/ 68325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SESSION_EVENT_TYPE_TOUCH = exports.SESSION_EVENT_TYPE_SELECT = exports.SESSION_EVENT_TYPE_SCROLL = exports.SESSION_EVENT_TYPE_POINTER = exports.SESSION_EVENT_TYPE_MOUSE = exports.SESSION_EVENT_TYPE_LASER = exports.SESSION_EVENT_TYPE_KEYPRESS = exports.SESSION_EVENT_TYPE_INPUT = exports.SESSION_EVENT_TYPE_HIGHLIGHT = exports.SESSION_EVENT_TYPE_FOCUS = exports.SESSION_EVENT_TYPE_DRAWING = exports.SESSION_EVENT_TYPE_CHANGE = void 0;
const SESSION_EVENT_TYPE_MOUSE = exports.SESSION_EVENT_TYPE_MOUSE = 'Mouse';
const SESSION_EVENT_TYPE_TOUCH = exports.SESSION_EVENT_TYPE_TOUCH = 'Touch';
const SESSION_EVENT_TYPE_POINTER = exports.SESSION_EVENT_TYPE_POINTER = 'Pointer';
const SESSION_EVENT_TYPE_FOCUS = exports.SESSION_EVENT_TYPE_FOCUS = 'Focus';
const SESSION_EVENT_TYPE_KEYPRESS = exports.SESSION_EVENT_TYPE_KEYPRESS = 'KeyPress';
const SESSION_EVENT_TYPE_SCROLL = exports.SESSION_EVENT_TYPE_SCROLL = 'Scroll';
const SESSION_EVENT_TYPE_CHANGE = exports.SESSION_EVENT_TYPE_CHANGE = 'Change';
const SESSION_EVENT_TYPE_INPUT = exports.SESSION_EVENT_TYPE_INPUT = 'Input';
const SESSION_EVENT_TYPE_LASER = exports.SESSION_EVENT_TYPE_LASER = 'Laser';
const SESSION_EVENT_TYPE_HIGHLIGHT = exports.SESSION_EVENT_TYPE_HIGHLIGHT = 'Highlight';
const SESSION_EVENT_TYPE_DRAWING = exports.SESSION_EVENT_TYPE_DRAWING = 'Drawing';
const SESSION_EVENT_TYPE_SELECT = exports.SESSION_EVENT_TYPE_SELECT = 'Select';

/***/ }),

/***/ 90324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(12041);
__webpack_require__(62953);
var _cocom = __webpack_require__(63439);
var _makeSocketUrl = _interopRequireDefault(__webpack_require__(56851));
var _protected = _interopRequireDefault(__webpack_require__(37609));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const SESSION_METRICS_INTERVAL_MS = 1000;
var _session = /*#__PURE__*/new WeakMap();
var _control = /*#__PURE__*/new WeakMap();
var _stream = /*#__PURE__*/new WeakMap();
var _sessionMetricsIntervalId = /*#__PURE__*/new WeakMap();
var _createSocket = /*#__PURE__*/new WeakMap();
var _openControl = /*#__PURE__*/new WeakMap();
var _openStream = /*#__PURE__*/new WeakMap();
class SessionSockets {
  constructor(session) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _control, void 0);
    _classPrivateFieldInitSpec(this, _stream, void 0);
    _classPrivateFieldInitSpec(this, _sessionMetricsIntervalId, void 0);
    _defineProperty(this, "open", () => {
      if (!_classPrivateFieldGet(_session, this).isEnded()) {
        _classPrivateFieldGet(_openControl, this).call(this);
        _classPrivateFieldGet(_openStream, this).call(this);
      }
    });
    _defineProperty(this, "close", () => {
      window.removeEventListener('visibilitychange', this.onVisibilityChange);
      if (_classPrivateFieldGet(_sessionMetricsIntervalId, this)) {
        clearInterval(_classPrivateFieldGet(_sessionMetricsIntervalId, this));
        _classPrivateFieldSet(_sessionMetricsIntervalId, this, null);
      }
      if (_classPrivateFieldGet(_session, this)) {
        _classPrivateFieldGet(_session, this).removeListener('updated', this.open);
        _classPrivateFieldSet(_session, this, null);
      }
      if (_classPrivateFieldGet(_stream, this)) {
        _classPrivateFieldGet(_stream, this).close();
        _classPrivateFieldSet(_stream, this, null);
      }
      if (_classPrivateFieldGet(_control, this)) {
        _classPrivateFieldGet(_control, this).close();
        _classPrivateFieldSet(_control, this, null);
      }
    });
    _classPrivateFieldInitSpec(this, _createSocket, (url, tokenField) => {
      const socket = new _cocom.CBORSocket({
        getUrl: () => (0, _makeSocketUrl.default)(url),
        getProtocols: () => ["cbio.http.headers.authorization.bearer.".concat(window.btoa(_classPrivateFieldGet(_session, this).field(tokenField)).replaceAll('=', ''))]
      });
      socket.on('error', err => {
        console.warn('CobrowseIO session socket error:', err);
      });
      return socket;
    });
    _classPrivateFieldInitSpec(this, _openControl, () => {
      const url = _classPrivateFieldGet(_session, this).field('control_url');
      const token = _classPrivateFieldGet(_session, this).field('control_token');
      if (url && token && !_classPrivateFieldGet(_control, this)) {
        _classPrivateFieldSet(_control, this, _classPrivateFieldGet(_createSocket, this).call(this, url, 'control_token'));
        _classPrivateFieldGet(_control, this).on('open', () => {
          _classPrivateFieldGet(_control, this).send('filter', {
            events: ['session']
          });
          _classPrivateFieldGet(_session, this).fetch().catch(err => {
            console.warn('CobrowseIO failed fetching session state', err);
          });
        });
        _classPrivateFieldGet(_control, this).on('event', (event, data) => {
          if (event === 'session') _classPrivateFieldGet(_session, this).updateResource(data);
        });
      }
    });
    _classPrivateFieldInitSpec(this, _openStream, () => {
      const url = _classPrivateFieldGet(_session, this).field('stream_url');
      const token = _classPrivateFieldGet(_session, this).field('stream_token');
      if (url && token && !_classPrivateFieldGet(_stream, this)) {
        _classPrivateFieldSet(_stream, this, _classPrivateFieldGet(_createSocket, this).call(this, url, 'stream_token'));
        _classPrivateFieldSet(_sessionMetricsIntervalId, this, setInterval(() => {
          const latency = Math.round(_classPrivateFieldGet(_stream, this).metrics.latency());
          _classPrivateFieldGet(_session, this)[_protected.default].setMetrics({
            latency
          });
        }, SESSION_METRICS_INTERVAL_MS));
        const annotation = ['highlight', 'drawing', 'laser', 'url'];
        const control = ['touch', 'mouse', 'pointer', 'keypress', 'scroll', 'focus', 'input', 'change', 'select'];
        _classPrivateFieldGet(_stream, this).on('event', (event, data) => {
          if (event === 'sync') _classPrivateFieldGet(_session, this).emit('sync', data);
          if (event === 'remote-error') _classPrivateFieldGet(_session, this).emit('remote-error', data);
          if (event === 'client') _classPrivateFieldGet(_session, this).emit('client', data);else if (event === 'probe') _classPrivateFieldGet(_stream, this).send('alive', data);else if (annotation.includes(event)) {
            _classPrivateFieldGet(_session, this).emit(event, data);
          } else if (control.includes(event)) {
            _classPrivateFieldGet(_session, this).emit('control', event, data);
          }
          _classPrivateFieldGet(_session, this)[_protected.default].setMetrics({
            last_alive: new Date()
          });
        });
        _classPrivateFieldGet(_stream, this).on('open', () => {
          _classPrivateFieldGet(_stream, this).send('filter', {
            events: [...control, ...annotation, 'sync', 'probe', 'remote-error', 'client', 'sdp', 'icecandidate']
          });
          _classPrivateFieldGet(_session, this).emit('stream-open');
        });
      }
    });
    _classPrivateFieldSet(_session, this, session);
    session.on('updated', this.open);
    session[_protected.default].setMetrics({
      last_alive: null,
      latency: null
    });
    this.open();
  }
  get stream() {
    return _classPrivateFieldGet(_stream, this);
  }
}
exports["default"] = SessionSockets;

/***/ }),

/***/ 73531:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SessionStorage = void 0;
__webpack_require__(62953);
var _ForwardingSessionStorage = __webpack_require__(99070);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.sessionStorage');
var _load = /*#__PURE__*/new WeakMap();
var _store = /*#__PURE__*/new WeakMap();
var _retain = /*#__PURE__*/new WeakMap();
class SessionStorage {
  static create(trustedOrigins, api, _ref) {
    let {
      localStorage
    } = _ref;
    if (trustedOrigins.length > 1) {
      // We always attempt to load from forwarding storage first. There can be
      // weird cases, such as coming from a domain that didn't have cross-origin
      // local storage support to a domain where it does (e.g., site on deny-list).
      // It doesn't hurt to just check if something was there, and if it was then
      // we almost definitely want to restore it
      const forwardingStorage = new _ForwardingSessionStorage.ForwardingSessionStorage();
      return new SessionStorage({
        load: [forwardingStorage, localStorage],
        store: [localStorage, forwardingStorage],
        retain: [localStorage]
      });
    } else {
      // We only need a storage configuration for a single domain
      return new SessionStorage({
        load: [localStorage],
        store: [localStorage],
        retain: [localStorage]
      });
    }
  }
  constructor(_ref2) {
    let {
      load = [],
      store = [],
      retain = []
    } = _ref2;
    _classPrivateFieldInitSpec(this, _load, void 0);
    _classPrivateFieldInitSpec(this, _store, void 0);
    _classPrivateFieldInitSpec(this, _retain, void 0);
    _classPrivateFieldSet(_load, this, load);
    _classPrivateFieldSet(_store, this, store);
    _classPrivateFieldSet(_retain, this, retain);
  }
  async load(delegate) {
    debug('loading session');
    /*
    * Storage implementations that will be used to try and load sessions. The load()
    * function of these implementations are traversed in order and the first non-falsey
    * result we get is the storage that is returned.
    */
    for (const s of _classPrivateFieldGet(_load, this)) {
      const found = await s.load(delegate);
      const updated = await (found === null || found === void 0 ? void 0 : found.fetch());
      if (updated) {
        if (updated.isActive()) return updated;else await s.store(null);
      }
    }
    return null;
  }
  async store(session) {
    debug('storing session');
    /*
     * Storage implementations that will have sessions stored into them. All storage
     * implementations will have their .store() functions called here when a session
     * update is being stored.
     */
    for (const s of _classPrivateFieldGet(_store, this)) {
      try {
        await s.store(session);
      } catch (e) {
        console.error("Unexpected error storing session: ".concat(s.constructor.name), e);
      }
    }
  }
  destroy() {
    const toDestroy = new Set([..._classPrivateFieldGet(_load, this), ..._classPrivateFieldGet(_store, this)].filter(s => !_classPrivateFieldGet(_retain, this).includes(s)));
    for (const s of toDestroy) {
      s.destroy();
    }
    _classPrivateFieldSet(_load, this, null);
    _classPrivateFieldSet(_store, this, null);
    _classPrivateFieldSet(_retain, this, null);
  }
}
exports.SessionStorage = SessionStorage;

/***/ }),

/***/ 72176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Session", ({
  enumerable: true,
  get: function () {
    return _Session.default;
  }
}));
Object.defineProperty(exports, "SessionCapabilities", ({
  enumerable: true,
  get: function () {
    return _SessionCapabilities.default;
  }
}));
Object.defineProperty(exports, "SessionContext", ({
  enumerable: true,
  get: function () {
    return _SessionContext.default;
  }
}));
var _Session = _interopRequireDefault(__webpack_require__(52404));
var _SessionContext = _interopRequireDefault(__webpack_require__(30729));
var _SessionCapabilities = _interopRequireDefault(__webpack_require__(60086));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 43443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ActiveSessionPath = void 0;
const ActiveSessionPath = exports.ActiveSessionPath = '_cobrowse_active_session';

/***/ }),

/***/ 99070:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ForwardingSessionStorage = void 0;
exports.extractActiveSession = extractActiveSession;
exports.rewriteUrlIfNecessary = rewriteUrlIfNecessary;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _protected = _interopRequireDefault(__webpack_require__(37609));
var _Session = _interopRequireDefault(__webpack_require__(52404));
var _Constants = __webpack_require__(43443);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.sessionStorage.ForwardingSessionStorage');
const dataOnLoad = extractActiveSession();
function extractActiveSession() {
  let {
    window: thisWindow = window
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  try {
    // Load data from the qs and clear it immediately regardless of if the
    // forwarding session storage is activated
    const url = new URL(thisWindow.location.href);
    const dataOnLoad = url.searchParams.get(_Constants.ActiveSessionPath);
    if (dataOnLoad) {
      debug('found forwarded session that can be loaded', dataOnLoad);
      url.searchParams.delete(_Constants.ActiveSessionPath);
      thisWindow.history.replaceState({}, '', url);
    } else {
      debug('no forwarded session to load', url);
    }
    return dataOnLoad;
  } catch (e) {
    console.warn('Failed to attempt to extract forwarded session', e);
  }
}
function rewriteUrlIfNecessary(url, sessionId) {
  let {
    window: thisWindow = window
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  try {
    const result = new URL(url);
    if (result.origin === thisWindow.location.origin) {
      debug('not rewriting url because we are not changing origin', result.toString());
      return url;
    }
    result.searchParams.set(_Constants.ActiveSessionPath, sessionId);
    debug('rewriting trusted url for an active session', {
      from: url,
      to: result.toString()
    });
    return typeof url === 'string' ? result.toString() : result;
  } catch (e) {
    debug('failed rewriting url', e);
    return url;
  }
}
var _activeSessionData = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
class ForwardingSessionStorage {
  constructor() {
    let {
      /** Any (optional) forwarded session data that could be loaded. */
      activeSessionData = dataOnLoad
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    /** Configuration parameters. */
    _classPrivateFieldInitSpec(this, _activeSessionData, void 0);
    /** State parameters. */
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldSet(_activeSessionData, this, activeSessionData);
  }
  isSupported() {
    debug('isSupported?', true);
    return true;
  }
  load(delegate) {
    try {
      if (_classPrivateFieldGet(_activeSessionData, this)) {
        debug('loading session', _classPrivateFieldGet(_activeSessionData, this));
        return new _Session.default(delegate)[_protected.default].decompress(_classPrivateFieldGet(_activeSessionData, this));
      } else {
        debug('no session to load');
      }
    } catch (err) {
      debug('failed to load forwarded session', err);
    }
    return null;
  }
  store(session) {
    if (session !== null && session !== void 0 && session.isActive()) {
      debug('storing active session by binding forwarding hooks');
      _classPrivateFieldSet(_session, this, session);
    } else {
      debug('removing active session by unbinding forwarding hooks');
      this.destroy();
    }
  }
  destroy() {
    _classPrivateFieldSet(_session, this, undefined);
  }
}
exports.ForwardingSessionStorage = ForwardingSessionStorage;

/***/ }),

/***/ 51312:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalSessionStorage = void 0;
__webpack_require__(62953);
var _protected = _interopRequireDefault(__webpack_require__(37609));
var _storage2 = _interopRequireDefault(__webpack_require__(86542));
var _Session = _interopRequireDefault(__webpack_require__(52404));
var _Constants = __webpack_require__(43443);
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.sessionStorage.LocalSessionStorage');
var _storage = /*#__PURE__*/new WeakMap();
class LocalSessionStorage {
  constructor() {
    _classPrivateFieldInitSpec(this, _storage, (0, _storage2.default)());
  }
  isSupported() {
    debug('isSupported?', true);
    return true;
  }
  load(delegate) {
    const resource = _classPrivateFieldGet(_storage, this).getItem(_Constants.ActiveSessionPath);
    if (resource) {
      debug('loading session');
      return new _Session.default(delegate)[_protected.default].deserialize(resource);
    } else {
      debug('no session to load');
      return null;
    }
  }
  store(session) {
    if (session !== null && session !== void 0 && session.isActive()) {
      debug('storing active session');
      _classPrivateFieldGet(_storage, this).setItem(_Constants.ActiveSessionPath, session[_protected.default].serialize());
    } else {
      debug('removing inactive session');
      _classPrivateFieldGet(_storage, this).removeItem(_Constants.ActiveSessionPath);
    }
  }
  destroy() {
    _classPrivateFieldSet(_storage, this, undefined);
  }
}
exports.LocalSessionStorage = LocalSessionStorage;

/***/ }),

/***/ 6900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _Navigation = __webpack_require__(44661);
var _navigation = __webpack_require__(49715);
var _ForwardingSessionStorage = __webpack_require__(99070);
var _protected = _interopRequireDefault(__webpack_require__(37609));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _trustedOrigins = /*#__PURE__*/new WeakMap();
var _getSessionId = /*#__PURE__*/new WeakMap();
class XDocHandler extends _navigation.NavigationHandler {
  constructor(session, delegate) {
    super();
    _classPrivateFieldInitSpec(this, _trustedOrigins, void 0);
    _classPrivateFieldInitSpec(this, _getSessionId, void 0);
    _classPrivateFieldSet(_trustedOrigins, this, delegate.trustedOrigins);
    _classPrivateFieldSet(_getSessionId, this, () => session[_protected.default].compress());
  }
  get type() {
    return _Navigation.NAVIGATION_TYPE.XDOC;
  }
  shouldHandleEvent(_e) {
    return true;
  }
  shouldHandle(u) {
    const url = new URL(u, window.location.origin);
    return _classPrivateFieldGet(_trustedOrigins, this).includes(url.origin);
  }
  handle(url) {
    const sessionId = _classPrivateFieldGet(_getSessionId, this).call(this);
    const rewrittenUrl = (0, _ForwardingSessionStorage.rewriteUrlIfNecessary)(url, sessionId);
    return {
      rewrittenUrl
    };
  }
}
exports["default"] = XDocHandler;

/***/ }),

/***/ 86542:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _storage.default;
  }
}));
var _storage = _interopRequireDefault(__webpack_require__(16667));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 16667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _jsCookie = _interopRequireDefault(__webpack_require__(2733));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const store = {};
function localStorageAvailable() {
  try {
    const testKey = '_cobrowse_test_item';
    localStorage.setItem(testKey, testKey);
    localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
}
function showWarning() {
  if (!localStorageAvailable() && !showWarning.done) {
    showWarning.done = true;
    console.warn('Warning: localStorage is not supported. Cobrowse falling back to cookie or in-memory storage and may not function as expected.');
  }
}
function _default(groupId) {
  return {
    setItem(key, value) {
      showWarning();
      const encoded = JSON.stringify({
        value,
        group: groupId
      });
      if (localStorageAvailable()) window.localStorage.setItem(key, encoded);else _jsCookie.default.set(key, encoded);
      store[key] = encoded;
    },
    getItem(key) {
      try {
        let encoded;
        // trust localstoage first of all
        if (localStorageAvailable()) {
          encoded = window.localStorage && window.localStorage.getItem(key);
        } else encoded = _jsCookie.default.get(key);
        if (!encoded) encoded = store[key];
        const {
          value,
          group
        } = JSON.parse(encoded);
        if (groupId && groupId !== group) return null;
        return value;
      } catch (e) {
        return null;
      }
    },
    removeItem(key) {
      if (localStorageAvailable()) window.localStorage.removeItem(key);
      _jsCookie.default.remove(key);
      store[key] = undefined;
    }
  };
}

/***/ }),

/***/ 63024:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
var _activity = __webpack_require__(45264);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class AnnotationOverlay {
  constructor() {
    _defineProperty(this, "el", () => {
      if (!this._el) {
        this._el = document.createElement('img');
        this._el.className = 'cbio_session_overlay';
        this._el.style.pointerEvents = 'none';
        this._el.style.visibility = 'visible';
        this._el.style.width = '10vw';
        this._el.style.height = '100vh';
        this._el.style.position = 'fixed';
        this._el.style.zIndex = '2147483647';
        this._el.style.display = 'none';
        this._el.style.top = '0';
        this._el.style.left = '0';
      }
      return this._el;
    });
    _defineProperty(this, "_arrayBufferToBase64", buffer => {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i += 1) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    });
    _defineProperty(this, "remove", function (el) {
      let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      // Set up the transition using inline styles
      el.style.transition = "opacity ".concat(duration, "ms ease-in-out");
      el.style.opacity = 1; // Ensure opacity starts at 1

      // Listen for the transition end event
      el.addEventListener('transitionend', function () {
        // Remove the image from the DOM once the fade-out is complete
        el.remove();
      });

      // Trigger the fade-out by setting opacity to 0
      el.style.opacity = 0;
    });
    _defineProperty(this, "update", drawing => {
      if (!_activity.WindowTracking.isActive()) return;
      if (!drawing.image) this.hide(drawing.agent);else {
        // We create an identical image element so that we can work with it behind the scenes without affecting the
        // original one. This is necessary because updating the src attribute and the styles of the original element
        // will cause the browser to re-render the image, which is slow and causes flickering on Firefox.
        const image = this.el().cloneNode();
        const asDataUri = "data:".concat(drawing.mime_type, ";base64,").concat(this._arrayBufferToBase64(drawing.image));
        const {
          id = 'cb_io_drawing'
        } = drawing;
        image.style.left = "".concat(drawing.x * 100, "%");
        image.style.top = "".concat(drawing.y * 100, "%");
        image.style.height = "".concat(drawing.height * 100, "%");
        image.style.width = "".concat(drawing.width * 100, "%");
        image.style.display = 'block';
        image.src = asDataUri;
        image.id = id;
        image.dataset.agent = drawing.agent;

        // We need to force decoding the image before we can use it to avoid flickering on Firefox. Only when it's decoded
        // can we replace the old image with the new one.
        image.decode().then(() => {
          const elem = document.getElementById(id);
          if (elem) {
            elem.replaceWith(image);
          } else {
            document.body.appendChild(image);
          }
          if (drawing.disappears_in != null) {
            setTimeout(() => {
              this.remove(image, drawing.fade_duration);
            }, drawing.disappears_in);
          }
        }).catch(e => {
          console.error(e);
        });
      }
    });
    _defineProperty(this, "hide", agentId => {
      const elems = agentId != null ? document.querySelectorAll(".cbio_session_overlay[data-agent=\"".concat(agentId, "\"]")) : document.querySelectorAll('.cbio_session_overlay');
      elems.forEach(function (element) {
        element.remove();
      });
    });
  }
}
var _default = exports["default"] = new AnnotationOverlay();

/***/ }),

/***/ 73807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(26910);
__webpack_require__(62953);
var _hooks = __webpack_require__(45994);
var _lite = __webpack_require__(22292);
var _Locale = _interopRequireDefault(__webpack_require__(77988));
var _Draggable = _interopRequireDefault(__webpack_require__(25029));
var _components = __webpack_require__(12996);
var _useSpeaking = __webpack_require__(94909);
var _storage = _interopRequireDefault(__webpack_require__(86542));
var _CallParticipantsModule = _interopRequireDefault(__webpack_require__(90396));
var _jsxRuntime = __webpack_require__(10201);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const POSITION_STORAGE_KEY = '_cobrowse_participants_position';
const getParticipantsPosition = () => (0, _storage.default)().getItem(POSITION_STORAGE_KEY) || 'top-right';
const saveParticipantsPosition = position => (0, _storage.default)().setItem(POSITION_STORAGE_KEY, position);
const CallParticipants = _ref => {
  let {
    mediaSettings,
    callSession
  } = _ref;
  const [participants, setParticipants] = (0, _hooks.useState)(callSession.participants);
  const [audioOutputDeviceId, setAudioOutputDeviceId] = (0, _hooks.useState)(mediaSettings.settings.audioOutputDeviceId);
  (0, _hooks.useEffect)(() => {
    const onAudioOutputSettingsUpdated = _ref2 => {
      let {
        audioOutputDeviceId
      } = _ref2;
      return setAudioOutputDeviceId(audioOutputDeviceId);
    };
    mediaSettings.on('audioOutputSettings.updated', onAudioOutputSettingsUpdated);
    return () => {
      mediaSettings.off('audioOutputSettings.updated', onAudioOutputSettingsUpdated);
    };
  }, [mediaSettings]);
  (0, _hooks.useEffect)(() => {
    const onParticipantsChanged = participants => setParticipants(new Map(participants));
    callSession.on('participants.added', onParticipantsChanged);
    callSession.on('participants.removed', onParticipantsChanged);
    return () => {
      callSession.off('participants.removed', onParticipantsChanged);
      callSession.off('participants.added', onParticipantsChanged);
    };
  }, [callSession]);
  const sortedParticipants = (0, _hooks.useMemo)(() => {
    return [...participants.values()].sort((a, b) => Number(b.isLocal) - Number(a.isLocal));
  }, [participants]);
  return (0, _jsxRuntime.jsx)(_Draggable.default, {
    style: {
      zIndex: '2147483646'
    },
    corner: getParticipantsPosition(),
    onCornerChange: saveParticipantsPosition,
    children: (0, _jsxRuntime.jsx)("div", {
      className: _CallParticipantsModule.default.container,
      children: sortedParticipants.map(participant => (0, _jsxRuntime.jsx)(Participant, {
        participant: participant,
        audioOutputDeviceId: audioOutputDeviceId
      }, participant.id))
    })
  });
};
const Participant = _ref3 => {
  let {
    participant,
    audioOutputDeviceId
  } = _ref3;
  const videoRef = (0, _hooks.useRef)(null);
  const [hasVideo, setHasVideo] = (0, _hooks.useState)(participant.hasVideo);
  const [hasAudio, setHasAudio] = (0, _hooks.useState)(participant.hasAudio);
  const isSpeaking = (0, _useSpeaking.useSpeaking)(participant);
  (0, _hooks.useEffect)(() => {
    const onTracksChanged = () => {
      setHasVideo(participant.hasVideo);
      setHasAudio(participant.hasAudio);
    };
    participant.on('track.added', onTracksChanged);
    participant.on('track.removed', onTracksChanged);
    return () => {
      participant.off('track.removed', onTracksChanged);
      participant.off('track.added', onTracksChanged);
    };
  }, [participant]);
  (0, _hooks.useEffect)(() => {
    videoRef.current.srcObject = participant.stream;
  }, [participant]);
  (0, _hooks.useEffect)(() => {
    const setAudioOutput = async () => {
      await videoRef.current.setSinkId(audioOutputDeviceId);
    };
    if (hasAudio) setAudioOutput();
  }, [audioOutputDeviceId, hasAudio]);
  return (0, _jsxRuntime.jsxs)("div", {
    className: (0, _lite.clsx)(_CallParticipantsModule.default.participantContainer, isSpeaking && _CallParticipantsModule.default.participantSpeaking),
    children: [(0, _jsxRuntime.jsxs)("div", {
      className: _CallParticipantsModule.default.videoContainer,
      children: [(0, _jsxRuntime.jsx)("video", {
        className: _CallParticipantsModule.default.video,
        ref: videoRef,
        autoPlay: true,
        playsInline: true,
        muted: participant.isLocal
      }), !hasVideo ? (0, _jsxRuntime.jsxs)("div", {
        className: _CallParticipantsModule.default.videoOverlay,
        children: [(0, _jsxRuntime.jsx)("span", {
          className: "cbio-sr-only",
          children: _Locale.default.tr('CALLING_CAMERA_OFF')
        }), (0, _jsxRuntime.jsx)(_components.Icon, {
          name: "VideoOff",
          className: _CallParticipantsModule.default.videoOverlayIcon
        })]
      }) : null]
    }), (0, _jsxRuntime.jsxs)("div", {
      className: _CallParticipantsModule.default.statusContainer,
      children: [(0, _jsxRuntime.jsx)(_components.Icon, {
        className: _CallParticipantsModule.default.statusIcon,
        name: hasAudio ? 'Microphone' : 'MicrophoneOff'
      }), (0, _jsxRuntime.jsx)("span", {
        className: _CallParticipantsModule.default.statusTitle,
        children: participant.isLocal ? _Locale.default.tr('CALLING_LOCAL_PARTICIPANT_DESCRIPTION') : _Locale.default.tr('CALLING_REMOTE_PARTICIPANT_DESCRIPTION')
      })]
    })]
  });
};
var _default = exports["default"] = CallParticipants;

/***/ }),

/***/ 65573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(89463);
__webpack_require__(62953);
var _Locale = _interopRequireDefault(__webpack_require__(77988));
var _mountComponent = __webpack_require__(89103);
var _components = __webpack_require__(12996);
var _ConsentDialogModule = _interopRequireDefault(__webpack_require__(91398));
var _jsxRuntime = __webpack_require__(10201);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const ConsentDialogComponent = _ref => {
  let {
    title,
    description,
    onDeny,
    onAllow
  } = _ref;
  return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: (0, _jsxRuntime.jsxs)(_components.Modal, {
      className: _ConsentDialogModule.default.content,
      "aria-labelledby": "title",
      "aria-describedby": "description",
      children: [(0, _jsxRuntime.jsx)("header", {
        children: (0, _jsxRuntime.jsx)("h2", {
          id: "title",
          className: _ConsentDialogModule.default.title,
          children: title
        })
      }), (0, _jsxRuntime.jsx)("div", {
        className: _ConsentDialogModule.default.body,
        children: (0, _jsxRuntime.jsx)("p", {
          id: "description",
          className: _ConsentDialogModule.default.description,
          children: description
        })
      }), (0, _jsxRuntime.jsxs)("footer", {
        className: _ConsentDialogModule.default.buttons,
        children: [(0, _jsxRuntime.jsx)(_components.Button, {
          variant: "secondary",
          onClick: onDeny,
          children: _Locale.default.tr('DENY')
        }), (0, _jsxRuntime.jsx)(_components.Button, {
          variant: "primary",
          onClick: onAllow,
          children: _Locale.default.tr('ALLOW')
        })]
      })]
    })
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
class ConsentDialog {
  constructor() {
    _classPrivateFieldInitSpec(this, _mountHandle, void 0);
    _defineProperty(this, "show", async (title, description) => {
      var _classPrivateFieldGet2;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      return new Promise(resolve => {
        const props = {
          title,
          description,
          onDeny: e => {
            if (!e.isTrusted) return;
            resolve(false);
            this.hide();
          },
          onAllow: e => {
            if (!e.isTrusted) return;
            resolve(true);
            this.hide();
          }
        };
        _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(ConsentDialogComponent, props, true, true));
      });
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet3;
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.unmount();
      _classPrivateFieldSet(_mountHandle, this, null);
    });
  }
}
exports["default"] = ConsentDialog;

/***/ }),

/***/ 76575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _HighlightOverlay = _interopRequireDefault(__webpack_require__(96438));
var _Tooltip = _interopRequireDefault(__webpack_require__(27527));
var _NodeTracker = _interopRequireDefault(__webpack_require__(34822));
var _iframes = _interopRequireDefault(__webpack_require__(77966));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.Highlight');
var _resolve = /*#__PURE__*/new WeakMap();
var _update = /*#__PURE__*/new WeakMap();
var _doUpdate = /*#__PURE__*/new WeakMap();
var _doHide = /*#__PURE__*/new WeakMap();
var _addClickListener = /*#__PURE__*/new WeakMap();
var _removeClickListener = /*#__PURE__*/new WeakMap();
var _handleClick = /*#__PURE__*/new WeakMap();
class Highlight {
  constructor() {
    _classPrivateFieldInitSpec(this, _resolve, void 0);
    _defineProperty(this, "highlight", async (delegate, event) => {
      var _delegate$highlightEl;
      const target = _NodeTracker.default.getById(event.target.id);
      if (!target) {
        // If it wasn't found here, it might be found in a child xdoc iframe. Forward it along to
        // highlight at another level
        _iframes.default.broadcastToChildren('highlight', event);
        return;
      }
      const highlightElement = (_delegate$highlightEl = delegate.highlightElement) !== null && _delegate$highlightEl !== void 0 ? _delegate$highlightEl : _classPrivateFieldGet(_update, this);
      const highlightElementP = highlightElement(target, event.title);
      delegate.emit('highlight.updated', {
        target,
        visible: true
      });
      await highlightElementP;
      delegate.emit('highlight.updated', {
        target,
        visible: false
      });
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet2;
      debug('hide', "resolve?=".concat(!!_classPrivateFieldGet(_resolve, this)));
      _classPrivateFieldGet(_removeClickListener, this).call(this);
      _classPrivateFieldGet(_doHide, this).call(this);
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_resolve, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this);
      _classPrivateFieldSet(_resolve, this, undefined);
    });
    _classPrivateFieldInitSpec(this, _update, (element, title) => new Promise(resolve => {
      debug('update', element, title);

      // It's theoretically possible that update can be run multiple times before being hidden. E.g.,
      // LLM decides to highlight multiple things when demoing a workflow. We don't want multiple
      // promise resolutions because those can be effectful
      _classPrivateFieldSet(_resolve, this, resolve);
      _classPrivateFieldGet(_doUpdate, this).call(this, element, title);
      _classPrivateFieldGet(_addClickListener, this).call(this);
    }));
    _classPrivateFieldInitSpec(this, _doUpdate, (element, title) => {
      _HighlightOverlay.default.update(element);
      _Tooltip.default.update(element, title);
    });
    _classPrivateFieldInitSpec(this, _doHide, () => {
      _Tooltip.default.hide();
      _HighlightOverlay.default.hide();
    });
    _classPrivateFieldInitSpec(this, _addClickListener, () => {
      _classPrivateFieldGet(_removeClickListener, this).call(this);
      document.addEventListener('click', _classPrivateFieldGet(_handleClick, this), {
        once: true,
        capture: true
      });
    });
    _classPrivateFieldInitSpec(this, _removeClickListener, () => {
      document.removeEventListener('click', _classPrivateFieldGet(_handleClick, this), true);
    });
    _classPrivateFieldInitSpec(this, _handleClick, () => {
      this.hide();
    });
  }
}
var _default = exports["default"] = new Highlight();

/***/ }),

/***/ 86162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _createRipple = __webpack_require__(42777);
var _activity = __webpack_require__(45264);
var _MultiAgentManager = __webpack_require__(2630);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const color = '#e94435';
class LaserOverlay {
  constructor() {
    _defineProperty(this, "el", () => {
      if (!this._el) {
        this._el = document.createElement('div');
        this._el.className = 'cbio_session_overlay';
        Object.assign(this._el.style, {
          position: 'fixed',
          zIndex: '2147483647',
          width: '8px',
          height: '8px',
          background: color,
          marginLeft: '-4px',
          marginTop: '-4px',
          borderRadius: '50%',
          border: 'border: 1px solid white',
          pointerEvents: 'none'
        });
      }
      return this._el;
    });
    _defineProperty(this, "hasChangedPosition", () => {
      if (this.previousPosition == null) return false;

      // we tolerade 1% movement before considerencing that the position has changed
      const tolerance = 1;
      return Math.abs(this.previousPosition.x - this.currentPosition.x) > tolerance || Math.abs(this.previousPosition.y - this.currentPosition.y) > tolerance;
    });
    _defineProperty(this, "startAnimation", color => {
      if (this._intervalId) return;
      this._intervalId = setInterval(() => this._createRipple(color), this.rippleInterval);

      // create a ripple immidiately to ensure the animation starts when the marker is visible
      this._createRipple(color);
    });
    _defineProperty(this, "stopAnimation", () => {
      if (this._intervalId) clearInterval(this._intervalId);
      if (this._el) this._el.replaceChildren();
      this.resetState();
    });
    _defineProperty(this, "update", laser => {
      if (!_activity.WindowTracking.isActive()) return;
      if (document.body && !this.el().parentNode) document.body.appendChild(this.el());
      if (laser.state === 'touchend') {
        this.hide();
      } else if (laser.x != null && laser.y != null) {
        this.currentPosition.x = laser.x * 100;
        this.currentPosition.y = laser.y * 100;
        this.el().style.background = laser.colour;
        this.el().style.left = "".concat(this.currentPosition.x, "%");
        this.el().style.top = "".concat(this.currentPosition.y, "%");
        this.startAnimation(laser.colour);
      }
    });
    _defineProperty(this, "hide", () => {
      var _this$_el;
      (_this$_el = this._el) === null || _this$_el === void 0 || (_this$_el = _this$_el.parentNode) === null || _this$_el === void 0 || _this$_el.removeChild(this._el);
      this.stopAnimation();
    });
    this.rippleDuration = 3000; // Total duration of each ripple in ms
    this.rippleInterval = 750; // Create a new ripple every 750ms
    this._el = null;
    this.resetState();
  }
  resetState() {
    this._intervalId = null;
    this.currentPosition = {
      x: 0,
      y: 0
    };
    this.previousPosition = null;
    this.resetRippleScale();
  }
  resetRippleScale() {
    this.rippleScale = 16;
  }
  _createRipple() {
    let selectedColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : color;
    if (!this.hasChangedPosition()) {
      this.rippleScale = Math.min(this.rippleScale + 5, 16);
    } else {
      this.rippleScale = 6;
    }
    this.previousPosition = _objectSpread({}, this.currentPosition);
    const ripple = (0, _createRipple.createRipple)(selectedColor, this.rippleDuration, this.rippleScale);
    this.el().appendChild(ripple);
  }
}
class LaserOverlayManager extends _MultiAgentManager.MultiAgentManager {
  constructor() {
    super(LaserOverlay);
  }
  update(laser) {
    const instance = this.getInstanceForAgent(laser.agent);
    instance.update(laser);
  }
}
var _default = exports["default"] = new LaserOverlayManager();

/***/ }),

/***/ 94037:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.MEDIA_PREVIEW_STATUS = void 0;
__webpack_require__(89463);
__webpack_require__(9391);
__webpack_require__(62953);
var _hooks = __webpack_require__(45994);
var _lite = __webpack_require__(22292);
var _Locale = _interopRequireDefault(__webpack_require__(77988));
var _components = __webpack_require__(12996);
var _MediaSettings = __webpack_require__(93646);
var _useMediaDevices = __webpack_require__(24364);
var _microphone = _interopRequireDefault(__webpack_require__(49020));
var _volume = _interopRequireDefault(__webpack_require__(9978));
var _video = _interopRequireDefault(__webpack_require__(64053));
var _MediaPreviewModule = _interopRequireDefault(__webpack_require__(97294));
var _jsxRuntime = __webpack_require__(10201);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const MEDIA_PREVIEW_STATUS = exports.MEDIA_PREVIEW_STATUS = {
  REQUESTED: 'requested',
  REJOINING: 'rejoining',
  UPDATING: 'updating'
};
const DEFAULT_DEVICE = 'default';
const containsDeviceId = (devices, id) => devices.some(device => device.deviceId === id);
const STATUS_TO_TEXT = {
  [MEDIA_PREVIEW_STATUS.REQUESTED]: {
    title: _Locale.default.tr('CALLING_REQUEST'),
    description: _Locale.default.tr('CALLING_JOIN_PROMPT'),
    acceptTitle: _Locale.default.tr('CALLING_ACCEPT'),
    rejectTitle: _Locale.default.tr('CALLING_REJECT')
  },
  [MEDIA_PREVIEW_STATUS.REJOINING]: {
    title: _Locale.default.tr('CALLING_REQUEST'),
    description: _Locale.default.tr('CALLING_REJOIN_PROMPT'),
    acceptTitle: _Locale.default.tr('CALLING_JOIN'),
    rejectTitle: _Locale.default.tr('CALLING_END')
  },
  [MEDIA_PREVIEW_STATUS.UPDATING]: {
    title: null,
    description: null,
    acceptTitle: _Locale.default.tr('CALLING_SAVE'),
    rejectTitle: _Locale.default.tr('CALLING_CANCEL')
  }
};
const MediaPreview = _ref => {
  let {
    settings,
    status,
    accept,
    reject
  } = _ref;
  const videoRef = (0, _hooks.useRef)(null);
  const previewMediaStream = (0, _hooks.useRef)(new MediaStream());
  const {
    audioInputDevices,
    audioOutputDevices,
    videoInputDevices,
    audioPermission,
    videoPermission,
    updateDeviceLists,
    updatePermissions
  } = (0, _useMediaDevices.useMediaDevices)();
  const [isVideoStarting, setIsVideoStarting] = (0, _hooks.useState)(false);
  const [videoEnabled, setVideoEnabled] = (0, _hooks.useState)(settings.videoEnabled);
  const [videoInputDeviceId, setVideoInputDeviceId] = (0, _hooks.useState)(settings.videoInputDeviceId);
  const [audioEnabled, setAudioEnabled] = (0, _hooks.useState)(settings.audioEnabled);
  const [audioInputDeviceId, setAudioInputDeviceId] = (0, _hooks.useState)(settings.audioInputDeviceId);
  const [audioOutputDeviceId, setAudioOutputDeviceId] = (0, _hooks.useState)(settings.audioOutputDeviceId);
  const removeTracksWithKind = (0, _hooks.useCallback)(kind => {
    const tracksOfKind = previewMediaStream.current.getTracks().filter(track => track.kind === kind);
    tracksOfKind.forEach(track => {
      track.stop();
      previewMediaStream.current.removeTrack(track);
    });
  }, []);
  (0, _hooks.useEffect)(() => {
    if (videoRef.current) videoRef.current.srcObject = previewMediaStream.current;
  }, []);
  (0, _hooks.useEffect)(() => {
    if (containsDeviceId(audioInputDevices, audioInputDeviceId)) return;
    if (containsDeviceId(audioInputDevices, DEFAULT_DEVICE)) return setAudioInputDeviceId(DEFAULT_DEVICE);
    if (audioInputDevices.length) setAudioInputDeviceId(audioInputDevices[0].deviceId);
  }, [audioInputDevices, audioInputDeviceId]);
  (0, _hooks.useEffect)(() => {
    if (containsDeviceId(audioOutputDevices, audioOutputDeviceId)) return;
    if (containsDeviceId(audioOutputDevices, DEFAULT_DEVICE)) return setAudioOutputDeviceId(DEFAULT_DEVICE);
    if (audioOutputDevices.length) setAudioOutputDeviceId(audioOutputDevices[0].deviceId);
  }, [audioOutputDevices, audioOutputDeviceId]);
  (0, _hooks.useEffect)(() => {
    if (containsDeviceId(videoInputDevices, videoInputDeviceId)) return;
    if (containsDeviceId(videoInputDevices, DEFAULT_DEVICE)) return setVideoInputDeviceId(DEFAULT_DEVICE);
    if (videoInputDevices.length) setVideoInputDeviceId(videoInputDevices[0].deviceId);
  }, [videoInputDevices, videoInputDeviceId]);
  (0, _hooks.useEffect)(() => {
    if (!videoEnabled) return;
    if (!navigator.mediaDevices) {
      console.warn('CobrowseIO: Failed to start video, mediaDevices is not available');
      setVideoEnabled(false);
      return;
    }
    setIsVideoStarting(true);
    const constraints = (0, _MediaSettings.createVideoConstraints)({
      videoEnabled,
      videoInputDeviceId
    });
    navigator.mediaDevices.getUserMedia(constraints).then(stream => {
      stream.getTracks().forEach(track => previewMediaStream.current.addTrack(track));
      // Firefox requires an active stream to enumerate
      // the device list so we manually refresh
      updateDeviceLists();
    }).catch(err => {
      console.warn('CobrowseIO: Failed to get video', err);
      if (videoPermission.prompt) setVideoEnabled(false);
    }).finally(() => {
      // Safari doesn't support the permission change event
      // so we manually refresh permissions after getUserMedia
      updatePermissions();
      setIsVideoStarting(false);
    });
    return () => removeTracksWithKind('video');
  }, [videoPermission, videoEnabled, videoInputDeviceId, removeTracksWithKind]);
  (0, _hooks.useEffect)(() => {
    if (!audioEnabled) return;
    if (!navigator.mediaDevices) {
      console.warn('CobrowseIO: Failed to start audio, mediaDevices is not available');
      setAudioEnabled(false);
      return;
    }
    const constraints = (0, _MediaSettings.createAudioConstraints)({
      audioEnabled,
      audioInputDeviceId
    });
    navigator.mediaDevices.getUserMedia(constraints).then(stream => {
      stream.getTracks().forEach(track => previewMediaStream.current.addTrack(track));
      // Firefox requires an active stream to enumerate
      // the device list so we manually refresh
      updateDeviceLists();
    }).catch(err => {
      console.warn('CobrowseIO: Failed to get audio', err);
      if (audioPermission.prompt) setAudioEnabled(false);
    }).finally(() => {
      // Safari doesn't support the permission change event
      // so we manually refresh permissions after getUserMedia
      updatePermissions();
    });
    return () => removeTracksWithKind('audio');
  }, [audioPermission, audioEnabled, audioInputDeviceId, removeTracksWithKind]);
  const handleAccept = () => accept({
    videoEnabled,
    videoInputDeviceId,
    audioEnabled,
    audioInputDeviceId,
    audioOutputDeviceId
  });
  const handleReject = () => reject();
  const renderVideoOverlay = (message, isBackgroundTransparent) => (0, _jsxRuntime.jsx)("div", {
    className: (0, _lite.clsx)(_MediaPreviewModule.default.videoOverlay, isBackgroundTransparent ? _MediaPreviewModule.default.videoOverlayTransparent : _MediaPreviewModule.default.videoOverlaySolid),
    children: (0, _jsxRuntime.jsx)("p", {
      className: _MediaPreviewModule.default.videoOverlayText,
      children: message
    })
  });
  const renderVideoState = () => {
    const isBackgroundTransparent = videoEnabled && videoPermission.granted;
    if (audioEnabled) {
      if (audioPermission.denied) return renderVideoOverlay(_Locale.default.tr('CALLING_MICROPHONE_PERMISSION_DENIED'), isBackgroundTransparent);
      if (audioPermission.prompt) return renderVideoOverlay(_Locale.default.tr('CALLING_MICROPHONE_PERMISSION_PROMPT'), isBackgroundTransparent);
    }
    if (videoEnabled) {
      if (videoPermission.denied) return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_PERMISSION_DENIED'), isBackgroundTransparent);
      if (videoPermission.prompt) return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_PERMISSION_PROMPT'), isBackgroundTransparent);
      if (isVideoStarting) return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_STARTING'), isBackgroundTransparent);
    } else {
      return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_OFF'), isBackgroundTransparent);
    }
    return null;
  };
  const renderPreview = () => (0, _jsxRuntime.jsxs)("div", {
    className: _MediaPreviewModule.default.previewContainer,
    children: [(0, _jsxRuntime.jsxs)("div", {
      className: _MediaPreviewModule.default.videoContainer,
      children: [(0, _jsxRuntime.jsx)("video", {
        ref: videoRef,
        className: _MediaPreviewModule.default.video,
        autoPlay: true,
        playsInline: true,
        muted: true
      }), renderVideoState()]
    }), (0, _jsxRuntime.jsx)(VoiceVideoControls, {
      audioEnabled: audioEnabled,
      toggleAudio: () => setAudioEnabled(prev => !prev),
      videoEnabled: videoEnabled,
      toggleVideo: () => setVideoEnabled(prev => !prev)
    })]
  });
  const renderMediaDeviceOptions = (hasPermission, devices) => {
    if (!hasPermission) return (0, _jsxRuntime.jsx)(_components.SelectOption, {
      value: "",
      disabled: true,
      selected: true,
      children: _Locale.default.tr('CALLING_PERMISSION_NEEDED')
    });
    if (!devices.length) return (0, _jsxRuntime.jsx)(_components.SelectOption, {
      value: "",
      disabled: true,
      selected: true,
      children: _Locale.default.tr('CALLING_NO_DEVICES')
    });
    return devices.map(device => (0, _jsxRuntime.jsx)(_components.SelectOption, {
      value: device.deviceId,
      children: device.label
    }, device.deviceId));
  };
  const renderMediaDevices = () => (0, _jsxRuntime.jsxs)("div", {
    className: _MediaPreviewModule.default.deviceContainer,
    children: [(0, _jsxRuntime.jsx)(_components.Select, {
      iconUrl: _microphone.default,
      ariaLabel: _Locale.default.tr('CALLING_SELECT_MICROPHONE'),
      value: audioPermission.granted && audioInputDevices.length ? audioInputDeviceId : '',
      onChange: e => setAudioInputDeviceId(e.target.value),
      disabled: !audioPermission.granted || !audioInputDevices.length,
      children: renderMediaDeviceOptions(audioPermission.granted, audioInputDevices)
    }), (0, _jsxRuntime.jsx)(_components.Select, {
      iconUrl: _volume.default,
      ariaLabel: _Locale.default.tr('CALLING_SELECT_SPEAKER'),
      value: audioPermission.granted && audioOutputDevices.length ? audioOutputDeviceId : '',
      onChange: e => setAudioOutputDeviceId(e.target.value),
      disabled: !audioPermission.granted || !audioOutputDevices.length,
      children: renderMediaDeviceOptions(audioPermission.granted, audioOutputDevices)
    }), (0, _jsxRuntime.jsx)(_components.Select, {
      iconUrl: _video.default,
      ariaLabel: _Locale.default.tr('CALLING_SELECT_CAMERA'),
      value: videoPermission.granted && videoInputDevices.length ? videoInputDeviceId : '',
      onChange: e => setVideoInputDeviceId(e.target.value),
      disabled: !videoPermission.granted || !videoInputDevices.length,
      children: renderMediaDeviceOptions(videoPermission.granted, videoInputDevices)
    })]
  });
  const {
    title,
    description,
    acceptTitle,
    rejectTitle
  } = STATUS_TO_TEXT[status];
  return (0, _jsxRuntime.jsxs)(_components.Modal, {
    className: _MediaPreviewModule.default.content,
    "aria-labelledby": "title",
    "aria-describedby": "description",
    children: [(0, _jsxRuntime.jsxs)("header", {
      className: _MediaPreviewModule.default.header,
      children: [(0, _jsxRuntime.jsxs)("section", {
        className: _MediaPreviewModule.default.media,
        children: [renderPreview(), renderMediaDevices()]
      }), title ? (0, _jsxRuntime.jsx)("h2", {
        id: "title",
        className: _MediaPreviewModule.default.title,
        children: title
      }) : null]
    }), description ? (0, _jsxRuntime.jsx)("div", {
      className: _MediaPreviewModule.default.body,
      children: (0, _jsxRuntime.jsx)("p", {
        id: "description",
        className: _MediaPreviewModule.default.description,
        children: description
      })
    }) : null, (0, _jsxRuntime.jsxs)("footer", {
      className: _MediaPreviewModule.default.buttonContainer,
      children: [(0, _jsxRuntime.jsx)(_components.Button, {
        variant: "secondary",
        onClick: handleReject,
        children: rejectTitle
      }), (0, _jsxRuntime.jsx)(_components.Button, {
        variant: "primary",
        onClick: handleAccept,
        children: acceptTitle
      })]
    })]
  });
};
const VoiceVideoControls = _ref2 => {
  let {
    audioEnabled,
    toggleAudio,
    videoEnabled,
    toggleVideo
  } = _ref2;
  return (0, _jsxRuntime.jsxs)("div", {
    className: _MediaPreviewModule.default.voiceVideoControls,
    children: [(0, _jsxRuntime.jsx)(_components.IconButton, {
      onClick: toggleAudio,
      ariaLabel: audioEnabled ? _Locale.default.tr('CALLING_DISABLE_AUDIO') : _Locale.default.tr('CALLING_ENABLE_AUDIO'),
      className: (0, _lite.clsx)(_MediaPreviewModule.default.voiceVideoControlsToggle, audioEnabled ? _MediaPreviewModule.default.voiceVideoControlsToggleOn : _MediaPreviewModule.default.voiceVideoControlsToggleOff),
      children: (0, _jsxRuntime.jsx)(_components.Icon, {
        className: _MediaPreviewModule.default.voiceVideoControlsIcon,
        name: audioEnabled ? 'Microphone' : 'MicrophoneOff'
      })
    }), (0, _jsxRuntime.jsx)(_components.IconButton, {
      onClick: toggleVideo,
      ariaLabel: videoEnabled ? _Locale.default.tr('CALLING_DISABLE_VIDEO') : _Locale.default.tr('CALLING_ENABLE_VIDEO'),
      className: (0, _lite.clsx)(_MediaPreviewModule.default.voiceVideoControlsToggle, videoEnabled ? _MediaPreviewModule.default.voiceVideoControlsToggleOn : _MediaPreviewModule.default.voiceVideoControlsToggleOff),
      style: {
        marginLeft: '-4px'
      },
      children: (0, _jsxRuntime.jsx)(_components.Icon, {
        className: _MediaPreviewModule.default.voiceVideoControlsIcon,
        name: videoEnabled ? 'Video' : 'VideoOff'
      })
    })]
  });
};
var _default = exports["default"] = MediaPreview;

/***/ }),

/***/ 2630:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MultiAgentManager = void 0;
__webpack_require__(62953);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _instances = /*#__PURE__*/new WeakMap();
var _classReference = /*#__PURE__*/new WeakMap();
class MultiAgentManager {
  constructor(ref) {
    _classPrivateFieldInitSpec(this, _instances, new Map());
    _classPrivateFieldInitSpec(this, _classReference, null);
    _classPrivateFieldSet(_classReference, this, ref);
  }
  getInstanceForAgent(agent) {
    if (_classPrivateFieldGet(_instances, this).has(agent)) {
      return _classPrivateFieldGet(_instances, this).get(agent);
    } else {
      _classPrivateFieldGet(_instances, this).set(agent, new (_classPrivateFieldGet(_classReference, this))());
      return _classPrivateFieldGet(_instances, this).get(agent);
    }
  }
  hide() {
    _classPrivateFieldGet(_instances, this).forEach((instance, key) => {
      instance.hide();
      _classPrivateFieldGet(_instances, this).delete(key);
    });
  }
}
exports.MultiAgentManager = MultiAgentManager;

/***/ }),

/***/ 51112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _dom = __webpack_require__(20949);
var _unpolyfill = __webpack_require__(79883);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const TICK_SVG = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5l10 -10" /></svg>';
const createCss = appendRule => {
  appendRule("\n    .cbioSelect {\n      z-index: 2147483647;\n      background-color: #6e6e6e;\n      box-sizing: border-box;\n      padding: 5px;\n      font-size: 13px;\n      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n      border-radius: 5px;\n      border: 1px solid #ccc;\n      max-height: 300px;\n      overflow-y: auto;\n      scrollbar-width: thin;\n      scrollbar-color: #c0c0c0 transparent;\n    }\n  ");
  appendRule("\n    .cbioOption {\n      color: white;\n      padding: 5px;\n      border-radius: 5px;\n      cursor: pointer;\n      display: flex;\n    }\n  ");
  appendRule("\n    .cbioOption:hover {\n      background-color: #649eec;\n    }\n  ");
  appendRule("\n    .cbioOptionIcon {\n      visibility: hidden;\n      margin-right: 5px;\n    }\n  ");
  appendRule("\n    .cbioOptionSelect .cbioOptionIcon {\n      visibility: visible;\n    }\n  ");
  appendRule("\n    .cbioOptionDisable {\n      color: #a9a9a9;\n      pointer-events: none;\n    }\n  ");
  appendRule("\n    .cbioOptionHighlight.cbioOption {\n      background-color: #649eec;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar {\n      width: 8px;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar-track {\n      background: transparent;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar-thumb {\n      background-color: #c0c0c0;\n      border-radius: 4px;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar-thumb:hover {\n      background-color: #a0a0a0;\n    }\n  ");
};
const createStyle = doc => {
  const element = doc.createElement('style');
  doc.head.appendChild(element);
  const appendRule = rule => {
    try {
      element.sheet.insertRule(rule, element.sheet.cssRules.length);
    } catch (error) {
      // ignore broken / incompatible rules
    }
  };
  return {
    appendRule,
    cleanUp: () => element.remove()
  };
};
const createSelect = (doc, isRedacted, onKeyDown, onMouseEnter, onMouseMove) => {
  const element = doc.createElement('div');
  element.classList.add('cbioSelect');
  if (isRedacted) element.classList.add('__cbio_ignored');
  element.setAttribute('role', 'combobox');
  element.setAttribute('aria-expanded', 'true');
  element.tabIndex = 0;
  element.addEventListener('keydown', onKeyDown);
  element.addEventListener('mouseenter', onMouseEnter);
  element.addEventListener('mousemove', onMouseMove);
  return {
    element,
    addOption: option => element.appendChild(option.element),
    cleanUp: () => element.remove()
  };
};
const createOption = (doc, text, selected, disabled, onSelect, onMouseEnter) => {
  const element = doc.createElement('div');
  element.classList.add('cbioOption');
  if (disabled) element.classList.add('cbioOptionDisable');
  if (selected) element.classList.add('cbioOptionSelect');
  element.setAttribute('role', 'option');
  element.setAttribute('aria-disabled', disabled);
  element.setAttribute('aria-selected', selected);
  element.addEventListener('mouseup', () => onSelect());
  element.addEventListener('mouseenter', onMouseEnter);
  const iconImg = doc.createElement('img');
  iconImg.className = 'cbioOptionIcon';
  iconImg.src = TICK_SVG;
  const titleSpan = doc.createElement('span');
  titleSpan.innerText = text;
  element.appendChild(iconImg);
  element.appendChild(titleSpan);
  const addHighlight = () => {
    element.classList.add('cbioOptionHighlight');
    element.scrollIntoView({
      block: 'nearest',
      inline: 'nearest'
    });
  };
  const removeHighlight = () => element.classList.remove('cbioOptionHighlight');
  return {
    element,
    disabled,
    addHighlight,
    removeHighlight,
    select: () => onSelect()
  };
};
const createSelectPositioner = (target, selectElement) => {
  let isInitialised = false;
  let isSelectInitiallySmaller = false;
  return () => {
    (0, _dom.computePosition)(target, selectElement, {
      placement: 'bottom-start',
      strategy: 'fixed',
      middleware: [(0, _dom.flip)(), (0, _dom.size)({
        apply() {
          if (isSelectInitiallySmaller) {
            Object.assign(selectElement.style, {
              width: "".concat(target.offsetWidth, "px")
            });
          }
        }
      })]
    }).then(_ref => {
      let {
        x,
        y
      } = _ref;
      Object.assign(selectElement.style, {
        top: "".concat(y, "px"),
        left: "".concat(x, "px"),
        position: 'fixed'
      });
      if (!isInitialised) {
        isSelectInitiallySmaller = selectElement.offsetWidth < target.offsetWidth;
        selectElement.focus();
      }
      isInitialised = true;
    });
  };
};
var _delegate = /*#__PURE__*/new WeakMap();
var _trackedWindows = /*#__PURE__*/new WeakMap();
var _currentSelect = /*#__PURE__*/new WeakMap();
var _options = /*#__PURE__*/new WeakMap();
var _highlightedOptionIndex = /*#__PURE__*/new WeakMap();
var _usingMouse = /*#__PURE__*/new WeakMap();
var _isActive = /*#__PURE__*/new WeakMap();
var _cleanUpAutoUpdate = /*#__PURE__*/new WeakMap();
var _cleanUpSelect = /*#__PURE__*/new WeakMap();
var _cleanUpStyle = /*#__PURE__*/new WeakMap();
var _closeSelect = /*#__PURE__*/new WeakMap();
var _highlightByIndex = /*#__PURE__*/new WeakMap();
var _highlightPrevious = /*#__PURE__*/new WeakMap();
var _highlightNext = /*#__PURE__*/new WeakMap();
var _selectHighlighted = /*#__PURE__*/new WeakMap();
var _removeAllHighlights = /*#__PURE__*/new WeakMap();
var _onSelectKeyDown = /*#__PURE__*/new WeakMap();
var _onSelectMouseMove = /*#__PURE__*/new WeakMap();
var _createSelectFromTarget = /*#__PURE__*/new WeakMap();
var _openSelect = /*#__PURE__*/new WeakMap();
var _shouldShowSelect = /*#__PURE__*/new WeakMap();
var _handleMouseDown = /*#__PURE__*/new WeakMap();
var _handleKeyDown = /*#__PURE__*/new WeakMap();
var _handleClick = /*#__PURE__*/new WeakMap();
class NativeSelect {
  constructor(delegate) {
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _trackedWindows, void 0);
    _classPrivateFieldInitSpec(this, _currentSelect, void 0);
    _classPrivateFieldInitSpec(this, _options, void 0);
    _classPrivateFieldInitSpec(this, _highlightedOptionIndex, void 0);
    _classPrivateFieldInitSpec(this, _usingMouse, void 0);
    _classPrivateFieldInitSpec(this, _isActive, void 0);
    _classPrivateFieldInitSpec(this, _cleanUpAutoUpdate, void 0);
    _classPrivateFieldInitSpec(this, _cleanUpSelect, void 0);
    _classPrivateFieldInitSpec(this, _cleanUpStyle, void 0);
    _defineProperty(this, "track", w => {
      if (_classPrivateFieldGet(_trackedWindows, this).has(w)) return;
      _classPrivateFieldGet(_trackedWindows, this).add(w);
      w.addEventListener('mousedown', _classPrivateFieldGet(_handleMouseDown, this));
      w.addEventListener('keydown', _classPrivateFieldGet(_handleKeyDown, this));
      w.addEventListener('click', _classPrivateFieldGet(_handleClick, this), {
        capture: true,
        passive: true
      });
    });
    _classPrivateFieldInitSpec(this, _closeSelect, () => {
      var _classPrivateFieldGet2, _classPrivateFieldGet3, _classPrivateFieldGet4;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_cleanUpAutoUpdate, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this);
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_cleanUpSelect, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.call(this);
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_cleanUpStyle, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.call(this);
      _classPrivateFieldSet(_currentSelect, this, null);
    });
    _classPrivateFieldInitSpec(this, _highlightByIndex, index => {
      if (_classPrivateFieldGet(_highlightedOptionIndex, this) >= 0) _classPrivateFieldGet(_options, this)[_classPrivateFieldGet(_highlightedOptionIndex, this)].removeHighlight();
      _classPrivateFieldGet(_options, this)[index].addHighlight();
      _classPrivateFieldSet(_highlightedOptionIndex, this, index);
    });
    _classPrivateFieldInitSpec(this, _highlightPrevious, () => {
      if (_classPrivateFieldGet(_highlightedOptionIndex, this) <= 0) return;
      let newOptionIndex = _classPrivateFieldGet(_highlightedOptionIndex, this) - 1;
      while (newOptionIndex >= 0) {
        if (!_classPrivateFieldGet(_options, this)[newOptionIndex].disabled) {
          return _classPrivateFieldGet(_highlightByIndex, this).call(this, newOptionIndex);
        }
        newOptionIndex--;
      }
    });
    _classPrivateFieldInitSpec(this, _highlightNext, () => {
      if (_classPrivateFieldGet(_highlightedOptionIndex, this) >= _classPrivateFieldGet(_options, this).length - 1) return;
      let newOptionIndex = _classPrivateFieldGet(_highlightedOptionIndex, this) + 1;
      while (newOptionIndex < _classPrivateFieldGet(_options, this).length) {
        if (!_classPrivateFieldGet(_options, this)[newOptionIndex].disabled) {
          return _classPrivateFieldGet(_highlightByIndex, this).call(this, newOptionIndex);
        }
        newOptionIndex++;
      }
    });
    _classPrivateFieldInitSpec(this, _selectHighlighted, () => {
      _classPrivateFieldGet(_options, this)[_classPrivateFieldGet(_highlightedOptionIndex, this)].select();
    });
    _classPrivateFieldInitSpec(this, _removeAllHighlights, () => {
      _classPrivateFieldGet(_options, this).forEach(option => option.removeHighlight());
    });
    _classPrivateFieldInitSpec(this, _onSelectKeyDown, e => {
      _classPrivateFieldSet(_usingMouse, this, false);
      switch (e.code) {
        case 'ArrowUp':
          e.preventDefault();
          _classPrivateFieldGet(_highlightPrevious, this).call(this);
          break;
        case 'ArrowDown':
          e.preventDefault();
          _classPrivateFieldGet(_highlightNext, this).call(this);
          break;
        case 'Space':
        case 'Enter':
          e.preventDefault();
          _classPrivateFieldGet(_selectHighlighted, this).call(this);
          break;
        case 'Escape':
          e.preventDefault();
          _classPrivateFieldGet(_closeSelect, this).call(this);
          break;
      }
    });
    _classPrivateFieldInitSpec(this, _onSelectMouseMove, () => {
      _classPrivateFieldSet(_usingMouse, this, true);
    });
    _classPrivateFieldInitSpec(this, _createSelectFromTarget, target => {
      const doc = target.ownerDocument || document;
      const style = createStyle(doc);
      _classPrivateFieldSet(_cleanUpStyle, this, style.cleanUp);
      createCss(style.appendRule);
      const isRedacted = _classPrivateFieldGet(_delegate, this).isRedacted(target);
      const select = createSelect(doc, isRedacted, _classPrivateFieldGet(_onSelectKeyDown, this), _classPrivateFieldGet(_removeAllHighlights, this), _classPrivateFieldGet(_onSelectMouseMove, this));
      _classPrivateFieldSet(_cleanUpSelect, this, select.cleanUp);
      const targetOptions = Array.from(target.options);
      _classPrivateFieldSet(_options, this, targetOptions.map((targetOption, index) => {
        const {
          text,
          value,
          disabled
        } = targetOption;
        const selected = !disabled && targetOption.selected;
        const onSelect = () => {
          if (!_classPrivateFieldGet(_isActive, this)) return;
          target.value = value;
          targetOption.selected = true;
          target.dispatchEvent(new _unpolyfill.Event('input', {
            bubbles: true
          }));
          target.dispatchEvent(new _unpolyfill.Event('change', {
            bubbles: true
          }));
          _classPrivateFieldGet(_closeSelect, this).call(this);
        };
        const onMouseEnter = () => {
          if (!_classPrivateFieldGet(_usingMouse, this)) return;
          _classPrivateFieldGet(_highlightByIndex, this).call(this, index);
        };
        const option = createOption(doc, text, selected, disabled, onSelect, onMouseEnter);
        if (selected) {
          _classPrivateFieldSet(_highlightedOptionIndex, this, index);
          option.addHighlight();
        }
        select.addOption(option);
        return option;
      }));
      const containsElement = el => {
        if (target === el) return true;
        if (select.element === el) return true;
        if (select.element.contains(el)) return true;
        return false;
      };
      target.after(select.element);
      _classPrivateFieldSet(_cleanUpAutoUpdate, this, (0, _dom.autoUpdate)(target, select.element, createSelectPositioner(target, select.element)));
      return {
        containsElement
      };
    });
    _classPrivateFieldInitSpec(this, _openSelect, target => {
      if (_classPrivateFieldGet(_currentSelect, this)) {
        _classPrivateFieldGet(_closeSelect, this).call(this);
        return;
      }

      // small debounce in case the select renders under the pointer
      // during a click event and makes an automatic selection
      _classPrivateFieldSet(_isActive, this, false);
      setTimeout(() => {
        _classPrivateFieldSet(_isActive, this, true);
      }, 200);
      _classPrivateFieldSet(_currentSelect, this, _classPrivateFieldGet(_createSelectFromTarget, this).call(this, target));
    });
    _classPrivateFieldInitSpec(this, _shouldShowSelect, e => {
      var _e$target;
      if (!_classPrivateFieldGet(_delegate, this).shouldShowSelect()) return false;
      if (((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.tagName) !== 'SELECT') return false;
      if (e.target.size > 1) return false;
      if (e.defaultPrevented) return false;
      const select = e.target;
      if (select.options.length === 0) return false;
      if (select.multiple) return false;
      return true;
    });
    _classPrivateFieldInitSpec(this, _handleMouseDown, e => {
      if (!_classPrivateFieldGet(_shouldShowSelect, this).call(this, e)) return;
      if (e.button !== 0) return;
      e.preventDefault();
      _classPrivateFieldGet(_openSelect, this).call(this, e.target);
    });
    _classPrivateFieldInitSpec(this, _handleKeyDown, e => {
      if (!_classPrivateFieldGet(_shouldShowSelect, this).call(this, e)) return;
      if (['Space', 'ArrowDown', 'ArrowUp'].includes(e.code)) {
        e.preventDefault();
        _classPrivateFieldGet(_openSelect, this).call(this, e.target);
      }
    });
    _classPrivateFieldInitSpec(this, _handleClick, e => {
      var _classPrivateFieldGet5;
      if (((_classPrivateFieldGet5 = _classPrivateFieldGet(_currentSelect, this)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.containsElement(e.target)) === false && _classPrivateFieldGet(_isActive, this)) {
        _classPrivateFieldGet(_closeSelect, this).call(this);
      }
    });
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_trackedWindows, this, new Set());
  }
}
var _default = exports["default"] = NativeSelect;

/***/ }),

/***/ 53291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _createRipple = __webpack_require__(42777);
var _activity = __webpack_require__(45264);
var _nodes = __webpack_require__(66938);
var _MultiAgentManager = __webpack_require__(2630);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class RemoteCursor {
  constructor() {
    var _this = this;
    _defineProperty(this, "el", () => {
      if (!this._el) {
        const svgNS = 'http://www.w3.org/2000/svg';
        this._el = document.createElementNS(svgNS, 'svg');
        this._el.setAttribute('class', '__cbio_ignored');
        this._el.setAttribute('viewBox', '0 0 35 35');
        this._el.setAttribute('fill', 'none');
        this._el.style.position = 'fixed';
        this._el.style.zIndex = '2147483647';
        this._el.style.height = '32px';
        this._el.style.width = '32px';
        this._el.style.marginLeft = '-16px';
        this._el.style.marginTop = '0px';
        this._el.style.color = 'red';
        this._el.style.transition = 'opacity 0.5s';
        this._el.style.opacity = 1;
        this._el.style.pointerEvents = 'none';
        const path1 = document.createElementNS(svgNS, 'path');
        path1.setAttribute('d', 'M26.5148 15.8441V17.0941C26.5148 17.7541 26.9798 17.2891 26.3198 17.2891C25.6598 17.2891 26.1248 17.7541 26.1248 17.0941V14.5108C26.1248 13.8361 24.5779 12.2891 23.9032 12.2891C23.2285 12.2891 21.6815 13.8361 21.6815 14.5108V17.0941C21.6815 17.7541 22.1465 17.2891 21.4865 17.2891C20.8265 17.2891 21.2915 17.7541 21.2915 17.0941V13.0108C21.2915 12.3361 19.7445 10.7891 19.0698 10.7891C18.3951 10.7891 16.8482 12.3361 16.8482 13.0108V17.0941C16.8482 17.7541 17.3131 17.2891 16.6532 17.2891C15.9932 17.2891 16.4582 17.7541 16.4582 17.0941V5.01073C16.4582 4.33602 14.9112 2.78906 14.2365 2.78906C13.5618 2.78906 12.0148 4.33602 12.0148 5.01073V18.5941C12.0148 19.0774 12.7237 18.5132 12.2771 18.6981C11.8306 18.8831 11.3166 18.7809 10.9748 18.4391L8.262 15.7263C7.85703 15.3213 6.23834 15.2209 5.72608 15.477C5.04602 15.8171 4.78867 17.6568 5.16142 18.3195L11.0678 28.0419C12.5818 30.7334 15.4298 32.3991 18.518 32.3991H21.3198C25.9066 32.3991 30.6248 27.6808 30.6248 23.0941V15.8441C30.6248 15.2614 29.1525 13.7891 28.5698 13.7891C27.9872 13.7891 26.5148 15.2614 26.5148 15.8441Z');
        path1.setAttribute('fill', 'currentColor');
        path1.setAttribute('fill-rule', 'evenodd');
        path1.setAttribute('clip-rule', 'evenodd');
        const path2 = document.createElementNS(svgNS, 'path');
        path2.setAttribute('d', 'M10.6247 5.01011C10.6247 3.01544 12.2417 1.39844 14.2364 1.39844C16.2311 1.39844 17.8481 3.01544 17.8481 5.01011V9.61029C18.2296 9.47316 18.641 9.39844 19.0697 9.39844C20.4448 9.39844 21.6404 10.1669 22.2505 11.2978C22.7457 11.0425 23.3076 10.8984 23.9031 10.8984C25.2578 10.8984 26.4383 11.6443 27.0563 12.7478C27.5131 12.524 28.0268 12.3984 28.5697 12.3984C30.4724 12.3984 32.0147 13.9408 32.0147 15.8434V23.0934C32.0147 29.0001 27.2264 33.7884 21.3197 33.7884H18.5179C14.5663 33.7884 10.9219 31.657 8.98462 28.2129L4.07828 19.4905C3.03598 17.6375 3.7556 15.2894 5.65716 14.3386C7.08954 13.6225 8.81951 13.9032 9.95191 15.0356L10.6247 15.7084V5.01011ZM27.5147 15.8434V17.0934C27.5147 17.7534 26.9797 18.2884 26.3197 18.2884C25.6597 18.2884 25.1247 17.7534 25.1247 17.0934V14.5101C25.1247 13.8354 24.5778 13.2884 23.9031 13.2884C23.2284 13.2884 22.6814 13.8354 22.6814 14.5101V17.0934C22.6814 17.7534 22.1464 18.2884 21.4864 18.2884C20.8264 18.2884 20.2914 17.7534 20.2914 17.0934V13.0101C20.2914 12.3354 19.7444 11.7884 19.0697 11.7884C18.395 11.7884 17.8481 12.3354 17.8481 13.0101V17.0934C17.8481 17.7534 17.313 18.2884 16.6531 18.2884C15.9931 18.2884 15.4581 17.7534 15.4581 17.0934V5.01011C15.4581 4.3354 14.9111 3.78844 14.2364 3.78844C13.5617 3.78844 13.0147 4.3354 13.0147 5.01011V18.5934C13.0147 19.0767 12.7236 19.5125 12.277 19.6974C11.8305 19.8824 11.3165 19.7802 10.9747 19.4384L8.26192 16.7256C7.85695 16.3206 7.23826 16.2202 6.726 16.4763C6.04594 16.8164 5.78859 17.6561 6.16134 18.3188L11.0677 27.0412C12.5817 29.7327 15.4297 31.3984 18.5179 31.3984H21.3197C25.9065 31.3984 29.6247 27.6801 29.6247 23.0934V15.8434C29.6247 15.2607 29.1524 14.7884 28.5697 14.7884C27.9871 14.7884 27.5147 15.2607 27.5147 15.8434Z');
        path2.setAttribute('fill', 'white');
        path2.setAttribute('fill-rule', 'evenodd');
        path2.setAttribute('clip-rule', 'evenodd');
        this._el.appendChild(path1);
        this._el.appendChild(path2);
      }
      return this._el;
    });
    _defineProperty(this, "calculateOffset", event => {
      var _target$ownerDocument;
      const target = _nodes.NodeTracker.getById(event.target.id);
      const iframe = target === null || target === void 0 || (_target$ownerDocument = target.ownerDocument) === null || _target$ownerDocument === void 0 || (_target$ownerDocument = _target$ownerDocument.defaultView) === null || _target$ownerDocument === void 0 ? void 0 : _target$ownerDocument.frameElement;
      if (!iframe) return {
        offsetX: 0,
        offsetY: 0
      };
      const rect = iframe.getBoundingClientRect();
      return {
        offsetX: Math.round(rect.left),
        offsetY: Math.round(rect.top)
      };
    });
    _defineProperty(this, "getOffset", event => {
      var _window$document, _window$document2;
      const {
        offsetX,
        offsetY
      } = event;
      const eventHasOffset = offsetX !== undefined && offsetY !== undefined;

      // for backwards compatibility when offset is not included in the event
      // we should still attempt to calculate it here. This calculation should
      // be removed once we can rely on the offset included within the event
      if (!eventHasOffset) return this.calculateOffset(event);
      return {
        offsetX: offsetX * ((_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.clientWidth),
        offsetY: offsetY * ((_window$document2 = window.document) === null || _window$document2 === void 0 || (_window$document2 = _window$document2.documentElement) === null || _window$document2 === void 0 ? void 0 : _window$document2.clientHeight)
      };
    });
    _defineProperty(this, "_updatePosition", event => {
      var _window$document3, _window$document4;
      let {
        x,
        y
      } = event;

      // prevent jumping cursor when crossing over iFrame borders due to condition
      // on the agent which can sometimes provide false for x and y coordinates
      if (x === false || y === false) return;
      x *= (_window$document3 = window.document) === null || _window$document3 === void 0 || (_window$document3 = _window$document3.documentElement) === null || _window$document3 === void 0 ? void 0 : _window$document3.clientWidth;
      y *= (_window$document4 = window.document) === null || _window$document4 === void 0 || (_window$document4 = _window$document4.documentElement) === null || _window$document4 === void 0 ? void 0 : _window$document4.clientHeight;
      const offset = this.getOffset(event);
      x += offset.offsetX;
      y += offset.offsetY;
      this.el().style.top = "".concat(y, "px");
      this.el().style.left = "".concat(x, "px");
      this._lastPosition = {
        x,
        y
      };
    });
    _defineProperty(this, "_getRippleStyle", () => ({
      position: 'fixed',
      left: "".concat(this._lastPosition.x - 4, "px"),
      top: "".concat(this._lastPosition.y + 4, "px")
    }));
    _defineProperty(this, "_createRipple", function () {
      let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#e94435';
      const ripple = (0, _createRipple.createRipple)(color, 1000, 12, _this._getRippleStyle());
      document.body.appendChild(ripple);
    });
    _defineProperty(this, "update", (type, event) => {
      if (type !== 'mouse') return;
      if (!_activity.WindowTracking.isActive()) return;
      if (document.body && !this.el().parentNode) document.body.appendChild(this.el());
      if (event.colour) this.el().style.color = event.colour;
      switch (event.state) {
        case 'mousedown':
          this._hideAfterTimeout();
          this._createRipple(event.colour);
          if (!this.interval) {
            this.interval = setInterval(() => {
              this._createRipple(event.colour);
            }, 500);
          }
          break;
        case 'mouseup':
          this._hideAfterTimeout();
          clearInterval(this.interval);
          this.interval = null;
          break;
        case 'mousemove':
          this._hideAfterTimeout();
          this._updatePosition(event);
          break;
        default:
          break;
      }
    });
    _defineProperty(this, "hide", () => {
      clearTimeout(this.fadeTimeOut);
      if (this.el().parentNode) {
        this.el().parentNode.removeChild(this.el());
      }
    });
  }
  _hideAfterTimeout() {
    clearTimeout(this.fadeTimeOut);
    this.el().style.opacity = 1;
    this.fadeTimeOut = setTimeout(() => {
      this.el().style.opacity = 0;
    }, 5000);
  }
}
class RemoteCursorManager extends _MultiAgentManager.MultiAgentManager {
  constructor() {
    super(RemoteCursor);
  }
  update(type, event) {
    const instance = this.getInstanceForAgent(event.agent);
    instance.update(type, event);
  }
}
var _default = exports["default"] = new RemoteCursorManager();

/***/ }),

/***/ 94340:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _events = _interopRequireDefault(__webpack_require__(37007));
var _lite = __webpack_require__(22292);
var _Locale = _interopRequireDefault(__webpack_require__(77988));
var _mountComponent = __webpack_require__(89103);
var _components = __webpack_require__(12996);
var _SessionStateOverlayModule = _interopRequireDefault(__webpack_require__(53983));
var _jsxRuntime = __webpack_require__(10201);
const _excluded = ["showSessionControls", "showCallingControls"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const EndSession = _ref => {
  let {
    onClick
  } = _ref;
  return (0, _jsxRuntime.jsxs)(_components.Button, {
    className: _SessionStateOverlayModule.default.endSessionButton,
    onClick: () => onClick('session-end'),
    children: [_Locale.default.tr('END_SESSION'), (0, _jsxRuntime.jsx)(_components.Icon, {
      className: _SessionStateOverlayModule.default.endSessionIcon,
      name: "EndSession"
    })]
  });
};
const CallingControls = _ref2 => {
  let {
    onClick,
    audioEnabled,
    videoEnabled
  } = _ref2;
  return (0, _jsxRuntime.jsxs)("div", {
    className: _SessionStateOverlayModule.default.callingControlsContainer,
    children: [(0, _jsxRuntime.jsxs)("div", {
      className: _SessionStateOverlayModule.default.callingControlsToggleContainer,
      children: [(0, _jsxRuntime.jsx)(_components.IconButton, {
        className: (0, _lite.clsx)(_SessionStateOverlayModule.default.callingControlsToggle, audioEnabled ? _SessionStateOverlayModule.default.callingControlsToggleOn : _SessionStateOverlayModule.default.callingControlsToggleOff),
        ariaLabel: audioEnabled ? _Locale.default.tr('CALLING_DISABLE_AUDIO') : _Locale.default.tr('CALLING_ENABLE_AUDIO'),
        onClick: () => onClick('audio'),
        children: (0, _jsxRuntime.jsx)(_components.Icon, {
          name: audioEnabled ? 'Microphone' : 'MicrophoneOff',
          className: _SessionStateOverlayModule.default.callingControlsIcon
        })
      }), (0, _jsxRuntime.jsx)(_components.IconButton, {
        className: (0, _lite.clsx)(_SessionStateOverlayModule.default.callingControlsToggle, videoEnabled ? _SessionStateOverlayModule.default.callingControlsToggleOn : _SessionStateOverlayModule.default.callingControlsToggleOff),
        ariaLabel: videoEnabled ? _Locale.default.tr('CALLING_DISABLE_VIDEO') : _Locale.default.tr('CALLING_ENABLE_VIDEO'),
        onClick: () => onClick('video'),
        children: (0, _jsxRuntime.jsx)(_components.Icon, {
          name: videoEnabled ? 'Video' : 'VideoOff',
          className: _SessionStateOverlayModule.default.callingControlsIcon
        })
      }), (0, _jsxRuntime.jsx)(_components.IconButton, {
        className: (0, _lite.clsx)(_SessionStateOverlayModule.default.callingControlsToggle, _SessionStateOverlayModule.default.callingControlsToggleOn),
        ariaLabel: _Locale.default.tr('CALLING_SHOW_CALL_SETTINGS'),
        onClick: () => onClick('settings'),
        children: (0, _jsxRuntime.jsx)(_components.Icon, {
          name: "DotsVertical",
          className: _SessionStateOverlayModule.default.callingControlsIcon
        })
      })]
    }), (0, _jsxRuntime.jsx)(_components.IconButton, {
      className: _SessionStateOverlayModule.default.callingControlsEnd,
      ariaLabel: _Locale.default.tr('CALLING_END'),
      onClick: () => onClick('call-end'),
      children: (0, _jsxRuntime.jsx)(_components.Icon, {
        name: "Phone",
        className: _SessionStateOverlayModule.default.callingControlsIcon
      })
    })]
  });
};
const SessionStateOverlayComponent = _ref3 => {
  let {
      showSessionControls,
      showCallingControls
    } = _ref3,
    props = _objectWithoutProperties(_ref3, _excluded);
  return (0, _jsxRuntime.jsxs)("div", {
    className: _SessionStateOverlayModule.default.sessionStateOverlay,
    children: [showSessionControls ? (0, _jsxRuntime.jsx)(EndSession, _objectSpread({}, props)) : null, showCallingControls ? (0, _jsxRuntime.jsx)(CallingControls, _objectSpread({}, props)) : null]
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
var _props = /*#__PURE__*/new WeakMap();
var _update = /*#__PURE__*/new WeakMap();
class SessionStateOverlay extends _events.default {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec(this, _mountHandle, null);
    _classPrivateFieldInitSpec(this, _props, {
      showSessionControls: false,
      showCallingControls: false,
      onClick: target => this.emit('click', target),
      audioEnabled: false,
      videoEnabled: false
    });
    _classPrivateFieldInitSpec(this, _update, () => {
      const shouldShow = _classPrivateFieldGet(_props, this).showSessionControls || _classPrivateFieldGet(_props, this).showCallingControls;
      if (!shouldShow) {
        var _classPrivateFieldGet2;
        (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
        _classPrivateFieldSet(_mountHandle, this, null);
        return;
      }
      if (_classPrivateFieldGet(_mountHandle, this)) return _classPrivateFieldGet(_mountHandle, this).rerender(_classPrivateFieldGet(_props, this));
      _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(SessionStateOverlayComponent, _classPrivateFieldGet(_props, this), true, true));
    });
    _defineProperty(this, "showSessionControls", () => {
      _classPrivateFieldGet(_props, this).showSessionControls = true;
      _classPrivateFieldGet(_update, this).call(this);
    });
    _defineProperty(this, "hideSessionControls", () => {
      _classPrivateFieldGet(_props, this).showSessionControls = false;
      _classPrivateFieldGet(_update, this).call(this);
    });
    _defineProperty(this, "showCallingControls", _ref4 => {
      let {
        audioEnabled,
        videoEnabled
      } = _ref4;
      _classPrivateFieldGet(_props, this).showCallingControls = true;
      _classPrivateFieldGet(_props, this).audioEnabled = audioEnabled;
      _classPrivateFieldGet(_props, this).videoEnabled = videoEnabled;
      _classPrivateFieldGet(_update, this).call(this);
    });
    _defineProperty(this, "hideCallingControls", () => {
      _classPrivateFieldGet(_props, this).showCallingControls = false;
      _classPrivateFieldGet(_update, this).call(this);
    });
  }
}
var _default = exports["default"] = new SessionStateOverlay();

/***/ }),

/***/ 198:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const LOADING_SVG = 'data:image/svg+xml,<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z"><animateTransform attributeName="transform" type="rotate" dur="0.75s" values="0 12 12;360 12 12" repeatCount="indefinite"/></path></svg>';
const GLOBE_SVG = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="gray"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 0 1 7.843 4.582M12 3a8.997 8.997 0 0 0-7.843 4.582m15.686 0A11.953 11.953 0 0 1 12 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0 1 21 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0 1 12 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 0 1 3 12c0-1.605.42-3.113 1.157-4.418" /></svg>';
var _openingHistoryLength = /*#__PURE__*/new WeakMap();
var _modal = /*#__PURE__*/new WeakMap();
var _tabs = /*#__PURE__*/new WeakMap();
var _mediaQuery = /*#__PURE__*/new WeakMap();
var _handlePopState = /*#__PURE__*/new WeakMap();
var _handleBeforeUnload = /*#__PURE__*/new WeakMap();
var _closeTab = /*#__PURE__*/new WeakMap();
var _activateTab = /*#__PURE__*/new WeakMap();
var _tabModal = /*#__PURE__*/new WeakMap();
var _tabToolbar = /*#__PURE__*/new WeakMap();
var _tabPanelContainer = /*#__PURE__*/new WeakMap();
var _tabButton = /*#__PURE__*/new WeakMap();
var _tabPanel = /*#__PURE__*/new WeakMap();
class TabOverlay {
  constructor() {
    _classPrivateFieldInitSpec(this, _openingHistoryLength, void 0);
    _classPrivateFieldInitSpec(this, _modal, void 0);
    _classPrivateFieldInitSpec(this, _tabs, []);
    _classPrivateFieldInitSpec(this, _mediaQuery, window.matchMedia('(min-width: 768px)'));
    _defineProperty(this, "singleTabFullScreen", false);
    _defineProperty(this, "enterFullScreen", () => _classPrivateFieldGet(_modal, this).enterFullScreen());
    _defineProperty(this, "exitFullScreen", () => _classPrivateFieldGet(_modal, this).exitFullScreen());
    _defineProperty(this, "getTabCount", () => _classPrivateFieldGet(_tabs, this).length);
    _defineProperty(this, "newTab", (el, icon, title, isLoading, onClose, confirmUnload) => {
      const tab = _classPrivateFieldGet(_modal, this).createTab({
        onTabClick: e => {
          _classPrivateFieldGet(_activateTab, this).call(this, tab);
        },
        onClose,
        confirmUnload
      });
      tab.setIcon(icon);
      tab.setTitle(title);
      tab.setIsLoading(isLoading);
      tab.setContent(el);
      _classPrivateFieldGet(_tabs, this).push(tab);
      _classPrivateFieldGet(_activateTab, this).call(this, tab);
      _classPrivateFieldGet(_modal, this).showModal();
      if (_classPrivateFieldGet(_tabs, this).length === 1) history.pushState({
        universalProxyOpen: true
      }, '');
      return _objectSpread(_objectSpread({}, tab), {}, {
        close: () => _classPrivateFieldGet(_closeTab, this).call(this, tab)
      });
    });
    _classPrivateFieldInitSpec(this, _handlePopState, () => {
      if (_classPrivateFieldGet(_tabs, this).length === 1) _classPrivateFieldGet(_closeTab, this).call(this, _classPrivateFieldGet(_tabs, this)[0]);
    });
    _classPrivateFieldInitSpec(this, _handleBeforeUnload, e => {
      const confirmUnload = _classPrivateFieldGet(_tabs, this).some(tab => tab.confirmUnload);
      if (confirmUnload) e.preventDefault();
    });
    _defineProperty(this, "closeAllTabs", () => {
      _classPrivateFieldGet(_tabs, this).forEach(_classPrivateFieldGet(_closeTab, this));
    });
    _classPrivateFieldInitSpec(this, _closeTab, tab => {
      const tabIndex = _classPrivateFieldGet(_tabs, this).indexOf(tab);
      if (tabIndex === -1) return;
      tab.removeTab();
      _classPrivateFieldGet(_tabs, this).splice(tabIndex, 1);
      if (!_classPrivateFieldGet(_tabs, this).length) return _classPrivateFieldGet(_modal, this).hideModal();
      const lastTabIndex = _classPrivateFieldGet(_tabs, this).length - 1;
      if (tab.isActive()) {
        if (tabIndex <= lastTabIndex) {
          _classPrivateFieldGet(_tabs, this)[tabIndex].show();
        } else {
          _classPrivateFieldGet(_tabs, this)[lastTabIndex].show();
        }
      }
    });
    _classPrivateFieldInitSpec(this, _activateTab, tab => {
      _classPrivateFieldGet(_tabs, this).forEach(t => t.hide());
      tab.show();
    });
    _classPrivateFieldInitSpec(this, _tabModal, () => {
      const host = document.createElement('div');
      const shadow = host.attachShadow({
        mode: 'open'
      });
      const element = document.createElement('div');
      element.style.background = 'rgba(50, 50, 50, 0.4)';
      element.style.position = 'fixed';
      element.style.zIndex = '2147483645';
      element.style.bottom = '0';
      element.style.top = '0';
      element.style.left = '0';
      element.style.right = '0';
      element.style.display = 'flex';
      element.style.flexDirection = 'column';
      element.style.padding = _classPrivateFieldGet(_mediaQuery, this).matches ? '25px' : '0';
      shadow.appendChild(element);
      const toolbar = _classPrivateFieldGet(_tabToolbar, this).call(this);
      element.appendChild(toolbar.element);
      const panelContainer = _classPrivateFieldGet(_tabPanelContainer, this).call(this);
      element.appendChild(panelContainer.element);
      const createTab = _ref => {
        let {
          onTabClick,
          onClose,
          confirmUnload
        } = _ref;
        const button = _classPrivateFieldGet(_tabButton, this).call(this, {
          onTabClick,
          onCloseClick: e => {
            e.stopPropagation();
            onClose();
          }
        });
        toolbar.addButton(button.element);
        const panel = _classPrivateFieldGet(_tabPanel, this).call(this);
        panelContainer.addPanel(panel.element);
        return {
          setIcon: button.setIcon,
          setTitle: button.setTitle,
          setIsLoading: button.setIsLoading,
          showBanner: panel.showBanner,
          hideBanner: panel.hideBanner,
          show: () => {
            button.setIsActive(true);
            panel.showPanel();
          },
          hide: () => {
            button.setIsActive(false);
            panel.hidePanel();
          },
          removeTab: () => {
            toolbar.removeButton(button.element);
            panelContainer.removePanel(panel.element);
          },
          isActive: () => button.isActive,
          onClose,
          confirmUnload,
          setContent: panel.setContent
        };
      };
      let overflow = null;
      const showModal = () => {
        if (this.isVisible) return;
        document.body.appendChild(host);
        overflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        this.isVisible = true;
        _classPrivateFieldSet(_openingHistoryLength, this, history.length);
      };
      const hideModal = () => {
        document.body.removeChild(host);
        document.body.style.overflow = overflow;
        this.isVisible = false;
        const requiredStepsBack = history.length - _classPrivateFieldGet(_openingHistoryLength, this);
        if (requiredStepsBack > 0) history.go(-requiredStepsBack);
      };
      const enterFullScreen = () => {
        toolbar.hide();
        element.style.padding = '0';
      };
      const exitFullScreen = () => {
        toolbar.show();
        element.style.padding = _classPrivateFieldGet(_mediaQuery, this).matches ? '25px' : '0';
      };
      return {
        element,
        showModal,
        hideModal,
        createTab,
        enterFullScreen,
        exitFullScreen
      };
    });
    _classPrivateFieldInitSpec(this, _tabToolbar, () => {
      const element = document.createElement('div');
      element.style.display = 'flex';
      element.style.backgroundColor = '#d6e2fb';
      element.style.borderBottom = '1px solid #d8d8d8';
      element.style.paddingTop = '6px';
      element.style.paddingLeft = '6px';
      element.style.paddingBottom = '5px';
      element.style.borderRadius = '10px 10px 0 0';
      if (this.fullScreen) element.style.display = 'none';
      return {
        element,
        addButton: tabButtonElement => element.appendChild(tabButtonElement),
        removeButton: tabButtonElement => element.removeChild(tabButtonElement),
        show: () => {
          element.style.display = 'flex';
        },
        hide: () => {
          element.style.display = 'none ';
        }
      };
    });
    _classPrivateFieldInitSpec(this, _tabPanelContainer, () => {
      const element = document.createElement('div');
      element.style.width = '100%';
      element.style.height = '100%';
      element.style.backgroundColor = 'white';
      element.style.borderRadius = '0 0 10px 10px';
      element.style.overflow = 'hidden';
      return {
        element,
        addPanel: tabPanelElement => element.appendChild(tabPanelElement),
        removePanel: tabPanelElement => element.removeChild(tabPanelElement)
      };
    });
    _classPrivateFieldInitSpec(this, _tabButton, _ref2 => {
      let {
        onTabClick,
        onCloseClick
      } = _ref2;
      const element = document.createElement('div');
      element.style.display = 'flex';
      element.style.alignItems = 'center';
      element.style.justifyContent = 'end';
      element.style.flex = '1 1 0';
      element.style.backgroundColor = '#ffffff66';
      element.style.padding = '4px';
      element.style.maxWidth = '200px';
      element.style.minWidth = '0';
      element.style.overflow = 'hidden';
      element.style.cursor = 'pointer';
      element.style.borderRadius = '9px';
      element.style.marginRight = '6px';
      const iconImg = document.createElement('img');
      iconImg.style.flex = '0 0 auto';
      iconImg.style.width = '16px';
      iconImg.style.height = '16px';
      iconImg.style.marginRight = '4px';
      const titleSpan = document.createElement('span');
      titleSpan.style.flex = '1 1 auto';
      titleSpan.style.display = 'block';
      titleSpan.style.fontFamily = 'sans-serif';
      titleSpan.style.fontSize = '13px';
      titleSpan.style.overflow = 'hidden';
      titleSpan.style.whiteSpace = 'nowrap';
      titleSpan.style.textOverflow = 'ellipsis';
      const closeButton = document.createElement('button');
      closeButton.style.flex = '0 0 auto';
      closeButton.style.width = '24px';
      closeButton.style.height = '24px';
      closeButton.style.border = 'none';
      closeButton.style.background = 'none';
      closeButton.style.padding = '4px';
      closeButton.style.cursor = 'pointer';
      const closeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      closeSvg.setAttribute('fill', 'none');
      closeSvg.setAttribute('viewBox', '0 0 24 24');
      closeSvg.setAttribute('stroke-width', '1.5');
      closeSvg.setAttribute('stroke', 'currentColor');
      closeSvg.style.width = '16px';
      closeSvg.style.height = '16px';
      const closeSvgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      closeSvgPath.setAttribute('stroke-linecap', 'round');
      closeSvgPath.setAttribute('stroke-linejoin', 'round');
      closeSvgPath.setAttribute('d', 'M6 18 18 6M6 6l12 12');
      closeSvg.appendChild(closeSvgPath);
      closeButton.appendChild(closeSvg);
      element.appendChild(iconImg);
      element.appendChild(titleSpan);
      element.appendChild(closeButton);
      element.addEventListener('click', onTabClick);
      closeButton.addEventListener('click', onCloseClick);
      iconImg.onerror = function () {
        this.src = GLOBE_SVG;
      };
      return {
        element,
        icon: '',
        title: '',
        isActive: false,
        isLoading: false,
        setIcon: function (src) {
          this.icon = src;
          iconImg.src = src;
        },
        setTitle: function (title) {
          this.title = title;
          titleSpan.textContent = title;
        },
        setIsActive: function (isActive) {
          this.isActive = isActive;
          if (this.isActive) {
            element.style.backgroundColor = 'white';
            element.style.borderColor = '#d8d8d8';
          } else {
            element.style.backgroundColor = '#ffffff66';
            element.style.borderColor = '#efefef';
          }
        },
        setIsLoading: function (isLoading) {
          this.isLoading = isLoading;
          iconImg.src = this.isLoading ? LOADING_SVG : this.icon;
        }
      };
    });
    _classPrivateFieldInitSpec(this, _tabPanel, () => {
      const element = document.createElement('div');
      element.style.width = '100%';
      element.style.height = '100%';
      element.style.backgroundColor = 'white';
      element.style.display = 'flex';
      element.style.flexDirection = 'column';
      const bannerElement = document.createElement('div');
      bannerElement.style.height = '30px';
      bannerElement.style.width = '100%';
      bannerElement.style.display = 'flex';
      bannerElement.style.alignItems = 'center';
      bannerElement.style.justifyContent = 'center';
      bannerElement.style.backgroundColor = 'white';
      bannerElement.style.color = 'black';
      bannerElement.style.fontFamily = 'sans-serif';
      bannerElement.style.fontSize = '13px';
      bannerElement.style.borderBottom = '1px solid #d8d8d8';
      const elementWrapper = document.createElement('div');
      elementWrapper.style.flex = '1';
      element.appendChild(elementWrapper);
      return {
        element,
        showPanel: () => {
          element.style.display = 'flex';
        },
        hidePanel: () => {
          element.style.display = 'none';
        },
        showBanner: text => {
          bannerElement.innerText = text;
          if (!element.contains(bannerElement)) element.prepend(bannerElement);
        },
        hideBanner: () => {
          if (element.contains(bannerElement)) element.removeChild(bannerElement);
        },
        setContent: el => {
          if (elementWrapper.contains(el)) return;
          elementWrapper.replaceChildren(el);
        }
      };
    });
    _classPrivateFieldSet(_modal, this, _classPrivateFieldGet(_tabModal, this).call(this));
    _classPrivateFieldGet(_mediaQuery, this).addEventListener('change', event => {
      _classPrivateFieldGet(_modal, this).element.style.padding = event.matches ? '25px' : '0';
    });
    window.addEventListener('popstate', _classPrivateFieldGet(_handlePopState, this));
    window.addEventListener('beforeunload', _classPrivateFieldGet(_handleBeforeUnload, this));
  }
}
var _default = exports["default"] = new TabOverlay();

/***/ }),

/***/ 7410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(22292);
var _ButtonModule = _interopRequireDefault(__webpack_require__(2989));
var _jsxRuntime = __webpack_require__(10201);
const _excluded = ["children", "className", "variant"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Button = _ref => {
  let {
      children,
      className,
      variant
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: (0, _jsxRuntime.jsx)("button", _objectSpread(_objectSpread({
      className: (0, _lite.clsx)(_ButtonModule.default.base, _ButtonModule.default[variant], className)
    }, props), {}, {
      children: children
    }))
  });
};
var _default = exports["default"] = Button;

/***/ }),

/***/ 25029:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _hooks = __webpack_require__(45994);
var _jsxRuntime = __webpack_require__(10201);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const Draggable = _ref => {
  let {
    children,
    style,
    corner = 'top-left',
    onCornerChange
  } = _ref;
  const [position, setPosition] = (0, _hooks.useState)({
    x: 0,
    y: 0
  });
  const [isDragging, setIsDragging] = (0, _hooks.useState)(false);
  const [isSnapping, setIsSnapping] = (0, _hooks.useState)(false);
  const positionRef = (0, _hooks.useRef)(position);
  const elementRef = (0, _hooks.useRef)(null);
  const dragOffsetRef = (0, _hooks.useRef)({
    x: 0,
    y: 0
  });
  const snappedCornerOffsetRef = (0, _hooks.useRef)(null);
  const lastCornerRef = (0, _hooks.useRef)(corner);
  (0, _hooks.useEffect)(() => {
    positionRef.current = position;
  }, [position]);
  (0, _hooks.useEffect)(() => {
    var _window$visualViewpor, _window$visualViewpor2;
    if (!elementRef.current) return;
    const bounds = {
      width: ((_window$visualViewpor = window.visualViewport) === null || _window$visualViewpor === void 0 ? void 0 : _window$visualViewpor.width) || window.innerWidth,
      height: ((_window$visualViewpor2 = window.visualViewport) === null || _window$visualViewpor2 === void 0 ? void 0 : _window$visualViewpor2.height) || window.innerHeight
    };
    const {
      offsetWidth,
      offsetHeight
    } = elementRef.current;
    const corners = {
      'top-left': {
        x: 0,
        y: 0,
        dx: 0,
        dy: 0
      },
      'top-right': {
        x: bounds.width - offsetWidth,
        y: 0,
        dx: 1,
        dy: 0
      },
      'bottom-left': {
        x: 0,
        y: bounds.height - offsetHeight,
        dx: 0,
        dy: 1
      },
      'bottom-right': {
        x: bounds.width - offsetWidth,
        y: bounds.height - offsetHeight,
        dx: 1,
        dy: 1
      }
    };
    const {
      x,
      y,
      dx,
      dy
    } = corners[corner];
    setPosition({
      x,
      y
    });
    snappedCornerOffsetRef.current = {
      dx,
      dy
    };
    lastCornerRef.current = corner;
  }, [corner]);
  const handleStart = (clientX, clientY) => {
    setIsDragging(true);
    setIsSnapping(false);
    dragOffsetRef.current = {
      x: clientX - position.x,
      y: clientY - position.y
    };
  };
  const handleMouseDown = e => {
    e.preventDefault();
    handleStart(e.clientX, e.clientY);
  };
  const handleTouchStart = e => {
    const touch = e.touches[0];
    if (touch) {
      handleStart(touch.clientX, touch.clientY);
    }
  };
  (0, _hooks.useEffect)(() => {
    const handleMouseMove = e => {
      var _window$visualViewpor3, _window$visualViewpor4;
      if (!isDragging) return;
      const bounds = {
        width: ((_window$visualViewpor3 = window.visualViewport) === null || _window$visualViewpor3 === void 0 ? void 0 : _window$visualViewpor3.width) || window.innerWidth,
        height: ((_window$visualViewpor4 = window.visualViewport) === null || _window$visualViewpor4 === void 0 ? void 0 : _window$visualViewpor4.height) || window.innerHeight
      };
      let newX = e.clientX - dragOffsetRef.current.x;
      let newY = e.clientY - dragOffsetRef.current.y;
      if (elementRef.current) {
        const {
          offsetWidth,
          offsetHeight
        } = elementRef.current;
        newX = Math.max(0, Math.min(newX, bounds.width - offsetWidth));
        newY = Math.max(0, Math.min(newY, bounds.height - offsetHeight));
      }
      setPosition({
        x: newX,
        y: newY
      });
      positionRef.current = {
        x: newX,
        y: newY
      };
    };
    const handleTouchMove = e => {
      var _window$visualViewpor5, _window$visualViewpor6;
      if (!isDragging) return;
      e.preventDefault();
      const touch = e.touches[0];
      if (!touch) return;
      const bounds = {
        width: ((_window$visualViewpor5 = window.visualViewport) === null || _window$visualViewpor5 === void 0 ? void 0 : _window$visualViewpor5.width) || window.innerWidth,
        height: ((_window$visualViewpor6 = window.visualViewport) === null || _window$visualViewpor6 === void 0 ? void 0 : _window$visualViewpor6.height) || window.innerHeight
      };
      let newX = touch.clientX - dragOffsetRef.current.x;
      let newY = touch.clientY - dragOffsetRef.current.y;
      if (elementRef.current) {
        const {
          offsetWidth,
          offsetHeight
        } = elementRef.current;
        newX = Math.max(0, Math.min(newX, bounds.width - offsetWidth));
        newY = Math.max(0, Math.min(newY, bounds.height - offsetHeight));
      }
      setPosition({
        x: newX,
        y: newY
      });
      positionRef.current = {
        x: newX,
        y: newY
      };
    };
    const endDrag = () => {
      setIsDragging(false);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', endDrag);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', endDrag);
      setTimeout(snapToCorner, 0);
    };
    if (isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', endDrag);
      window.addEventListener('touchmove', handleTouchMove, {
        passive: false
      }); // 🔥 important
      window.addEventListener('touchend', endDrag);
    }
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', endDrag);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', endDrag);
    };
  }, [isDragging]);
  const handleResize = (0, _hooks.useCallback)(() => {
    var _window$visualViewpor7, _window$visualViewpor8;
    if (!elementRef.current || !snappedCornerOffsetRef.current) return;
    const bounds = {
      width: ((_window$visualViewpor7 = window.visualViewport) === null || _window$visualViewpor7 === void 0 ? void 0 : _window$visualViewpor7.width) || window.innerWidth,
      height: ((_window$visualViewpor8 = window.visualViewport) === null || _window$visualViewpor8 === void 0 ? void 0 : _window$visualViewpor8.height) || window.innerHeight
    };
    const {
      offsetWidth,
      offsetHeight
    } = elementRef.current;
    const {
      dx,
      dy
    } = snappedCornerOffsetRef.current;
    const newX = dx === 0 ? 0 : bounds.width - offsetWidth;
    const newY = dy === 0 ? 0 : bounds.height - offsetHeight;
    setPosition({
      x: newX,
      y: newY
    });
  }, []);
  (0, _hooks.useEffect)(() => {
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);
  (0, _hooks.useEffect)(() => {
    const observer = new ResizeObserver(() => {
      setIsSnapping(true);
      handleResize();
      setTimeout(() => setIsSnapping(false), 300);
    });
    if (elementRef.current) {
      observer.observe(elementRef.current);
    }
    return () => observer.disconnect();
  }, [handleResize]);
  const snapToCorner = () => {
    var _window$visualViewpor9, _window$visualViewpor0;
    if (!elementRef.current) return;
    const bounds = {
      width: ((_window$visualViewpor9 = window.visualViewport) === null || _window$visualViewpor9 === void 0 ? void 0 : _window$visualViewpor9.width) || window.innerWidth,
      height: ((_window$visualViewpor0 = window.visualViewport) === null || _window$visualViewpor0 === void 0 ? void 0 : _window$visualViewpor0.height) || window.innerHeight
    };
    const {
      offsetWidth,
      offsetHeight
    } = elementRef.current;
    const corners = [{
      name: 'top-left',
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    }, {
      name: 'top-right',
      x: bounds.width - offsetWidth,
      y: 0,
      dx: 1,
      dy: 0
    }, {
      name: 'bottom-left',
      x: 0,
      y: bounds.height - offsetHeight,
      dx: 0,
      dy: 1
    }, {
      name: 'bottom-right',
      x: bounds.width - offsetWidth,
      y: bounds.height - offsetHeight,
      dx: 1,
      dy: 1
    }];
    const current = positionRef.current;
    const distance = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    const nearest = corners.reduce((closest, corner) => distance(current, corner) < distance(current, closest) ? corner : closest);
    setIsSnapping(true);
    setPosition({
      x: nearest.x,
      y: nearest.y
    });
    snappedCornerOffsetRef.current = {
      dx: nearest.dx,
      dy: nearest.dy
    };
    if (lastCornerRef.current !== nearest.name) {
      onCornerChange === null || onCornerChange === void 0 || onCornerChange(nearest.name);
      lastCornerRef.current = nearest.name;
    }
    setTimeout(() => setIsSnapping(false), 300);
  };
  return (0, _jsxRuntime.jsx)("div", {
    ref: elementRef,
    style: _objectSpread(_objectSpread({}, style), {}, {
      position: 'fixed',
      left: position.x,
      top: position.y,
      cursor: isDragging ? 'grabbing' : 'grab',
      transition: isSnapping ? 'left 0.3s ease, top 0.3s ease, transform 0.2s ease' : 'transform 0.2s ease',
      transform: isDragging ? 'scale(1.02)' : 'scale(1)'
    }),
    onMouseDown: handleMouseDown,
    onTouchStart: handleTouchStart,
    children: children
  });
};
var _default = exports["default"] = Draggable;

/***/ }),

/***/ 66497:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(62953);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var icons = _interopRequireWildcard(__webpack_require__(66746));
var _jsxRuntime = __webpack_require__(10201);
const _excluded = ["name"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Icon = _ref => {
  let {
      name
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread({
    "aria-hidden": "true",
    style: {
      display: 'inline-block'
    }
  }, props), {}, {
    children: icons[name]
  }));
};
var _default = exports["default"] = Icon;

/***/ }),

/***/ 50341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(22292);
var _IconButtonModule = _interopRequireDefault(__webpack_require__(64556));
var _jsxRuntime = __webpack_require__(10201);
const _excluded = ["children", "className", "ariaLabel", "title"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const IconButton = _ref => {
  let {
      children,
      className,
      ariaLabel,
      title
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("button", _objectSpread(_objectSpread({
    className: (0, _lite.clsx)(_IconButtonModule.default.base, className),
    "aria-label": ariaLabel,
    title: ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : title
  }, props), {}, {
    children: children
  }));
};
var _default = exports["default"] = IconButton;

/***/ }),

/***/ 4287:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(22292);
var _Locale = _interopRequireDefault(__webpack_require__(77988));
var _ModalModule = _interopRequireDefault(__webpack_require__(32704));
var _jsxRuntime = __webpack_require__(10201);
const _excluded = ["children", "className"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Modal = _ref => {
  let {
      children,
      className
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread({
    className: _ModalModule.default.container,
    role: "dialog",
    "aria-modal": "true"
  }, props), {}, {
    children: (0, _jsxRuntime.jsx)("section", {
      className: (0, _lite.clsx)(_ModalModule.default.content, className),
      dir: _Locale.default.direction(),
      children: children
    })
  }));
};
var _default = exports["default"] = Modal;

/***/ }),

/***/ 88670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(22292);
var _chevronDown = _interopRequireDefault(__webpack_require__(52098));
var _SelectModule = _interopRequireDefault(__webpack_require__(9417));
var _jsxRuntime = __webpack_require__(10201);
const _excluded = ["children", "iconUrl", "className", "ariaLabel", "style"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Select = _ref => {
  let {
      children,
      iconUrl,
      className,
      ariaLabel,
      style
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  const iconStyle = iconUrl ? {
    backgroundImage: "url(\"".concat(iconUrl, "\"),url(\"").concat(_chevronDown.default, "\")"),
    backgroundPosition: 'left 4px center,right 4px center',
    padding: '8px 24px 8px 24px'
  } : {
    backgroundImage: "url(\"".concat(_chevronDown.default, "\")")
  };
  const mergedStyle = _objectSpread(_objectSpread({}, iconStyle), style);
  return (0, _jsxRuntime.jsx)("select", _objectSpread(_objectSpread({
    className: (0, _lite.clsx)(_SelectModule.default.base, !iconUrl && _SelectModule.default.noIcon, className),
    "aria-label": ariaLabel,
    style: mergedStyle
  }, props), {}, {
    children: children
  }));
};
var _default = exports["default"] = Select;

/***/ }),

/***/ 82973:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
const _excluded = ["children"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const SelectOption = _ref => {
  let {
      children
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("option", _objectSpread(_objectSpread({}, props), {}, {
    children: children
  }));
};
var _default = exports["default"] = SelectOption;

/***/ }),

/***/ 12996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Button", ({
  enumerable: true,
  get: function () {
    return _Button.default;
  }
}));
Object.defineProperty(exports, "Draggable", ({
  enumerable: true,
  get: function () {
    return _Draggable.default;
  }
}));
Object.defineProperty(exports, "Icon", ({
  enumerable: true,
  get: function () {
    return _Icon.default;
  }
}));
Object.defineProperty(exports, "IconButton", ({
  enumerable: true,
  get: function () {
    return _IconButton.default;
  }
}));
Object.defineProperty(exports, "Modal", ({
  enumerable: true,
  get: function () {
    return _Modal.default;
  }
}));
Object.defineProperty(exports, "Select", ({
  enumerable: true,
  get: function () {
    return _Select.default;
  }
}));
Object.defineProperty(exports, "SelectOption", ({
  enumerable: true,
  get: function () {
    return _SelectOption.default;
  }
}));
var _Button = _interopRequireDefault(__webpack_require__(7410));
var _Draggable = _interopRequireDefault(__webpack_require__(25029));
var _Icon = _interopRequireDefault(__webpack_require__(66497));
var _IconButton = _interopRequireDefault(__webpack_require__(50341));
var _Modal = _interopRequireDefault(__webpack_require__(4287));
var _Select = _interopRequireDefault(__webpack_require__(88670));
var _SelectOption = _interopRequireDefault(__webpack_require__(82973));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 96438:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _hooks = __webpack_require__(45994);
var _mountComponent = __webpack_require__(89103);
var _HighlightOverlayModule = _interopRequireDefault(__webpack_require__(59887));
var _jsxRuntime = __webpack_require__(10201);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const DEFAULT_BORDER_RADIUS = '4px';
const getOverlayPosition = element => {
  // Calculate the element's position and size
  const rect = element.getBoundingClientRect();
  const scrollTop = document.documentElement.scrollTop;
  const scrollLeft = document.documentElement.scrollLeft;
  const top = rect.top + scrollTop;
  const left = rect.left + scrollLeft;
  const width = rect.width;
  const height = rect.height;
  if (!width || !height) return null;

  // Get the element's border radius so that we can apply the same radius
  // to the highlight area. For elements without a border radius, we use a
  // default value to avoid showing sharp corners.
  const computedStyles = window.getComputedStyle(element);
  let borderRadius = computedStyles.borderRadius || computedStyles.borderTopLeftRadius;
  if (borderRadius === '0px') {
    borderRadius = DEFAULT_BORDER_RADIUS;
  }

  // Calculate padding to achieve 6px spacing on all sides
  const paddedX = (width + 6) / width;
  const paddedY = (height + 6) / height;
  return {
    top,
    left,
    width,
    height,
    borderRadius,
    paddedX,
    paddedY
  };
};
const HighlightOverlayComponent = _ref => {
  let {
    targetElement
  } = _ref;
  const overlayRef = (0, _hooks.useRef)();
  const scrollEventDisabledRef = (0, _hooks.useRef)(false);
  const updatePosition = (0, _hooks.useCallback)(() => {
    if (!targetElement) return;
    const position = getOverlayPosition(targetElement);
    if (!position || !overlayRef.current) return;
    const {
      top,
      left,
      width,
      height,
      borderRadius,
      paddedX,
      paddedY
    } = position;

    // Update the overlay position and size and show it
    requestAnimationFrame(() => {
      overlayRef.current.style.width = "".concat(width, "px");
      overlayRef.current.style.height = "".concat(height, "px");
      overlayRef.current.style.top = "".concat(top, "px");
      overlayRef.current.style.left = "".concat(left, "px");
      overlayRef.current.style.borderRadius = borderRadius;
      overlayRef.current.style.setProperty('--cbio-padded-x', paddedX);
      overlayRef.current.style.setProperty('--cbio-padded-y', paddedY);
    });
  }, [targetElement]);
  const scrollElementIntoView = (0, _hooks.useCallback)(() => {
    if (!targetElement) return;
    scrollEventDisabledRef.current = true;
    targetElement.scrollIntoView({
      behavior: 'smooth',
      block: 'center',
      inline: 'center'
    });
    setTimeout(() => {
      scrollEventDisabledRef.current = false;
      updatePosition();
    }, 100);
  }, [targetElement, updatePosition]);
  (0, _hooks.useEffect)(() => {
    scrollElementIntoView();
  }, [scrollElementIntoView]);

  // Set the initial position
  (0, _hooks.useEffect)(() => {
    updatePosition();
  }, [updatePosition]);
  (0, _hooks.useEffect)(() => {
    let animationTimeout;
    const reposition = () => {
      if (scrollEventDisabledRef.current) return;
      if (overlayRef.current) {
        // Temporarily disable animations during resize or scroll so that
        // the highlight stays in position and doesn't jump around
        requestAnimationFrame(() => {
          overlayRef.current.classList.add(_HighlightOverlayModule.default.disableAnimations);
        });
        updatePosition();

        // Restore animations
        requestAnimationFrame(() => {
          overlayRef.current.classList.remove(_HighlightOverlayModule.default.disableAnimations);
        });
      }
    };
    window.addEventListener('resize', reposition);
    window.addEventListener('scroll', reposition, {
      passive: true,
      capture: true
    });
    return () => {
      window.removeEventListener('resize', reposition);
      window.removeEventListener('scroll', reposition, {
        passive: true,
        capture: true
      });
      clearTimeout(animationTimeout);
    };
  }, [updatePosition, targetElement]);
  (0, _hooks.useEffect)(() => {
    let mutationObserver;
    if (targetElement) {
      mutationObserver = new MutationObserver(() => {
        const isInDOM = targetElement.isConnected;
        const isVisible = targetElement.checkVisibility ? targetElement.checkVisibility() : true;
        overlayRef.current.style.display = isInDOM && isVisible ? 'block' : 'none';
      });

      // Detect when the element styles change
      mutationObserver.observe(targetElement, {
        attributes: true,
        attributeFilter: ['style', 'class']
      });
      // Detect when the element is removed from the DOM
      mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
    return () => {
      var _mutationObserver;
      (_mutationObserver = mutationObserver) === null || _mutationObserver === void 0 || _mutationObserver.disconnect();
    };
  }, [targetElement]);
  return (0, _jsxRuntime.jsx)("div", {
    className: _HighlightOverlayModule.default.overlay,
    ref: overlayRef
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
class HighlightOverlay {
  constructor() {
    _classPrivateFieldInitSpec(this, _mountHandle, null);
    _defineProperty(this, "update", element => {
      if (!_classPrivateFieldGet(_mountHandle, this)) {
        _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(HighlightOverlayComponent, {
          targetElement: element
        }, false, true));
      } else {
        _classPrivateFieldGet(_mountHandle, this).rerender({
          targetElement: element
        });
      }
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet2;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      _classPrivateFieldSet(_mountHandle, this, null);
    });
  }
}
var _default = exports["default"] = new HighlightOverlay();

/***/ }),

/***/ 27527:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
var _dom = __webpack_require__(20949);
var _hooks = __webpack_require__(45994);
var _mountComponent = __webpack_require__(89103);
var _TooltipModule = _interopRequireDefault(__webpack_require__(36000));
var _jsxRuntime = __webpack_require__(10201);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const getUpdatedPositions = async (targetElement, tooltipElement, arrowElement) => {
  if (!targetElement || !tooltipElement || !arrowElement) return null;
  const {
    x,
    y,
    placement,
    middlewareData
  } = await (0, _dom.computePosition)(targetElement, tooltipElement, {
    placement: 'top',
    middleware: [(0, _dom.offset)(12), (0, _dom.flip)(), (0, _dom.shift)({
      padding: 8
    }), (0, _dom.arrow)({
      element: arrowElement
    }), (0, _dom.hide)()]
  });
  const {
    x: arrowX,
    y: arrowY
  } = middlewareData.arrow;
  const isVisible = !middlewareData.hide.referenceHidden;
  const staticSide = {
    top: 'bottom',
    right: 'left',
    bottom: 'top',
    left: 'right'
  }[placement.split('-')[0]];
  return {
    tooltip: {
      x,
      y
    },
    arrow: {
      x: arrowX,
      y: arrowY,
      staticSide
    },
    isVisible
  };
};
const TooltipTitle = _ref => {
  let {
    title
  } = _ref;
  return (0, _jsxRuntime.jsx)("div", {
    className: _TooltipModule.default.tooltipTitle,
    children: title
  });
};
const TooltipArrow = _ref2 => {
  let {
    arrowRef
  } = _ref2;
  return (0, _jsxRuntime.jsx)("div", {
    className: _TooltipModule.default.tooltipArrow,
    ref: arrowRef
  });
};
const TooltipComponent = _ref3 => {
  let {
    targetElement,
    title
  } = _ref3;
  const tooltipRef = (0, _hooks.useRef)();
  const arrowRef = (0, _hooks.useRef)();
  (0, _hooks.useEffect)(() => {
    var _tooltipRef$current;
    const updatePosition = async () => {
      const positions = await getUpdatedPositions(targetElement, tooltipRef.current, arrowRef.current);
      if (!positions) return;
      tooltipRef.current.style.left = "".concat(positions.tooltip.x, "px");
      tooltipRef.current.style.top = "".concat(positions.tooltip.y, "px");
      tooltipRef.current.style.display = positions.isVisible ? 'block' : 'none';
      arrowRef.current.style.left = positions.arrow.x ? "".concat(positions.arrow.x, "px") : '';
      arrowRef.current.style.top = positions.arrow.y ? "".concat(positions.arrow.y, "px") : '';
      arrowRef.current.style[positions.arrow.staticSide] = '-4px';
    };
    let cleanup;
    if (targetElement) {
      cleanup = (0, _dom.autoUpdate)(targetElement, tooltipRef.current, updatePosition);
    }
    (_tooltipRef$current = tooltipRef.current) === null || _tooltipRef$current === void 0 || _tooltipRef$current.classList.add(_TooltipModule.default.tooltipVisible);
    return () => {
      var _cleanup;
      (_cleanup = cleanup) === null || _cleanup === void 0 || _cleanup();
    };
  }, [targetElement]);
  return (0, _jsxRuntime.jsxs)("div", {
    className: _TooltipModule.default.tooltip,
    role: "tooltip",
    "aria-live": "polite",
    ref: tooltipRef,
    children: [(0, _jsxRuntime.jsx)(TooltipTitle, {
      title: title
    }), (0, _jsxRuntime.jsx)(TooltipArrow, {
      arrowRef: arrowRef
    })]
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
class Tooltip {
  constructor() {
    _classPrivateFieldInitSpec(this, _mountHandle, null);
    _defineProperty(this, "update", (element, title) => {
      if (!_classPrivateFieldGet(_mountHandle, this)) {
        _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(TooltipComponent, {
          targetElement: element,
          title
        }, true, true));
      } else {
        _classPrivateFieldGet(_mountHandle, this).rerender({
          targetElement: element,
          title
        });
      }
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet2;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      _classPrivateFieldSet(_mountHandle, this, null);
    });
  }
}
var _default = exports["default"] = new Tooltip();

/***/ }),

/***/ 24364:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useMediaDevices = void 0;
__webpack_require__(62953);
var _hooks = __webpack_require__(45994);
const PERMISSION = {
  GRANTED: 'granted',
  DENIED: 'denied',
  PROMPT: 'prompt'
};
const isPermission = permission => ({
  granted: permission === PERMISSION.GRANTED,
  denied: permission === PERMISSION.DENIED,
  prompt: permission === PERMISSION.PROMPT
});
const useMediaDevices = () => {
  const [audioInputDevices, setAudioInputDevices] = (0, _hooks.useState)([]);
  const [audioOutputDevices, setAudioOutputDevices] = (0, _hooks.useState)([]);
  const [videoInputDevices, setVideoInputDevices] = (0, _hooks.useState)([]);
  const [audioPermissionState, setAudioPermissionState] = (0, _hooks.useState)(PERMISSION.PROMPT);
  const [videoPermissionState, setVideoPermissionState] = (0, _hooks.useState)(PERMISSION.PROMPT);
  const audioPermission = (0, _hooks.useMemo)(() => isPermission(audioPermissionState), [audioPermissionState]);
  const videoPermission = (0, _hooks.useMemo)(() => isPermission(videoPermissionState), [videoPermissionState]);
  const audioPermissionRef = (0, _hooks.useRef)(null);
  const videoPermissionRef = (0, _hooks.useRef)(null);
  const updateDeviceLists = (0, _hooks.useCallback)(async () => {
    if (!navigator.mediaDevices) return;
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = [];
    const audioOutputs = [];
    const videoInputs = [];
    devices.forEach(device => {
      if (!device.deviceId) return;
      if (device.kind === 'audioinput') audioInputs.push(device);
      if (device.kind === 'audiooutput') audioOutputs.push(device);
      if (device.kind === 'videoinput') videoInputs.push(device);
    });
    setAudioInputDevices(audioInputs);
    setAudioOutputDevices(audioOutputs);
    setVideoInputDevices(videoInputs);
  }, []);
  const onAudioPermissionChange = () => setAudioPermissionState(audioPermissionRef.current.state);
  const onVideoPermissionChange = () => setVideoPermissionState(videoPermissionRef.current.state);
  const updatePermissions = (0, _hooks.useCallback)(async () => {
    try {
      var _audioPermissionRef$c, _videoPermissionRef$c;
      (_audioPermissionRef$c = audioPermissionRef.current) === null || _audioPermissionRef$c === void 0 || _audioPermissionRef$c.removeEventListener('change', onAudioPermissionChange);
      audioPermissionRef.current = await navigator.permissions.query({
        name: 'microphone'
      });
      audioPermissionRef.current.addEventListener('change', onAudioPermissionChange);
      (_videoPermissionRef$c = videoPermissionRef.current) === null || _videoPermissionRef$c === void 0 || _videoPermissionRef$c.removeEventListener('change', onVideoPermissionChange);
      videoPermissionRef.current = await navigator.permissions.query({
        name: 'camera'
      });
      videoPermissionRef.current.addEventListener('change', onVideoPermissionChange);
      setAudioPermissionState(audioPermissionRef.current.state);
      setVideoPermissionState(videoPermissionRef.current.state);
    } catch (err) {
      console.warn('CobrowseIO: Failed to get permissions', err);
      setAudioPermissionState(PERMISSION.PROMPT);
      setVideoPermissionState(PERMISSION.PROMPT);
    }
  }, []);
  (0, _hooks.useEffect)(() => {
    updatePermissions();
  }, [updatePermissions]);
  (0, _hooks.useEffect)(() => {
    var _navigator$mediaDevic;
    (_navigator$mediaDevic = navigator.mediaDevices) === null || _navigator$mediaDevic === void 0 || _navigator$mediaDevic.addEventListener('devicechange', updateDeviceLists);
    updateDeviceLists();
    return () => {
      var _navigator$mediaDevic2;
      (_navigator$mediaDevic2 = navigator.mediaDevices) === null || _navigator$mediaDevic2 === void 0 || _navigator$mediaDevic2.removeEventListener('devicechange', updateDeviceLists);
    };
  }, [updateDeviceLists]);
  (0, _hooks.useEffect)(() => {
    updateDeviceLists();
  }, [audioPermissionState, videoPermissionState, updateDeviceLists]);
  return {
    audioInputDevices,
    audioOutputDevices,
    videoInputDevices,
    audioPermission,
    videoPermission,
    updateDeviceLists,
    updatePermissions
  };
};
exports.useMediaDevices = useMediaDevices;

/***/ }),

/***/ 94909:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useSpeaking = void 0;
__webpack_require__(62953);
var _hooks = __webpack_require__(45994);
var _NoiseAnalyser = _interopRequireDefault(__webpack_require__(37688));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const SPEAKING_VOLUME_THRESHOLD = 15;
const useSpeaking = participant => {
  const [isSpeaking, setIsSpeaking] = (0, _hooks.useState)(false);
  const noiseAnalyser = (0, _hooks.useRef)(null);
  (0, _hooks.useEffect)(() => {
    const onNoiseUpdated = hasNoise => setIsSpeaking(hasNoise);
    const handleTrackChange = () => {
      if (participant.hasAudio && !noiseAnalyser.current) {
        noiseAnalyser.current = new _NoiseAnalyser.default(participant.stream, SPEAKING_VOLUME_THRESHOLD);
        noiseAnalyser.current.on('noise.updated', onNoiseUpdated);
      }
      if (!participant.hasAudio && noiseAnalyser.current) {
        noiseAnalyser.current.off('noise.updated', onNoiseUpdated);
        noiseAnalyser.current.destroy();
        noiseAnalyser.current = null;
        setIsSpeaking(false);
      }
    };
    participant.on('track.added', handleTrackChange);
    participant.on('track.removed', handleTrackChange);
    handleTrackChange();
    return () => {
      participant.off('track.removed', handleTrackChange);
      participant.off('track.added', handleTrackChange);
      if (noiseAnalyser.current) {
        noiseAnalyser.current.off('noise.updated', onNoiseUpdated);
        noiseAnalyser.current.destroy();
        noiseAnalyser.current = null;
      }
    };
  }, [participant]);
  return isSpeaking;
};
exports.useSpeaking = useSpeaking;

/***/ }),

/***/ 78898:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"
  })]
});

/***/ }),

/***/ 29515:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsx)("svg", {
  height: "100%",
  viewBox: "0 0 25 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: (0, _jsxRuntime.jsx)("path", {
    d: "M21.5 12V15C21.5 15.2652 21.3946 15.5196 21.2071 15.7071C21.0196 15.8946 20.7652 16 20.5 16H4.5C4.23478 16 3.98043 15.8946 3.79289 15.7071C3.60536 15.5196 3.5 15.2652 3.5 15L3.5 5C3.5 4.73478 3.60536 4.48043 3.79289 4.29289C3.98043 4.10536 4.23478 4 4.5 4L13.5 4M7.5 20H17.5M9.5 16V20M15.5 16V20M17.5 8L21.5 4M17.5 4L21.5 8",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  })
});

/***/ }),

/***/ 27008:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M5 10a7 7 0 0 0 14 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M8 21l8 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 17l0 4"
  })]
});

/***/ }),

/***/ 25239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M3 3l18 18"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M8 21l8 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 17l0 4"
  })]
});

/***/ }),

/***/ 98930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsx)("svg", {
  height: "100%",
  viewBox: "0 0 25 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: (0, _jsxRuntime.jsx)("path", {
    d: "M23.1068 13.9142L20.2784 16.7426L15.3286 14.6213L16.0357 11.7929C13.7429 11.0147 11.2574 11.0147 8.96465 11.7929L9.67175 14.6213L4.72201 16.7426L1.89358 13.9142C1.51851 13.5391 1.30779 13.0304 1.30779 12.5C1.30779 11.9696 1.51851 11.4609 1.89358 11.0858C4.81944 8.49517 8.59225 7.06493 12.5002 7.06493C16.4081 7.06493 20.1809 8.49517 23.1068 11.0858C23.4819 11.4609 23.6926 11.9696 23.6926 12.5C23.6926 13.0304 23.4819 13.5391 23.1068 13.9142Z",
    stroke: "#F5F6FB",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  })
});

/***/ }),

/***/ 50505:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M15 10l4.553 -2.276a1 1 0 0 1 1.447 .894v6.764a1 1 0 0 1 -1.447 .894l-4.553 -2.276v-4z"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M3 6m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"
  })]
});

/***/ }),

/***/ 84032:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M3 3l18 18"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M15 11v-1l4.553 -2.276a1 1 0 0 1 1.447 .894v6.764a1 1 0 0 1 -.675 .946"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M10 6h3a2 2 0 0 1 2 2v3m0 4v1a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-8a2 2 0 0 1 2 -2h1"
  })]
});

/***/ }),

/***/ 63894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(10201);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M15 8a5 5 0 0 1 0 8"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M17.7 5a9 9 0 0 1 0 14"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M6 15h-2a1 1 0 0 1 -1 -1v-4a1 1 0 0 1 1 -1h2l3.5 -4.5a.8 .8 0 0 1 1.5 .5v14a.8 .8 0 0 1 -1.5 .5l-3.5 -4.5"
  })]
});

/***/ }),

/***/ 66746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "DotsVertical", ({
  enumerable: true,
  get: function () {
    return _DotsVertical.default;
  }
}));
Object.defineProperty(exports, "EndSession", ({
  enumerable: true,
  get: function () {
    return _EndSession.default;
  }
}));
Object.defineProperty(exports, "Microphone", ({
  enumerable: true,
  get: function () {
    return _Microphone.default;
  }
}));
Object.defineProperty(exports, "MicrophoneOff", ({
  enumerable: true,
  get: function () {
    return _MicrophoneOff.default;
  }
}));
Object.defineProperty(exports, "Phone", ({
  enumerable: true,
  get: function () {
    return _Phone.default;
  }
}));
Object.defineProperty(exports, "Video", ({
  enumerable: true,
  get: function () {
    return _Video.default;
  }
}));
Object.defineProperty(exports, "VideoOff", ({
  enumerable: true,
  get: function () {
    return _VideoOff.default;
  }
}));
Object.defineProperty(exports, "Volume", ({
  enumerable: true,
  get: function () {
    return _Volume.default;
  }
}));
var _DotsVertical = _interopRequireDefault(__webpack_require__(78898));
var _EndSession = _interopRequireDefault(__webpack_require__(29515));
var _Microphone = _interopRequireDefault(__webpack_require__(27008));
var _MicrophoneOff = _interopRequireDefault(__webpack_require__(25239));
var _Phone = _interopRequireDefault(__webpack_require__(98930));
var _Video = _interopRequireDefault(__webpack_require__(50505));
var _VideoOff = _interopRequireDefault(__webpack_require__(84032));
var _Volume = _interopRequireDefault(__webpack_require__(63894));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 33035:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AnnotationOverlay", ({
  enumerable: true,
  get: function () {
    return _AnnotationOverlay.default;
  }
}));
Object.defineProperty(exports, "CallParticipants", ({
  enumerable: true,
  get: function () {
    return _CallParticipants.default;
  }
}));
Object.defineProperty(exports, "ConsentDialog", ({
  enumerable: true,
  get: function () {
    return _ConsentDialog.default;
  }
}));
Object.defineProperty(exports, "Highlight", ({
  enumerable: true,
  get: function () {
    return _Highlight.default;
  }
}));
Object.defineProperty(exports, "LaserOverlay", ({
  enumerable: true,
  get: function () {
    return _LaserOverlay.default;
  }
}));
Object.defineProperty(exports, "MediaPreview", ({
  enumerable: true,
  get: function () {
    return _MediaPreview.default;
  }
}));
Object.defineProperty(exports, "RemoteCursor", ({
  enumerable: true,
  get: function () {
    return _RemoteCursor.default;
  }
}));
Object.defineProperty(exports, "SessionStateOverlay", ({
  enumerable: true,
  get: function () {
    return _SessionStateOverlay.default;
  }
}));
__webpack_require__(2143);
var _AnnotationOverlay = _interopRequireDefault(__webpack_require__(63024));
var _LaserOverlay = _interopRequireDefault(__webpack_require__(86162));
var _RemoteCursor = _interopRequireDefault(__webpack_require__(53291));
var _SessionStateOverlay = _interopRequireDefault(__webpack_require__(94340));
var _ConsentDialog = _interopRequireDefault(__webpack_require__(65573));
var _Highlight = _interopRequireDefault(__webpack_require__(76575));
var _CallParticipants = _interopRequireDefault(__webpack_require__(73807));
var _MediaPreview = _interopRequireDefault(__webpack_require__(94037));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 37487:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(27495);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _convertLinkToRegExp = __webpack_require__(50048);
var _navigation = __webpack_require__(49715);
var _Navigation = __webpack_require__(44661);
var _UniversalProxy = _interopRequireDefault(__webpack_require__(88619));
var _iframes = _interopRequireDefault(__webpack_require__(77966));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _universalLinkRegExps = /*#__PURE__*/new WeakMap();
var _universalProxy = /*#__PURE__*/new WeakMap();
var _loadUniversalDocument = /*#__PURE__*/new WeakMap();
var _loadForbiddenDocument = /*#__PURE__*/new WeakMap();
class UniversalHandler extends _navigation.NavigationHandler {
  constructor(session, delegate) {
    var _delegate$universalLi;
    super();
    _classPrivateFieldInitSpec(this, _universalLinkRegExps, void 0);
    _classPrivateFieldInitSpec(this, _universalProxy, void 0);
    _classPrivateFieldInitSpec(this, _loadUniversalDocument, (url, target, windowFeatures, options) => {
      const {
        document: universalDocument
      } = options;
      const universalProxyFrameName = _classPrivateFieldGet(_universalProxy, this).createUniversalProxyFrameName();
      const universalProxyUrl = _classPrivateFieldGet(_universalProxy, this).createUniversalProxyUrl(url, universalProxyFrameName);
      const universalProxyIFrame = _classPrivateFieldGet(_universalProxy, this).createUniversalProxyIFrame(universalProxyUrl, universalProxyFrameName);
      universalDocument.load(universalProxyUrl, target, windowFeatures, {
        element: universalProxyIFrame,
        type: this.type
      });
      const onDocument = (_ref, _ref2) => {
        let {
          handle,
          document: {
            url,
            icon,
            title,
            isLoading,
            isBlocked
          }
        } = _ref;
        let {
          trusted,
          iframe
        } = _ref2;
        if (handle) return;
        if (!trusted) return;
        if (iframe !== universalProxyIFrame) return;
        universalDocument.url = url;
        universalDocument.icon = icon;
        universalDocument.title = title;
        universalDocument.isLoading = isLoading;
        universalDocument.isBlocked = isBlocked;
      };
      _iframes.default.on('document', onDocument);
      universalDocument.once('closed', () => {
        _iframes.default.off('document', onDocument);
      });
    });
    _classPrivateFieldInitSpec(this, _loadForbiddenDocument, (url, target, windowFeatures, options) => {
      const {
        document: fobiddenDocument
      } = options;
      const element = document.createElement('div');
      element.style.width = '100%';
      element.style.height = '100%';
      element.style.backgroundColor = 'black';
      fobiddenDocument.load(url, target, windowFeatures, {
        element,
        type: this.type
      });
      fobiddenDocument.isLoading = false;
      fobiddenDocument.isBlocked = true;
    });
    _classPrivateFieldSet(_universalLinkRegExps, this, ((_delegate$universalLi = delegate.universalLinks) === null || _delegate$universalLi === void 0 ? void 0 : _delegate$universalLi.map(_convertLinkToRegExp.convertLinkToRegExp)) || []);
    _classPrivateFieldSet(_universalProxy, this, new _UniversalProxy.default(session, delegate.api, delegate.version));
  }
  get type() {
    return _Navigation.NAVIGATION_TYPE.UNIVERSAL;
  }
  shouldHandleEvent(e) {
    // only watch for events that have started bubbling
    if (e.eventPhase === Event.CAPTURING_PHASE) return false;
    // we need to honor the defaultPrevented flag for Universal
    // navigations as this can cause a double navigation to occur
    return !e.defaultPrevented;
  }
  shouldHandle(u) {
    const urlWithoutQueryParams = new URL(u, window.location.origin);
    urlWithoutQueryParams.search = '';
    return _classPrivateFieldGet(_universalLinkRegExps, this).some(regExp => regExp.test(urlWithoutQueryParams));
  }
  handle(url, target, windowFeatures, options) {
    const loadDocument = this.shouldHandle(url) ? _classPrivateFieldGet(_loadUniversalDocument, this) : _classPrivateFieldGet(_loadForbiddenDocument, this);
    loadDocument(url, target, windowFeatures, options);
    return {
      document: options.document
    };
  }
}
exports["default"] = UniversalHandler;

/***/ }),

/***/ 11191:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class UniversalHooks {
  constructor() {
    _defineProperty(this, "proxify", url => url);
    _defineProperty(this, "unproxify", url => url);
    _defineProperty(this, "inUniversalProxy", false);
  }
}
var _default = exports["default"] = new UniversalHooks();

/***/ }),

/***/ 88619:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _protected = _interopRequireDefault(__webpack_require__(37609));
var _proxy = __webpack_require__(9147);
var _randomString = _interopRequireDefault(__webpack_require__(78981));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _session = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _sdkVersion = /*#__PURE__*/new WeakMap();
class UniversalProxy {
  constructor(session, api, sdkVersion) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _api, void 0);
    _classPrivateFieldInitSpec(this, _sdkVersion, void 0);
    _defineProperty(this, "createUniversalProxyFrameName", () => "cbioUniversalFrame-".concat((0, _randomString.default)(5)));
    _defineProperty(this, "createUniversalProxyUrl", (url, frameName) => {
      const proxyToken = _classPrivateFieldGet(_session, this)[_protected.default].proxyToken();
      const sessionProxyUrl = _classPrivateFieldGet(_session, this)[_protected.default].proxyUrl();
      const proxyUrl = new URL(sessionProxyUrl, _classPrivateFieldGet(_api, this));
      const queryParams = {
        parent_origin: window.location.origin,
        proxy_path: proxyUrl.pathname,
        sdk_version: _classPrivateFieldGet(_sdkVersion, this),
        frame_name: frameName
      };
      const urlRewriter = new _proxy.URLRewriter(proxyUrl, _proxy.PROXY_PREFIX.UNIVERSAL, proxyToken, window.location, queryParams);
      const targetUrl = urlRewriter.proxify(url);
      return targetUrl;
    });
    _defineProperty(this, "createUniversalProxyIFrame", (src, name) => {
      const iframe = document.createElement('iframe');

      // allow WebAuthn within the iframe
      iframe.allow = 'publickey-credentials-get *';
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.backgroundColor = 'white';
      iframe.style.border = 'none';
      iframe.src = src;
      iframe.name = name;
      return iframe;
    });
    _classPrivateFieldSet(_session, this, session);
    _classPrivateFieldSet(_api, this, api);
    _classPrivateFieldSet(_sdkVersion, this, sdkVersion);
  }
}
exports["default"] = UniversalProxy;

/***/ }),

/***/ 91834:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "UniversalHandler", ({
  enumerable: true,
  get: function () {
    return _UniversalHandler.default;
  }
}));
Object.defineProperty(exports, "UniversalProxy", ({
  enumerable: true,
  get: function () {
    return _UniversalProxy.default;
  }
}));
var _UniversalProxy = _interopRequireDefault(__webpack_require__(88619));
var _UniversalHandler = _interopRequireDefault(__webpack_require__(37487));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 29516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _debug = _interopRequireDefault(__webpack_require__(51227));
var _storage = _interopRequireDefault(__webpack_require__(86542));
var _rest = __webpack_require__(18111);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.VirtualAgent.VirtualAgentEmbed');
const storageKeyPrefix = '_cobrowse_va_conversation_';

/**
 * How long the embed data can be cached in local storage.
 * This depends on how long the signed urls are valid.
 * e.g. ElevenLabs is only valid for 15 minutes
 */
const conversationTtlMillis = 13 * 60 * 1000;

/** The maximum number of seconds to wait when retrying a failed embed request */
const expBackoffLimitSeconds = 15 * 60;
class VirtualAgentEmbed extends _rest.RESTResource {
  constructor() {
    super();
    _defineProperty(this, "url", () => {
      return new URL("api/1/virtualagents/".concat(encodeURIComponent(this.slug()), "/embed"), VirtualAgentEmbed.api).toString();
    });
    _defineProperty(this, "slug", () => {
      return this.field('slug');
    });
    _defineProperty(this, "type", () => {
      return this.field('type');
    });
    /**
     * Get the provider-specific data that is needed to embed the agent widget for this specific
     * provider. This data-structure is not known by the interface at this level, however its model
     * is known between the provider impl in the API and the provider impl in the JS SDK.
     *
     * @returns {Record<string, unknown>}
     */
    _defineProperty(this, "data", () => {
      return this.field('data');
    });
    debug('constructed');
  }
  static async load(delegate, slug) {
    var _store$getItem;
    const agent = new VirtualAgentEmbed();
    const store = (0, _storage.default)(delegate.license);
    const storageKey = "".concat(storageKeyPrefix).concat(slug);
    const {
      iat,
      resource,
      attempts = 0
    } = (_store$getItem = store.getItem(storageKey)) !== null && _store$getItem !== void 0 ? _store$getItem : {};
    if (resource && iat && iat > Date.now() - conversationTtlMillis) {
      debug('loaded agent embed data from storage');
      agent.updateResource(resource);
      return agent;
    }
    if (!resource && attempts) {
      const nextRetry = getNextRetryTime(iat, attempts);
      if (nextRetry > Date.now()) {
        console.warn("Not loading virtual agent embed data, next retry at: ".concat(new Date(nextRetry)));
        return;
      }
    }
    try {
      debug('loading agent embed data from the API');
      agent.updateResource({
        slug
      });
      await agent.fetch();
    } catch (err) {
      const nextRetry = getNextRetryTime(Date.now(), attempts);
      console.error("Unable to resolve virtual agent embed data. Next retry at ".concat(new Date(nextRetry)), err);
      store.setItem(storageKey, {
        iat: Date.now(),
        attempts: attempts + 1
      });
      return;
    }
    store.setItem(storageKey, {
      resource: agent.resource,
      iat: Date.now()
    });
    return agent;
  }
}
exports["default"] = VirtualAgentEmbed;
function getNextRetryTime(iat, attempts) {
  const backoffSeconds = Math.min(Math.pow(2, attempts), expBackoffLimitSeconds);
  const backoffMs = backoffSeconds * 1000;
  return iat + backoffMs;
}

/***/ }),

/***/ 13177:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.initializeVirtualAgent = initializeVirtualAgent;
__webpack_require__(62953);
var _VirtualAgentEmbed = _interopRequireDefault(__webpack_require__(29516));
var _debug = _interopRequireDefault(__webpack_require__(51227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.VirtualAgent');
async function initializeVirtualAgent(agentSlug, delegate) {
  debug('Loading virtual agent %s', agentSlug);
  const embed = await _VirtualAgentEmbed.default.load(delegate, agentSlug);
  if ((embed === null || embed === void 0 ? void 0 : embed.type()) === 'elevenlabs') {
    // Dynamically import the widget logic so it doesn't get bundled into the main SDK
    const {
      loadElevenLabsWidget
    } = await __webpack_require__.e(/* import() | elevenlabs */ 660).then(__webpack_require__.bind(__webpack_require__, 31475));
    await loadElevenLabsWidget(embed, delegate);
  }
}

/***/ }),

/***/ 14162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ClientTracker = void 0;
__webpack_require__(62953);
var _events = _interopRequireDefault(__webpack_require__(37007));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _id = /*#__PURE__*/new WeakMap();
var _instanceId = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _pingInterval = /*#__PURE__*/new WeakMap();
var _clients = /*#__PURE__*/new WeakMap();
var _expired = /*#__PURE__*/new WeakMap();
class ClientTracker extends _events.default {
  constructor(_id2, _instanceId2) {
    let {
      interval
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      interval: 3000
    };
    super();
    _classPrivateFieldInitSpec(this, _id, void 0);
    _classPrivateFieldInitSpec(this, _instanceId, void 0);
    _classPrivateFieldInitSpec(this, _interval, void 0);
    _classPrivateFieldInitSpec(this, _pingInterval, void 0);
    _classPrivateFieldInitSpec(this, _clients, new Map());
    _defineProperty(this, "ping", () => {
      this.emit('ping', {
        id: _classPrivateFieldGet(_id, this),
        instanceId: _classPrivateFieldGet(_instanceId, this),
        timeout: _classPrivateFieldGet(_interval, this) * 2
      });
    });
    _defineProperty(this, "track", _ref => {
      let {
        id,
        instanceId,
        timeout,
        agent
      } = _ref;
      if (this.id === id) return;
      const hasClient = _classPrivateFieldGet(_clients, this).has(id);
      if (!hasClient) _classPrivateFieldGet(_clients, this).set(id, {
        instances: new Map(),
        agent
      });
      const client = _classPrivateFieldGet(_clients, this).get(id);
      const instance = client.instances.get(instanceId);
      const timer = setTimeout(() => _classPrivateFieldGet(_expired, this).call(this, id, instanceId), timeout || _classPrivateFieldGet(_interval, this) * 2);
      if (instance) clearTimeout(instance.timeout);
      client.instances.set(instanceId, {
        timestamp: new Date(),
        timeout: timer
      });
      if (!hasClient) this.emit('join', {
        id,
        agent
      });

      // when a new client instance is detected we resend our client state
      if (!instance) this.ping();
    });
    _classPrivateFieldInitSpec(this, _expired, (id, instanceId) => {
      const client = _classPrivateFieldGet(_clients, this).get(id);
      client.instances.delete(instanceId);
      if (client.instances.size === 0) {
        _classPrivateFieldGet(_clients, this).delete(id);
        this.emit('leave', id);
      }
    });
    _defineProperty(this, "all", () => {
      return Array.from(_classPrivateFieldGet(_clients, this)).map(_ref2 => {
        let [id, {
          agent
        }] = _ref2;
        return {
          id,
          agent
        };
      });
    });
    _defineProperty(this, "destroy", () => {
      for (const client of _classPrivateFieldGet(_clients, this).values()) {
        for (const instance of client.instances.values()) {
          clearTimeout(instance.timeout);
        }
        client.instances.clear();
      }
      _classPrivateFieldGet(_clients, this).clear();
      clearInterval(_classPrivateFieldGet(_pingInterval, this));
      this.removeAllListeners();
    });
    _classPrivateFieldSet(_id, this, _id2);
    _classPrivateFieldSet(_instanceId, this, _instanceId2);
    _classPrivateFieldSet(_interval, this, interval);
    _classPrivateFieldSet(_pingInterval, this, setInterval(this.ping, interval));
  }
  get id() {
    return _classPrivateFieldGet(_id, this);
  }
}
exports.ClientTracker = ClientTracker;

/***/ }),

/***/ 31762:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class DataUrl {
  static fromImage(img) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    return this.fromCanvas(canvas);
  }
  static fromCanvas(canvas) {
    let scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let quality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.3;
    if (scale === 1) return canvas.toDataURL ? canvas.toDataURL('image/webp', quality) : null;
    const scaledCanvas = document.createElement('canvas');
    const scaledContext = scaledCanvas.getContext('2d');
    scaledCanvas.width = canvas.width * scale;
    scaledCanvas.height = canvas.height * scale;
    scaledContext.drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
    return scaledCanvas.toDataURL('image/webp', quality);
  }
}
exports["default"] = DataUrl;

/***/ }),

/***/ 63976:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Deferred = void 0;
class Deferred {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
}
exports.Deferred = Deferred;

/***/ }),

/***/ 18781:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class RateLimiter {
  constructor(rate, period) {
    // allow rate passes over period milliseconds
    this.rate = rate;
    this.period = period;

    // tracks timestamps of the limit calls
    this._tracked = [];
  }
  limit() {
    // clear out expired entries from the tracking array
    const expiry = Date.now() - this.period;
    this._tracked = this._tracked.filter(t => t > expiry);

    // work out if there's space for the new entry
    if (this._tracked.length < this.rate) {
      this._tracked.push(Date.now());
      return false;
    } else {
      return true;
    }
  }
}
exports["default"] = RateLimiter;

/***/ }),

/***/ 44153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(62953);
var _events = __webpack_require__(37007);
var _throttle = _interopRequireDefault(__webpack_require__(7350));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class WindowTaps extends _events.EventEmitter {
  constructor() {
    super();
    _defineProperty(this, "windows", new Set());
    _defineProperty(this, "tap", window => {
      if (this.windows.has(window)) return;
      this.windows.add(window);
      const self = this;
      const pushState = window.history.pushState.bind(window.history);
      window.history.pushState = function () {
        const previousUrl = window.location.href;
        pushState(...arguments);
        self.emit('navigate', window, previousUrl);
      };
      const replaceState = window.history.replaceState.bind(window.history);
      window.history.replaceState = function () {
        const previousUrl = window.location.href;
        replaceState(...arguments);
        self.emit('navigate', window, previousUrl);
      };
      const {
        insertRule
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.insertRule = function () {
        const ret = insertRule.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        deleteRule
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.deleteRule = function () {
        const ret = deleteRule.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        replace
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.replace = function () {
        const ret = replace.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        replaceSync
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.replaceSync = function () {
        const ret = replaceSync.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        attachShadow
      } = window.Element.prototype;
      window.Element.prototype.attachShadow = function (options) {
        const shadowRoot = attachShadow.bind(this)(options);
        self.emit('attachshadow', shadowRoot);
        return shadowRoot;
      };
      const watchCanvasContext = canvasContext => {
        Object.getOwnPropertyNames(canvasContext.prototype).forEach(prop => {
          try {
            if (typeof canvasContext.prototype[prop] !== 'function') return;
          } catch (_err) {
            // accessing some properties will throw an exception we can't test for
            return;
          }
          const originalFn = canvasContext.prototype[prop];
          canvasContext.prototype[prop] = function () {
            if (!this.canvas.__cbio_emit_change) {
              this.canvas.__cbio_emit_change = (0, _throttle.default)(c => self.emit('canvaschange', c), 500, {
                leading: false,
                trailing: true
              });
            }
            this.canvas.__cbio_emit_change(this.canvas);
            return originalFn.apply(this, arguments);
          };
        });
      };
      watchCanvasContext(window.CanvasRenderingContext2D);
      watchCanvasContext(window.WebGLRenderingContext);
      if (window.WebGL2RenderingContext) watchCanvasContext(window.WebGL2RenderingContext);
    });
    _defineProperty(this, "untap", (/* window */
    ) => {
      // todo: work out how to remove only our taps...
    });
    this.setMaxListeners(200);
  }
}
var _default = exports["default"] = new WindowTaps();

/***/ }),

/***/ 40923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _nodes = __webpack_require__(66938);
async function _default() {
  if (_nodes.NodeSerializer.isLocalResource(window.location.href)) {
    console.warn('CobrowseIO: This page was loaded from a local address, Cobrowse may not work as expected due to inaccessible resources. We recommend using ngrok for testing development versions.');
  }
}

/***/ }),

/***/ 50048:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertLinkToRegExp = void 0;
__webpack_require__(84864);
__webpack_require__(27495);
var _globToRegexp = _interopRequireDefault(__webpack_require__(37047));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const convertLinkToRegExp = link => link instanceof RegExp ? link : (0, _globToRegexp.default)(link, {
  flags: 'i'
});
exports.convertLinkToRegExp = convertLinkToRegExp;

/***/ }),

/***/ 42777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createRipple = createRipple;
__webpack_require__(62953);
var _hexToRgb = __webpack_require__(98276);
// track the styles already added to the page
const rippleStyleSet = new Set();
function injectRippleStyles(rippleDuration, rippleScale) {
  const key = "".concat(rippleDuration, "-").concat(rippleScale);
  if (rippleStyleSet.has(key)) {
    return;
  }
  const styleElement = document.createElement('style');
  styleElement.id = "cbio_session_ripple_stylesheet_".concat(key);
  styleElement.textContent = "\n        @keyframes cbio_session_ripple_effect-".concat(key, " {\n            0% {\n                transform: translate(-50%, -50%) scale(2);\n                opacity: 1;\n            }\n            100% {\n                transform: translate(-50%, -50%) scale(").concat(rippleScale, ");\n                opacity: 0;\n            }\n        }\n        .cbio_session_ripple-").concat(key, " {\n            width: 8px;\n            height: 8px;\n            border-radius: 50%;\n            position: absolute;\n            z-index: 2147483647;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%) scale(").concat(rippleScale, ");\n            pointer-events: none;\n            animation: cbio_session_ripple_effect-").concat(key, " ").concat(rippleDuration, "ms ease-out forwards;\n        }\n    ");
  document.head.appendChild(styleElement);

  // Add the key to the Set to mark this combination as injected
  rippleStyleSet.add(key);
}
function createRipple(selectedColor, rippleDuration, rippleScale) {
  let customStyles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  injectRippleStyles(rippleDuration, rippleScale);
  const selectedColorRgba = (0, _hexToRgb.hexToRGB)(selectedColor, 0.25);
  const ripple = document.createElement('div');
  ripple.classList.add("cbio_session_ripple-".concat(rippleDuration, "-").concat(rippleScale));
  Object.assign(ripple.style, {
    backgroundColor: selectedColorRgba
  }, customStyles);
  setTimeout(() => {
    ripple.remove();
  }, rippleDuration);
  return ripple;
}

/***/ }),

/***/ 38091:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.discoverNodes = discoverNodes;
__webpack_require__(62953);
var _nodes = __webpack_require__(66938);
/**
 * Builds a list of elements which have been added, removed or modified by mutating
 * the passed objects. Added and removed nodes are expanded to include their children.
 *
 * @param {MutationRecord} change - The mutation record to process
 * @param {Set} modified - The set of modified nodes
 * @param {Set} added - The map of added nodes
 * @param {Set} removed - The map of removed nodes
 */
function discoverNodes(change, modified, added, removed) {
  const addedNodes = new Set(change.addedNodes
  // slices because of IE 11 wierdness
  ? [].slice.call(change.addedNodes) : []);
  if (!removed.has(change.target)) {
    modified.add(change.target);
  }
  for (const node of addedNodes) {
    _nodes.NodeTree.depthFirst(node, n => {
      modified.add(n);
      removed.delete(n);
      added.add(n);
    });
  }

  // when a node is removed we also need to make sure we track all its its children
  // as removed, even those in the modified collection
  if (change.removedNodes) {
    [].slice.call(change.removedNodes).forEach(node => {
      _nodes.NodeTree.depthFirst(node, n => {
        modified.delete(n);
        added.delete(n);
        removed.add(n);
      });
    });
  }
}

/***/ }),

/***/ 10000:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setFormAttribute = exports.getFormAttribute = void 0;
const getFormAttribute = (form, attribute) => {
  return Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, attribute).get.call(form);
};
exports.getFormAttribute = getFormAttribute;
const setFormAttribute = (form, attribute, value) => {
  return Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, attribute).set.call(form, value);
};
exports.setFormAttribute = setFormAttribute;

/***/ }),

/***/ 37387:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getCssText = void 0;
const getCssText = sheet => {
  try {
    if (sheet.media && sheet.media.length && !window.matchMedia(sheet.media).matches) return '';
  } catch (e) {
    console.warn('CobrowseIO: Media detection for sheet failed:', e, 'sheet', sheet);
  }
  return [].slice.call(sheet.cssRules).reduce((prev, cssRule) => {
    // IE11 throws an error on serializing some css animation rules
    // so we simply ignore them for now.
    try {
      return prev + cssRule.cssText;
    } catch (e) {
      return prev;
    }
  }, '');
};
exports.getCssText = getCssText;

/***/ }),

/***/ 37195:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getPersistentId = void 0;
var _uuid = __webpack_require__(65392);
var _storage = _interopRequireDefault(__webpack_require__(86542));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const getPersistentId = key => {
  const id = (0, _storage.default)().getItem(key);
  if (id) return id;
  const newId = (0, _uuid.v4)();
  (0, _storage.default)().setItem(key, newId);
  return newId;
};
exports.getPersistentId = getPersistentId;

/***/ }),

/***/ 97384:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getScrollBarSize = getScrollBarSize;
let scrollbarSize = null;
function getScrollBarSize() {
  if (scrollbarSize == null) {
    var _document$body, _document$body2;
    const elem = document.createElement('div');
    elem.style.cssText = 'width: 100px; height: 100px; overflow: scroll; position: absolute; top: -500px; left: -500px; margin: 0px; padding: 0px; border: none;';
    (_document$body = document.body) === null || _document$body === void 0 || _document$body.appendChild(elem);
    scrollbarSize = elem.offsetWidth - elem.clientWidth;
    (_document$body2 = document.body) === null || _document$body2 === void 0 || _document$body2.removeChild(elem);
  }
  return scrollbarSize;
}

/***/ }),

/***/ 98276:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hexToRGB = hexToRGB;
function hexToRGB(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  if (alpha) {
    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
  } else {
    return 'rgb(' + r + ', ' + g + ', ' + b + ')';
  }
}

/***/ }),

/***/ 56851:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
__webpack_require__(27495);
__webpack_require__(25440);
__webpack_require__(62953);
__webpack_require__(3296);
__webpack_require__(27208);
__webpack_require__(48408);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _default(url, token) {
  let delegate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _CobrowseIO.default;
  // websockets dont support cusotmer headers, so use query
  // string instead
  const query = [token ? "access_token=".concat(token) : null, "X-CobrowseSDKVersion=".concat(delegate.version), 'X-CobrowsePlatform=web', "X-CobrowseDevice=".concat(delegate.deviceId()), "X-CobrowseLicense=".concat(delegate.license)].filter(Boolean).join('&');

  // The server may not always specify the FQDN of the socket server
  // and may return a path relative to the API URL.
  // We resolve the value sent by the server against the currently configured
  // API to create an URL with a full domain name included.
  // Note: this will likely result in an URL that ends in a slash
  const resolved = new URL(url, delegate.api).toString();

  // The browser APIs require a wss:// protocol for connecting websockets
  // so we'll do a simple replacement of http(s) -> ws(s)
  const wsUrl = resolved.replace('https://', 'wss://').replace('http://', 'ws://');

  // Resolve the sockets path against the URL we've generated for the socket
  // server so far.
  // Note: we unofficially support socket paths that include a base path,
  //       e.g. https://example.com/cobrowse/ so this means we should leave
  //       off the leading / so it resolves relative to the current path
  return new URL("sockets/1/ws?".concat(query), wsUrl).toString();
}

/***/ }),

/***/ 89103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.mountComponent = void 0;
var _preact = __webpack_require__(50172);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const mountComponent = (component, initialProps, hideFromAgent, useShadowRoot) => {
  const container = document.createElement('div');
  if (hideFromAgent) container.className = '__cbio_ignored';
  const mountTarget = useShadowRoot ? container.attachShadow({
    mode: 'open'
  }) : container;
  const unmount = () => {
    (0, _preact.render)(null, mountTarget);
    if (document.body.contains(container)) document.body.removeChild(container);
  };
  const renderWithProps = props => {
    (0, _preact.render)((0, _preact.h)(component, _objectSpread(_objectSpread({}, props), {}, {
      unmount
    })), mountTarget);
  };
  renderWithProps(initialProps);
  document.body.appendChild(container);
  const styleTag = document.createElement('style');
  styleTag.textContent = window.__cbio_sdk_styles;
  mountTarget.prepend(styleTag);
  return {
    unmount,
    rerender: renderWithProps
  };
};
exports.mountComponent = mountComponent;

/***/ }),

/***/ 18567:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseWindowFeatures = void 0;
__webpack_require__(62953);
const TRUE_VALUES = ['true', 'yes', undefined];
const FALSE_VALUES = ['false', 'no'];
const parseWindowFeatures = windowFeatures => {
  if (typeof windowFeatures !== 'string') return {};
  const lowerCaseWindowFeatures = windowFeatures.toLowerCase();
  return lowerCaseWindowFeatures.split(',').reduce((acc, feature) => {
    const [key, value] = feature.split('=');
    acc[key] = TRUE_VALUES.indexOf(value) >= 0 ? true : FALSE_VALUES.indexOf(value) >= 0 ? false : value;
    return acc;
  }, {});
};
exports.parseWindowFeatures = parseWindowFeatures;

/***/ }),

/***/ 37609:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.protect = protect;
__webpack_require__(89463);
const symbol = Symbol('protected');
var _default = exports["default"] = symbol;
function protect(obj, method, fn) {
  if (!obj[symbol]) {
    Object.defineProperty(obj, symbol, {
      enumerable: false,
      value: {}
    });
  }
  const existing = obj[symbol][method];
  Object.getPrototypeOf(Object.getPrototypeOf(obj))[method] = existing;
  Object.defineProperty(obj[symbol], method, {
    enumerable: false,
    value: fn,
    configurable: true
  });
  return fn;
}

/***/ }),

/***/ 78981:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = randomString;
const nums = '0123456789';
const alphas = 'abcdefghijklmnopqrstuvwxyz';
const alphanums = "".concat(nums).concat(alphas.toLowerCase()).concat(alphas.toUpperCase());
function randomString(len) {
  let chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : alphanums;
  let random = '';
  for (let i = len; i > 0; i -= 1) {
    random += chars[Math.floor(Math.random() * chars.length)];
  }
  return random;
}

/***/ }),

/***/ 82117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.splitNameFromTarget = void 0;
const SPECIAL_TARGET_NAMES = ['_blank', '_self', '_parent', '_top', '_unfencedTop'];
const splitNameFromTarget = (target, defaultTarget) => {
  if (!target) return {
    name: '',
    target: defaultTarget
  };
  if (SPECIAL_TARGET_NAMES.includes(target)) return {
    name: '',
    target
  };
  return {
    name: target,
    target: defaultTarget
  };
};
exports.splitNameFromTarget = splitNameFromTarget;

/***/ }),

/***/ 58325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.delta = delta;
exports.mark = mark;
const timestamps = {
  load: Date.now()
};
function mark(tag) {
  timestamps[tag] = Date.now();
}
function delta(tag1, tag2) {
  if (!timestamps[tag1]) return NaN;
  if (tag1 && tag2) {
    return timestamps[tag2] - timestamps[tag1];
  } else {
    return Date.now() - timestamps[tag1];
  }
}

/***/ }),

/***/ 58973:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class UserAgents {
  static isHeadless() {
    return navigator.userAgent.toLowerCase().includes('headless');
  }
}
exports["default"] = UserAgents;

/***/ }),

/***/ 79883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Node = exports.MutationObserver = exports.EventTarget = exports.Event = exports.Element = void 0;
var _iframe$contentWindow, _iframe;
let iframe;
try {
  iframe = document.createElement('iframe');
  document.documentElement.appendChild(iframe);
  iframe.style.display = 'none';
  iframe.className = '__cbio_ignored';
  iframe.width = 0;
  iframe.height = 0;
} catch (e) {
  console.warn('Failed to create unpolyfill iframe', e);
}
const {
  Node,
  Element,
  MutationObserver,
  Event,
  EventTarget
} = (_iframe$contentWindow = (_iframe = iframe) === null || _iframe === void 0 ? void 0 : _iframe.contentWindow) !== null && _iframe$contentWindow !== void 0 ? _iframe$contentWindow : window;
exports.EventTarget = EventTarget;
exports.Event = Event;
exports.MutationObserver = MutationObserver;
exports.Element = Element;
exports.Node = Node;

/***/ }),

/***/ 22292:
/***/ ((module) => {

function e(){for(var e,o=0,r="",t=arguments.length;o<t;o++)(e=arguments[o])&&"string"==typeof e&&(r+=(r&&" ")+e);return r}module.exports=e,module.exports.clsx=e;

/***/ }),

/***/ 25454:
/***/ ((module) => {

"use strict";
/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */



const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object; // eslint-disable-line import/no-mutable-exports
let {
  apply,
  construct
} = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const arraySplice = unapply(Array.prototype.splice);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
/**
 * Creates a new function that calls the given function with a specified thisArg and arguments.
 *
 * @param func - The function to be wrapped and called.
 * @returns A new function that calls the given function with a specified thisArg and arguments.
 */
function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
/**
 * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
 *
 * @param func - The constructor function to be wrapped and called.
 * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
 */
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
/**
 * Add properties to a lookup table
 *
 * @param set - The set to which elements will be added.
 * @param array - The array containing elements to be added to the set.
 * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
 * @returns The modified set with added elements.
 */
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === 'string') {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
/**
 * Clean up an array to harden against CSPP
 *
 * @param array - The array to be cleaned.
 * @returns The cleaned version of the array
 */
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}
/**
 * Shallow clone an object
 *
 * @param object - The object to be cloned.
 * @returns A new object that copies the original.
 */
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === 'object' && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
/**
 * This method automatically checks if the prop is function or getter and behaves accordingly.
 *
 * @param object - The object to look up the getter function in its prototype chain.
 * @param prop - The property name for which to find the getter function.
 * @returns The getter function found in the prototype chain or a fallback function.
 */
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}

const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
const text = freeze(['#text']);

const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var EXPRESSIONS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ARIA_ATTR: ARIA_ATTR,
  ATTR_WHITESPACE: ATTR_WHITESPACE,
  CUSTOM_ELEMENT: CUSTOM_ELEMENT,
  DATA_ATTR: DATA_ATTR,
  DOCTYPE_NAME: DOCTYPE_NAME,
  ERB_EXPR: ERB_EXPR,
  IS_ALLOWED_URI: IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR: MUSTACHE_EXPR,
  TMPLIT_EXPR: TMPLIT_EXPR
});

/* eslint-disable @typescript-eslint/indent */
// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12 // Deprecated
};
const getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param trustedTypes The policy factory.
 * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
 * @return The policy created (or null, if Trusted Types
 * are not supported or creating the policy failed).
 */
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }
  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  let suffix = null;
  const ATTR_NAME = 'data-tt-policy-suffix';
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html) {
        return html;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};
const _createHooksMap = function _createHooksMap() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
  const DOMPurify = root => createDOMPurify(root);
  DOMPurify.version = '3.2.4';
  DOMPurify.removed = [];
  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  const remove = lookupGetter(ElementPrototype, 'remove');
  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    const template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = '';
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
  const {
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */
  /* allowed element names */
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  /* Allowed attribute names */
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  /*
   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  let FORBID_TAGS = null;
  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  let FORBID_ATTR = null;
  /* Decide if ARIA attributes are okay */
  let ALLOW_ARIA_ATTR = true;
  /* Decide if custom data attributes are okay */
  let ALLOW_DATA_ATTR = true;
  /* Decide if unknown protocols are okay */
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  let SAFE_FOR_TEMPLATES = false;
  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  let SAFE_FOR_XML = true;
  /* Decide if document with <html>... should be returned */
  let WHOLE_DOCUMENT = false;
  /* Track whether config is already set on this instance of DOMPurify. */
  let SET_CONFIG = false;
  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  let FORCE_BODY = false;
  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  let RETURN_DOM = false;
  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  let RETURN_DOM_FRAGMENT = false;
  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  let RETURN_TRUSTED_TYPE = false;
  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  let SANITIZE_DOM = true;
  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  /* Keep element content when removing element? */
  let KEEP_CONTENT = true;
  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  let IN_PLACE = false;
  /* Allow usage of profiles like html, svg and mathMl */
  let USE_PROFILES = {};
  /* Tags to ignore content of when KEEP_CONTENT is true */
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  /* Tags that are safe for data: URIs */
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  /* Attributes safe for values like "javascript:" */
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  /* Allowed XHTML+XML namespaces */
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  /* Parsing of strict XHTML documents */
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  let transformCaseFunc = null;
  /* Keep a reference to config to pass to hooks */
  let CONFIG = null;
  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */
  const formElement = document.createElement('form');
  const isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  /**
   * _parseConfig
   *
   * @param cfg optional config literal
   */
  // eslint-disable-next-line complexity
  const _parseConfig = function _parseConfig() {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    /* Shield configuration object from tampering */
    if (!cfg || typeof cfg !== 'object') {
      cfg = {};
    }
    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
    /* Set configuration parameters */
    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      // Overwrite existing TrustedTypes policy.
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      // Sign local variables required by `sanitize`.
      emptyHTML = trustedTypesPolicy.createHTML('');
    } else {
      // Uninitialized policy, attempt to initialize the internal dompurify policy.
      if (trustedTypesPolicy === undefined) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      // If creating the internal policy succeeded sign internal variables.
      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
        emptyHTML = trustedTypesPolicy.createHTML('');
      }
    }
    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  /**
   * @param element a DOM element whose namespace is being checked
   * @returns Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  const _checkValidNamespace = function _checkValidNamespace(element) {
    let parent = getParentNode(element);
    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template'
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }
      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }
      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }
      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };
  /**
   * _forceRemove
   *
   * @param node a DOM node
   */
  const _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };
  /**
   * _removeAttribute
   *
   * @param name an Attribute name
   * @param element a DOM node
   */
  const _removeAttribute = function _removeAttribute(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    // We void attribute values for unremovable "is" attributes
    if (name === 'is') {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {}
      } else {
        try {
          element.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  /**
   * _initDocument
   *
   * @param dirty - a string of dirty markup
   * @return a DOM, filled with the dirty markup
   */
  const _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  /**
   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
   *
   * @param root The root element or node to start traversing on.
   * @return The created NodeIterator
   */
  const _createNodeIterator = function _createNodeIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
  };
  /**
   * _isClobbered
   *
   * @param element element to check for clobbering attacks
   * @return true if clobbered, false if safe
   */
  const _isClobbered = function _isClobbered(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
  };
  /**
   * Checks whether the given object is a DOM node.
   *
   * @param value object to check whether it's a DOM node
   * @return true is object is a DOM node
   */
  const _isNode = function _isNode(value) {
    return typeof Node === 'function' && value instanceof Node;
  };
  function _executeHooks(hooks, currentNode, data) {
    arrayForEach(hooks, hook => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   * @param currentNode to check for permission to exist
   * @return true if node was killed, false if left alive
   */
  const _sanitizeElements = function _sanitizeElements(currentNode) {
    let content = null;
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Now let's check the element's type and name */
    const tagName = transformCaseFunc(currentNode.nodeName);
    /* Execute a hook if present */
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    /* Detect mXSS attempts abusing namespace confusion */
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any occurrence of processing instructions */
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      /* Get the element's text content */
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        content = stringReplace(content, expr, ' ');
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  /**
   * _isValidAttribute
   *
   * @param lcTag Lowercase tag name of containing element.
   * @param lcName Lowercase attribute name.
   * @param value Attribute value.
   * @return Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
      return false;
    } else ;
    return true;
  };
  /**
   * _isBasicCustomElement
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   *
   * @param tagName name of the tag of the node to sanitize
   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
   */
  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
  };
  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param currentNode to sanitize
   */
  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    /* Check if we have attributes; if not we might have a text node */
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: undefined
    };
    let l = attributes.length;
    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      let value = name === 'value' ? attrValue : stringTrim(attrValue);
      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);
        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      /* Remove attribute */
      _removeAttribute(name, currentNode);
      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }
      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          value = stringReplace(value, expr, ' ');
        });
      }
      /* Is `value` valid for this attribute? */
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
          }
        }
      }
      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {}
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  /**
   * _sanitizeShadowDOM
   *
   * @param fragment to iterate over recursively
   */
  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      /* Sanitize tags and elements */
      _sanitizeElements(shadowNode);
      /* Check attributes next */
      _sanitizeAttributes(shadowNode);
      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      if (typeof dirty.toString === 'function') {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      } else {
        throw typeErrorCreate('toString is not a function');
      }
    }
    /* Return dirty HTML if DOMPurify cannot run */
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    /* Clean up removed elements */
    DOMPurify.removed = [];
    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      /* Initialize the document to work on */
      body = _initDocument(dirty);
      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    /* Get node iterator */
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Sanitize tags and elements */
      _sanitizeElements(currentNode);
      /* Check attributes next */
      _sanitizeAttributes(currentNode);
      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }
    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        serializedHTML = stringReplace(serializedHTML, expr, ' ');
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function () {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function (entryPoint, hookFunction) {
    if (hookFunction !== undefined) {
      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function (entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function () {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

module.exports = purify;
//# sourceMappingURL=purify.cjs.js.map


/***/ }),

/***/ 37007:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 32017:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 37047:
/***/ ((module) => {

module.exports = function (glob, opts) {
  if (typeof glob !== 'string') {
    throw new TypeError('Expected a string');
  }

  var str = String(glob);

  // The regexp we are building, as a string.
  var reStr = "";

  // Whether we are matching so called "extended" globs (like bash) and should
  // support single character matching, matching ranges of characters, group
  // matching, etc.
  var extended = opts ? !!opts.extended : false;

  // When globstar is _false_ (default), '/foo/*' is translated a regexp like
  // '^\/foo\/.*$' which will match any string beginning with '/foo/'
  // When globstar is _true_, '/foo/*' is translated to regexp like
  // '^\/foo\/[^/]*$' which will match any string beginning with '/foo/' BUT
  // which does not have a '/' to the right of it.
  // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but
  // these will not '/foo/bar/baz', '/foo/bar/baz.txt'
  // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when
  // globstar is _false_
  var globstar = opts ? !!opts.globstar : false;

  // If we are doing extended matching, this boolean is true when we are inside
  // a group (eg {*.html,*.js}), and false otherwise.
  var inGroup = false;

  // RegExp flags (eg "i" ) to pass in to RegExp constructor.
  var flags = opts && typeof( opts.flags ) === "string" ? opts.flags : "";

  var c;
  for (var i = 0, len = str.length; i < len; i++) {
    c = str[i];

    switch (c) {
    case "/":
    case "$":
    case "^":
    case "+":
    case ".":
    case "(":
    case ")":
    case "=":
    case "!":
    case "|":
      reStr += "\\" + c;
      break;

    case "?":
      if (extended) {
        reStr += ".";
	    break;
      }

    case "[":
    case "]":
      if (extended) {
        reStr += c;
	    break;
      }

    case "{":
      if (extended) {
        inGroup = true;
	    reStr += "(";
	    break;
      }

    case "}":
      if (extended) {
        inGroup = false;
	    reStr += ")";
	    break;
      }

    case ",":
      if (inGroup) {
        reStr += "|";
	    break;
      }
      reStr += "\\" + c;
      break;

    case "*":
      // Move over all consecutive "*"'s.
      // Also store the previous and next characters
      var prevChar = str[i - 1];
      var starCount = 1;
      while(str[i + 1] === "*") {
        starCount++;
        i++;
      }
      var nextChar = str[i + 1];

      if (!globstar) {
        // globstar is disabled, so treat any number of "*" as one
        reStr += ".*";
      } else {
        // globstar is enabled, so determine if this is a globstar segment
        var isGlobstar = starCount > 1                      // multiple "*"'s
          && (prevChar === "/" || prevChar === undefined)   // from the start of the segment
          && (nextChar === "/" || nextChar === undefined)   // to the end of the segment

        if (isGlobstar) {
          // it's a globstar, so match zero or more path segments
          reStr += "((?:[^/]*(?:\/|$))*)";
          i++; // move over the "/"
        } else {
          // it's not a globstar, so only match one path segment
          reStr += "([^/]*)";
        }
      }
      break;

    default:
      reStr += c;
    }
  }

  // When regexp 'g' flag is specified don't
  // constrain the regular expression with ^ & $
  if (!flags || !~flags.indexOf('g')) {
    reStr = "^" + reStr + "$";
  }

  return new RegExp(reStr, flags);
};


/***/ }),

/***/ 2733:
/***/ (function(module) {

/*! js-cookie v3.0.5 | MIT */
;
(function (global, factory) {
   true ? module.exports = factory() :
  0;
})(this, (function () { 'use strict';

  /* eslint-disable no-var */
  function assign (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target
  }
  /* eslint-enable no-var */

  /* eslint-disable no-var */
  var defaultConverter = {
    read: function (value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function (value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      )
    }
  };
  /* eslint-enable no-var */

  /* eslint-disable no-var */

  function init (converter, defaultAttributes) {
    function set (name, value, attributes) {
      if (typeof document === 'undefined') {
        return
      }

      attributes = assign({}, defaultAttributes, attributes);

      if (typeof attributes.expires === 'number') {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }

      name = encodeURIComponent(name)
        .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
        .replace(/[()]/g, escape);

      var stringifiedAttributes = '';
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue
        }

        stringifiedAttributes += '; ' + attributeName;

        if (attributes[attributeName] === true) {
          continue
        }

        // Considers RFC 6265 section 5.2:
        // ...
        // 3.  If the remaining unparsed-attributes contains a %x3B (";")
        //     character:
        // Consume the characters of the unparsed-attributes up to,
        // not including, the first %x3B (";") character.
        // ...
        stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
      }

      return (document.cookie =
        name + '=' + converter.write(value, name) + stringifiedAttributes)
    }

    function get (name) {
      if (typeof document === 'undefined' || (arguments.length && !name)) {
        return
      }

      // To prevent the for loop in the first place assign an empty array
      // in case there are no cookies at all.
      var cookies = document.cookie ? document.cookie.split('; ') : [];
      var jar = {};
      for (var i = 0; i < cookies.length; i++) {
        var parts = cookies[i].split('=');
        var value = parts.slice(1).join('=');

        try {
          var found = decodeURIComponent(parts[0]);
          jar[found] = converter.read(value, found);

          if (name === found) {
            break
          }
        } catch (e) {}
      }

      return name ? jar[name] : jar
    }

    return Object.create(
      {
        set,
        get,
        remove: function (name, attributes) {
          set(
            name,
            '',
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function (attributes) {
          return init(this.converter, assign({}, this.attributes, attributes))
        },
        withConverter: function (converter) {
          return init(assign({}, this.converter, converter), this.attributes)
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    )
  }

  var api = init(defaultConverter, { path: '/' });
  /* eslint-enable no-var */

  return api;

}));


/***/ }),

/***/ 55580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(56110),
    root = __webpack_require__(9325);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 21549:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(22032),
    hashDelete = __webpack_require__(63862),
    hashGet = __webpack_require__(66721),
    hashHas = __webpack_require__(12749),
    hashSet = __webpack_require__(35749);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 80079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(63702),
    listCacheDelete = __webpack_require__(70080),
    listCacheGet = __webpack_require__(24739),
    listCacheHas = __webpack_require__(48655),
    listCacheSet = __webpack_require__(31175);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 68223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(56110),
    root = __webpack_require__(9325);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 53661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(63040),
    mapCacheDelete = __webpack_require__(17670),
    mapCacheGet = __webpack_require__(90289),
    mapCacheHas = __webpack_require__(4509),
    mapCacheSet = __webpack_require__(72949);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 32804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(56110),
    root = __webpack_require__(9325);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 76545:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(56110),
    root = __webpack_require__(9325);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 38859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(53661),
    setCacheAdd = __webpack_require__(31380),
    setCacheHas = __webpack_require__(51459);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ 37217:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(80079),
    stackClear = __webpack_require__(51420),
    stackDelete = __webpack_require__(90938),
    stackGet = __webpack_require__(63605),
    stackHas = __webpack_require__(29817),
    stackSet = __webpack_require__(80945);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 51873:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(9325);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 37828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(9325);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 28303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(56110),
    root = __webpack_require__(9325);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 91033:
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ 83729:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ 79770:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 70695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(78096),
    isArguments = __webpack_require__(72428),
    isArray = __webpack_require__(56449),
    isBuffer = __webpack_require__(3656),
    isIndex = __webpack_require__(30361),
    isTypedArray = __webpack_require__(37167);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 34932:
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ 14528:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 14248:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ 16547:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(43360),
    eq = __webpack_require__(75288);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ 26025:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(75288);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 74733:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(21791),
    keys = __webpack_require__(95950);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ 43838:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(21791),
    keysIn = __webpack_require__(37241);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ 43360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(93243);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ 9999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(37217),
    arrayEach = __webpack_require__(83729),
    assignValue = __webpack_require__(16547),
    baseAssign = __webpack_require__(74733),
    baseAssignIn = __webpack_require__(43838),
    cloneBuffer = __webpack_require__(93290),
    copyArray = __webpack_require__(23007),
    copySymbols = __webpack_require__(92271),
    copySymbolsIn = __webpack_require__(48948),
    getAllKeys = __webpack_require__(50002),
    getAllKeysIn = __webpack_require__(83349),
    getTag = __webpack_require__(5861),
    initCloneArray = __webpack_require__(76189),
    initCloneByTag = __webpack_require__(77199),
    initCloneObject = __webpack_require__(35529),
    isArray = __webpack_require__(56449),
    isBuffer = __webpack_require__(3656),
    isMap = __webpack_require__(87730),
    isObject = __webpack_require__(23805),
    isSet = __webpack_require__(38440),
    keys = __webpack_require__(95950),
    keysIn = __webpack_require__(37241);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ 39344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(23805);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ 83120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(14528),
    isFlattenable = __webpack_require__(45891);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ 47422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(31769),
    toKey = __webpack_require__(77797);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ 82199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(14528),
    isArray = __webpack_require__(56449);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 72552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(51873),
    getRawTag = __webpack_require__(659),
    objectToString = __webpack_require__(59350);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 28077:
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ 27534:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(72552),
    isObjectLike = __webpack_require__(40346);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 60270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(87068),
    isObjectLike = __webpack_require__(40346);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ 87068:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(37217),
    equalArrays = __webpack_require__(25911),
    equalByTag = __webpack_require__(21986),
    equalObjects = __webpack_require__(50689),
    getTag = __webpack_require__(5861),
    isArray = __webpack_require__(56449),
    isBuffer = __webpack_require__(3656),
    isTypedArray = __webpack_require__(37167);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ 29172:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(5861),
    isObjectLike = __webpack_require__(40346);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ 41799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(37217),
    baseIsEqual = __webpack_require__(60270);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ 45083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(1882),
    isMasked = __webpack_require__(87296),
    isObject = __webpack_require__(23805),
    toSource = __webpack_require__(47473);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 16038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(5861),
    isObjectLike = __webpack_require__(40346);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ 4901:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(72552),
    isLength = __webpack_require__(30294),
    isObjectLike = __webpack_require__(40346);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 88984:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(55527),
    nativeKeys = __webpack_require__(3650);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 72903:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(23805),
    isPrototype = __webpack_require__(55527),
    nativeKeysIn = __webpack_require__(90181);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ 76001:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePickBy = __webpack_require__(97420),
    hasIn = __webpack_require__(80631);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ 97420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(47422),
    baseSet = __webpack_require__(73170),
    castPath = __webpack_require__(31769);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ 73170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(16547),
    castPath = __webpack_require__(31769),
    isIndex = __webpack_require__(30361),
    isObject = __webpack_require__(23805),
    toKey = __webpack_require__(77797);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ 19570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(37334),
    defineProperty = __webpack_require__(93243),
    identity = __webpack_require__(83488);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ 25160:
/***/ ((module) => {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),

/***/ 78096:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 77556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(51873),
    arrayMap = __webpack_require__(34932),
    isArray = __webpack_require__(56449),
    isSymbol = __webpack_require__(44394);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ 54128:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(31800);

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ 27301:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 19931:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(31769),
    last = __webpack_require__(68090),
    parent = __webpack_require__(68969),
    toKey = __webpack_require__(77797);

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;


/***/ }),

/***/ 19219:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ 31769:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(56449),
    isKey = __webpack_require__(28586),
    stringToPath = __webpack_require__(61802),
    toString = __webpack_require__(13222);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ 49653:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(37828);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ 93290:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(9325);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ 76169:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(49653);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ 73201:
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ 93736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(51873);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ 71961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(49653);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ 23007:
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ 21791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(16547),
    baseAssignValue = __webpack_require__(43360);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ 92271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(21791),
    getSymbols = __webpack_require__(4664);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ 48948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(21791),
    getSymbolsIn = __webpack_require__(86375);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ 55481:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(9325);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 53138:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPlainObject = __webpack_require__(11331);

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;


/***/ }),

/***/ 93243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(56110);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ 25911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(38859),
    arraySome = __webpack_require__(14248),
    cacheHas = __webpack_require__(19219);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ 21986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(51873),
    Uint8Array = __webpack_require__(37828),
    eq = __webpack_require__(75288),
    equalArrays = __webpack_require__(25911),
    mapToArray = __webpack_require__(20317),
    setToArray = __webpack_require__(84247);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ 50689:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(50002);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ 38816:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var flatten = __webpack_require__(35970),
    overRest = __webpack_require__(56757),
    setToString = __webpack_require__(32865);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ 34840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ 50002:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(82199),
    getSymbols = __webpack_require__(4664),
    keys = __webpack_require__(95950);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 83349:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(82199),
    getSymbolsIn = __webpack_require__(86375),
    keysIn = __webpack_require__(37241);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ 12651:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(74218);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 10776:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(30756),
    keys = __webpack_require__(95950);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ 56110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(45083),
    getValue = __webpack_require__(10392);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 28879:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(74335);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ 659:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(51873);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 4664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(79770),
    stubArray = __webpack_require__(63345);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 86375:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(14528),
    getPrototype = __webpack_require__(28879),
    getSymbols = __webpack_require__(4664),
    stubArray = __webpack_require__(63345);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ 5861:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(55580),
    Map = __webpack_require__(68223),
    Promise = __webpack_require__(32804),
    Set = __webpack_require__(76545),
    WeakMap = __webpack_require__(28303),
    baseGetTag = __webpack_require__(72552),
    toSource = __webpack_require__(47473);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 10392:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 49326:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(31769),
    isArguments = __webpack_require__(72428),
    isArray = __webpack_require__(56449),
    isIndex = __webpack_require__(30361),
    isLength = __webpack_require__(30294),
    toKey = __webpack_require__(77797);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ 22032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(81042);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 63862:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 66721:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(81042);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 12749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(81042);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 35749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(81042);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 76189:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ 77199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(49653),
    cloneDataView = __webpack_require__(76169),
    cloneRegExp = __webpack_require__(73201),
    cloneSymbol = __webpack_require__(93736),
    cloneTypedArray = __webpack_require__(71961);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ 35529:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(39344),
    getPrototype = __webpack_require__(28879),
    isPrototype = __webpack_require__(55527);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ 45891:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(51873),
    isArguments = __webpack_require__(72428),
    isArray = __webpack_require__(56449);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ 30361:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 28586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(56449),
    isSymbol = __webpack_require__(44394);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ 74218:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 87296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(55481);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 55527:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 30756:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(23805);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ 63702:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 70080:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(26025);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 24739:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(26025);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 48655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(26025);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 31175:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(26025);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 63040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(21549),
    ListCache = __webpack_require__(80079),
    Map = __webpack_require__(68223);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 17670:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(12651);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 90289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(12651);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 4509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(12651);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 72949:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(12651);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 20317:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ 62224:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(50104);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ 81042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(56110);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 3650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(74335);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 90181:
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ 86009:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(34840);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 59350:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 74335:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 56757:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(91033);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ 68969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(47422),
    baseSlice = __webpack_require__(25160);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;


/***/ }),

/***/ 9325:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(34840);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 31380:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ 51459:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ 84247:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ 32865:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(19570),
    shortOut = __webpack_require__(51811);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ 51811:
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ 51420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(80079);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 90938:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 63605:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 29817:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 80945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(80079),
    Map = __webpack_require__(68223),
    MapCache = __webpack_require__(53661);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 61802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(62224);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ 77797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(44394);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ 47473:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 31800:
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ 37334:
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ 38221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(23805),
    now = __webpack_require__(10124),
    toNumber = __webpack_require__(99374);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ 75288:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 35970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(83120);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ 80631:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(28077),
    hasPath = __webpack_require__(49326);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ 83488:
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ 72428:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(27534),
    isObjectLike = __webpack_require__(40346);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 56449:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 64894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(1882),
    isLength = __webpack_require__(30294);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 3656:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(9325),
    stubFalse = __webpack_require__(89935);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 2404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(60270);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),

/***/ 1882:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(72552),
    isObject = __webpack_require__(23805);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 30294:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 87730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(29172),
    baseUnary = __webpack_require__(27301),
    nodeUtil = __webpack_require__(86009);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ 1045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(41799),
    getMatchData = __webpack_require__(10776);

/**
 * This method is like `_.isMatch` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with five
 * arguments: (objValue, srcValue, index|key, object, source).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, srcValue) {
 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
 *     return true;
 *   }
 * }
 *
 * var object = { 'greeting': 'hello' };
 * var source = { 'greeting': 'hi' };
 *
 * _.isMatchWith(object, source, customizer);
 * // => true
 */
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return baseIsMatch(object, source, getMatchData(source), customizer);
}

module.exports = isMatchWith;


/***/ }),

/***/ 23805:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 40346:
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 11331:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(72552),
    getPrototype = __webpack_require__(28879),
    isObjectLike = __webpack_require__(40346);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ 38440:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(16038),
    baseUnary = __webpack_require__(27301),
    nodeUtil = __webpack_require__(86009);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ 44394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(72552),
    isObjectLike = __webpack_require__(40346);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ 37167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(4901),
    baseUnary = __webpack_require__(27301),
    nodeUtil = __webpack_require__(86009);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 95950:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(70695),
    baseKeys = __webpack_require__(88984),
    isArrayLike = __webpack_require__(64894);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 37241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(70695),
    baseKeysIn = __webpack_require__(72903),
    isArrayLike = __webpack_require__(64894);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ 68090:
/***/ ((module) => {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ 50104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(53661);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ 10124:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(9325);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ 90179:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(34932),
    baseClone = __webpack_require__(9999),
    baseUnset = __webpack_require__(19931),
    castPath = __webpack_require__(31769),
    copyObject = __webpack_require__(21791),
    customOmitClone = __webpack_require__(53138),
    flatRest = __webpack_require__(38816),
    getAllKeysIn = __webpack_require__(83349);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;


/***/ }),

/***/ 44383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePick = __webpack_require__(76001),
    flatRest = __webpack_require__(38816);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ 63345:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 89935:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 7350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debounce = __webpack_require__(38221),
    isObject = __webpack_require__(23805);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),

/***/ 99374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(54128),
    isObject = __webpack_require__(23805),
    isSymbol = __webpack_require__(44394);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ 13222:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(77556);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ 2143:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 90396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"container":"CallParticipants-module__container___JHyh3","participantContainer":"CallParticipants-module__participantContainer___WEeET","participantSpeaking":"CallParticipants-module__participantSpeaking___aovg8","videoContainer":"CallParticipants-module__videoContainer___cuUmK","video":"CallParticipants-module__video___osVRK","videoOverlay":"CallParticipants-module__videoOverlay___x1yb0","statusContainer":"CallParticipants-module__statusContainer___Vrvvr","statusTitle":"CallParticipants-module__statusTitle___puKch","statusIcon":"CallParticipants-module__statusIcon____w42b","videoOverlayIcon":"CallParticipants-module__videoOverlayIcon___Fph1m"});

/***/ }),

/***/ 91398:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"content":"ConsentDialog-module__content___fUfL3","title":"ConsentDialog-module__title___MTrAq","body":"ConsentDialog-module__body___FtS5W","confirmation":"ConsentDialog-module__confirmation___v7fj3","description":"ConsentDialog-module__description___eSwUl","buttons":"ConsentDialog-module__buttons___nToO7"});

/***/ }),

/***/ 97294:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"content":"MediaPreview-module__content___4fxuk","header":"MediaPreview-module__header___E2CcH","media":"MediaPreview-module__media___kmkmo","body":"MediaPreview-module__body___VPagd","title":"MediaPreview-module__title___uSKCr","description":"MediaPreview-module__description___IPolu","previewContainer":"MediaPreview-module__previewContainer___hZF98","videoContainer":"MediaPreview-module__videoContainer____O8KD","video":"MediaPreview-module__video___DnVpX","videoOverlay":"MediaPreview-module__videoOverlay___Wy27K","videoOverlaySolid":"MediaPreview-module__videoOverlaySolid___Ifi1O","videoOverlayTransparent":"MediaPreview-module__videoOverlayTransparent___vPzQr","videoOverlayText":"MediaPreview-module__videoOverlayText___kzAHr","deviceContainer":"MediaPreview-module__deviceContainer___MEdwh","buttonContainer":"MediaPreview-module__buttonContainer___aXcOQ","voiceVideoControls":"MediaPreview-module__voiceVideoControls___qTsRx","voiceVideoControlsToggle":"MediaPreview-module__voiceVideoControlsToggle___prGk3","voiceVideoControlsToggleOff":"MediaPreview-module__voiceVideoControlsToggleOff___ql_2k","voiceVideoControlsToggleOn":"MediaPreview-module__voiceVideoControlsToggleOn___URkye","voiceVideoControlsIcon":"MediaPreview-module__voiceVideoControlsIcon___yrQoV"});

/***/ }),

/***/ 53983:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"sessionStateOverlay":"SessionStateOverlay-module__sessionStateOverlay___pCowu","endSessionButton":"SessionStateOverlay-module__endSessionButton___pUtd7","endSessionIcon":"SessionStateOverlay-module__endSessionIcon___vLhgE","callingControlsContainer":"SessionStateOverlay-module__callingControlsContainer___UYdU1","callingControlsToggleContainer":"SessionStateOverlay-module__callingControlsToggleContainer___jmNM6","callingControlsToggle":"SessionStateOverlay-module__callingControlsToggle___ry4m0","callingControlsToggleOff":"SessionStateOverlay-module__callingControlsToggleOff___jxwB4","callingControlsToggleOn":"SessionStateOverlay-module__callingControlsToggleOn___FUuRG","callingControlsIcon":"SessionStateOverlay-module__callingControlsIcon___OWYpc","callingControlsEnd":"SessionStateOverlay-module__callingControlsEnd___t4Xky"});

/***/ }),

/***/ 2989:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"base":"Button-module__base___PvaYv","primary":"Button-module__primary___jyGbF","secondary":"Button-module__secondary___V1ksJ"});

/***/ }),

/***/ 64556:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"base":"IconButton-module__base___wAyLz"});

/***/ }),

/***/ 32704:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"container":"Modal-module__container___G4Twz","content":"Modal-module__content___tkuQp"});

/***/ }),

/***/ 9417:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"base":"Select-module__base___YM7TJ","noIcon":"Select-module__noIcon___nzh9A"});

/***/ }),

/***/ 59887:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"overlay":"HighlightOverlay-module__overlay___IwXTu","highlightOverlayFadeIn":"HighlightOverlay-module__highlightOverlayFadeIn___gxAX9","highlightOverlayPulse":"HighlightOverlay-module__highlightOverlayPulse___fW7eg","disableAnimations":"HighlightOverlay-module__disableAnimations___vQPvb"});

/***/ }),

/***/ 36000:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"tooltip":"Tooltip-module__tooltip___IL4dx","tooltipVisible":"Tooltip-module__tooltipVisible___a7Zvs","tooltipTitle":"Tooltip-module__tooltipTitle___gG75M","tooltipArrow":"Tooltip-module__tooltipArrow___kPSXv"});

/***/ }),

/***/ 6585:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 50172:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ x),
/* harmony export */   Fragment: () => (/* binding */ k),
/* harmony export */   cloneElement: () => (/* binding */ K),
/* harmony export */   createContext: () => (/* binding */ Q),
/* harmony export */   createElement: () => (/* binding */ _),
/* harmony export */   createRef: () => (/* binding */ b),
/* harmony export */   h: () => (/* binding */ _),
/* harmony export */   hydrate: () => (/* binding */ J),
/* harmony export */   isValidElement: () => (/* binding */ t),
/* harmony export */   options: () => (/* binding */ l),
/* harmony export */   render: () => (/* binding */ G),
/* harmony export */   toChildArray: () => (/* binding */ H)
/* harmony export */ });
var n,l,u,t,i,r,o,e,f,c,s,a,h,p={},v=[],y=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,w=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function g(n){n&&n.parentNode&&n.parentNode.removeChild(n)}function _(l,u,t){var i,r,o,e={};for(o in u)"key"==o?i=u[o]:"ref"==o?r=u[o]:e[o]=u[o];if(arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===e[o]&&(e[o]=l.defaultProps[o]);return m(l,e,i,r,null)}function m(n,t,i,r,o){var e={type:n,props:t,key:i,ref:r,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:null==o?++u:o,__i:-1,__u:0};return null==o&&null!=l.vnode&&l.vnode(e),e}function b(){return{current:null}}function k(n){return n.children}function x(n,l){this.props=n,this.context=l}function S(n,l){if(null==l)return n.__?S(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?S(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!$.__r++||r!=l.debounceRendering)&&((r=l.debounceRendering)||o)($)}function $(){for(var n,u,t,r,o,f,c,s=1;i.length;)i.length>s&&i.sort(e),n=i.shift(),s=i.length,n.__d&&(t=void 0,r=void 0,o=(r=(u=n).__v).__e,f=[],c=[],u.__P&&((t=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(t),O(u.__P,t,r,u.__n,u.__P.namespaceURI,32&r.__u?[o]:null,f,null==o?S(r):o,!!(32&r.__u),c),t.__v=r.__v,t.__.__k[t.__i]=t,N(f,t,c),r.__e=r.__=null,t.__e!=o&&C(t)));$.__r=0}function I(n,l,u,t,i,r,o,e,f,c,s){var a,h,y,w,d,g,_,m=t&&t.__k||v,b=l.length;for(f=P(u,l,m,f,b),a=0;a<b;a++)null!=(y=u.__k[a])&&(h=-1==y.__i?p:m[y.__i]||p,y.__i=a,g=O(n,y,h,i,r,o,e,f,c,s),w=y.__e,y.ref&&h.ref!=y.ref&&(h.ref&&B(h.ref,null,y),s.push(y.ref,y.__c||w,y)),null==d&&null!=w&&(d=w),(_=!!(4&y.__u))||h.__k===y.__k?f=A(y,f,n,_):"function"==typeof y.type&&void 0!==g?f=g:w&&(f=w.nextSibling),y.__u&=-7);return u.__e=d,f}function P(n,l,u,t,i){var r,o,e,f,c,s=u.length,a=s,h=0;for(n.__k=new Array(i),r=0;r<i;r++)null!=(o=l[r])&&"boolean"!=typeof o&&"function"!=typeof o?(f=r+h,(o=n.__k[r]="string"==typeof o||"number"==typeof o||"bigint"==typeof o||o.constructor==String?m(null,o,null,null,null):w(o)?m(k,{children:o},null,null,null):null==o.constructor&&o.__b>0?m(o.type,o.props,o.key,o.ref?o.ref:null,o.__v):o).__=n,o.__b=n.__b+1,e=null,-1!=(c=o.__i=L(o,u,f,a))&&(a--,(e=u[c])&&(e.__u|=2)),null==e||null==e.__v?(-1==c&&(i>s?h--:i<s&&h++),"function"!=typeof o.type&&(o.__u|=4)):c!=f&&(c==f-1?h--:c==f+1?h++:(c>f?h--:h++,o.__u|=4))):n.__k[r]=null;if(a)for(r=0;r<s;r++)null!=(e=u[r])&&0==(2&e.__u)&&(e.__e==t&&(t=S(e)),D(e,e));return t}function A(n,l,u,t){var i,r;if("function"==typeof n.type){for(i=n.__k,r=0;i&&r<i.length;r++)i[r]&&(i[r].__=n,l=A(i[r],l,u,t));return l}n.__e!=l&&(t&&(l&&n.type&&!l.parentNode&&(l=S(n)),u.insertBefore(n.__e,l||null)),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8==l.nodeType);return l}function H(n,l){return l=l||[],null==n||"boolean"==typeof n||(w(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i,r,o,e=n.key,f=n.type,c=l[u],s=null!=c&&0==(2&c.__u);if(null===c&&null==n.key||s&&e==c.key&&f==c.type)return u;if(t>(s?1:0))for(i=u-1,r=u+1;i>=0||r<l.length;)if(null!=(c=l[o=i>=0?i--:r++])&&0==(2&c.__u)&&e==c.key&&f==c.type)return o;return-1}function T(n,l,u){"-"==l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||y.test(l)?u:u+"px"}function j(n,l,u,t,i){var r,o;n:if("style"==l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||T(n.style,l,"");if(u)for(l in u)t&&u[l]==t[l]||T(n.style,l,u[l])}else if("o"==l[0]&&"n"==l[1])r=l!=(l=l.replace(f,"$1")),o=l.toLowerCase(),l=o in n||"onFocusOut"==l||"onFocusIn"==l?o.slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?t?u.u=t.u:(u.u=c,n.addEventListener(l,r?a:s,r)):n.removeEventListener(l,r?a:s,r);else{if("http://www.w3.org/2000/svg"==i)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!=l&&"height"!=l&&"href"!=l&&"list"!=l&&"form"!=l&&"tabIndex"!=l&&"download"!=l&&"rowSpan"!=l&&"colSpan"!=l&&"role"!=l&&"popover"!=l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&"-"!=l[4]?n.removeAttribute(l):n.setAttribute(l,"popover"==l&&1==u?"":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=c++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,r,o,e,f,c,s){var a,h,p,v,y,_,m,b,S,C,M,$,P,A,H,L,T,j=u.type;if(null!=u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),o=[f=u.__e=t.__e]),(a=l.__b)&&a(u);n:if("function"==typeof j)try{if(b=u.props,S="prototype"in j&&j.prototype.render,C=(a=j.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?m=(h=u.__c=t.__c).__=h.__E:(S?u.__c=h=new j(b,M):(u.__c=h=new x(b,M),h.constructor=j,h.render=E),C&&C.sub(h),h.props=b,h.state||(h.state={}),h.context=M,h.__n=i,p=h.__d=!0,h.__h=[],h._sb=[]),S&&null==h.__s&&(h.__s=h.state),S&&null!=j.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,j.getDerivedStateFromProps(b,h.__s))),v=h.props,y=h.state,h.__v=u,p)S&&null==j.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),S&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(S&&null==j.getDerivedStateFromProps&&b!==v&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(b,M),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(b,h.__s,M)||u.__v==t.__v){for(u.__v!=t.__v&&(h.props=b,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.some(function(n){n&&(n.__=u)}),$=0;$<h._sb.length;$++)h.__h.push(h._sb[$]);h._sb=[],h.__h.length&&e.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(b,h.__s,M),S&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(v,y,_)})}if(h.context=M,h.props=b,h.__P=n,h.__e=!1,P=l.__r,A=0,S){for(h.state=h.__s,h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++A<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),S&&!p&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(v,y)),L=a,null!=a&&a.type===k&&null==a.key&&(L=V(a.props.children)),f=I(n,w(L)?L:[L],u,t,i,r,o,e,f,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&e.push(h),m&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=o)if(n.then){for(u.__u|=c?160:128;f&&8==f.nodeType&&f.nextSibling;)f=f.nextSibling;o[o.indexOf(f)]=null,u.__e=f}else{for(T=o.length;T--;)g(o[T]);z(u)}else u.__e=t.__e,u.__k=t.__k,n.then||z(u);l.__e(n,u,t)}else null==o&&u.__v==t.__v?(u.__k=t.__k,u.__e=t.__e):f=u.__e=q(t.__e,u,t,i,r,o,e,c,s);return(a=l.diffed)&&a(u),128&u.__u?void 0:f}function z(n){n&&n.__c&&(n.__c.__e=!0),n&&n.__k&&n.__k.forEach(z)}function N(n,u,t){for(var i=0;i<t.length;i++)B(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function V(n){return"object"!=typeof n||null==n||n.__b&&n.__b>0?n:w(n)?n.map(V):d({},n)}function q(u,t,i,r,o,e,f,c,s){var a,h,v,y,d,_,m,b=i.props,k=t.props,x=t.type;if("svg"==x?o="http://www.w3.org/2000/svg":"math"==x?o="http://www.w3.org/1998/Math/MathML":o||(o="http://www.w3.org/1999/xhtml"),null!=e)for(a=0;a<e.length;a++)if((d=e[a])&&"setAttribute"in d==!!x&&(x?d.localName==x:3==d.nodeType)){u=d,e[a]=null;break}if(null==u){if(null==x)return document.createTextNode(k);u=document.createElementNS(o,x,k.is&&k),c&&(l.__m&&l.__m(t,e),c=!1),e=null}if(null==x)b===k||c&&u.data==k||(u.data=k);else{if(e=e&&n.call(u.childNodes),b=i.props||p,!c&&null!=e)for(b={},a=0;a<u.attributes.length;a++)b[(d=u.attributes[a]).name]=d.value;for(a in b)if(d=b[a],"children"==a);else if("dangerouslySetInnerHTML"==a)v=d;else if(!(a in k)){if("value"==a&&"defaultValue"in k||"checked"==a&&"defaultChecked"in k)continue;j(u,a,null,d,o)}for(a in k)d=k[a],"children"==a?y=d:"dangerouslySetInnerHTML"==a?h=d:"value"==a?_=d:"checked"==a?m=d:c&&"function"!=typeof d||b[a]===d||j(u,a,d,b[a],o);if(h)c||v&&(h.__html==v.__html||h.__html==u.innerHTML)||(u.innerHTML=h.__html),t.__k=[];else if(v&&(u.innerHTML=""),I("template"==t.type?u.content:u,w(y)?y:[y],t,i,r,"foreignObject"==x?"http://www.w3.org/1999/xhtml":o,e,f,e?e[0]:i.__k&&S(i,0),c,s),null!=e)for(a=e.length;a--;)g(e[a]);c||(a="value","progress"==x&&null==_?u.removeAttribute("value"):null!=_&&(_!==u[a]||"progress"==x&&!_||"option"==x&&_!=b[a])&&j(u,a,_,b[a],o),a="checked",null!=m&&m!=u[a]&&j(u,a,m,b[a],o))}return u}function B(n,u,t){try{if("function"==typeof n){var i="function"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function D(n,u,t){var i,r;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!=n.__e||B(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(r=0;r<i.length;r++)i[r]&&D(i[r],u,t||"function"!=typeof n.type);t||g(n.__e),n.__c=n.__=n.__e=void 0}function E(n,l,u){return this.constructor(n,u)}function G(u,t,i){var r,o,e,f;t==document&&(t=document.documentElement),l.__&&l.__(u,t),o=(r="function"==typeof i)?null:i&&i.__k||t.__k,e=[],f=[],O(t,u=(!r&&i||t).__k=_(k,null,[u]),o||p,p,t.namespaceURI,!r&&i?[i]:o?null:t.firstChild?n.call(t.childNodes):null,e,!r&&i?i:o?o.__e:t.firstChild,r,f),N(e,u,f)}function J(n,l){G(n,l,J)}function K(l,u,t){var i,r,o,e,f=d({},l.props);for(o in l.type&&l.type.defaultProps&&(e=l.type.defaultProps),u)"key"==o?i=u[o]:"ref"==o?r=u[o]:f[o]=void 0===u[o]&&null!=e?e[o]:u[o];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),m(l.type,f,i||l.key,r||l.ref,null)}function Q(n){function l(n){var u,t;return this.getChildContext||(u=new Set,(t={})[l.__c]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!=n.value&&u.forEach(function(n){n.__e=!0,M(n)})},this.sub=function(n){u.add(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.delete(n),l&&l.call(n)}}),n.children}return l.__c="__cC"+h++,l.__=n,l.Provider=l.__l=(l.Consumer=function(n,l){return n.children(l)}).contextType=l,l}n=v.slice,l={__e:function(n,l,u,t){for(var i,r,o;l=l.__;)if((i=l.__c)&&!i.__)try{if((r=i.constructor)&&null!=r.getDerivedStateFromError&&(i.setState(r.getDerivedStateFromError(n)),o=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),o=i.__d),o)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},x.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!=this.state?this.__s:this.__s=d({},this.state),"function"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this))},x.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),M(this))},x.prototype.render=k,i=[],o="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,e=function(n,l){return n.__v.__b-l.__v.__b},$.__r=0,f=/(PointerCapture)$|Capture$/i,c=0,s=F(!1),a=F(!0),h=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ 45994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useCallback: () => (/* binding */ q),
/* harmony export */   useContext: () => (/* binding */ x),
/* harmony export */   useDebugValue: () => (/* binding */ P),
/* harmony export */   useEffect: () => (/* binding */ y),
/* harmony export */   useErrorBoundary: () => (/* binding */ b),
/* harmony export */   useId: () => (/* binding */ g),
/* harmony export */   useImperativeHandle: () => (/* binding */ F),
/* harmony export */   useLayoutEffect: () => (/* binding */ _),
/* harmony export */   useMemo: () => (/* binding */ T),
/* harmony export */   useReducer: () => (/* binding */ h),
/* harmony export */   useRef: () => (/* binding */ A),
/* harmony export */   useState: () => (/* binding */ d)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50172);
var t,r,u,i,o=0,f=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function p(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function d(n){return o=1,h(D,n)}function h(n,u,i){var o=p(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.__f)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=o.__c.props!==n;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),c&&c.call(this,n,t,r)||i};r.__f=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=p(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__H.__h.push(i))}function _(n,u){var i=p(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){if("function"==typeof n){var r=n(t());return function(){n(null),r&&"function"==typeof r&&r()}}if(n)return n.current=t(),function(){return n.current=null}},null==r?r:r.concat(n))}function T(n,r){var u=p(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=p(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=p(t++,10),i=d();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=p(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__="P"+i[0]+"-"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.u=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.u&&(n.__H=n.u),n.u=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k="function"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,35);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return"function"==typeof t?t(n):t}
//# sourceMappingURL=hooks.module.js.map


/***/ }),

/***/ 10201:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fragment: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   jsx: () => (/* binding */ u),
/* harmony export */   jsxAttr: () => (/* binding */ l),
/* harmony export */   jsxDEV: () => (/* binding */ u),
/* harmony export */   jsxEscape: () => (/* binding */ s),
/* harmony export */   jsxTemplate: () => (/* binding */ a),
/* harmony export */   jsxs: () => (/* binding */ u)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50172);
var t=/["&<]/;function n(r){if(0===r.length||!1===t.test(r))return r;for(var e=0,n=0,o="",f="";n<r.length;n++){switch(r.charCodeAt(n)){case 34:f="&quot;";break;case 38:f="&amp;";break;case 60:f="&lt;";break;default:continue}n!==e&&(o+=r.slice(e,n)),o+=f,e=n+1}return n!==e&&(o+=r.slice(e,n)),o}var o=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,f=0,i=Array.isArray;function u(e,t,n,o,i,u){t||(t={});var a,c,p=t;if("ref"in p)for(c in p={},t)"ref"==c?a=t[c]:p[c]=t[c];var l={type:e,props:p,key:n,ref:a,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:--f,__i:-1,__u:0,__source:i,__self:u};if("function"==typeof e&&(a=e.defaultProps))for(c in a)void 0===p[c]&&(p[c]=a[c]);return preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode&&preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode(l),l}function a(r){var t=u(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,{tpl:r,exprs:[].slice.call(arguments,1)});return t.key=t.__v,t}var c={},p=/[A-Z]/g;function l(e,t){if(preact__WEBPACK_IMPORTED_MODULE_0__.options.attr){var f=preact__WEBPACK_IMPORTED_MODULE_0__.options.attr(e,t);if("string"==typeof f)return f}if(t=function(r){return null!==r&&"object"==typeof r&&"function"==typeof r.valueOf?r.valueOf():r}(t),"ref"===e||"key"===e)return"";if("style"===e&&"object"==typeof t){var i="";for(var u in t){var a=t[u];if(null!=a&&""!==a){var l="-"==u[0]?u:c[u]||(c[u]=u.replace(p,"-$&").toLowerCase()),s=";";"number"!=typeof a||l.startsWith("--")||o.test(l)||(s="px;"),i=i+l+":"+a+s}}return e+'="'+n(i)+'"'}return null==t||!1===t||"function"==typeof t||"object"==typeof t?"":!0===t?e:e+'="'+n(""+t)+'"'}function s(r){if(null==r||"boolean"==typeof r||"function"==typeof r)return null;if("object"==typeof r){if(void 0===r.constructor)return r;if(i(r)){for(var e=0;e<r.length;e++)r[e]=s(r[e]);return r}}return n(""+r)}
//# sourceMappingURL=jsxRuntime.module.js.map


/***/ }),

/***/ 56277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./ar.json": 75120,
	"./cs.json": 97337,
	"./da.json": 81088,
	"./de.json": 30428,
	"./en.json": 45448,
	"./es-MX.json": 49467,
	"./es.json": 70831,
	"./et.json": 93202,
	"./fi.json": 34818,
	"./fr.json": 99867,
	"./hi.json": 87876,
	"./it.json": 28038,
	"./ja.json": 16582,
	"./kk.json": 61753,
	"./ko.json": 45613,
	"./lt.json": 32391,
	"./mr.json": 59396,
	"./ms.json": 8439,
	"./nl.json": 19121,
	"./pl.json": 85443,
	"./pt-BR.json": 26770,
	"./pt.json": 63851,
	"./ro.json": 17304,
	"./ru.json": 86146,
	"./sk.json": 35537,
	"./sl.json": 41224,
	"./sv.json": 88978,
	"./th-TH.json": 29250,
	"./th.json": 80747,
	"./uk.json": 31559,
	"./vi.json": 87762,
	"./zh-Hant.json": 84181,
	"./zh.json": 81606
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 56277;

/***/ }),

/***/ 52098:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDI0IDI0JyBmaWxsPSdub25lJyBzdHJva2U9J2N1cnJlbnRDb2xvcicgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogIDxwYXRoIHN0cm9rZT0nbm9uZScgZD0nTTAgMGgyNHYyNEgweicgZmlsbD0nbm9uZScvPjxwYXRoIGQ9J002IDlsNiA2bDYgLTYnIC8+Cjwvc3ZnPg==";

/***/ }),

/***/ 49020:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDI0IDI0JyBmaWxsPSdub25lJyBzdHJva2U9J2N1cnJlbnRDb2xvcicgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogIDxwYXRoIHN0cm9rZT0nbm9uZScgZD0nTTAgMGgyNHYyNEgweicgZmlsbD0nbm9uZScgLz48cGF0aCBkPSdNOSAybTAgM2EzIDMgMCAwIDEgMyAtM2gwYTMgMyAwIDAgMSAzIDN2NWEzIDMgMCAwIDEgLTMgM2gwYTMgMyAwIDAgMSAtMyAtM3onIC8+PHBhdGggZD0nTTUgMTBhNyA3IDAgMCAwIDE0IDAnIC8+PHBhdGggZD0nTTggMjFsOCAwJyAvPjxwYXRoIGQ9J00xMiAxN2wwIDQnIC8+Cjwvc3ZnPg==";

/***/ }),

/***/ 64053:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDI0IDI0JyBmaWxsPSdub25lJyBzdHJva2U9J2N1cnJlbnRDb2xvcicgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogIDxwYXRoIHN0cm9rZT0nbm9uZScgZD0nTTAgMGgyNHYyNEgweicgZmlsbD0nbm9uZScgLz48cGF0aCBkPSdNMTUgMTBsNC41NTMgLTIuMjc2YTEgMSAwIDAgMSAxLjQ0NyAuODk0djYuNzY0YTEgMSAwIDAgMSAtMS40NDcgLjg5NGwtNC41NTMgLTIuMjc2di00eicgLz48cGF0aCBkPSdNMyA2bTAgMmEyIDIgMCAwIDEgMiAtMmg4YTIgMiAwIDAgMSAyIDJ2OGEyIDIgMCAwIDEgLTIgMmgtOGEyIDIgMCAwIDEgLTIgLTJ6JyAvPgo8L3N2Zz4=";

/***/ }),

/***/ 9978:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,ICA8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JzI0JyBoZWlnaHQ9JzI0JyB2aWV3Qm94PScwIDAgMjQgMjQnIGZpbGw9J25vbmUnIHN0cm9rZT0nY3VycmVudENvbG9yJyBzdHJva2Utd2lkdGg9JzInIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+PHBhdGggc3Ryb2tlPSdub25lJyBkPSdNMCAwaDI0djI0SDB6JyBmaWxsPSdub25lJyAvPgogICAgPHBhdGggZD0nTTE1IDhhNSA1IDAgMCAxIDAgOCcgLz48cGF0aCBkPSdNMTcuNyA1YTkgOSAwIDAgMSAwIDE0JyAvPjxwYXRoIGQ9J002IDE1aC0yYTEgMSAwIDAgMSAtMSAtMXYtNGExIDEgMCAwIDEgMSAtMWgybDMuNSAtNC41YS44IC44IDAgMCAxIDEuNSAuNXYxNGEuOCAuOCAwIDAgMSAtMS41IC41bC0zLjUgLTQuNScgLz4KICA8L3N2Zz4=";

/***/ }),

/***/ 29284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(89463);
__webpack_require__(66412);
__webpack_require__(94490);
__webpack_require__(26910);
__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(84864);
__webpack_require__(27495);
__webpack_require__(69479);
__webpack_require__(34594);
__webpack_require__(29833);
__webpack_require__(46594);
__webpack_require__(72107);
__webpack_require__(95477);
__webpack_require__(21489);
__webpack_require__(22134);
__webpack_require__(3690);
__webpack_require__(61740);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
__webpack_require__(62480);
__webpack_require__(62953);
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _asyncGeneratorDelegate(t) { var e = {}, n = !1; function pump(e, r) { return n = !0, r = new Promise(function (n) { n(t[e](r)); }), { done: !1, value: new _OverloadYield(r, 1) }; } return e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () { return this; }, e.next = function (t) { return n ? (n = !1, t) : pump("next", t); }, "function" == typeof t.throw && (e.throw = function (t) { if (n) throw n = !1, t; return pump("throw", t); }), "function" == typeof t.return && (e.return = function (t) { return n ? (n = !1, t) : pump("return", t); }), e; }
function _OverloadYield(e, d) { this.v = e, this.k = d; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }
(function (global, factory) {
   true ? factory(exports) : 0;
})(void 0, function (exports) {
  'use strict';

  let decoder;
  try {
    decoder = new TextDecoder();
  } catch (error) {}
  let src;
  let srcEnd;
  let position$1 = 0;
  const LEGACY_RECORD_INLINE_ID = 105;
  const RECORD_DEFINITIONS_ID = 0xdffe;
  const RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'
  const BUNDLED_STRINGS_ID = 0xdff9;
  const PACKED_REFERENCE_TAG_ID = 6;
  const STOP_CODE = {};
  let maxArraySize = 112810000; // This is the maximum array size in V8. We would potentially detect and set it higher
  // for JSC, but this is pretty large and should be sufficient for most use cases
  let maxMapSize = 16810000; // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,
  let currentDecoder = {};
  let currentStructures;
  let srcString;
  let srcStringStart = 0;
  let srcStringEnd = 0;
  let bundledStrings$1;
  let referenceMap;
  let currentExtensions = [];
  let currentExtensionRanges = [];
  let packedValues;
  let dataView;
  let restoreMapsAsObject;
  let defaultOptions = {
    useRecords: false,
    mapsAsObjects: true
  };
  let sequentialMode = false;
  let inlineObjectReadThreshold = 2;
  var BlockedFunction; // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for
  // no-eval build
  try {
    new BlockedFunction('');
  } catch (error) {
    // if eval variants are not supported, do not create inline object readers ever
    inlineObjectReadThreshold = Infinity;
  }
  class Decoder {
    constructor(options) {
      if (options) {
        if ((options.keyMap || options._keyMap) && !options.useRecords) {
          options.useRecords = false;
          options.mapsAsObjects = true;
        }
        if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;
        if (options.getStructures) options.getShared = options.getStructures;
        if (options.getShared && !options.structures) (options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures
        if (options.keyMap) {
          this.mapKey = new Map();
          for (let [k, v] of Object.entries(options.keyMap)) this.mapKey.set(v, k);
        }
      }
      Object.assign(this, options);
    }
    /*
    decodeKey(key) {
    	return this.keyMap
    		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
    		: key
    }
    */
    decodeKey(key) {
      return this.keyMap ? this.mapKey.get(key) || key : key;
    }
    encodeKey(key) {
      return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
    }
    encodeKeys(rec) {
      if (!this._keyMap) return rec;
      let map = new Map();
      for (let [k, v] of Object.entries(rec)) map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
      return map;
    }
    decodeKeys(map) {
      if (!this._keyMap || map.constructor.name != 'Map') return map;
      if (!this._mapKey) {
        this._mapKey = new Map();
        for (let [k, v] of Object.entries(this._keyMap)) this._mapKey.set(v, k);
      }
      let res = {};
      //map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)
      map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
      return res;
    }
    mapDecode(source, end) {
      let res = this.decode(source);
      if (this._keyMap) {
        //Experiemntal support for Optimised KeyMap  decoding 
        switch (res.constructor.name) {
          case 'Array':
            return res.map(r => this.decodeKeys(r));
          //case 'Map': return this.decodeKeys(res)
        }
      }
      return res;
    }
    decode(source, end) {
      if (src) {
        // re-entrant execution, save the state and restore it after we do this decode
        return saveState(() => {
          clearSource();
          return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);
        });
      }
      srcEnd = end > -1 ? end : source.length;
      position$1 = 0;
      srcStringEnd = 0;
      srcString = null;
      bundledStrings$1 = null;
      src = source;
      // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
      // technique for getting data from a database where it can be copied into an existing buffer instead of creating
      // new ones
      try {
        dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
      } catch (error) {
        // if it doesn't have a buffer, maybe it is the wrong type of object
        src = null;
        if (source instanceof Uint8Array) throw error;
        throw new Error('Source must be a Uint8Array or Buffer but was a ' + (source && typeof source == 'object' ? source.constructor.name : typeof source));
      }
      if (this instanceof Decoder) {
        currentDecoder = this;
        packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
        if (this.structures) {
          currentStructures = this.structures;
          return checkedRead();
        } else if (!currentStructures || currentStructures.length > 0) {
          currentStructures = [];
        }
      } else {
        currentDecoder = defaultOptions;
        if (!currentStructures || currentStructures.length > 0) currentStructures = [];
        packedValues = null;
      }
      return checkedRead();
    }
    decodeMultiple(source, forEach) {
      let values,
        lastPosition = 0;
      try {
        let size = source.length;
        sequentialMode = true;
        let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
        if (forEach) {
          if (forEach(value) === false) {
            return;
          }
          while (position$1 < size) {
            lastPosition = position$1;
            if (forEach(checkedRead()) === false) {
              return;
            }
          }
        } else {
          values = [value];
          while (position$1 < size) {
            lastPosition = position$1;
            values.push(checkedRead());
          }
          return values;
        }
      } catch (error) {
        error.lastPosition = lastPosition;
        error.values = values;
        throw error;
      } finally {
        sequentialMode = false;
        clearSource();
      }
    }
  }
  function checkedRead() {
    try {
      let result = read();
      if (bundledStrings$1) {
        if (position$1 >= bundledStrings$1.postBundlePosition) {
          let error = new Error('Unexpected bundle position');
          error.incomplete = true;
          throw error;
        }
        // bundled strings to skip past
        position$1 = bundledStrings$1.postBundlePosition;
        bundledStrings$1 = null;
      }
      if (position$1 == srcEnd) {
        // finished reading this source, cleanup references
        currentStructures = null;
        src = null;
        if (referenceMap) referenceMap = null;
      } else if (position$1 > srcEnd) {
        // over read
        let error = new Error('Unexpected end of CBOR data');
        error.incomplete = true;
        throw error;
      } else if (!sequentialMode) {
        throw new Error('Data read, but end of buffer not reached');
      }
      // else more to read, but we are reading sequentially, so don't clear source yet
      return result;
    } catch (error) {
      clearSource();
      if (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {
        error.incomplete = true;
      }
      throw error;
    }
  }
  function read() {
    let token = src[position$1++];
    let majorType = token >> 5;
    token = token & 0x1f;
    if (token > 0x17) {
      switch (token) {
        case 0x18:
          token = src[position$1++];
          break;
        case 0x19:
          if (majorType == 7) {
            return getFloat16();
          }
          token = dataView.getUint16(position$1);
          position$1 += 2;
          break;
        case 0x1a:
          if (majorType == 7) {
            let value = dataView.getFloat32(position$1);
            if (currentDecoder.useFloat32 > 2) {
              // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
              let multiplier = mult10[(src[position$1] & 0x7f) << 1 | src[position$1 + 1] >> 7];
              position$1 += 4;
              return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
            }
            position$1 += 4;
            return value;
          }
          token = dataView.getUint32(position$1);
          position$1 += 4;
          break;
        case 0x1b:
          if (majorType == 7) {
            let value = dataView.getFloat64(position$1);
            position$1 += 8;
            return value;
          }
          if (majorType > 1) {
            if (dataView.getUint32(position$1) > 0) throw new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295');
            token = dataView.getUint32(position$1 + 4);
          } else if (currentDecoder.int64AsNumber) {
            token = dataView.getUint32(position$1) * 0x100000000;
            token += dataView.getUint32(position$1 + 4);
          } else token = dataView.getBigUint64(position$1);
          position$1 += 8;
          break;
        case 0x1f:
          // indefinite length
          switch (majorType) {
            case 2: // byte string
            case 3:
              // text string
              throw new Error('Indefinite length not supported for byte or text strings');
            case 4:
              // array
              let array = [];
              let value,
                i = 0;
              while ((value = read()) != STOP_CODE) {
                if (i >= maxArraySize) throw new Error("Array length exceeds ".concat(maxArraySize));
                array[i++] = value;
              }
              return majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array);
            case 5:
              // map
              let key;
              if (currentDecoder.mapsAsObjects) {
                let object = {};
                let i = 0;
                if (currentDecoder.keyMap) {
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) throw new Error("Property count exceeds ".concat(maxMapSize));
                    object[safeKey(currentDecoder.decodeKey(key))] = read();
                  }
                } else {
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) throw new Error("Property count exceeds ".concat(maxMapSize));
                    object[safeKey(key)] = read();
                  }
                }
                return object;
              } else {
                if (restoreMapsAsObject) {
                  currentDecoder.mapsAsObjects = true;
                  restoreMapsAsObject = false;
                }
                let map = new Map();
                if (currentDecoder.keyMap) {
                  let i = 0;
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) {
                      throw new Error("Map size exceeds ".concat(maxMapSize));
                    }
                    map.set(currentDecoder.decodeKey(key), read());
                  }
                } else {
                  let i = 0;
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) {
                      throw new Error("Map size exceeds ".concat(maxMapSize));
                    }
                    map.set(key, read());
                  }
                }
                return map;
              }
            case 7:
              return STOP_CODE;
            default:
              throw new Error('Invalid major type for indefinite length ' + majorType);
          }
        default:
          throw new Error('Unknown token ' + token);
      }
    }
    switch (majorType) {
      case 0:
        // positive int
        return token;
      case 1:
        // negative int
        return ~token;
      case 2:
        // buffer
        return readBin(token);
      case 3:
        // string
        if (srcStringEnd >= position$1) {
          return srcString.slice(position$1 - srcStringStart, (position$1 += token) - srcStringStart);
        }
        if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
          // for small blocks, avoiding the overhead of the extract call is helpful
          let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
          if (string != null) return string;
        }
        return readFixedString(token);
      case 4:
        // array
        if (token >= maxArraySize) throw new Error("Array length exceeds ".concat(maxArraySize));
        let array = new Array(token);
        //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())	
        //else 
        for (let i = 0; i < token; i++) array[i] = read();
        return array;
      case 5:
        // map
        if (token >= maxMapSize) throw new Error("Map size exceeds ".concat(maxArraySize));
        if (currentDecoder.mapsAsObjects) {
          let object = {};
          if (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read();else for (let i = 0; i < token; i++) object[safeKey(read())] = read();
          return object;
        } else {
          if (restoreMapsAsObject) {
            currentDecoder.mapsAsObjects = true;
            restoreMapsAsObject = false;
          }
          let map = new Map();
          if (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()), read());else for (let i = 0; i < token; i++) map.set(read(), read());
          return map;
        }
      case 6:
        // extension
        if (token >= BUNDLED_STRINGS_ID) {
          let structure = currentStructures[token & 0x1fff]; // check record structures first
          // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
          if (structure) {
            if (!structure.read) structure.read = createStructureReader(structure);
            return structure.read();
          }
          if (token < 0x10000) {
            if (token == RECORD_INLINE_ID) {
              // we do a special check for this so that we can keep the
              // currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
              let length = readJustLength();
              let id = read();
              let structure = read();
              recordDefinition(id, structure);
              let object = {};
              if (currentDecoder.keyMap) for (let i = 2; i < length; i++) {
                let key = currentDecoder.decodeKey(structure[i - 2]);
                object[safeKey(key)] = read();
              } else for (let i = 2; i < length; i++) {
                let key = structure[i - 2];
                object[safeKey(key)] = read();
              }
              return object;
            } else if (token == RECORD_DEFINITIONS_ID) {
              let length = readJustLength();
              let id = read();
              for (let i = 2; i < length; i++) {
                recordDefinition(id++, read());
              }
              return read();
            } else if (token == BUNDLED_STRINGS_ID) {
              return readBundleExt();
            }
            if (currentDecoder.getShared) {
              loadShared();
              structure = currentStructures[token & 0x1fff];
              if (structure) {
                if (!structure.read) structure.read = createStructureReader(structure);
                return structure.read();
              }
            }
          }
        }
        let extension = currentExtensions[token];
        if (extension) {
          if (extension.handlesRead) return extension(read);else return extension(read());
        } else {
          let input = read();
          for (let i = 0; i < currentExtensionRanges.length; i++) {
            let value = currentExtensionRanges[i](token, input);
            if (value !== undefined) return value;
          }
          return new Tag(input, token);
        }
      case 7:
        // fixed value
        switch (token) {
          case 0x14:
            return false;
          case 0x15:
            return true;
          case 0x16:
            return null;
          case 0x17:
            return;
          // undefined
          case 0x1f:
          default:
            let packedValue = (packedValues || getPackedValues())[token];
            if (packedValue !== undefined) return packedValue;
            throw new Error('Unknown token ' + token);
        }
      default:
        // negative int
        if (isNaN(token)) {
          let error = new Error('Unexpected end of CBOR data');
          error.incomplete = true;
          throw error;
        }
        throw new Error('Unknown CBOR token ' + token);
    }
  }
  const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
  function createStructureReader(structure) {
    if (!structure) throw new Error('Structure is required in record definition');
    function readObject() {
      // get the array size from the header
      let length = src[position$1++];
      //let majorType = token >> 5
      length = length & 0x1f;
      if (length > 0x17) {
        switch (length) {
          case 0x18:
            length = src[position$1++];
            break;
          case 0x19:
            length = dataView.getUint16(position$1);
            position$1 += 2;
            break;
          case 0x1a:
            length = dataView.getUint32(position$1);
            position$1 += 4;
            break;
          default:
            throw new Error('Expected array header, but got ' + src[position$1 - 1]);
        }
      }
      // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
      let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function
      while (compiledReader) {
        // we have a fast compiled object literal reader
        if (compiledReader.propertyCount === length) return compiledReader(read); // with the right length, so we use it
        compiledReader = compiledReader.next; // see if there is another reader with the right length
      }
      if (this.slowReads++ >= inlineObjectReadThreshold) {
        // create a fast compiled reader
        let array = this.length == length ? this : this.slice(0, length);
        compiledReader = currentDecoder.keyMap ? new BlockedFunction('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : '[' + JSON.stringify(k) + ']:r()').join(',') + '}') : new BlockedFunction('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : '[' + JSON.stringify(key) + ']:r()').join(',') + '}');
        if (this.compiledReader) compiledReader.next = this.compiledReader; // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure
        compiledReader.propertyCount = length;
        this.compiledReader = compiledReader;
        return compiledReader(read);
      }
      let object = {};
      if (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read();else for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
      return object;
    }
    structure.slowReads = 0;
    return readObject;
  }
  function safeKey(key) {
    // protect against prototype pollution
    if (typeof key === 'string') return key === '__proto__' ? '__proto_' : key;
    if (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();
    if (key == null) return key + '';
    // protect against expensive (DoS) string conversions
    throw new Error('Invalid property name type ' + typeof key);
  }
  let readFixedString = readStringJS;
  let isNativeAccelerationEnabled = false;
  function readStringJS(length) {
    let result;
    if (length < 16) {
      if (result = shortStringInJS(length)) return result;
    }
    if (length > 64 && decoder) return decoder.decode(src.subarray(position$1, position$1 += length));
    const end = position$1 + length;
    const units = [];
    result = '';
    while (position$1 < end) {
      const byte1 = src[position$1++];
      if ((byte1 & 0x80) === 0) {
        // 1 byte
        units.push(byte1);
      } else if ((byte1 & 0xe0) === 0xc0) {
        // 2 bytes
        const byte2 = src[position$1++] & 0x3f;
        units.push((byte1 & 0x1f) << 6 | byte2);
      } else if ((byte1 & 0xf0) === 0xe0) {
        // 3 bytes
        const byte2 = src[position$1++] & 0x3f;
        const byte3 = src[position$1++] & 0x3f;
        units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
      } else if ((byte1 & 0xf8) === 0xf0) {
        // 4 bytes
        const byte2 = src[position$1++] & 0x3f;
        const byte3 = src[position$1++] & 0x3f;
        const byte4 = src[position$1++] & 0x3f;
        let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;
        if (unit > 0xffff) {
          unit -= 0x10000;
          units.push(unit >>> 10 & 0x3ff | 0xd800);
          unit = 0xdc00 | unit & 0x3ff;
        }
        units.push(unit);
      } else {
        units.push(byte1);
      }
      if (units.length >= 0x1000) {
        result += fromCharCode.apply(String, units);
        units.length = 0;
      }
    }
    if (units.length > 0) {
      result += fromCharCode.apply(String, units);
    }
    return result;
  }
  let fromCharCode = String.fromCharCode;
  function longStringInJS(length) {
    let start = position$1;
    let bytes = new Array(length);
    for (let i = 0; i < length; i++) {
      const byte = src[position$1++];
      if ((byte & 0x80) > 0) {
        position$1 = start;
        return;
      }
      bytes[i] = byte;
    }
    return fromCharCode.apply(String, bytes);
  }
  function shortStringInJS(length) {
    if (length < 4) {
      if (length < 2) {
        if (length === 0) return '';else {
          let a = src[position$1++];
          if ((a & 0x80) > 1) {
            position$1 -= 1;
            return;
          }
          return fromCharCode(a);
        }
      } else {
        let a = src[position$1++];
        let b = src[position$1++];
        if ((a & 0x80) > 0 || (b & 0x80) > 0) {
          position$1 -= 2;
          return;
        }
        if (length < 3) return fromCharCode(a, b);
        let c = src[position$1++];
        if ((c & 0x80) > 0) {
          position$1 -= 3;
          return;
        }
        return fromCharCode(a, b, c);
      }
    } else {
      let a = src[position$1++];
      let b = src[position$1++];
      let c = src[position$1++];
      let d = src[position$1++];
      if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
        position$1 -= 4;
        return;
      }
      if (length < 6) {
        if (length === 4) return fromCharCode(a, b, c, d);else {
          let e = src[position$1++];
          if ((e & 0x80) > 0) {
            position$1 -= 5;
            return;
          }
          return fromCharCode(a, b, c, d, e);
        }
      } else if (length < 8) {
        let e = src[position$1++];
        let f = src[position$1++];
        if ((e & 0x80) > 0 || (f & 0x80) > 0) {
          position$1 -= 6;
          return;
        }
        if (length < 7) return fromCharCode(a, b, c, d, e, f);
        let g = src[position$1++];
        if ((g & 0x80) > 0) {
          position$1 -= 7;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g);
      } else {
        let e = src[position$1++];
        let f = src[position$1++];
        let g = src[position$1++];
        let h = src[position$1++];
        if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
          position$1 -= 8;
          return;
        }
        if (length < 10) {
          if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h);else {
            let i = src[position$1++];
            if ((i & 0x80) > 0) {
              position$1 -= 9;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i);
          }
        } else if (length < 12) {
          let i = src[position$1++];
          let j = src[position$1++];
          if ((i & 0x80) > 0 || (j & 0x80) > 0) {
            position$1 -= 10;
            return;
          }
          if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i, j);
          let k = src[position$1++];
          if ((k & 0x80) > 0) {
            position$1 -= 11;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
        } else {
          let i = src[position$1++];
          let j = src[position$1++];
          let k = src[position$1++];
          let l = src[position$1++];
          if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
            position$1 -= 12;
            return;
          }
          if (length < 14) {
            if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);else {
              let m = src[position$1++];
              if ((m & 0x80) > 0) {
                position$1 -= 13;
                return;
              }
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
            }
          } else {
            let m = src[position$1++];
            let n = src[position$1++];
            if ((m & 0x80) > 0 || (n & 0x80) > 0) {
              position$1 -= 14;
              return;
            }
            if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
            let o = src[position$1++];
            if ((o & 0x80) > 0) {
              position$1 -= 15;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
          }
        }
      }
    }
  }
  function readBin(length) {
    return currentDecoder.copyBuffers ?
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position$1, position$1 += length) : src.subarray(position$1, position$1 += length);
  }
  let f32Array = new Float32Array(1);
  let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
  function getFloat16() {
    let byte0 = src[position$1++];
    let byte1 = src[position$1++];
    let exponent = (byte0 & 0x7f) >> 2;
    if (exponent === 0x1f) {
      // specials
      if (byte1 || byte0 & 3) return NaN;
      return byte0 & 0x80 ? -Infinity : Infinity;
    }
    if (exponent === 0) {
      // sub-normals
      // significand with 10 fractional bits and divided by 2^14
      let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
      return byte0 & 0x80 ? -abs : abs;
    }
    u8Array[3] = byte0 & 0x80 |
    // sign bit
    (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed
    u8Array[2] = (byte0 & 7) << 5 |
    // last exponent bit and first two mantissa bits
    byte1 >> 3; // next 5 bits of mantissa
    u8Array[1] = byte1 << 5; // last three bits of mantissa
    u8Array[0] = 0;
    return f32Array[0];
  }
  new Array(4096);
  class Tag {
    constructor(value, tag) {
      this.value = value;
      this.tag = tag;
    }
  }
  currentExtensions[0] = dateString => {
    // string date extension
    return new Date(dateString);
  };
  currentExtensions[1] = epochSec => {
    // numeric date extension
    return new Date(Math.round(epochSec * 1000));
  };
  currentExtensions[2] = buffer => {
    // bigint extension
    let value = BigInt(0);
    for (let i = 0, l = buffer.byteLength; i < l; i++) {
      value = BigInt(buffer[i]) + (value << BigInt(8));
    }
    return value;
  };
  currentExtensions[3] = buffer => {
    // negative bigint extension
    return BigInt(-1) - currentExtensions[2](buffer);
  };
  currentExtensions[4] = fraction => {
    // best to reparse to maintain accuracy
    return +(fraction[1] + 'e' + fraction[0]);
  };
  currentExtensions[5] = fraction => {
    // probably not sufficiently accurate
    return fraction[1] * Math.exp(fraction[0] * Math.log(2));
  };

  // the registration of the record definition extension
  const recordDefinition = (id, structure) => {
    id = id - 0xe000;
    let existingStructure = currentStructures[id];
    if (existingStructure && existingStructure.isShared) {
      (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
    }
    currentStructures[id] = structure;
    structure.read = createStructureReader(structure);
  };
  currentExtensions[LEGACY_RECORD_INLINE_ID] = data => {
    let length = data.length;
    let structure = data[1];
    recordDefinition(data[0], structure);
    let object = {};
    for (let i = 2; i < length; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = data[i];
    }
    return object;
  };
  currentExtensions[14] = value => {
    if (bundledStrings$1) return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 += value);
    return new Tag(value, 14);
  };
  currentExtensions[15] = value => {
    if (bundledStrings$1) return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value);
    return new Tag(value, 15);
  };
  let glbl = {
    Error,
    RegExp
  };
  currentExtensions[27] = data => {
    // http://cbor.schmorp.de/generic-object
    return (glbl[data[0]] || Error)(data[1], data[2]);
  };
  const packedTable = read => {
    if (src[position$1++] != 0x84) {
      let error = new Error('Packed values structure must be followed by a 4 element array');
      if (src.length < position$1) error.incomplete = true;
      throw error;
    }
    let newPackedValues = read(); // packed values
    if (!newPackedValues || !newPackedValues.length) {
      let error = new Error('Packed values structure must be followed by a 4 element array');
      error.incomplete = true;
      throw error;
    }
    packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
    packedValues.prefixes = read();
    packedValues.suffixes = read();
    return read(); // read the rump
  };
  packedTable.handlesRead = true;
  currentExtensions[51] = packedTable;
  currentExtensions[PACKED_REFERENCE_TAG_ID] = data => {
    // packed reference
    if (!packedValues) {
      if (currentDecoder.getShared) loadShared();else return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
    if (typeof data == 'number') return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
    let error = new Error('No support for non-integer packed references yet');
    if (data === undefined) error.incomplete = true;
    throw error;
  };

  // The following code is an incomplete implementation of http://cbor.schmorp.de/stringref
  // the real thing would need to implemennt more logic to populate the stringRefs table and
  // maintain a stack of stringRef "namespaces".
  //
  // currentExtensions[25] = (id) => {
  // 	return stringRefs[id]
  // }
  // currentExtensions[256] = (read) => {
  // 	stringRefs = []
  // 	try {
  // 		return read()
  // 	} finally {
  // 		stringRefs = null
  // 	}
  // }
  // currentExtensions[256].handlesRead = true

  currentExtensions[28] = read => {
    // shareable http://cbor.schmorp.de/value-sharing (for structured clones)
    if (!referenceMap) {
      referenceMap = new Map();
      referenceMap.id = 0;
    }
    let id = referenceMap.id++;
    let startingPosition = position$1;
    let token = src[position$1];
    let target;
    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
    // ahead past references to record structure definitions
    if (token >> 5 == 4) target = [];else target = {};
    let refEntry = {
      target
    }; // a placeholder object
    referenceMap.set(id, refEntry);
    let targetProperties = read(); // read the next value as the target object to id
    if (refEntry.used) {
      // there is a cycle, so we have to assign properties to original target
      if (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {
        // this means that the returned target does not match the targetProperties, so we need rerun the read to
        // have the correctly create instance be assigned as a reference, then we do the copy the properties back to the
        // target
        // reset the position so that the read can be repeated
        position$1 = startingPosition;
        // the returned instance is our new target for references
        target = targetProperties;
        referenceMap.set(id, {
          target
        });
        targetProperties = read();
      }
      return Object.assign(target, targetProperties);
    }
    refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one
    return targetProperties; // no cycle, can just use the returned read object
  };
  currentExtensions[28].handlesRead = true;
  currentExtensions[29] = id => {
    // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
    let refEntry = referenceMap.get(id);
    refEntry.used = true;
    return refEntry.target;
  };
  currentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  (currentExtensions[259] = read => {
    // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec
    // for decoding as a standard Map
    if (currentDecoder.mapsAsObjects) {
      currentDecoder.mapsAsObjects = false;
      restoreMapsAsObject = true;
    }
    return read();
  }).handlesRead = true;
  function combine(a, b) {
    if (typeof a === 'string') return a + b;
    if (a instanceof Array) return a.concat(b);
    return Object.assign({}, a, b);
  }
  function getPackedValues() {
    if (!packedValues) {
      if (currentDecoder.getShared) loadShared();else throw new Error('No packed values available');
    }
    return packedValues;
  }
  const SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'
  currentExtensionRanges.push((tag, input) => {
    if (tag >= 225 && tag <= 255) return combine(getPackedValues().prefixes[tag - 224], input);
    if (tag >= 28704 && tag <= 32767) return combine(getPackedValues().prefixes[tag - 28672], input);
    if (tag >= 1879052288 && tag <= 2147483647) return combine(getPackedValues().prefixes[tag - 1879048192], input);
    if (tag >= 216 && tag <= 223) return combine(input, getPackedValues().suffixes[tag - 216]);
    if (tag >= 27647 && tag <= 28671) return combine(input, getPackedValues().suffixes[tag - 27639]);
    if (tag >= 1811940352 && tag <= 1879048191) return combine(input, getPackedValues().suffixes[tag - 1811939328]);
    if (tag == SHARED_DATA_TAG_ID) {
      // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
      return {
        packedValues: packedValues,
        structures: currentStructures.slice(0),
        version: input
      };
    }
    if (tag == 55799)
      // self-descriptive CBOR tag, just return input value
      return input;
  });
  const isLittleEndianMachine$1 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
  const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == 'undefined' ? {
    name: 'BigUint64Array'
  } : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == 'undefined' ? {
    name: 'BigInt64Array'
  } : BigInt64Array, Float32Array, Float64Array];
  const typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
  for (let i = 0; i < typedArrays.length; i++) {
    registerTypedArray(typedArrays[i], typedArrayTags[i]);
  }
  function registerTypedArray(TypedArray, tag) {
    let dvMethod = 'get' + TypedArray.name.slice(0, -5);
    let bytesPerElement;
    if (typeof TypedArray === 'function') bytesPerElement = TypedArray.BYTES_PER_ELEMENT;else TypedArray = null;
    for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
      if (!littleEndian && bytesPerElement == 1) continue;
      let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0;
      currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine$1 ? buffer => {
        if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);
        if (!currentDecoder.copyBuffers) {
          // try provide a direct view, but will only work if we are byte-aligned
          if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer.byteOffset & 1) || bytesPerElement === 4 && !(buffer.byteOffset & 3) || bytesPerElement === 8 && !(buffer.byteOffset & 7)) return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);
        }
        // we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned
        return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
      } : buffer => {
        if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);
        let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        let elements = buffer.length >> sizeShift;
        let ta = new TypedArray(elements);
        let method = dv[dvMethod];
        for (let i = 0; i < elements; i++) {
          ta[i] = method.call(dv, i << sizeShift, littleEndian);
        }
        return ta;
      };
    }
  }
  function readBundleExt() {
    let length = readJustLength();
    let bundlePosition = position$1 + read();
    for (let i = 2; i < length; i++) {
      // skip past bundles that were already read
      let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards
      position$1 += bundleLength;
    }
    let dataPosition = position$1;
    position$1 = bundlePosition;
    bundledStrings$1 = [readStringJS(readJustLength()), readStringJS(readJustLength())];
    bundledStrings$1.position0 = 0;
    bundledStrings$1.position1 = 0;
    bundledStrings$1.postBundlePosition = position$1;
    position$1 = dataPosition;
    return read();
  }
  function readJustLength() {
    let token = src[position$1++] & 0x1f;
    if (token > 0x17) {
      switch (token) {
        case 0x18:
          token = src[position$1++];
          break;
        case 0x19:
          token = dataView.getUint16(position$1);
          position$1 += 2;
          break;
        case 0x1a:
          token = dataView.getUint32(position$1);
          position$1 += 4;
          break;
      }
    }
    return token;
  }
  function loadShared() {
    if (currentDecoder.getShared) {
      let sharedData = saveState(() => {
        // save the state in case getShared modifies our buffer
        src = null;
        return currentDecoder.getShared();
      }) || {};
      let updatedStructures = sharedData.structures || [];
      currentDecoder.sharedVersion = sharedData.version;
      packedValues = currentDecoder.sharedValues = sharedData.packedValues;
      if (currentStructures === true) currentDecoder.structures = currentStructures = updatedStructures;else currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
  function saveState(callback) {
    let savedSrcEnd = srcEnd;
    let savedPosition = position$1;
    let savedSrcStringStart = srcStringStart;
    let savedSrcStringEnd = srcStringEnd;
    let savedSrcString = srcString;
    let savedReferenceMap = referenceMap;
    let savedBundledStrings = bundledStrings$1;

    // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)
    let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed
    let savedStructures = currentStructures;
    let savedDecoder = currentDecoder;
    let savedSequentialMode = sequentialMode;
    let value = callback();
    srcEnd = savedSrcEnd;
    position$1 = savedPosition;
    srcStringStart = savedSrcStringStart;
    srcStringEnd = savedSrcStringEnd;
    srcString = savedSrcString;
    referenceMap = savedReferenceMap;
    bundledStrings$1 = savedBundledStrings;
    src = savedSrc;
    sequentialMode = savedSequentialMode;
    currentStructures = savedStructures;
    currentDecoder = savedDecoder;
    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
    return value;
  }
  function clearSource() {
    src = null;
    referenceMap = null;
    currentStructures = null;
  }
  function addExtension$1(extension) {
    currentExtensions[extension.tag] = extension.decode;
  }
  function setSizeLimits(limits) {
    if (limits.maxMapSize) maxMapSize = limits.maxMapSize;
    if (limits.maxArraySize) maxArraySize = limits.maxArraySize;
    if (limits.maxObjectSize) limits.maxObjectSize;
  }
  const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding
  for (let i = 0; i < 256; i++) {
    mult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103));
  }
  let defaultDecoder = new Decoder({
    useRecords: false
  });
  const decode = defaultDecoder.decode;
  const decodeMultiple = defaultDecoder.decodeMultiple;
  const FLOAT32_OPTIONS = {
    NEVER: 0,
    ALWAYS: 1,
    DECIMAL_ROUND: 3,
    DECIMAL_FIT: 4
  };
  function roundFloat32(float32Number) {
    f32Array[0] = float32Number;
    let multiplier = mult10[(u8Array[3] & 0x7f) << 1 | u8Array[2] >> 7];
    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
  }
  let textEncoder;
  try {
    textEncoder = new TextEncoder();
  } catch (error) {}
  let extensions, extensionClasses;
  const Buffer$1 = typeof globalThis === 'object' && globalThis.Buffer;
  const hasNodeBuffer = typeof Buffer$1 !== 'undefined';
  const ByteArrayAllocate = hasNodeBuffer ? Buffer$1.allocUnsafeSlow : Uint8Array;
  const ByteArray = hasNodeBuffer ? Buffer$1 : Uint8Array;
  const MAX_STRUCTURES = 0x100;
  const MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000;
  let throwOnIterable;
  let target;
  let targetView;
  let position = 0;
  let safeEnd;
  let bundledStrings = null;
  const MAX_BUNDLE_SIZE = 0xf000;
  const hasNonLatin = /[\u0080-\uFFFF]/;
  const RECORD_SYMBOL = Symbol('record-id');
  class Encoder extends Decoder {
    constructor(options) {
      super(options);
      this.offset = 0;
      let start;
      let sharedStructures;
      let hasSharedUpdate;
      let structures;
      let referenceMap;
      options = options || {};
      let encodeUtf8 = ByteArray.prototype.utf8Write ? function (string, position, maxBytes) {
        return target.utf8Write(string, position, maxBytes);
      } : textEncoder && textEncoder.encodeInto ? function (string, position) {
        return textEncoder.encodeInto(string, target.subarray(position)).written;
      } : false;
      let encoder = this;
      let hasSharedStructures = options.structures || options.saveStructures;
      let maxSharedStructures = options.maxSharedStructures;
      if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 128 : 0;
      if (maxSharedStructures > 8190) throw new Error('Maximum maxSharedStructure is 8190');
      let isSequential = options.sequential;
      if (isSequential) {
        maxSharedStructures = 0;
      }
      if (!this.structures) this.structures = [];
      if (this.saveStructures) this.saveShared = this.saveStructures;
      let samplingPackedValues,
        packedObjectMap,
        sharedValues = options.sharedValues;
      let sharedPackedObjectMap;
      if (sharedValues) {
        sharedPackedObjectMap = Object.create(null);
        for (let i = 0, l = sharedValues.length; i < l; i++) {
          sharedPackedObjectMap[sharedValues[i]] = i;
        }
      }
      let recordIdsToRemove = [];
      let transitionsCount = 0;
      let serializationsSinceTransitionRebuild = 0;
      this.mapEncode = function (value, encodeOptions) {
        // Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)
        if (this._keyMap && !this._mapped) {
          //console.log('encoding ', value)
          switch (value.constructor.name) {
            case 'Array':
              value = value.map(r => this.encodeKeys(r));
              break;
            //case 'Map': 
            //	value = this.encodeKeys(value)
            //	break
          }
          //this._mapped = true
        }
        return this.encode(value, encodeOptions);
      };
      this.encode = function (value, encodeOptions) {
        if (!target) {
          target = new ByteArrayAllocate(8192);
          targetView = new DataView(target.buffer, 0, 8192);
          position = 0;
        }
        safeEnd = target.length - 10;
        if (safeEnd - position < 0x800) {
          // don't start too close to the end, 
          target = new ByteArrayAllocate(target.length);
          targetView = new DataView(target.buffer, 0, target.length);
          safeEnd = target.length - 10;
          position = 0;
        } else if (encodeOptions === REUSE_BUFFER_MODE) position = position + 7 & 0x7ffffff8; // Word align to make any future copying of this buffer faster
        start = position;
        if (encoder.useSelfDescribedHeader) {
          targetView.setUint32(position, 0xd9d9f700); // tag two byte, then self-descriptive tag
          position += 3;
        }
        referenceMap = encoder.structuredClone ? new Map() : null;
        if (encoder.bundleStrings && typeof value !== 'string') {
          bundledStrings = [];
          bundledStrings.size = Infinity; // force a new bundle start on first string
        } else bundledStrings = null;
        sharedStructures = encoder.structures;
        if (sharedStructures) {
          if (sharedStructures.uninitialized) {
            let sharedData = encoder.getShared() || {};
            encoder.structures = sharedStructures = sharedData.structures || [];
            encoder.sharedVersion = sharedData.version;
            let sharedValues = encoder.sharedValues = sharedData.packedValues;
            if (sharedValues) {
              sharedPackedObjectMap = {};
              for (let i = 0, l = sharedValues.length; i < l; i++) sharedPackedObjectMap[sharedValues[i]] = i;
            }
          }
          let sharedStructuresLength = sharedStructures.length;
          if (sharedStructuresLength > maxSharedStructures && !isSequential) sharedStructuresLength = maxSharedStructures;
          if (!sharedStructures.transitions) {
            // rebuild our structure transitions
            sharedStructures.transitions = Object.create(null);
            for (let i = 0; i < sharedStructuresLength; i++) {
              let keys = sharedStructures[i];
              //console.log('shared struct keys:', keys)
              if (!keys) continue;
              let nextTransition,
                transition = sharedStructures.transitions;
              for (let j = 0, l = keys.length; j < l; j++) {
                if (transition[RECORD_SYMBOL] === undefined) transition[RECORD_SYMBOL] = i;
                let key = keys[j];
                nextTransition = transition[key];
                if (!nextTransition) {
                  nextTransition = transition[key] = Object.create(null);
                }
                transition = nextTransition;
              }
              transition[RECORD_SYMBOL] = i | 0x100000;
            }
          }
          if (!isSequential) sharedStructures.nextId = sharedStructuresLength;
        }
        if (hasSharedUpdate) hasSharedUpdate = false;
        structures = sharedStructures || [];
        packedObjectMap = sharedPackedObjectMap;
        if (options.pack) {
          let packedValues = new Map();
          packedValues.values = [];
          packedValues.encoder = encoder;
          packedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity);
          packedValues.objectMap = sharedPackedObjectMap || false;
          packedValues.samplingPackedValues = samplingPackedValues;
          findRepetitiveStrings(value, packedValues);
          if (packedValues.values.length > 0) {
            target[position++] = 0xd8; // one-byte tag
            target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
            writeArrayHeader(4);
            let valuesArray = packedValues.values;
            encode(valuesArray);
            writeArrayHeader(0); // prefixes
            writeArrayHeader(0); // suffixes
            packedObjectMap = Object.create(sharedPackedObjectMap || null);
            for (let i = 0, l = valuesArray.length; i < l; i++) {
              packedObjectMap[valuesArray[i]] = i;
            }
          }
        }
        throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
        try {
          if (throwOnIterable) return;
          encode(value);
          if (bundledStrings) {
            writeBundles(start, encode);
          }
          encoder.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
          if (referenceMap && referenceMap.idsToInsert) {
            position += referenceMap.idsToInsert.length * 2;
            if (position > safeEnd) makeRoom(position);
            encoder.offset = position;
            let serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert);
            referenceMap = null;
            return serialized;
          }
          if (encodeOptions & REUSE_BUFFER_MODE) {
            target.start = start;
            target.end = position;
            return target;
          }
          return target.subarray(start, position); // position can change if we call encode again in saveShared, so we get the buffer now
        } finally {
          if (sharedStructures) {
            if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;
            if (sharedStructures.length > maxSharedStructures) sharedStructures.length = maxSharedStructures;
            if (transitionsCount > 10000) {
              // force a rebuild occasionally after a lot of transitions so it can get cleaned up
              sharedStructures.transitions = null;
              serializationsSinceTransitionRebuild = 0;
              transitionsCount = 0;
              if (recordIdsToRemove.length > 0) recordIdsToRemove = [];
            } else if (recordIdsToRemove.length > 0 && !isSequential) {
              for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                recordIdsToRemove[i][RECORD_SYMBOL] = undefined;
              }
              recordIdsToRemove = [];
              //sharedStructures.nextId = maxSharedStructures
            }
          }
          if (hasSharedUpdate && encoder.saveShared) {
            if (encoder.structures.length > maxSharedStructures) {
              encoder.structures = encoder.structures.slice(0, maxSharedStructures);
            }
            // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
            let returnBuffer = target.subarray(start, position);
            if (encoder.updateSharedData() === false) return encoder.encode(value); // re-encode if it fails
            return returnBuffer;
          }
          if (encodeOptions & RESET_BUFFER_MODE) position = start;
        }
      };
      this.findCommonStringsToPack = () => {
        samplingPackedValues = new Map();
        if (!sharedPackedObjectMap) sharedPackedObjectMap = Object.create(null);
        return options => {
          let threshold = options && options.threshold || 4;
          let position = this.pack ? options.maxPrivatePackedValues || 16 : 0;
          if (!sharedValues) sharedValues = this.sharedValues = [];
          for (let [key, status] of samplingPackedValues) {
            if (status.count > threshold) {
              sharedPackedObjectMap[key] = position++;
              sharedValues.push(key);
              hasSharedUpdate = true;
            }
          }
          while (this.saveShared && this.updateSharedData() === false) {}
          samplingPackedValues = null;
        };
      };
      const encode = value => {
        if (position > safeEnd) target = makeRoom(position);
        var type = typeof value;
        var length;
        if (type === 'string') {
          if (packedObjectMap) {
            let packedPosition = packedObjectMap[value];
            if (packedPosition >= 0) {
              if (packedPosition < 16) target[position++] = packedPosition + 0xe0; // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
              else {
                target[position++] = 0xc6; // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
                if (packedPosition & 1) encode(15 - packedPosition >> 1);else encode(packedPosition - 16 >> 1);
              }
              return;
              /*						} else if (packedStatus.serializationId != serializationId) {
              							packedStatus.serializationId = serializationId
              							packedStatus.count = 1
              							if (options.sharedPack) {
              								let sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1
              								if (shareCount > (options.sharedPack.threshold || 5)) {
              									let sharedPosition = packedStatus.position = packedStatus.nextSharedPosition
              									hasSharedUpdate = true
              									if (sharedPosition < 16)
              										target[position++] = sharedPosition + 0xc0
              									}
              							}
              						} // else any in-doc incrementation?*/
            } else if (samplingPackedValues && !options.pack) {
              let status = samplingPackedValues.get(value);
              if (status) status.count++;else samplingPackedValues.set(value, {
                count: 1
              });
            }
          }
          let strLength = value.length;
          if (bundledStrings && strLength >= 4 && strLength < 0x400) {
            if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
              let extStart;
              let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
              if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);
              target[position++] = 0xd9; // tag 16-bit
              target[position++] = 0xdf; // tag 0xdff9
              target[position++] = 0xf9;
              // TODO: If we only have one bundle with any string data, only write one string bundle
              target[position++] = bundledStrings.position ? 0x84 : 0x82; // array of 4 or 2 elements depending on if we write bundles
              target[position++] = 0x1a; // 32-bit unsigned int
              extStart = position - start;
              position += 4; // reserve for writing bundle reference
              if (bundledStrings.position) {
                writeBundles(start, encode); // write the last bundles
              }
              bundledStrings = ['', '']; // create new ones
              bundledStrings.size = 0;
              bundledStrings.position = extStart;
            }
            let twoByte = hasNonLatin.test(value);
            bundledStrings[twoByte ? 0 : 1] += value;
            target[position++] = twoByte ? 0xce : 0xcf;
            encode(strLength);
            return;
          }
          let headerSize;
          // first we estimate the header size, so we can write to the correct location
          if (strLength < 0x20) {
            headerSize = 1;
          } else if (strLength < 0x100) {
            headerSize = 2;
          } else if (strLength < 0x10000) {
            headerSize = 3;
          } else {
            headerSize = 5;
          }
          let maxBytes = strLength * 3;
          if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);
          if (strLength < 0x40 || !encodeUtf8) {
            let i,
              c1,
              c2,
              strPosition = position + headerSize;
            for (i = 0; i < strLength; i++) {
              c1 = value.charCodeAt(i);
              if (c1 < 0x80) {
                target[strPosition++] = c1;
              } else if (c1 < 0x800) {
                target[strPosition++] = c1 >> 6 | 0xc0;
                target[strPosition++] = c1 & 0x3f | 0x80;
              } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {
                c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);
                i++;
                target[strPosition++] = c1 >> 18 | 0xf0;
                target[strPosition++] = c1 >> 12 & 0x3f | 0x80;
                target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
                target[strPosition++] = c1 & 0x3f | 0x80;
              } else {
                target[strPosition++] = c1 >> 12 | 0xe0;
                target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
                target[strPosition++] = c1 & 0x3f | 0x80;
              }
            }
            length = strPosition - position - headerSize;
          } else {
            length = encodeUtf8(value, position + headerSize, maxBytes);
          }
          if (length < 0x18) {
            target[position++] = 0x60 | length;
          } else if (length < 0x100) {
            if (headerSize < 2) {
              target.copyWithin(position + 2, position + 1, position + 1 + length);
            }
            target[position++] = 0x78;
            target[position++] = length;
          } else if (length < 0x10000) {
            if (headerSize < 3) {
              target.copyWithin(position + 3, position + 2, position + 2 + length);
            }
            target[position++] = 0x79;
            target[position++] = length >> 8;
            target[position++] = length & 0xff;
          } else {
            if (headerSize < 5) {
              target.copyWithin(position + 5, position + 3, position + 3 + length);
            }
            target[position++] = 0x7a;
            targetView.setUint32(position, length);
            position += 4;
          }
          position += length;
        } else if (type === 'number') {
          if (!this.alwaysUseFloat && value >>> 0 === value) {
            // positive integer, 32-bit or less
            // positive uint
            if (value < 0x18) {
              target[position++] = value;
            } else if (value < 0x100) {
              target[position++] = 0x18;
              target[position++] = value;
            } else if (value < 0x10000) {
              target[position++] = 0x19;
              target[position++] = value >> 8;
              target[position++] = value & 0xff;
            } else {
              target[position++] = 0x1a;
              targetView.setUint32(position, value);
              position += 4;
            }
          } else if (!this.alwaysUseFloat && value >> 0 === value) {
            // negative integer
            if (value >= -0x18) {
              target[position++] = 0x1f - value;
            } else if (value >= -0x100) {
              target[position++] = 0x38;
              target[position++] = ~value;
            } else if (value >= -0x10000) {
              target[position++] = 0x39;
              targetView.setUint16(position, ~value);
              position += 2;
            } else {
              target[position++] = 0x3a;
              targetView.setUint32(position, ~value);
              position += 4;
            }
          } else {
            let useFloat32;
            if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {
              target[position++] = 0xfa;
              targetView.setFloat32(position, value);
              let xShifted;
              if (useFloat32 < 4 ||
              // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
              (xShifted = value * mult10[(target[position] & 0x7f) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {
                position += 4;
                return;
              } else position--; // move back into position for writing a double
            }
            target[position++] = 0xfb;
            targetView.setFloat64(position, value);
            position += 8;
          }
        } else if (type === 'object') {
          if (!value) target[position++] = 0xf6;else {
            if (referenceMap) {
              let referee = referenceMap.get(value);
              if (referee) {
                target[position++] = 0xd8;
                target[position++] = 29; // http://cbor.schmorp.de/value-sharing
                target[position++] = 0x19; // 16-bit uint
                if (!referee.references) {
                  let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);
                  referee.references = [];
                  idsToInsert.push(referee);
                }
                referee.references.push(position - start);
                position += 2; // TODO: also support 32-bit
                return;
              } else referenceMap.set(value, {
                offset: position - start
              });
            }
            let constructor = value.constructor;
            if (constructor === Object) {
              writeObject(value);
            } else if (constructor === Array) {
              length = value.length;
              if (length < 0x18) {
                target[position++] = 0x80 | length;
              } else {
                writeArrayHeader(length);
              }
              for (let i = 0; i < length; i++) {
                encode(value[i]);
              }
            } else if (constructor === Map) {
              if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                // use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way
                target[position++] = 0xd9;
                target[position++] = 1;
                target[position++] = 3;
              }
              length = value.size;
              if (length < 0x18) {
                target[position++] = 0xa0 | length;
              } else if (length < 0x100) {
                target[position++] = 0xb8;
                target[position++] = length;
              } else if (length < 0x10000) {
                target[position++] = 0xb9;
                target[position++] = length >> 8;
                target[position++] = length & 0xff;
              } else {
                target[position++] = 0xba;
                targetView.setUint32(position, length);
                position += 4;
              }
              if (encoder.keyMap) {
                for (let [key, entryValue] of value) {
                  encode(encoder.encodeKey(key));
                  encode(entryValue);
                }
              } else {
                for (let [key, entryValue] of value) {
                  encode(key);
                  encode(entryValue);
                }
              }
            } else {
              for (let i = 0, l = extensions.length; i < l; i++) {
                let extensionClass = extensionClasses[i];
                if (value instanceof extensionClass) {
                  let extension = extensions[i];
                  let tag = extension.tag;
                  if (tag == undefined) tag = extension.getTag && extension.getTag.call(this, value);
                  if (tag < 0x18) {
                    target[position++] = 0xc0 | tag;
                  } else if (tag < 0x100) {
                    target[position++] = 0xd8;
                    target[position++] = tag;
                  } else if (tag < 0x10000) {
                    target[position++] = 0xd9;
                    target[position++] = tag >> 8;
                    target[position++] = tag & 0xff;
                  } else if (tag > -1) {
                    target[position++] = 0xda;
                    targetView.setUint32(position, tag);
                    position += 4;
                  } // else undefined, don't write tag
                  extension.encode.call(this, value, encode, makeRoom);
                  return;
                }
              }
              if (value[Symbol.iterator]) {
                if (throwOnIterable) {
                  let error = new Error('Iterable should be serialized as iterator');
                  error.iteratorNotHandled = true;
                  throw error;
                }
                target[position++] = 0x9f; // indefinite length array
                for (let entry of value) {
                  encode(entry);
                }
                target[position++] = 0xff; // stop-code
                return;
              }
              if (value[Symbol.asyncIterator] || isBlob(value)) {
                let error = new Error('Iterable/blob should be serialized as iterator');
                error.iteratorNotHandled = true;
                throw error;
              }
              if (this.useToJSON && value.toJSON) {
                const json = value.toJSON();
                // if for some reason value.toJSON returns itself it'll loop forever
                if (json !== value) return encode(json);
              }

              // no extension found, write as a plain object
              writeObject(value);
            }
          }
        } else if (type === 'boolean') {
          target[position++] = value ? 0xf5 : 0xf4;
        } else if (type === 'bigint') {
          if (value < BigInt(1) << BigInt(64) && value >= 0) {
            // use an unsigned int as long as it fits
            target[position++] = 0x1b;
            targetView.setBigUint64(position, value);
          } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
            // if we can fit an unsigned int, use that
            target[position++] = 0x3b;
            targetView.setBigUint64(position, -value - BigInt(1));
          } else {
            // overflow
            if (this.largeBigIntToFloat) {
              target[position++] = 0xfb;
              targetView.setFloat64(position, Number(value));
            } else {
              if (value >= BigInt(0)) target[position++] = 0xc2; // tag 2
              else {
                target[position++] = 0xc3; // tag 2
                value = BigInt(-1) - value;
              }
              let bytes = [];
              while (value) {
                bytes.push(Number(value & BigInt(0xff)));
                value >>= BigInt(8);
              }
              writeBuffer(new Uint8Array(bytes.reverse()), makeRoom);
              return;
            }
          }
          position += 8;
        } else if (type === 'undefined') {
          target[position++] = 0xf7;
        } else {
          throw new Error('Unknown type: ' + type);
        }
      };
      const writeObject = this.useRecords === false ? this.variableMapSize ? object => {
        // this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
        let keys = Object.keys(object);
        let vals = Object.values(object);
        let length = keys.length;
        if (length < 0x18) {
          target[position++] = 0xa0 | length;
        } else if (length < 0x100) {
          target[position++] = 0xb8;
          target[position++] = length;
        } else if (length < 0x10000) {
          target[position++] = 0xb9;
          target[position++] = length >> 8;
          target[position++] = length & 0xff;
        } else {
          target[position++] = 0xba;
          targetView.setUint32(position, length);
          position += 4;
        }
        if (encoder.keyMap) {
          for (let i = 0; i < length; i++) {
            encode(encoder.encodeKey(keys[i]));
            encode(vals[i]);
          }
        } else {
          for (let i = 0; i < length; i++) {
            encode(keys[i]);
            encode(vals[i]);
          }
        }
      } : object => {
        target[position++] = 0xb9; // always use map 16, so we can preallocate and set the length afterwards
        let objectOffset = position - start;
        position += 2;
        let size = 0;
        if (encoder.keyMap) {
          for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
            encode(encoder.encodeKey(key));
            encode(object[key]);
            size++;
          }
        } else {
          for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
            encode(key);
            encode(object[key]);
            size++;
          }
        }
        target[objectOffset++ + start] = size >> 8;
        target[objectOffset + start] = size & 0xff;
      } : (object, skipValues) => {
        let nextTransition,
          transition = structures.transitions || (structures.transitions = Object.create(null));
        let newTransitions = 0;
        let length = 0;
        let parentRecordId;
        let keys;
        if (this.keyMap) {
          keys = Object.keys(object).map(k => this.encodeKey(k));
          length = keys.length;
          for (let i = 0; i < length; i++) {
            let key = keys[i];
            nextTransition = transition[key];
            if (!nextTransition) {
              nextTransition = transition[key] = Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
          }
        } else {
          for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (!nextTransition) {
              if (transition[RECORD_SYMBOL] & 0x100000) {
                // this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it
                parentRecordId = transition[RECORD_SYMBOL] & 0xffff;
              }
              nextTransition = transition[key] = Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
            length++;
          }
        }
        let recordId = transition[RECORD_SYMBOL];
        if (recordId !== undefined) {
          recordId &= 0xffff;
          target[position++] = 0xd9;
          target[position++] = recordId >> 8 | 0xe0;
          target[position++] = recordId & 0xff;
        } else {
          if (!keys) keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
          if (parentRecordId === undefined) {
            recordId = structures.nextId++;
            if (!recordId) {
              recordId = 0;
              structures.nextId = 1;
            }
            if (recordId >= MAX_STRUCTURES) {
              // cycle back around
              structures.nextId = (recordId = maxSharedStructures) + 1;
            }
          } else {
            recordId = parentRecordId;
          }
          structures[recordId] = keys;
          if (recordId < maxSharedStructures) {
            target[position++] = 0xd9;
            target[position++] = recordId >> 8 | 0xe0;
            target[position++] = recordId & 0xff;
            transition = structures.transitions;
            for (let i = 0; i < length; i++) {
              if (transition[RECORD_SYMBOL] === undefined || transition[RECORD_SYMBOL] & 0x100000) transition[RECORD_SYMBOL] = recordId;
              transition = transition[keys[i]];
            }
            transition[RECORD_SYMBOL] = recordId | 0x100000; // indicates it is a extendable terminal
            hasSharedUpdate = true;
          } else {
            transition[RECORD_SYMBOL] = recordId;
            targetView.setUint32(position, 0xd9dfff00); // tag two byte, then record definition id
            position += 3;
            if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
            // record the removal of the id, we can maintain our shared structure
            if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures) recordIdsToRemove.shift()[RECORD_SYMBOL] = undefined; // we are cycling back through, and have to remove old ones
            recordIdsToRemove.push(transition);
            writeArrayHeader(length + 2);
            encode(0xe000 + recordId);
            encode(keys);
            if (skipValues) return; // special exit for iterator
            for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) encode(object[key]);
            return;
          }
        }
        if (length < 0x18) {
          // write the array header
          target[position++] = 0x80 | length;
        } else {
          writeArrayHeader(length);
        }
        if (skipValues) return; // special exit for iterator
        for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) encode(object[key]);
      };
      const makeRoom = end => {
        let newSize;
        if (end > 0x1000000) {
          // special handling for really large buffers
          if (end - start > MAX_BUFFER_SIZE) throw new Error('Encoded buffer would be larger than maximum buffer size');
          newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);
        } else
          // faster handling for smaller buffers
          newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
        let newBuffer = new ByteArrayAllocate(newSize);
        targetView = new DataView(newBuffer.buffer, 0, newSize);
        if (target.copy) target.copy(newBuffer, 0, start, end);else newBuffer.set(target.slice(start, end));
        position -= start;
        start = 0;
        safeEnd = newBuffer.length - 10;
        return target = newBuffer;
      };
      let chunkThreshold = 100;
      let continuedChunkThreshold = 1000;
      this.encodeAsIterable = function (value, options) {
        return startEncoding(value, options, encodeObjectAsIterable);
      };
      this.encodeAsAsyncIterable = function (value, options) {
        return startEncoding(value, options, encodeObjectAsAsyncIterable);
      };
      function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
        let constructor = object.constructor;
        if (constructor === Object) {
          let useRecords = encoder.useRecords !== false;
          if (useRecords) writeObject(object, true); // write the record identifier
          else writeEntityLength(Object.keys(object).length, 0xa0);
          for (let key in object) {
            let value = object[key];
            if (!useRecords) encode(key);
            if (value && typeof value === 'object') {
              if (iterateProperties[key]) yield* encodeObjectAsIterable(value, iterateProperties[key]);else yield* tryEncode(value, iterateProperties, key);
            } else encode(value);
          }
        } else if (constructor === Array) {
          let length = object.length;
          writeArrayHeader(length);
          for (let i = 0; i < length; i++) {
            let value = object[i];
            if (value && (typeof value === 'object' || position - start > chunkThreshold)) {
              if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);else yield* tryEncode(value, iterateProperties, 'element');
            } else encode(value);
          }
        } else if (object[Symbol.iterator] && !object.buffer) {
          // iterator, but exclude typed arrays
          target[position++] = 0x9f; // start indefinite array
          for (let value of object) {
            if (value && (typeof value === 'object' || position - start > chunkThreshold)) {
              if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);else yield* tryEncode(value, iterateProperties, 'element');
            } else encode(value);
          }
          target[position++] = 0xff; // stop byte
        } else if (isBlob(object)) {
          writeEntityLength(object.size, 0x40); // encode as binary data
          yield target.subarray(start, position);
          yield object; // directly return blobs, they have to be encoded asynchronously
          restartEncoding();
        } else if (object[Symbol.asyncIterator]) {
          target[position++] = 0x9f; // start indefinite array
          yield target.subarray(start, position);
          yield object; // directly return async iterators, they have to be encoded asynchronously
          restartEncoding();
          target[position++] = 0xff; // stop byte
        } else {
          encode(object);
        }
        if (finalIterable && position > start) yield target.subarray(start, position);else if (position - start > chunkThreshold) {
          yield target.subarray(start, position);
          restartEncoding();
        }
      }
      function* tryEncode(value, iterateProperties, key) {
        let restart = position - start;
        try {
          encode(value);
          if (position - start > chunkThreshold) {
            yield target.subarray(start, position);
            restartEncoding();
          }
        } catch (error) {
          if (error.iteratorNotHandled) {
            iterateProperties[key] = {};
            position = start + restart; // restart our position so we don't have partial data from last encode
            yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
          } else throw error;
        }
      }
      function restartEncoding() {
        chunkThreshold = continuedChunkThreshold;
        encoder.encode(null, THROW_ON_ITERABLE); // restart encoding
      }
      function startEncoding(value, options, encodeIterable) {
        if (options && options.chunkThreshold)
          // explicitly specified chunk sizes
          chunkThreshold = continuedChunkThreshold = options.chunkThreshold;else
          // we start with a smaller threshold to get initial bytes sent quickly
          chunkThreshold = 100;
        if (value && typeof value === 'object') {
          encoder.encode(null, THROW_ON_ITERABLE); // start encoding
          return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
        }
        return [encoder.encode(value)];
      }
      function encodeObjectAsAsyncIterable(_x, _x2) {
        return _encodeObjectAsAsyncIterable.apply(this, arguments);
      }
      function _encodeObjectAsAsyncIterable() {
        _encodeObjectAsAsyncIterable = _wrapAsyncGenerator(function* (value, iterateProperties) {
          for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
            let constructor = encodedValue.constructor;
            if (constructor === ByteArray || constructor === Uint8Array) yield encodedValue;else if (isBlob(encodedValue)) {
              let reader = encodedValue.stream().getReader();
              let next;
              while (!(next = yield _awaitAsyncGenerator(reader.read())).done) {
                yield next.value;
              }
            } else if (encodedValue[Symbol.asyncIterator]) {
              var _iteratorAbruptCompletion = false;
              var _didIteratorError = false;
              var _iteratorError;
              try {
                for (var _iterator = _asyncIterator(encodedValue), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {
                  let asyncValue = _step.value;
                  {
                    restartEncoding();
                    if (asyncValue) yield* _asyncGeneratorDelegate(_asyncIterator(encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}))), _awaitAsyncGenerator);else yield encoder.encode(asyncValue);
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (_iteratorAbruptCompletion && _iterator.return != null) {
                    yield _awaitAsyncGenerator(_iterator.return());
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            } else {
              yield encodedValue;
            }
          }
        });
        return _encodeObjectAsAsyncIterable.apply(this, arguments);
      }
    }
    useBuffer(buffer) {
      // this means we are finished using our own buffer and we can write over it safely
      target = buffer;
      targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
      position = 0;
    }
    clearSharedData() {
      if (this.structures) this.structures = [];
      if (this.sharedValues) this.sharedValues = undefined;
    }
    updateSharedData() {
      let lastVersion = this.sharedVersion || 0;
      this.sharedVersion = lastVersion + 1;
      let structuresCopy = this.structures.slice(0);
      let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
      let saveResults = this.saveShared(sharedData, existingShared => (existingShared && existingShared.version || 0) == lastVersion);
      if (saveResults === false) {
        // get updated structures and try again if the update failed
        sharedData = this.getShared() || {};
        this.structures = sharedData.structures || [];
        this.sharedValues = sharedData.packedValues;
        this.sharedVersion = sharedData.version;
        this.structures.nextId = this.structures.length;
      } else {
        // restore structures
        structuresCopy.forEach((structure, i) => this.structures[i] = structure);
      }
      // saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data
      return saveResults;
    }
  }
  function writeEntityLength(length, majorValue) {
    if (length < 0x18) target[position++] = majorValue | length;else if (length < 0x100) {
      target[position++] = majorValue | 0x18;
      target[position++] = length;
    } else if (length < 0x10000) {
      target[position++] = majorValue | 0x19;
      target[position++] = length >> 8;
      target[position++] = length & 0xff;
    } else {
      target[position++] = majorValue | 0x1a;
      targetView.setUint32(position, length);
      position += 4;
    }
  }
  class SharedData {
    constructor(structures, values, version) {
      this.structures = structures;
      this.packedValues = values;
      this.version = version;
    }
  }
  function writeArrayHeader(length) {
    if (length < 0x18) target[position++] = 0x80 | length;else if (length < 0x100) {
      target[position++] = 0x98;
      target[position++] = length;
    } else if (length < 0x10000) {
      target[position++] = 0x99;
      target[position++] = length >> 8;
      target[position++] = length & 0xff;
    } else {
      target[position++] = 0x9a;
      targetView.setUint32(position, length);
      position += 4;
    }
  }
  const BlobConstructor = typeof Blob === 'undefined' ? function () {} : Blob;
  function isBlob(object) {
    if (object instanceof BlobConstructor) return true;
    let tag = object[Symbol.toStringTag];
    return tag === 'Blob' || tag === 'File';
  }
  function findRepetitiveStrings(value, packedValues) {
    switch (typeof value) {
      case 'string':
        if (value.length > 3) {
          if (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues) return;
          let packedStatus = packedValues.get(value);
          if (packedStatus) {
            if (++packedStatus.count == 2) {
              packedValues.values.push(value);
            }
          } else {
            packedValues.set(value, {
              count: 1
            });
            if (packedValues.samplingPackedValues) {
              let status = packedValues.samplingPackedValues.get(value);
              if (status) status.count++;else packedValues.samplingPackedValues.set(value, {
                count: 1
              });
            }
          }
        }
        break;
      case 'object':
        if (value) {
          if (value instanceof Array) {
            for (let i = 0, l = value.length; i < l; i++) {
              findRepetitiveStrings(value[i], packedValues);
            }
          } else {
            let includeKeys = !packedValues.encoder.useRecords;
            for (var key in value) {
              if (value.hasOwnProperty(key)) {
                if (includeKeys) findRepetitiveStrings(key, packedValues);
                findRepetitiveStrings(value[key], packedValues);
              }
            }
          }
        }
        break;
      case 'function':
        console.log(value);
    }
  }
  const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
  extensionClasses = [Date, Set, Error, RegExp, Tag, ArrayBuffer, Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == 'undefined' ? function () {} : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == 'undefined' ? function () {} : BigInt64Array, Float32Array, Float64Array, SharedData];

  //Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/
  extensions = [{
    // Date
    tag: 1,
    encode(date, encode) {
      let seconds = date.getTime() / 1000;
      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {
        // Timestamp 32
        target[position++] = 0x1a;
        targetView.setUint32(position, seconds);
        position += 4;
      } else {
        // Timestamp float64
        target[position++] = 0xfb;
        targetView.setFloat64(position, seconds);
        position += 8;
      }
    }
  }, {
    // Set
    tag: 258,
    // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
    encode(set, encode) {
      let array = Array.from(set);
      encode(array);
    }
  }, {
    // Error
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(error, encode) {
      encode([error.name, error.message]);
    }
  }, {
    // RegExp
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(regex, encode) {
      encode(['RegExp', regex.source, regex.flags]);
    }
  }, {
    // Tag
    getTag(tag) {
      return tag.tag;
    },
    encode(tag, encode) {
      encode(tag.value);
    }
  }, {
    // ArrayBuffer
    encode(arrayBuffer, encode, makeRoom) {
      writeBuffer(arrayBuffer, makeRoom);
    }
  }, {
    // Uint8Array
    getTag(typedArray) {
      if (typedArray.constructor === Uint8Array) {
        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false) return 64;
      } // else no tag
    },
    encode(typedArray, encode, makeRoom) {
      writeBuffer(typedArray, makeRoom);
    }
  }, typedArrayEncoder(68, 1), typedArrayEncoder(69, 2), typedArrayEncoder(70, 4), typedArrayEncoder(71, 8), typedArrayEncoder(72, 1), typedArrayEncoder(77, 2), typedArrayEncoder(78, 4), typedArrayEncoder(79, 8), typedArrayEncoder(85, 4), typedArrayEncoder(86, 8), {
    encode(sharedData, encode) {
      // write SharedData
      let packedValues = sharedData.packedValues || [];
      let sharedStructures = sharedData.structures || [];
      if (packedValues.values.length > 0) {
        target[position++] = 0xd8; // one-byte tag
        target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
        writeArrayHeader(4);
        let valuesArray = packedValues.values;
        encode(valuesArray);
        writeArrayHeader(0); // prefixes
        writeArrayHeader(0); // suffixes
        packedObjectMap = Object.create(sharedPackedObjectMap || null);
        for (let i = 0, l = valuesArray.length; i < l; i++) {
          packedObjectMap[valuesArray[i]] = i;
        }
      }
      if (sharedStructures) {
        targetView.setUint32(position, 0xd9dffe00);
        position += 3;
        let definitions = sharedStructures.slice(0);
        definitions.unshift(0xe000);
        definitions.push(new Tag(sharedData.version, 0x53687264));
        encode(definitions);
      } else encode(new Tag(sharedData.version, 0x53687264));
    }
  }];
  function typedArrayEncoder(tag, size) {
    if (!isLittleEndianMachine && size > 1) tag -= 4; // the big endian equivalents are 4 less
    return {
      tag: tag,
      encode: function writeExtBuffer(typedArray, encode) {
        let length = typedArray.byteLength;
        let offset = typedArray.byteOffset || 0;
        let buffer = typedArray.buffer || typedArray;
        encode(hasNodeBuffer ? Buffer$1.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
      }
    };
  }
  function writeBuffer(buffer, makeRoom) {
    let length = buffer.byteLength;
    if (length < 0x18) {
      target[position++] = 0x40 + length;
    } else if (length < 0x100) {
      target[position++] = 0x58;
      target[position++] = length;
    } else if (length < 0x10000) {
      target[position++] = 0x59;
      target[position++] = length >> 8;
      target[position++] = length & 0xff;
    } else {
      target[position++] = 0x5a;
      targetView.setUint32(position, length);
      position += 4;
    }
    if (position + length >= target.length) {
      makeRoom(position + length);
    }
    // if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,
    // must wrap it to set it.
    target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position);
    position += length;
  }
  function insertIds(serialized, idsToInsert) {
    // insert the ids that need to be referenced for structured clones
    let nextId;
    let distanceToMove = idsToInsert.length * 2;
    let lastEnd = serialized.length - distanceToMove;
    idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
    for (let id = 0; id < idsToInsert.length; id++) {
      let referee = idsToInsert[id];
      referee.id = id;
      for (let position of referee.references) {
        serialized[position++] = id >> 8;
        serialized[position] = id & 0xff;
      }
    }
    while (nextId = idsToInsert.pop()) {
      let offset = nextId.offset;
      serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
      distanceToMove -= 2;
      let position = offset + distanceToMove;
      serialized[position++] = 0xd8;
      serialized[position++] = 28; // http://cbor.schmorp.de/value-sharing
      lastEnd = offset;
    }
    return serialized;
  }
  function writeBundles(start, encode) {
    targetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1); // the offset to bundle
    let writeStrings = bundledStrings;
    bundledStrings = null;
    encode(writeStrings[0]);
    encode(writeStrings[1]);
  }
  function addExtension(extension) {
    if (extension.Class) {
      if (!extension.encode) throw new Error('Extension has no encode function');
      extensionClasses.unshift(extension.Class);
      extensions.unshift(extension);
    }
    addExtension$1(extension);
  }
  let defaultEncoder = new Encoder({
    useRecords: false
  });
  const encode = defaultEncoder.encode;
  const encodeAsIterable = defaultEncoder.encodeAsIterable;
  const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
  const {
    NEVER,
    ALWAYS,
    DECIMAL_ROUND,
    DECIMAL_FIT
  } = FLOAT32_OPTIONS;
  const REUSE_BUFFER_MODE = 512;
  const RESET_BUFFER_MODE = 1024;
  const THROW_ON_ITERABLE = 2048;

  /**
   * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer
   * If the argument is only Async Iterable, the return value will be an Async Iterable.
   * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
   * @param {options} [options] - cbor-x Encoder options
   * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
   */
  function encodeIter(objectIterator) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!objectIterator || typeof objectIterator !== 'object') {
      throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable');
    } else if (typeof objectIterator[Symbol.iterator] === 'function') {
      return encodeIterSync(objectIterator, options);
    } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {
      return encodeIterAsync(objectIterator, options);
    } else {
      throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise');
    }
  }
  function* encodeIterSync(objectIterator, options) {
    const encoder = new Encoder(options);
    for (const value of objectIterator) {
      yield encoder.encode(value);
    }
  }
  function encodeIterAsync(_x3, _x4) {
    return _encodeIterAsync.apply(this, arguments);
  }
  /**
   * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
   * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
   * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
   * @param {object} [options] - Decoder options
   * @returns {IterableIterator|Promise.<AsyncIterableIterator}
   */
  function _encodeIterAsync() {
    _encodeIterAsync = _wrapAsyncGenerator(function* (objectIterator, options) {
      const encoder = new Encoder(options);
      var _iteratorAbruptCompletion2 = false;
      var _didIteratorError2 = false;
      var _iteratorError2;
      try {
        for (var _iterator2 = _asyncIterator(objectIterator), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {
          const value = _step2.value;
          {
            yield encoder.encode(value);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {
            yield _awaitAsyncGenerator(_iterator2.return());
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    });
    return _encodeIterAsync.apply(this, arguments);
  }
  function decodeIter(bufferIterator) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!bufferIterator || typeof bufferIterator !== 'object') {
      throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise');
    }
    const decoder = new Decoder(options);
    let incomplete;
    const parser = chunk => {
      let yields;
      // if there's incomplete data from previous chunk, concatinate and try again
      if (incomplete) {
        chunk = Buffer.concat([incomplete, chunk]);
        incomplete = undefined;
      }
      try {
        yields = decoder.decodeMultiple(chunk);
      } catch (err) {
        if (err.incomplete) {
          incomplete = chunk.slice(err.lastPosition);
          yields = err.values;
        } else {
          throw err;
        }
      }
      return yields;
    };
    if (typeof bufferIterator[Symbol.iterator] === 'function') {
      return function* iter() {
        for (const value of bufferIterator) {
          yield* parser(value);
        }
      }();
    } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {
      return function () {
        var _iter = _wrapAsyncGenerator(function* () {
          var _iteratorAbruptCompletion3 = false;
          var _didIteratorError3 = false;
          var _iteratorError3;
          try {
            for (var _iterator3 = _asyncIterator(bufferIterator), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _awaitAsyncGenerator(_iterator3.next())).done; _iteratorAbruptCompletion3 = false) {
              const value = _step3.value;
              {
                yield* _asyncGeneratorDelegate(_asyncIterator(parser(value)), _awaitAsyncGenerator);
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (_iteratorAbruptCompletion3 && _iterator3.return != null) {
                yield _awaitAsyncGenerator(_iterator3.return());
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        });
        function iter() {
          return _iter.apply(this, arguments);
        }
        return iter;
      }()();
    }
  }
  exports.ALWAYS = ALWAYS;
  exports.DECIMAL_FIT = DECIMAL_FIT;
  exports.DECIMAL_ROUND = DECIMAL_ROUND;
  exports.Decoder = Decoder;
  exports.Encoder = Encoder;
  exports.FLOAT32_OPTIONS = FLOAT32_OPTIONS;
  exports.NEVER = NEVER;
  exports.REUSE_BUFFER_MODE = REUSE_BUFFER_MODE;
  exports.Tag = Tag;
  exports.addExtension = addExtension;
  exports.clearSource = clearSource;
  exports.decode = decode;
  exports.decodeIter = decodeIter;
  exports.decodeMultiple = decodeMultiple;
  exports.encode = encode;
  exports.encodeAsAsyncIterable = encodeAsAsyncIterable;
  exports.encodeAsIterable = encodeAsIterable;
  exports.encodeIter = encodeIter;
  exports.isNativeAccelerationEnabled = isNativeAccelerationEnabled;
  exports.roundFloat32 = roundFloat32;
  exports.setSizeLimits = setSizeLimits;
});

/***/ }),

/***/ 65392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
var max_js_1 = __webpack_require__(21026);
Object.defineProperty(exports, "MAX", ({
  enumerable: true,
  get: function () {
    return max_js_1.default;
  }
}));
var nil_js_1 = __webpack_require__(82459);
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return nil_js_1.default;
  }
}));
var parse_js_1 = __webpack_require__(4243);
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return parse_js_1.default;
  }
}));
var stringify_js_1 = __webpack_require__(53149);
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return stringify_js_1.default;
  }
}));
var v1_js_1 = __webpack_require__(96431);
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return v1_js_1.default;
  }
}));
var v1ToV6_js_1 = __webpack_require__(92234);
Object.defineProperty(exports, "v1ToV6", ({
  enumerable: true,
  get: function () {
    return v1ToV6_js_1.default;
  }
}));
var v3_js_1 = __webpack_require__(50481);
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return v3_js_1.default;
  }
}));
var v4_js_1 = __webpack_require__(20356);
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return v4_js_1.default;
  }
}));
var v5_js_1 = __webpack_require__(26027);
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return v5_js_1.default;
  }
}));
var v6_js_1 = __webpack_require__(18926);
Object.defineProperty(exports, "v6", ({
  enumerable: true,
  get: function () {
    return v6_js_1.default;
  }
}));
var v6ToV1_js_1 = __webpack_require__(62022);
Object.defineProperty(exports, "v6ToV1", ({
  enumerable: true,
  get: function () {
    return v6ToV1_js_1.default;
  }
}));
var v7_js_1 = __webpack_require__(68237);
Object.defineProperty(exports, "v7", ({
  enumerable: true,
  get: function () {
    return v7_js_1.default;
  }
}));
var validate_js_1 = __webpack_require__(94184);
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return validate_js_1.default;
  }
}));
var version_js_1 = __webpack_require__(36732);
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return version_js_1.default;
  }
}));

/***/ }),

/***/ 21026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';

/***/ }),

/***/ 49448:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(61740);
__webpack_require__(75044);
__webpack_require__(52568);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 0xff;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 0x80 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 0xff) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports["default"] = md5;

/***/ }),

/***/ 88045:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports["default"] = {
  randomUUID
};

/***/ }),

/***/ 82459:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = '00000000-0000-0000-0000-000000000000';

/***/ }),

/***/ 4243:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(52568);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const validate_js_1 = __webpack_require__(94184);
function parse(uuid) {
  if (!(0, validate_js_1.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff, v / 0x100000000 & 0xff, v >>> 24 & 0xff, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff);
}
exports["default"] = parse;

/***/ }),

/***/ 52071:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

/***/ }),

/***/ 41357:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

/***/ }),

/***/ 14267:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(61740);
__webpack_require__(75044);
__webpack_require__(52568);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 0x80;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
exports["default"] = sha1;

/***/ }),

/***/ 53149:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.unsafeStringify = unsafeStringify;
const validate_js_1 = __webpack_require__(94184);
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const uuid = unsafeStringify(arr, offset);
  if (!(0, validate_js_1.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
exports["default"] = stringify;

/***/ }),

/***/ 96431:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.updateV1State = updateV1State;
const rng_js_1 = __webpack_require__(41357);
const stringify_js_1 = __webpack_require__(53149);
const _state = {};
function v1(options, buf, offset) {
  var _options$_v, _options;
  let bytes;
  const isV6 = (_options$_v = (_options = options) === null || _options === void 0 ? void 0 : _options._v6) !== null && _options$_v !== void 0 ? _options$_v : false;
  if (options) {
    const optionsKeys = Object.keys(options);
    if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {
      options = undefined;
    }
  }
  if (options) {
    var _ref, _options$random, _options$rng, _options2;
    bytes = v1Bytes((_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = (_options2 = options).rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(_options2)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
  } else {
    const now = Date.now();
    const rnds = (0, rng_js_1.default)();
    updateV1State(_state, now, rnds);
    bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);
  }
  return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV1State(state, now, rnds) {
  var _state$msecs, _state$nsecs;
  (_state$msecs = state.msecs) !== null && _state$msecs !== void 0 ? _state$msecs : state.msecs = -Infinity;
  (_state$nsecs = state.nsecs) !== null && _state$nsecs !== void 0 ? _state$nsecs : state.nsecs = 0;
  if (now === state.msecs) {
    state.nsecs++;
    if (state.nsecs >= 10000) {
      state.node = undefined;
      state.nsecs = 0;
    }
  } else if (now > state.msecs) {
    state.nsecs = 0;
  } else if (now < state.msecs) {
    state.node = undefined;
  }
  if (!state.node) {
    state.node = rnds.slice(10, 16);
    state.node[0] |= 0x01;
    state.clockseq = (rnds[8] << 8 | rnds[9]) & 0x3fff;
  }
  state.msecs = now;
  return state;
}
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf) {
  var _msecs, _nsecs, _clockseq, _node;
  let offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
  }
  (_msecs = msecs) !== null && _msecs !== void 0 ? _msecs : msecs = Date.now();
  (_nsecs = nsecs) !== null && _nsecs !== void 0 ? _nsecs : nsecs = 0;
  (_clockseq = clockseq) !== null && _clockseq !== void 0 ? _clockseq : clockseq = (rnds[8] << 8 | rnds[9]) & 0x3fff;
  (_node = node) !== null && _node !== void 0 ? _node : node = rnds.slice(10, 16);
  msecs += 12219292800000;
  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  buf[offset++] = tl >>> 24 & 0xff;
  buf[offset++] = tl >>> 16 & 0xff;
  buf[offset++] = tl >>> 8 & 0xff;
  buf[offset++] = tl & 0xff;
  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  buf[offset++] = tmh >>> 8 & 0xff;
  buf[offset++] = tmh & 0xff;
  buf[offset++] = tmh >>> 24 & 0xf | 0x10;
  buf[offset++] = tmh >>> 16 & 0xff;
  buf[offset++] = clockseq >>> 8 | 0x80;
  buf[offset++] = clockseq & 0xff;
  for (let n = 0; n < 6; ++n) {
    buf[offset++] = node[n];
  }
  return buf;
}
exports["default"] = v1;

/***/ }),

/***/ 92234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(52568);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = v1ToV6;
const parse_js_1 = __webpack_require__(4243);
const stringify_js_1 = __webpack_require__(53149);
function v1ToV6(uuid) {
  const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
  const v6Bytes = _v1ToV6(v1Bytes);
  return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
}
function _v1ToV6(v1Bytes) {
  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}

/***/ }),

/***/ 50481:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
const md5_js_1 = __webpack_require__(49448);
const v35_js_1 = __webpack_require__(15042);
var v35_js_2 = __webpack_require__(15042);
Object.defineProperty(exports, "DNS", ({
  enumerable: true,
  get: function () {
    return v35_js_2.DNS;
  }
}));
Object.defineProperty(exports, "URL", ({
  enumerable: true,
  get: function () {
    return v35_js_2.URL;
  }
}));
function v3(value, namespace, buf, offset) {
  return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);
}
v3.DNS = v35_js_1.DNS;
v3.URL = v35_js_1.URL;
exports["default"] = v3;

/***/ }),

/***/ 15042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
exports.stringToBytes = stringToBytes;
exports["default"] = v35;
const parse_js_1 = __webpack_require__(4243);
const stringify_js_1 = __webpack_require__(53149);
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
exports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(version, hash, value, namespace, buf, offset) {
  var _namespace;
  const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;
  if (typeof namespace === 'string') {
    namespace = (0, parse_js_1.default)(namespace);
  }
  if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
    throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 0x0f | version;
  bytes[8] = bytes[8] & 0x3f | 0x80;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(bytes);
}

/***/ }),

/***/ 20356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const native_js_1 = __webpack_require__(88045);
const rng_js_1 = __webpack_require__(41357);
const stringify_js_1 = __webpack_require__(53149);
function v4(options, buf, offset) {
  var _ref, _options$random, _options$rng, _options;
  if (native_js_1.default.randomUUID && !buf && !options) {
    return native_js_1.default.randomUUID();
  }
  options = options || {};
  const rnds = (_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = (_options = options).rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(_options)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1.default)();
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(rnds);
}
exports["default"] = v4;

/***/ }),

/***/ 26027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
const sha1_js_1 = __webpack_require__(14267);
const v35_js_1 = __webpack_require__(15042);
var v35_js_2 = __webpack_require__(15042);
Object.defineProperty(exports, "DNS", ({
  enumerable: true,
  get: function () {
    return v35_js_2.DNS;
  }
}));
Object.defineProperty(exports, "URL", ({
  enumerable: true,
  get: function () {
    return v35_js_2.URL;
  }
}));
function v5(value, namespace, buf, offset) {
  return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);
}
v5.DNS = v35_js_1.DNS;
v5.URL = v35_js_1.URL;
exports["default"] = v5;

/***/ }),

/***/ 18926:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const stringify_js_1 = __webpack_require__(53149);
const v1_js_1 = __webpack_require__(96431);
const v1ToV6_js_1 = __webpack_require__(92234);
function v6(options, buf, offset) {
  var _options, _offset;
  (_options = options) !== null && _options !== void 0 ? _options : options = {};
  (_offset = offset) !== null && _offset !== void 0 ? _offset : offset = 0;
  let bytes = (0, v1_js_1.default)(_objectSpread(_objectSpread({}, options), {}, {
    _v6: true
  }), new Uint8Array(16));
  bytes = (0, v1ToV6_js_1.default)(bytes);
  if (buf) {
    for (let i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v6;

/***/ }),

/***/ 62022:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(52568);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = v6ToV1;
const parse_js_1 = __webpack_require__(4243);
const stringify_js_1 = __webpack_require__(53149);
function v6ToV1(uuid) {
  const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
  const v1Bytes = _v6ToV1(v6Bytes);
  return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
}
function _v6ToV1(v6Bytes) {
  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}

/***/ }),

/***/ 68237:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(54743);
__webpack_require__(11745);
__webpack_require__(21489);
__webpack_require__(75044);
__webpack_require__(28845);
__webpack_require__(373);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.updateV7State = updateV7State;
const rng_js_1 = __webpack_require__(41357);
const stringify_js_1 = __webpack_require__(53149);
const _state = {};
function v7(options, buf, offset) {
  let bytes;
  if (options) {
    var _ref, _options$random, _options$rng;
    bytes = v7Bytes((_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = options.rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(options)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
  } else {
    const now = Date.now();
    const rnds = (0, rng_js_1.default)();
    updateV7State(_state, now, rnds);
    bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
  }
  return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV7State(state, now, rnds) {
  var _state$msecs, _state$seq;
  (_state$msecs = state.msecs) !== null && _state$msecs !== void 0 ? _state$msecs : state.msecs = -Infinity;
  (_state$seq = state.seq) !== null && _state$seq !== void 0 ? _state$seq : state.seq = 0;
  if (now > state.msecs) {
    state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    state.msecs = now;
  } else {
    state.seq = state.seq + 1 | 0;
    if (state.seq === 0) {
      state.msecs++;
    }
  }
  return state;
}
function v7Bytes(rnds, msecs, seq, buf) {
  var _msecs, _seq;
  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
  }
  (_msecs = msecs) !== null && _msecs !== void 0 ? _msecs : msecs = Date.now();
  (_seq = seq) !== null && _seq !== void 0 ? _seq : seq = rnds[6] * 0x7f << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
  buf[offset++] = msecs / 0x10000000000 & 0xff;
  buf[offset++] = msecs / 0x100000000 & 0xff;
  buf[offset++] = msecs / 0x1000000 & 0xff;
  buf[offset++] = msecs / 0x10000 & 0xff;
  buf[offset++] = msecs / 0x100 & 0xff;
  buf[offset++] = msecs & 0xff;
  buf[offset++] = 0x70 | seq >>> 28 & 0x0f;
  buf[offset++] = seq >>> 20 & 0xff;
  buf[offset++] = 0x80 | seq >>> 14 & 0x3f;
  buf[offset++] = seq >>> 6 & 0xff;
  buf[offset++] = seq << 2 & 0xff | rnds[10] & 0x03;
  buf[offset++] = rnds[11];
  buf[offset++] = rnds[12];
  buf[offset++] = rnds[13];
  buf[offset++] = rnds[14];
  buf[offset++] = rnds[15];
  return buf;
}
exports["default"] = v7;

/***/ }),

/***/ 94184:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(27495);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const regex_js_1 = __webpack_require__(52071);
function validate(uuid) {
  return typeof uuid === 'string' && regex_js_1.default.test(uuid);
}
exports["default"] = validate;

/***/ }),

/***/ 36732:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const validate_js_1 = __webpack_require__(94184);
function version(uuid) {
  if (!(0, validate_js_1.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  return parseInt(uuid.slice(14, 15), 16);
}
exports["default"] = version;

/***/ }),

/***/ 25477:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(23792);
__webpack_require__(26099);
__webpack_require__(3362);
__webpack_require__(96167);
__webpack_require__(47764);
var call = __webpack_require__(69565);
var isCallable = __webpack_require__(94901);
var path = __webpack_require__(19167);

var Promise = path.Promise;
var $allSettled = Promise.allSettled;

module.exports = function allSettled(iterable) {
  return call($allSettled, isCallable(this) ? this : Promise, iterable);
};


/***/ }),

/***/ 79306:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(94901);
var tryToString = __webpack_require__(16823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 35548:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isConstructor = __webpack_require__(33517);
var tryToString = __webpack_require__(16823);

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ 73506:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPossiblePrototype = __webpack_require__(13925);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 6469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(78227);
var create = __webpack_require__(2360);
var defineProperty = (__webpack_require__(24913).f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] === undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 57829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(68183).charAt);

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ 90679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(1625);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ }),

/***/ 28551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(20034);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 77811:
/***/ ((module) => {

"use strict";

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ 15652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__(79039);

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ 94644:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(77811);
var DESCRIPTORS = __webpack_require__(43724);
var globalThis = __webpack_require__(22195);
var isCallable = __webpack_require__(94901);
var isObject = __webpack_require__(20034);
var hasOwn = __webpack_require__(39297);
var classof = __webpack_require__(36955);
var tryToString = __webpack_require__(16823);
var createNonEnumerableProperty = __webpack_require__(66699);
var defineBuiltIn = __webpack_require__(36840);
var defineBuiltInAccessor = __webpack_require__(62106);
var isPrototypeOf = __webpack_require__(1625);
var getPrototypeOf = __webpack_require__(42787);
var setPrototypeOf = __webpack_require__(52967);
var wellKnownSymbol = __webpack_require__(78227);
var uid = __webpack_require__(33392);
var InternalStateModule = __webpack_require__(91181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = globalThis.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = globalThis.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = globalThis.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf(it);
  if (!isObject(proto)) return;
  var state = getInternalState(proto);
  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw new TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw new TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = globalThis[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = globalThis[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = globalThis[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = globalThis[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = globalThis[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw new TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (globalThis[NAME]) setPrototypeOf(globalThis[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (globalThis[NAME]) setPrototypeOf(globalThis[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
    configurable: true,
    get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });
  for (NAME in TypedArrayConstructorsList) if (globalThis[NAME]) {
    createNonEnumerableProperty(globalThis[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 66346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var uncurryThis = __webpack_require__(79504);
var DESCRIPTORS = __webpack_require__(43724);
var NATIVE_ARRAY_BUFFER = __webpack_require__(77811);
var FunctionName = __webpack_require__(10350);
var createNonEnumerableProperty = __webpack_require__(66699);
var defineBuiltInAccessor = __webpack_require__(62106);
var defineBuiltIns = __webpack_require__(56279);
var fails = __webpack_require__(79039);
var anInstance = __webpack_require__(90679);
var toIntegerOrInfinity = __webpack_require__(91291);
var toLength = __webpack_require__(18014);
var toIndex = __webpack_require__(57696);
var fround = __webpack_require__(15617);
var IEEE754 = __webpack_require__(88490);
var getPrototypeOf = __webpack_require__(42787);
var setPrototypeOf = __webpack_require__(52967);
var arrayFill = __webpack_require__(84373);
var arraySlice = __webpack_require__(67680);
var inheritIfRequired = __webpack_require__(23167);
var copyConstructorProperties = __webpack_require__(77740);
var setToStringTag = __webpack_require__(10687);
var InternalStateModule = __webpack_require__(91181);

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
var setInternalState = InternalStateModule.set;
var NativeArrayBuffer = globalThis[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
var $DataView = globalThis[DATA_VIEW];
var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var Array = globalThis.Array;
var RangeError = globalThis.RangeError;
var fill = uncurryThis(arrayFill);
var reverse = uncurryThis([].reverse);

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(fround(number), 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key, getInternalState) {
  defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
    configurable: true,
    get: function () {
      return getInternalState(this)[key];
    }
  });
};

var get = function (view, count, index, isLittleEndian) {
  var store = getInternalDataViewState(view);
  var intIndex = toIndex(index);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store.byteLength) throw new RangeError(WRONG_INDEX);
  var bytes = store.bytes;
  var start = intIndex + store.byteOffset;
  var pack = arraySlice(bytes, start, start + count);
  return boolIsLittleEndian ? pack : reverse(pack);
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var store = getInternalDataViewState(view);
  var intIndex = toIndex(index);
  var pack = conversion(+value);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store.byteLength) throw new RangeError(WRONG_INDEX);
  var bytes = store.bytes;
  var start = intIndex + store.byteOffset;
  for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, ArrayBufferPrototype);
    var byteLength = toIndex(length);
    setInternalState(this, {
      type: ARRAY_BUFFER,
      bytes: fill(Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) {
      this.byteLength = byteLength;
      this.detached = false;
    }
  };

  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, DataViewPrototype);
    anInstance(buffer, ArrayBufferPrototype);
    var bufferState = getInternalArrayBufferState(buffer);
    var bufferLength = bufferState.byteLength;
    var offset = toIntegerOrInfinity(byteOffset);
    if (offset < 0 || offset > bufferLength) throw new RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw new RangeError(WRONG_LENGTH);
    setInternalState(this, {
      type: DATA_VIEW,
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset,
      bytes: bufferState.bytes
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  DataViewPrototype = $DataView[PROTOTYPE];

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength', getInternalArrayBufferState);
    addGetter($DataView, 'buffer', getInternalDataViewState);
    addGetter($DataView, 'byteLength', getInternalDataViewState);
    addGetter($DataView, 'byteOffset', getInternalDataViewState);
  }

  defineBuiltIns(DataViewPrototype, {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
    }
  });
} else {
  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
  /* eslint-disable no-new, sonarjs/inconsistent-function-call -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
  })) {
    /* eslint-enable no-new, sonarjs/inconsistent-function-call -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, ArrayBufferPrototype);
      return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
    };

    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;

    ArrayBufferPrototype.constructor = $ArrayBuffer;

    copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
    createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf(DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),

/***/ 57029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toObject = __webpack_require__(48981);
var toAbsoluteIndex = __webpack_require__(35610);
var lengthOfArrayLike = __webpack_require__(26198);
var deletePropertyOrThrow = __webpack_require__(84606);

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = lengthOfArrayLike(O);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else deletePropertyOrThrow(O, to);
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ 84373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toObject = __webpack_require__(48981);
var toAbsoluteIndex = __webpack_require__(35610);
var lengthOfArrayLike = __webpack_require__(26198);

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = lengthOfArrayLike(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ 90235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $forEach = (__webpack_require__(59213).forEach);
var arrayMethodIsStrict = __webpack_require__(34598);

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ 35370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var lengthOfArrayLike = __webpack_require__(26198);

module.exports = function (Constructor, list, $length) {
  var index = 0;
  var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
  var result = new Constructor(length);
  while (length > index) result[index] = list[index++];
  return result;
};


/***/ }),

/***/ 97916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(76080);
var call = __webpack_require__(69565);
var toObject = __webpack_require__(48981);
var callWithSafeIterationClosing = __webpack_require__(96319);
var isArrayIteratorMethod = __webpack_require__(44209);
var isConstructor = __webpack_require__(33517);
var lengthOfArrayLike = __webpack_require__(26198);
var createProperty = __webpack_require__(97040);
var getIterator = __webpack_require__(70081);
var getIteratorMethod = __webpack_require__(50851);

var $Array = Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
    result = IS_CONSTRUCTOR ? new this() : [];
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    for (;!(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ 19617:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(25397);
var toAbsoluteIndex = __webpack_require__(35610);
var lengthOfArrayLike = __webpack_require__(26198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 59213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(76080);
var uncurryThis = __webpack_require__(79504);
var IndexedObject = __webpack_require__(47055);
var toObject = __webpack_require__(48981);
var lengthOfArrayLike = __webpack_require__(26198);
var arraySpeciesCreate = __webpack_require__(1469);

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(self);
    var boundFunction = bind(callbackfn, that);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ 8379:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-array-prototype-lastindexof -- safe */
var apply = __webpack_require__(18745);
var toIndexedObject = __webpack_require__(25397);
var toIntegerOrInfinity = __webpack_require__(91291);
var lengthOfArrayLike = __webpack_require__(26198);
var arrayMethodIsStrict = __webpack_require__(34598);

var min = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = lengthOfArrayLike(O);
  if (length === 0) return -1;
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf;


/***/ }),

/***/ 70597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var wellKnownSymbol = __webpack_require__(78227);
var V8_VERSION = __webpack_require__(39519);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ 34598:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ 80926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(79306);
var toObject = __webpack_require__(48981);
var IndexedObject = __webpack_require__(47055);
var lengthOfArrayLike = __webpack_require__(26198);

var $TypeError = TypeError;

var REDUCE_EMPTY = 'Reduce of empty array with no initial value';

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    aCallable(callbackfn);
    if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw new $TypeError(REDUCE_EMPTY);
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ 67680:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);

module.exports = uncurryThis([].slice);


/***/ }),

/***/ 74488:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySlice = __webpack_require__(67680);

var floor = Math.floor;

var sort = function (array, comparefn) {
  var length = array.length;

  if (length < 8) {
    // insertion sort
    var i = 1;
    var element, j;

    while (i < length) {
      j = i;
      element = array[i];
      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }
      if (j !== i++) array[j] = element;
    }
  } else {
    // merge sort
    var middle = floor(length / 2);
    var left = sort(arraySlice(array, 0, middle), comparefn);
    var right = sort(arraySlice(array, middle), comparefn);
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;

    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = (lindex < llength && rindex < rlength)
        ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
        : lindex < llength ? left[lindex++] : right[rindex++];
    }
  }

  return array;
};

module.exports = sort;


/***/ }),

/***/ 87433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isArray = __webpack_require__(34376);
var isConstructor = __webpack_require__(33517);
var isObject = __webpack_require__(20034);
var wellKnownSymbol = __webpack_require__(78227);

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ 1469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySpeciesConstructor = __webpack_require__(87433);

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ 96319:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(28551);
var iteratorClose = __webpack_require__(9539);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ 84428:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(78227);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ 44576:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 36955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(92140);
var isCallable = __webpack_require__(94901);
var classofRaw = __webpack_require__(44576);
var wellKnownSymbol = __webpack_require__(78227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 86938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var create = __webpack_require__(2360);
var defineBuiltInAccessor = __webpack_require__(62106);
var defineBuiltIns = __webpack_require__(56279);
var bind = __webpack_require__(76080);
var anInstance = __webpack_require__(90679);
var isNullOrUndefined = __webpack_require__(64117);
var iterate = __webpack_require__(72652);
var defineIterator = __webpack_require__(51088);
var createIterResultObject = __webpack_require__(62529);
var setSpecies = __webpack_require__(87633);
var DESCRIPTORS = __webpack_require__(43724);
var fastKey = (__webpack_require__(3451).fastKey);
var InternalStateModule = __webpack_require__(91181);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: null,
        last: null,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: null,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key === key) return entry;
      }
    };

    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = null;
          entry = entry.next;
        }
        state.first = state.last = null;
        state.index = create(null);
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first === entry) state.first = next;
          if (state.last === entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: null
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = null;
        return createIterResultObject(undefined, true);
      }
      // return step by kind
      if (kind === 'keys') return createIterResultObject(entry.key, false);
      if (kind === 'values') return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ 91625:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var defineBuiltIns = __webpack_require__(56279);
var getWeakData = (__webpack_require__(3451).getWeakData);
var anInstance = __webpack_require__(90679);
var anObject = __webpack_require__(28551);
var isNullOrUndefined = __webpack_require__(64117);
var isObject = __webpack_require__(20034);
var iterate = __webpack_require__(72652);
var ArrayIterationModule = __webpack_require__(59213);
var hasOwn = __webpack_require__(39297);
var InternalStateModule = __webpack_require__(91181);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis([].splice);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: null
      });
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    defineBuiltIns(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          if (data) return data[state.id];
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return Constructor;
  }
};


/***/ }),

/***/ 16468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);
var uncurryThis = __webpack_require__(79504);
var isForced = __webpack_require__(92796);
var defineBuiltIn = __webpack_require__(36840);
var InternalMetadataModule = __webpack_require__(3451);
var iterate = __webpack_require__(72652);
var anInstance = __webpack_require__(90679);
var isCallable = __webpack_require__(94901);
var isNullOrUndefined = __webpack_require__(64117);
var isObject = __webpack_require__(20034);
var fails = __webpack_require__(79039);
var checkCorrectnessOfIteration = __webpack_require__(84428);
var setToStringTag = __webpack_require__(10687);
var inheritIfRequired = __webpack_require__(23167);

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = globalThis[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
    defineBuiltIn(NativePrototype, KEY,
      KEY === 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY === 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ 77740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(39297);
var ownKeys = __webpack_require__(35031);
var getOwnPropertyDescriptorModule = __webpack_require__(77347);
var definePropertyModule = __webpack_require__(24913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 41436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(78227);

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ 12211:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 62529:
/***/ ((module) => {

"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ 66699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var definePropertyModule = __webpack_require__(24913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 97040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var definePropertyModule = __webpack_require__(24913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),

/***/ 53640:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(28551);
var ordinaryToPrimitive = __webpack_require__(84270);

var $TypeError = TypeError;

// `Date.prototype[@@toPrimitive](hint)` method implementation
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
module.exports = function (hint) {
  anObject(this);
  if (hint === 'string' || hint === 'default') hint = 'string';
  else if (hint !== 'number') throw new $TypeError('Incorrect hint');
  return ordinaryToPrimitive(this, hint);
};


/***/ }),

/***/ 62106:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var makeBuiltIn = __webpack_require__(50283);
var defineProperty = __webpack_require__(24913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 36840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(94901);
var definePropertyModule = __webpack_require__(24913);
var makeBuiltIn = __webpack_require__(50283);
var defineGlobalProperty = __webpack_require__(39433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 56279:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineBuiltIn = __webpack_require__(36840);

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 39433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ 84606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var tryToString = __webpack_require__(16823);

var $TypeError = TypeError;

module.exports = function (O, P) {
  if (!delete O[P]) throw new $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
};


/***/ }),

/***/ 43724:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var isObject = __webpack_require__(20034);

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 96837:
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 67400:
/***/ ((module) => {

"use strict";

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 79296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__(4055);

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ 88727:
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 13709:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(82839);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 13763:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var UA = __webpack_require__(82839);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 44265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(82839);

module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';


/***/ }),

/***/ 89544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(82839);

// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),

/***/ 16193:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ENVIRONMENT = __webpack_require__(84215);

module.exports = ENVIRONMENT === 'NODE';


/***/ }),

/***/ 7860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(82839);

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ 82839:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ 39519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var userAgent = __webpack_require__(82839);

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 3607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(82839);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 84215:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global Bun, Deno -- detection */
var globalThis = __webpack_require__(22195);
var userAgent = __webpack_require__(82839);
var classof = __webpack_require__(44576);

var userAgentStartsWith = function (string) {
  return userAgent.slice(0, string.length) === string;
};

module.exports = (function () {
  if (userAgentStartsWith('Bun/')) return 'BUN';
  if (userAgentStartsWith('Cloudflare-Workers')) return 'CLOUDFLARE';
  if (userAgentStartsWith('Deno/')) return 'DENO';
  if (userAgentStartsWith('Node.js/')) return 'NODE';
  if (globalThis.Bun && typeof Bun.version == 'string') return 'BUN';
  if (globalThis.Deno && typeof Deno.version == 'object') return 'DENO';
  if (classof(globalThis.process) === 'process') return 'NODE';
  if (globalThis.window && globalThis.document) return 'BROWSER';
  return 'REST';
})();


/***/ }),

/***/ 46518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var getOwnPropertyDescriptor = (__webpack_require__(77347).f);
var createNonEnumerableProperty = __webpack_require__(66699);
var defineBuiltIn = __webpack_require__(36840);
var defineGlobalProperty = __webpack_require__(39433);
var copyConstructorProperties = __webpack_require__(77740);
var isForced = __webpack_require__(92796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 79039:
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 89228:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(27495);
var call = __webpack_require__(69565);
var defineBuiltIn = __webpack_require__(36840);
var regexpExec = __webpack_require__(57323);
var fails = __webpack_require__(79039);
var wellKnownSymbol = __webpack_require__(78227);
var createNonEnumerableProperty = __webpack_require__(66699);

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegExp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) !== 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
        }
        return { done: true, value: call(nativeMethod, str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ 70259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isArray = __webpack_require__(34376);
var lengthOfArrayLike = __webpack_require__(26198);
var doesNotExceedSafeInteger = __webpack_require__(96837);
var bind = __webpack_require__(76080);

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg) : false;
  var element, elementLen;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        elementLen = lengthOfArrayLike(element);
        targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        doesNotExceedSafeInteger(targetIndex + 1);
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ 92744:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ 18745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(40616);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 76080:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(27476);
var aCallable = __webpack_require__(79306);
var NATIVE_BIND = __webpack_require__(40616);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 40616:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 30566:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var aCallable = __webpack_require__(79306);
var isObject = __webpack_require__(20034);
var hasOwn = __webpack_require__(39297);
var arraySlice = __webpack_require__(67680);
var NATIVE_BIND = __webpack_require__(40616);

var $Function = Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    var list = [];
    var i = 0;
    for (; i < argsLength; i++) list[i] = 'a[' + i + ']';
    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};


/***/ }),

/***/ 69565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(40616);

var call = Function.prototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 10350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var hasOwn = __webpack_require__(39297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 46706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var aCallable = __webpack_require__(79306);

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ 27476:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(44576);
var uncurryThis = __webpack_require__(79504);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ 79504:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(40616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 97751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var isCallable = __webpack_require__(94901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ 50851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(36955);
var getMethod = __webpack_require__(55966);
var isNullOrUndefined = __webpack_require__(64117);
var Iterators = __webpack_require__(26269);
var wellKnownSymbol = __webpack_require__(78227);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ 70081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(69565);
var aCallable = __webpack_require__(79306);
var anObject = __webpack_require__(28551);
var tryToString = __webpack_require__(16823);
var getIteratorMethod = __webpack_require__(50851);

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw new $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ 66933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var isArray = __webpack_require__(34376);
var isCallable = __webpack_require__(94901);
var classof = __webpack_require__(44576);
var toString = __webpack_require__(655);

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ 55966:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(79306);
var isNullOrUndefined = __webpack_require__(64117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 2478:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var toObject = __webpack_require__(48981);

var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
// eslint-disable-next-line redos/no-vulnerable -- safe
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice(str, 0, position);
      case "'": return stringSlice(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ 22195:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 39297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var toObject = __webpack_require__(48981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 30421:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 90757:
/***/ ((module) => {

"use strict";

module.exports = function (a, b) {
  try {
    // eslint-disable-next-line no-console -- safe
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ 20397:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(97751);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 35917:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var fails = __webpack_require__(79039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 88490:
/***/ ((module) => {

"use strict";

// IEEE754 conversions based on https://github.com/feross/ieee754
var $Array = Array;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = $Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number !== number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number !== number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    c = pow(2, -exponent);
    if (number * c < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent += eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer[index - 1] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer[index--];
    nBits -= 8;
  }
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa += pow(2, mantissaLength);
    exponent -= eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),

/***/ 47055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var fails = __webpack_require__(79039);
var classof = __webpack_require__(44576);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 23167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(94901);
var isObject = __webpack_require__(20034);
var setPrototypeOf = __webpack_require__(52967);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ 33706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var isCallable = __webpack_require__(94901);
var store = __webpack_require__(77629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 3451:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var uncurryThis = __webpack_require__(79504);
var hiddenKeys = __webpack_require__(30421);
var isObject = __webpack_require__(20034);
var hasOwn = __webpack_require__(39297);
var defineProperty = (__webpack_require__(24913).f);
var getOwnPropertyNamesModule = __webpack_require__(38480);
var getOwnPropertyNamesExternalModule = __webpack_require__(10298);
var isExtensible = __webpack_require__(34124);
var uid = __webpack_require__(33392);
var FREEZING = __webpack_require__(92744);

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ 91181:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(58622);
var globalThis = __webpack_require__(22195);
var isObject = __webpack_require__(20034);
var createNonEnumerableProperty = __webpack_require__(66699);
var hasOwn = __webpack_require__(39297);
var shared = __webpack_require__(77629);
var sharedKey = __webpack_require__(66119);
var hiddenKeys = __webpack_require__(30421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 44209:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(78227);
var Iterators = __webpack_require__(26269);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 34376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(44576);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 18727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(36955);

module.exports = function (it) {
  var klass = classof(it);
  return klass === 'BigInt64Array' || klass === 'BigUint64Array';
};


/***/ }),

/***/ 94901:
/***/ ((module) => {

"use strict";

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 33517:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var fails = __webpack_require__(79039);
var isCallable = __webpack_require__(94901);
var classof = __webpack_require__(36955);
var getBuiltIn = __webpack_require__(97751);
var inspectSource = __webpack_require__(33706);

var noop = function () { /* empty */ };
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, [], argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ 92796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var isCallable = __webpack_require__(94901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 2087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(20034);

var floor = Math.floor;

// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es/no-number-isinteger -- safe
module.exports = Number.isInteger || function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ 64117:
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 20034:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(94901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 13925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(20034);

module.exports = function (argument) {
  return isObject(argument) || argument === null;
};


/***/ }),

/***/ 96395:
/***/ ((module) => {

"use strict";

module.exports = false;


/***/ }),

/***/ 60788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(20034);
var classof = __webpack_require__(44576);
var wellKnownSymbol = __webpack_require__(78227);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
};


/***/ }),

/***/ 10757:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(97751);
var isCallable = __webpack_require__(94901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 72652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(76080);
var call = __webpack_require__(69565);
var anObject = __webpack_require__(28551);
var tryToString = __webpack_require__(16823);
var isArrayIteratorMethod = __webpack_require__(44209);
var lengthOfArrayLike = __webpack_require__(26198);
var isPrototypeOf = __webpack_require__(1625);
var getIterator = __webpack_require__(70081);
var getIteratorMethod = __webpack_require__(50851);
var iteratorClose = __webpack_require__(9539);

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ 9539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(69565);
var anObject = __webpack_require__(28551);
var getMethod = __webpack_require__(55966);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ 33994:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(57657).IteratorPrototype);
var create = __webpack_require__(2360);
var createPropertyDescriptor = __webpack_require__(6980);
var setToStringTag = __webpack_require__(10687);
var Iterators = __webpack_require__(26269);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 51088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var call = __webpack_require__(69565);
var IS_PURE = __webpack_require__(96395);
var FunctionName = __webpack_require__(10350);
var isCallable = __webpack_require__(94901);
var createIteratorConstructor = __webpack_require__(33994);
var getPrototypeOf = __webpack_require__(42787);
var setPrototypeOf = __webpack_require__(52967);
var setToStringTag = __webpack_require__(10687);
var createNonEnumerableProperty = __webpack_require__(66699);
var defineBuiltIn = __webpack_require__(36840);
var wellKnownSymbol = __webpack_require__(78227);
var Iterators = __webpack_require__(26269);
var IteratorsCore = __webpack_require__(57657);

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    }

    return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ 57657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var isCallable = __webpack_require__(94901);
var isObject = __webpack_require__(20034);
var create = __webpack_require__(2360);
var getPrototypeOf = __webpack_require__(42787);
var defineBuiltIn = __webpack_require__(36840);
var wellKnownSymbol = __webpack_require__(78227);
var IS_PURE = __webpack_require__(96395);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 26269:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 26198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(18014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 50283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var fails = __webpack_require__(79039);
var isCallable = __webpack_require__(94901);
var hasOwn = __webpack_require__(39297);
var DESCRIPTORS = __webpack_require__(43724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(10350).CONFIGURABLE);
var inspectSource = __webpack_require__(33706);
var InternalStateModule = __webpack_require__(91181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 33164:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var sign = __webpack_require__(77782);
var roundTiesToEven = __webpack_require__(53602);

var abs = Math.abs;

var EPSILON = 2.220446049250313e-16; // Number.EPSILON

module.exports = function (x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
  var n = +x;
  var absolute = abs(n);
  var s = sign(n);
  if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
  var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
  var result = a - (a - absolute);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
  return s * result;
};


/***/ }),

/***/ 15617:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var floatRound = __webpack_require__(33164);

var FLOAT32_EPSILON = 1.1920928955078125e-7; // 2 ** -23;
var FLOAT32_MAX_VALUE = 3.4028234663852886e+38; // 2 ** 128 - 2 ** 104
var FLOAT32_MIN_VALUE = 1.1754943508222875e-38; // 2 ** -126;

// `Math.fround` method implementation
// https://tc39.es/ecma262/#sec-math.fround
// eslint-disable-next-line es/no-math-fround -- safe
module.exports = Math.fround || function fround(x) {
  return floatRound(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
};


/***/ }),

/***/ 53602:
/***/ ((module) => {

"use strict";

var EPSILON = 2.220446049250313e-16; // Number.EPSILON
var INVERSE_EPSILON = 1 / EPSILON;

module.exports = function (n) {
  return n + INVERSE_EPSILON - INVERSE_EPSILON;
};


/***/ }),

/***/ 77782:
/***/ ((module) => {

"use strict";

// `Math.sign` method implementation
// https://tc39.es/ecma262/#sec-math.sign
// eslint-disable-next-line es/no-math-sign -- safe
module.exports = Math.sign || function sign(x) {
  var n = +x;
  // eslint-disable-next-line no-self-compare -- NaN check
  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
};


/***/ }),

/***/ 80741:
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 91955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var safeGetBuiltIn = __webpack_require__(93389);
var bind = __webpack_require__(76080);
var macrotask = (__webpack_require__(59225).set);
var Queue = __webpack_require__(18265);
var IS_IOS = __webpack_require__(89544);
var IS_IOS_PEBBLE = __webpack_require__(44265);
var IS_WEBOS_WEBKIT = __webpack_require__(7860);
var IS_NODE = __webpack_require__(16193);

var MutationObserver = globalThis.MutationObserver || globalThis.WebKitMutationObserver;
var document = globalThis.document;
var process = globalThis.process;
var Promise = globalThis.Promise;
var microtask = safeGetBuiltIn('queueMicrotask');
var notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!microtask) {
  var queue = new Queue();

  var flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error) {
      if (queue.head) notify();
      throw error;
    }
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise;
    then = bind(promise.then, promise);
    notify = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessage
  // - onreadystatechange
  // - setTimeout
  } else {
    // `webpack` dev server bug on IE global methods - use bind(fn, global)
    macrotask = bind(macrotask, globalThis);
    notify = function () {
      macrotask(flush);
    };
  }

  microtask = function (fn) {
    if (!queue.head) notify();
    queue.add(fn);
  };
}

module.exports = microtask;


/***/ }),

/***/ 36043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(79306);

var $TypeError = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw new $TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ 60511:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isRegExp = __webpack_require__(60788);

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw new $TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ 44213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var uncurryThis = __webpack_require__(79504);
var call = __webpack_require__(69565);
var fails = __webpack_require__(79039);
var objectKeys = __webpack_require__(71072);
var getOwnPropertySymbolsModule = __webpack_require__(33717);
var propertyIsEnumerableModule = __webpack_require__(48773);
var toObject = __webpack_require__(48981);
var IndexedObject = __webpack_require__(47055);

// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es/no-symbol -- safe
  var symbol = Symbol('assign detection');
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  // eslint-disable-next-line es/no-array-prototype-foreach -- safe
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join('') !== alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ 2360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(28551);
var definePropertiesModule = __webpack_require__(96801);
var enumBugKeys = __webpack_require__(88727);
var hiddenKeys = __webpack_require__(30421);
var html = __webpack_require__(20397);
var documentCreateElement = __webpack_require__(4055);
var sharedKey = __webpack_require__(66119);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 96801:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(48686);
var definePropertyModule = __webpack_require__(24913);
var anObject = __webpack_require__(28551);
var toIndexedObject = __webpack_require__(25397);
var objectKeys = __webpack_require__(71072);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 24913:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var IE8_DOM_DEFINE = __webpack_require__(35917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(48686);
var anObject = __webpack_require__(28551);
var toPropertyKey = __webpack_require__(56969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 77347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var call = __webpack_require__(69565);
var propertyIsEnumerableModule = __webpack_require__(48773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(25397);
var toPropertyKey = __webpack_require__(56969);
var hasOwn = __webpack_require__(39297);
var IE8_DOM_DEFINE = __webpack_require__(35917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 10298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(44576);
var toIndexedObject = __webpack_require__(25397);
var $getOwnPropertyNames = (__webpack_require__(38480).f);
var arraySlice = __webpack_require__(67680);

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) === 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ 38480:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(61828);
var enumBugKeys = __webpack_require__(88727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 33717:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 42787:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(39297);
var isCallable = __webpack_require__(94901);
var toObject = __webpack_require__(48981);
var sharedKey = __webpack_require__(66119);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(12211);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 34124:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var isObject = __webpack_require__(20034);
var classof = __webpack_require__(44576);
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(15652);

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ 1625:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 61828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var hasOwn = __webpack_require__(39297);
var toIndexedObject = __webpack_require__(25397);
var indexOf = (__webpack_require__(19617).indexOf);
var hiddenKeys = __webpack_require__(30421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 71072:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(61828);
var enumBugKeys = __webpack_require__(88727);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 48773:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 52967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(46706);
var isObject = __webpack_require__(20034);
var requireObjectCoercible = __webpack_require__(67750);
var aPossiblePrototype = __webpack_require__(73506);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    requireObjectCoercible(O);
    aPossiblePrototype(proto);
    if (!isObject(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 53179:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(92140);
var classof = __webpack_require__(36955);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 84270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(69565);
var isCallable = __webpack_require__(94901);
var isObject = __webpack_require__(20034);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 35031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(97751);
var uncurryThis = __webpack_require__(79504);
var getOwnPropertyNamesModule = __webpack_require__(38480);
var getOwnPropertySymbolsModule = __webpack_require__(33717);
var anObject = __webpack_require__(28551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 19167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);

module.exports = globalThis;


/***/ }),

/***/ 1103:
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ 10916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var NativePromiseConstructor = __webpack_require__(80550);
var isCallable = __webpack_require__(94901);
var isForced = __webpack_require__(92796);
var inspectSource = __webpack_require__(33706);
var wellKnownSymbol = __webpack_require__(78227);
var ENVIRONMENT = __webpack_require__(84215);
var IS_PURE = __webpack_require__(96395);
var V8_VERSION = __webpack_require__(39519);

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var SPECIES = wellKnownSymbol('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis.PromiseRejectionEvent);

var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
  if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    // Detect correctness of subclassing with @@species support
    var promise = new NativePromiseConstructor(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  } return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === 'BROWSER' || ENVIRONMENT === 'DENO') && !NATIVE_PROMISE_REJECTION_EVENT;
});

module.exports = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
  SUBCLASSING: SUBCLASSING
};


/***/ }),

/***/ 80550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);

module.exports = globalThis.Promise;


/***/ }),

/***/ 93438:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(28551);
var isObject = __webpack_require__(20034);
var newPromiseCapability = __webpack_require__(36043);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ 90537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NativePromiseConstructor = __webpack_require__(80550);
var checkCorrectnessOfIteration = __webpack_require__(84428);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(10916).CONSTRUCTOR);

module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor.all(iterable).then(undefined, function () { /* empty */ });
});


/***/ }),

/***/ 11056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(24913).f);

module.exports = function (Target, Source, key) {
  key in Target || defineProperty(Target, key, {
    configurable: true,
    get: function () { return Source[key]; },
    set: function (it) { Source[key] = it; }
  });
};


/***/ }),

/***/ 18265:
/***/ ((module) => {

"use strict";

var Queue = function () {
  this.head = null;
  this.tail = null;
};

Queue.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      var next = this.head = entry.next;
      if (next === null) this.tail = null;
      return entry.item;
    }
  }
};

module.exports = Queue;


/***/ }),

/***/ 56682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(69565);
var anObject = __webpack_require__(28551);
var isCallable = __webpack_require__(94901);
var classof = __webpack_require__(44576);
var regexpExec = __webpack_require__(57323);

var $TypeError = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw new $TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ 57323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call = __webpack_require__(69565);
var uncurryThis = __webpack_require__(79504);
var toString = __webpack_require__(655);
var regexpFlags = __webpack_require__(67979);
var stickyHelpers = __webpack_require__(58429);
var shared = __webpack_require__(25745);
var create = __webpack_require__(2360);
var getInternalState = (__webpack_require__(91181).get);
var UNSUPPORTED_DOT_ALL = __webpack_require__(83635);
var UNSUPPORTED_NCG = __webpack_require__(18814);

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call(nativeExec, re1, 'a');
  call(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice(match.input, charsAdded);
        match[0] = stringSlice(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
      call(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ 67979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(28551);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 61034:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(69565);
var hasOwn = __webpack_require__(39297);
var isPrototypeOf = __webpack_require__(1625);
var regExpFlags = __webpack_require__(67979);

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ 58429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var globalThis = __webpack_require__(22195);

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = globalThis.RegExp;

var UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') !== null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
  return !$RegExp('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') !== null;
});

module.exports = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y
};


/***/ }),

/***/ 83635:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var globalThis = __webpack_require__(22195);

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = globalThis.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.test('\n') && re.flags === 's');
});


/***/ }),

/***/ 18814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var globalThis = __webpack_require__(22195);

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = globalThis.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ 67750:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(64117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 93389:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var DESCRIPTORS = __webpack_require__(43724);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Avoid NodeJS experimental warning
module.exports = function (name) {
  if (!DESCRIPTORS) return globalThis[name];
  var descriptor = getOwnPropertyDescriptor(globalThis, name);
  return descriptor && descriptor.value;
};


/***/ }),

/***/ 79472:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var apply = __webpack_require__(18745);
var isCallable = __webpack_require__(94901);
var ENVIRONMENT = __webpack_require__(84215);
var USER_AGENT = __webpack_require__(82839);
var arraySlice = __webpack_require__(67680);
var validateArgumentsLength = __webpack_require__(22812);

var Function = globalThis.Function;
// dirty IE9- and Bun 0.3.0- checks
var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === 'BUN' && (function () {
  var version = globalThis.Bun.version.split('.');
  return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');
})();

// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
// https://github.com/oven-sh/bun/issues/1633
module.exports = function (scheduler, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function (handler, timeout /* , ...arguments */) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
    var fn = isCallable(handler) ? handler : Function(handler);
    var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
    var callback = boundArgs ? function () {
      apply(fn, this, params);
    } : fn;
    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
  } : scheduler;
};


/***/ }),

/***/ 87633:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(97751);
var defineBuiltInAccessor = __webpack_require__(62106);
var wellKnownSymbol = __webpack_require__(78227);
var DESCRIPTORS = __webpack_require__(43724);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineBuiltInAccessor(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ 10687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(24913).f);
var hasOwn = __webpack_require__(39297);
var wellKnownSymbol = __webpack_require__(78227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ 66119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(25745);
var uid = __webpack_require__(33392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 77629:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(96395);
var globalThis = __webpack_require__(22195);
var defineGlobalProperty = __webpack_require__(39433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.40.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2025 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.40.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 25745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var store = __webpack_require__(77629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 2293:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(28551);
var aConstructor = __webpack_require__(35548);
var isNullOrUndefined = __webpack_require__(64117);
var wellKnownSymbol = __webpack_require__(78227);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ 68183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var toIntegerOrInfinity = __webpack_require__(91291);
var toString = __webpack_require__(655);
var requireObjectCoercible = __webpack_require__(67750);

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 3717:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var uncurryThis = __webpack_require__(79504);

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;

var $RangeError = RangeError;
var exec = uncurryThis(regexSeparators.exec);
var floor = Math.floor;
var fromCharCode = String.fromCharCode;
var charCodeAt = uncurryThis(''.charCodeAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var split = uncurryThis(''.split);
var toLowerCase = uncurryThis(''.toLowerCase);

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = charCodeAt(string, counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = charCodeAt(string, counter++);
      if ((extra & 0xFC00) === 0xDC00) { // Low surrogate.
        push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        push(output, value);
        counter--;
      }
    } else {
      push(output, value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  while (delta > baseMinusTMin * tMax >> 1) {
    delta = floor(delta / baseMinusTMin);
    k += base;
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      push(output, fromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    push(output, delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw new $RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw new $RangeError(OVERFLOW_ERROR);
      }
      if (currentValue === n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        var k = base;
        while (true) {
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
          k += base;
        }

        push(output, fromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        handledCPCount++;
      }
    }

    delta++;
    n++;
  }
  return join(output, '');
};

module.exports = function (input) {
  var encoded = [];
  var labels = split(replace(toLowerCase(input), regexSeparators, '\u002E'), '.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);
  }
  return join(encoded, '.');
};


/***/ }),

/***/ 60706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var PROPER_FUNCTION_NAME = (__webpack_require__(10350).PROPER);
var fails = __webpack_require__(79039);
var whitespaces = __webpack_require__(47452);

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]()
      || non[METHOD_NAME]() !== non
      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
  });
};


/***/ }),

/***/ 43802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var requireObjectCoercible = __webpack_require__(67750);
var toString = __webpack_require__(655);
var whitespaces = __webpack_require__(47452);

var replace = uncurryThis(''.replace);
var ltrim = RegExp('^[' + whitespaces + ']+');
var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ 4495:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(39519);
var fails = __webpack_require__(79039);
var globalThis = __webpack_require__(22195);

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 58242:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(69565);
var getBuiltIn = __webpack_require__(97751);
var wellKnownSymbol = __webpack_require__(78227);
var defineBuiltIn = __webpack_require__(36840);

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ 91296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_SYMBOL = __webpack_require__(4495);

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ 59225:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var apply = __webpack_require__(18745);
var bind = __webpack_require__(76080);
var isCallable = __webpack_require__(94901);
var hasOwn = __webpack_require__(39297);
var fails = __webpack_require__(79039);
var html = __webpack_require__(20397);
var arraySlice = __webpack_require__(67680);
var createElement = __webpack_require__(4055);
var validateArgumentsLength = __webpack_require__(22812);
var IS_IOS = __webpack_require__(89544);
var IS_NODE = __webpack_require__(16193);

var set = globalThis.setImmediate;
var clear = globalThis.clearImmediate;
var process = globalThis.process;
var Dispatch = globalThis.Dispatch;
var Function = globalThis.Function;
var MessageChannel = globalThis.MessageChannel;
var String = globalThis.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = globalThis.location;
});

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  globalThis.postMessage(String(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    globalThis.addEventListener &&
    isCallable(globalThis.postMessage) &&
    !globalThis.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    globalThis.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ 31240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ 35610:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(91291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 75854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(72777);

var $TypeError = TypeError;

// `ToBigInt` abstract operation
// https://tc39.es/ecma262/#sec-tobigint
module.exports = function (argument) {
  var prim = toPrimitive(argument, 'number');
  if (typeof prim == 'number') throw new $TypeError("Can't convert number to bigint");
  // eslint-disable-next-line es/no-bigint -- safe
  return BigInt(prim);
};


/***/ }),

/***/ 57696:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(91291);
var toLength = __webpack_require__(18014);

var $RangeError = RangeError;

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toIntegerOrInfinity(it);
  var length = toLength(number);
  if (number !== length) throw new $RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ 25397:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(47055);
var requireObjectCoercible = __webpack_require__(67750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 91291:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(80741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 18014:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(91291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 48981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(67750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 58229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPositiveInteger = __webpack_require__(99590);

var $RangeError = RangeError;

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw new $RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ 99590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(91291);

var $RangeError = RangeError;

module.exports = function (it) {
  var result = toIntegerOrInfinity(it);
  if (result < 0) throw new $RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ 72777:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(69565);
var isObject = __webpack_require__(20034);
var isSymbol = __webpack_require__(10757);
var getMethod = __webpack_require__(55966);
var ordinaryToPrimitive = __webpack_require__(84270);
var wellKnownSymbol = __webpack_require__(78227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 56969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(72777);
var isSymbol = __webpack_require__(10757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 92140:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(78227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(36955);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 58319:
/***/ ((module) => {

"use strict";

var round = Math.round;

module.exports = function (it) {
  var value = round(it);
  return value < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
};


/***/ }),

/***/ 16823:
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 15823:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);
var call = __webpack_require__(69565);
var DESCRIPTORS = __webpack_require__(43724);
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(72805);
var ArrayBufferViewCore = __webpack_require__(94644);
var ArrayBufferModule = __webpack_require__(66346);
var anInstance = __webpack_require__(90679);
var createPropertyDescriptor = __webpack_require__(6980);
var createNonEnumerableProperty = __webpack_require__(66699);
var isIntegralNumber = __webpack_require__(2087);
var toLength = __webpack_require__(18014);
var toIndex = __webpack_require__(57696);
var toOffset = __webpack_require__(58229);
var toUint8Clamped = __webpack_require__(58319);
var toPropertyKey = __webpack_require__(56969);
var hasOwn = __webpack_require__(39297);
var classof = __webpack_require__(36955);
var isObject = __webpack_require__(20034);
var isSymbol = __webpack_require__(10757);
var create = __webpack_require__(2360);
var isPrototypeOf = __webpack_require__(1625);
var setPrototypeOf = __webpack_require__(52967);
var getOwnPropertyNames = (__webpack_require__(38480).f);
var typedArrayFrom = __webpack_require__(43251);
var forEach = (__webpack_require__(59213).forEach);
var setSpecies = __webpack_require__(87633);
var defineBuiltInAccessor = __webpack_require__(62106);
var definePropertyModule = __webpack_require__(24913);
var getOwnPropertyDescriptorModule = __webpack_require__(77347);
var arrayFromConstructorAndList = __webpack_require__(35370);
var InternalStateModule = __webpack_require__(91181);
var inheritIfRequired = __webpack_require__(23167);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var enforceInternalState = InternalStateModule.enforce;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var RangeError = globalThis.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer.prototype;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var addGetter = function (it, key) {
  defineBuiltInAccessor(it, key, {
    configurable: true,
    get: function () {
      return getInternalState(this)[key];
    }
  });
};

var isArrayBuffer = function (it) {
  var klass;
  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === 'ArrayBuffer' || klass === 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && !isSymbol(key)
    && key in target
    && isIntegralNumber(+key)
    && key >= 0;
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  key = toPropertyKey(key);
  return isTypedArrayIndex(target, key)
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  key = toPropertyKey(key);
  if (isTypedArrayIndex(target, key)
    && isObject(descriptor)
    && hasOwn(descriptor, 'value')
    && !hasOwn(descriptor, 'get')
    && !hasOwn(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!hasOwn(descriptor, 'writable') || descriptor.writable)
    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = globalThis[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      data.view[SETTER](index * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw new RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw new RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw new RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return arrayFromConstructorAndList(TypedArrayConstructor, data);
        } else {
          return call(typedArrayFrom, TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return arrayFromConstructorAndList(TypedArrayConstructor, data);
          return call(typedArrayFrom, TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ 72805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-new, sonarjs/inconsistent-function-call -- required for testing */
var globalThis = __webpack_require__(22195);
var fails = __webpack_require__(79039);
var checkCorrectnessOfIteration = __webpack_require__(84428);
var NATIVE_ARRAY_BUFFER_VIEWS = (__webpack_require__(94644).NATIVE_ARRAY_BUFFER_VIEWS);

var ArrayBuffer = globalThis.ArrayBuffer;
var Int8Array = globalThis.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ 29948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arrayFromConstructorAndList = __webpack_require__(35370);
var getTypedArrayConstructor = (__webpack_require__(94644).getTypedArrayConstructor);

module.exports = function (instance, list) {
  return arrayFromConstructorAndList(getTypedArrayConstructor(instance), list);
};


/***/ }),

/***/ 43251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(76080);
var call = __webpack_require__(69565);
var aConstructor = __webpack_require__(35548);
var toObject = __webpack_require__(48981);
var lengthOfArrayLike = __webpack_require__(26198);
var getIterator = __webpack_require__(70081);
var getIteratorMethod = __webpack_require__(50851);
var isArrayIteratorMethod = __webpack_require__(44209);
var isBigIntArray = __webpack_require__(18727);
var aTypedArrayConstructor = (__webpack_require__(94644).aTypedArrayConstructor);
var toBigInt = __webpack_require__(75854);

module.exports = function from(source /* , mapfn, thisArg */) {
  var C = aConstructor(this);
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, thisIsBigIntArray, value, step, iterator, next;
  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    O = [];
    while (!(step = call(next, iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2]);
  }
  length = lengthOfArrayLike(O);
  result = new (aTypedArrayConstructor(C))(length);
  thisIsBigIntArray = isBigIntArray(result);
  for (i = 0; length > i; i++) {
    value = mapping ? mapfn(O[i], i) : O[i];
    // FF30- typed arrays doesn't properly convert objects to typed array values
    result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
  }
  return result;
};


/***/ }),

/***/ 33392:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 67416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(79039);
var wellKnownSymbol = __webpack_require__(78227);
var DESCRIPTORS = __webpack_require__(43724);
var IS_PURE = __webpack_require__(96395);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
  var url = new URL('b?a=1&b=2&c=3', 'https://a');
  var params = url.searchParams;
  var params2 = new URLSearchParams('a=1&a=2&b=3');
  var result = '';
  url.pathname = 'c%20d';
  params.forEach(function (value, key) {
    params['delete']('b');
    result += key + value;
  });
  params2['delete']('a', 2);
  // `undefined` case is a Chromium 117 bug
  // https://bugs.chromium.org/p/v8/issues/detail?id=14222
  params2['delete']('b', undefined);
  return (IS_PURE && (!url.toJSON || !params2.has('a', 1) || params2.has('a', 2) || !params2.has('a', undefined) || params2.has('b')))
    || (!params.size && (IS_PURE || !DESCRIPTORS))
    || !params.sort
    || url.href !== 'https://a/c%20d?a=1&c=3'
    || params.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !params[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('https://тест').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('https://a#б').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('https://x', undefined).host !== 'x';
});


/***/ }),

/***/ 7040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 48686:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var fails = __webpack_require__(79039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 22812:
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 58622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var isCallable = __webpack_require__(94901);

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 70511:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(19167);
var hasOwn = __webpack_require__(39297);
var wrappedWellKnownSymbolModule = __webpack_require__(1951);
var defineProperty = (__webpack_require__(24913).f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ 1951:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(78227);

exports.f = wellKnownSymbol;


/***/ }),

/***/ 78227:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var shared = __webpack_require__(25745);
var hasOwn = __webpack_require__(39297);
var uid = __webpack_require__(33392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 47452:
/***/ ((module) => {

"use strict";

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ 54743:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);
var arrayBufferModule = __webpack_require__(66346);
var setSpecies = __webpack_require__(87633);

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = globalThis[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.es/ecma262/#sec-arraybuffer-constructor
$({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
  ArrayBuffer: ArrayBuffer
});

setSpecies(ARRAY_BUFFER);


/***/ }),

/***/ 11745:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var uncurryThis = __webpack_require__(27476);
var fails = __webpack_require__(79039);
var ArrayBufferModule = __webpack_require__(66346);
var anObject = __webpack_require__(28551);
var toAbsoluteIndex = __webpack_require__(35610);
var toLength = __webpack_require__(18014);

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var DataViewPrototype = DataView.prototype;
var nativeArrayBufferSlice = uncurryThis(ArrayBuffer.prototype.slice);
var getUint8 = uncurryThis(DataViewPrototype.getUint8);
var setUint8 = uncurryThis(DataViewPrototype.setUint8);

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice && end === undefined) {
      return nativeArrayBufferSlice(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new ArrayBuffer(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      setUint8(viewTarget, index++, getUint8(viewSource, first++));
    } return result;
  }
});


/***/ }),

/***/ 28706:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var fails = __webpack_require__(79039);
var isArray = __webpack_require__(34376);
var isObject = __webpack_require__(20034);
var toObject = __webpack_require__(48981);
var lengthOfArrayLike = __webpack_require__(26198);
var doesNotExceedSafeInteger = __webpack_require__(96837);
var createProperty = __webpack_require__(97040);
var arraySpeciesCreate = __webpack_require__(1469);
var arrayMethodHasSpeciesSupport = __webpack_require__(70597);
var wellKnownSymbol = __webpack_require__(78227);
var V8_VERSION = __webpack_require__(39519);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ 2008:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var $filter = (__webpack_require__(59213).filter);
var arrayMethodHasSpeciesSupport = __webpack_require__(70597);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 50113:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var $find = (__webpack_require__(59213).find);
var addToUnscopables = __webpack_require__(6469);

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
// eslint-disable-next-line es/no-array-prototype-find -- testing
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ 78350:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var flattenIntoArray = __webpack_require__(70259);
var aCallable = __webpack_require__(79306);
var toObject = __webpack_require__(48981);
var lengthOfArrayLike = __webpack_require__(26198);
var arraySpeciesCreate = __webpack_require__(1469);

// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = lengthOfArrayLike(O);
    var A;
    aCallable(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),

/***/ 46449:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var flattenIntoArray = __webpack_require__(70259);
var toObject = __webpack_require__(48981);
var lengthOfArrayLike = __webpack_require__(26198);
var toIntegerOrInfinity = __webpack_require__(91291);
var arraySpeciesCreate = __webpack_require__(1469);

// `Array.prototype.flat` method
// https://tc39.es/ecma262/#sec-array.prototype.flat
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = lengthOfArrayLike(O);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toIntegerOrInfinity(depthArg));
    return A;
  }
});


/***/ }),

/***/ 51629:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var forEach = __webpack_require__(90235);

// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
$({ target: 'Array', proto: true, forced: [].forEach !== forEach }, {
  forEach: forEach
});


/***/ }),

/***/ 23418:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var from = __webpack_require__(97916);
var checkCorrectnessOfIteration = __webpack_require__(84428);

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ 74423:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var $includes = (__webpack_require__(19617).includes);
var fails = __webpack_require__(79039);
var addToUnscopables = __webpack_require__(6469);

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ 64346:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var isArray = __webpack_require__(34376);

// `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray
$({ target: 'Array', stat: true }, {
  isArray: isArray
});


/***/ }),

/***/ 23792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(25397);
var addToUnscopables = __webpack_require__(6469);
var Iterators = __webpack_require__(26269);
var InternalStateModule = __webpack_require__(91181);
var defineProperty = (__webpack_require__(24913).f);
var defineIterator = __webpack_require__(51088);
var createIterResultObject = __webpack_require__(62529);
var IS_PURE = __webpack_require__(96395);
var DESCRIPTORS = __webpack_require__(43724);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(undefined, true);
  }
  switch (state.kind) {
    case 'keys': return createIterResultObject(index, false);
    case 'values': return createIterResultObject(target[index], false);
  } return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ 94490:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var uncurryThis = __webpack_require__(79504);
var isArray = __webpack_require__(34376);

var nativeReverse = uncurryThis([].reverse);
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray(this)) this.length = this.length;
    return nativeReverse(this);
  }
});


/***/ }),

/***/ 34782:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var isArray = __webpack_require__(34376);
var isConstructor = __webpack_require__(33517);
var isObject = __webpack_require__(20034);
var toAbsoluteIndex = __webpack_require__(35610);
var lengthOfArrayLike = __webpack_require__(26198);
var toIndexedObject = __webpack_require__(25397);
var createProperty = __webpack_require__(97040);
var wellKnownSymbol = __webpack_require__(78227);
var arrayMethodHasSpeciesSupport = __webpack_require__(70597);
var nativeSlice = __webpack_require__(67680);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var $Array = Array;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === $Array || Constructor === undefined) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ 26910:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var uncurryThis = __webpack_require__(79504);
var aCallable = __webpack_require__(79306);
var toObject = __webpack_require__(48981);
var lengthOfArrayLike = __webpack_require__(26198);
var deletePropertyOrThrow = __webpack_require__(84606);
var toString = __webpack_require__(655);
var fails = __webpack_require__(79039);
var internalSort = __webpack_require__(74488);
var arrayMethodIsStrict = __webpack_require__(34598);
var FF = __webpack_require__(13709);
var IE_OR_EDGE = __webpack_require__(13763);
var V8 = __webpack_require__(39519);
var WEBKIT = __webpack_require__(3607);

var test = [];
var nativeSort = uncurryThis(test.sort);
var push = uncurryThis(test.push);

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);

    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));

    itemsLength = lengthOfArrayLike(items);
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow(array, index++);

    return array;
  }
});


/***/ }),

/***/ 30237:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(6469);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');


/***/ }),

/***/ 93514:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(6469);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flat');


/***/ }),

/***/ 24359:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var ArrayBufferModule = __webpack_require__(66346);
var NATIVE_ARRAY_BUFFER = __webpack_require__(77811);

// `DataView` constructor
// https://tc39.es/ecma262/#sec-dataview-constructor
$({ global: true, constructor: true, forced: !NATIVE_ARRAY_BUFFER }, {
  DataView: ArrayBufferModule.DataView
});


/***/ }),

/***/ 38309:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(24359);


/***/ }),

/***/ 59089:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(46518);
var uncurryThis = __webpack_require__(79504);

var $Date = Date;
var thisTimeValue = uncurryThis($Date.prototype.getTime);

// `Date.now` method
// https://tc39.es/ecma262/#sec-date.now
$({ target: 'Date', stat: true }, {
  now: function now() {
    return thisTimeValue(new $Date());
  }
});


/***/ }),

/***/ 89572:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(39297);
var defineBuiltIn = __webpack_require__(36840);
var dateToPrimitive = __webpack_require__(53640);
var wellKnownSymbol = __webpack_require__(78227);

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;

// `Date.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
  defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}


/***/ }),

/***/ 23288:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var uncurryThis = __webpack_require__(79504);
var defineBuiltIn = __webpack_require__(36840);

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = uncurryThis(DatePrototype[TO_STRING]);
var thisTimeValue = uncurryThis(DatePrototype.getTime);

// `Date.prototype.toString` method
// https://tc39.es/ecma262/#sec-date.prototype.tostring
if (String(new Date(NaN)) !== INVALID_DATE) {
  defineBuiltIn(DatePrototype, TO_STRING, function toString() {
    var value = thisTimeValue(this);
    // eslint-disable-next-line no-self-compare -- NaN check
    return value === value ? nativeDateToString(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ 94170:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(46518);
var bind = __webpack_require__(30566);

// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
$({ target: 'Function', proto: true, forced: Function.bind !== bind }, {
  bind: bind
});


/***/ }),

/***/ 62010:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var FUNCTION_NAME_EXISTS = (__webpack_require__(10350).EXISTS);
var uncurryThis = __webpack_require__(79504);
var defineBuiltInAccessor = __webpack_require__(62106);

var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec = uncurryThis(nameRE.exec);
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
  defineBuiltInAccessor(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return regExpExec(nameRE, functionToString(this))[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ 55081:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);

// `globalThis` object
// https://tc39.es/ecma262/#sec-globalthis
$({ global: true, forced: globalThis.globalThis !== globalThis }, {
  globalThis: globalThis
});


/***/ }),

/***/ 33110:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var getBuiltIn = __webpack_require__(97751);
var apply = __webpack_require__(18745);
var call = __webpack_require__(69565);
var uncurryThis = __webpack_require__(79504);
var fails = __webpack_require__(79039);
var isCallable = __webpack_require__(94901);
var isSymbol = __webpack_require__(10757);
var arraySlice = __webpack_require__(67680);
var getReplacerFunction = __webpack_require__(66933);
var NATIVE_SYMBOL = __webpack_require__(4495);

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')('stringify detection');
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) !== '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) !== '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) !== '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ 4731:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var setToStringTag = __webpack_require__(10687);

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(globalThis.JSON, 'JSON', true);


/***/ }),

/***/ 48523:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(16468);
var collectionStrong = __webpack_require__(86938);

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ 36033:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(48523);


/***/ }),

/***/ 60479:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var setToStringTag = __webpack_require__(10687);

// Math[@@toStringTag] property
// https://tc39.es/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);


/***/ }),

/***/ 2892:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var IS_PURE = __webpack_require__(96395);
var DESCRIPTORS = __webpack_require__(43724);
var globalThis = __webpack_require__(22195);
var path = __webpack_require__(19167);
var uncurryThis = __webpack_require__(79504);
var isForced = __webpack_require__(92796);
var hasOwn = __webpack_require__(39297);
var inheritIfRequired = __webpack_require__(23167);
var isPrototypeOf = __webpack_require__(1625);
var isSymbol = __webpack_require__(10757);
var toPrimitive = __webpack_require__(72777);
var fails = __webpack_require__(79039);
var getOwnPropertyNames = (__webpack_require__(38480).f);
var getOwnPropertyDescriptor = (__webpack_require__(77347).f);
var defineProperty = (__webpack_require__(24913).f);
var thisNumberValue = __webpack_require__(31240);
var trim = (__webpack_require__(43802).trim);

var NUMBER = 'Number';
var NativeNumber = globalThis[NUMBER];
var PureNumberNamespace = path[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = globalThis.TypeError;
var stringSlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw new TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        // fast equal of /^0b[01]+$/i
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0o[0-7]+$/i
        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        default:
          return +it;
      }
      digits = stringSlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

var FORCED = isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'));

var calledWithNew = function (dummy) {
  // includes check on 1..constructor(foo) case
  return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); });
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
var NumberWrapper = function Number(value) {
  var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
  return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
};

NumberWrapper.prototype = NumberPrototype;
if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;

$({ global: true, constructor: true, wrap: true, forced: FORCED }, {
  Number: NumberWrapper
});

// Use `internal/copy-constructor-properties` helper in `core-js@4`
var copyConstructorProperties = function (target, source) {
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);


/***/ }),

/***/ 59904:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(46518);
var DESCRIPTORS = __webpack_require__(43724);
var create = __webpack_require__(2360);

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});


/***/ }),

/***/ 84185:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var DESCRIPTORS = __webpack_require__(43724);
var defineProperty = (__webpack_require__(24913).f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ 49773:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var NATIVE_SYMBOL = __webpack_require__(4495);
var fails = __webpack_require__(79039);
var getOwnPropertySymbolsModule = __webpack_require__(33717);
var toObject = __webpack_require__(48981);

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ 40875:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var fails = __webpack_require__(79039);
var toObject = __webpack_require__(48981);
var nativeGetPrototypeOf = __webpack_require__(42787);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(12211);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ 10287:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var setPrototypeOf = __webpack_require__(52967);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ 26099:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(92140);
var defineBuiltIn = __webpack_require__(36840);
var toString = __webpack_require__(53179);

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ 96167:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var call = __webpack_require__(69565);
var aCallable = __webpack_require__(79306);
var newPromiseCapabilityModule = __webpack_require__(36043);
var perform = __webpack_require__(1103);
var iterate = __webpack_require__(72652);
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__(90537);

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call(promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'fulfilled', value: value };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'rejected', reason: error };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 16499:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var call = __webpack_require__(69565);
var aCallable = __webpack_require__(79306);
var newPromiseCapabilityModule = __webpack_require__(36043);
var perform = __webpack_require__(1103);
var iterate = __webpack_require__(72652);
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__(90537);

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 82003:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var IS_PURE = __webpack_require__(96395);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(10916).CONSTRUCTOR);
var NativePromiseConstructor = __webpack_require__(80550);
var getBuiltIn = __webpack_require__(97751);
var isCallable = __webpack_require__(94901);
var defineBuiltIn = __webpack_require__(36840);

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['catch'];
  if (NativePromisePrototype['catch'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'catch', method, { unsafe: true });
  }
}


/***/ }),

/***/ 10436:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var IS_PURE = __webpack_require__(96395);
var IS_NODE = __webpack_require__(16193);
var globalThis = __webpack_require__(22195);
var call = __webpack_require__(69565);
var defineBuiltIn = __webpack_require__(36840);
var setPrototypeOf = __webpack_require__(52967);
var setToStringTag = __webpack_require__(10687);
var setSpecies = __webpack_require__(87633);
var aCallable = __webpack_require__(79306);
var isCallable = __webpack_require__(94901);
var isObject = __webpack_require__(20034);
var anInstance = __webpack_require__(90679);
var speciesConstructor = __webpack_require__(2293);
var task = (__webpack_require__(59225).set);
var microtask = __webpack_require__(91955);
var hostReportErrors = __webpack_require__(90757);
var perform = __webpack_require__(1103);
var Queue = __webpack_require__(18265);
var InternalStateModule = __webpack_require__(91181);
var NativePromiseConstructor = __webpack_require__(80550);
var PromiseConstructorDetection = __webpack_require__(10916);
var newPromiseCapabilityModule = __webpack_require__(36043);

var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var PromiseConstructor = NativePromiseConstructor;
var PromisePrototype = NativePromisePrototype;
var TypeError = globalThis.TypeError;
var document = globalThis.document;
var process = globalThis.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;

var DISPATCH_EVENT = !!(document && document.createEvent && globalThis.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && isCallable(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state === FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(new TypeError('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    globalThis.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call(task, globalThis, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call(task, globalThis, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw new TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call(then, value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    call(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };

  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: null
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : undefined;
    if (state.state === PENDING) state.reactions.add(reaction);
    else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;

    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
  }
}

// `Promise` constructor
// https://tc39.es/ecma262/#sec-promise-executor
$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);


/***/ }),

/***/ 9391:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var IS_PURE = __webpack_require__(96395);
var NativePromiseConstructor = __webpack_require__(80550);
var fails = __webpack_require__(79039);
var getBuiltIn = __webpack_require__(97751);
var isCallable = __webpack_require__(94901);
var speciesConstructor = __webpack_require__(2293);
var promiseResolve = __webpack_require__(93438);
var defineBuiltIn = __webpack_require__(36840);

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromiseConstructor && fails(function () {
  // eslint-disable-next-line unicorn/no-thenable -- required for testing
  NativePromisePrototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = isCallable(onFinally);
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});

// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['finally'];
  if (NativePromisePrototype['finally'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'finally', method, { unsafe: true });
  }
}


/***/ }),

/***/ 3362:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(10436);
__webpack_require__(16499);
__webpack_require__(82003);
__webpack_require__(7743);
__webpack_require__(51481);
__webpack_require__(40280);


/***/ }),

/***/ 7743:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var call = __webpack_require__(69565);
var aCallable = __webpack_require__(79306);
var newPromiseCapabilityModule = __webpack_require__(36043);
var perform = __webpack_require__(1103);
var iterate = __webpack_require__(72652);
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__(90537);

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function (promise) {
        call($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 51481:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var newPromiseCapabilityModule = __webpack_require__(36043);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(10916).CONSTRUCTOR);

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule.f(this);
    var capabilityReject = capability.reject;
    capabilityReject(r);
    return capability.promise;
  }
});


/***/ }),

/***/ 40280:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var getBuiltIn = __webpack_require__(97751);
var IS_PURE = __webpack_require__(96395);
var NativePromiseConstructor = __webpack_require__(80550);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(10916).CONSTRUCTOR);
var promiseResolve = __webpack_require__(93438);

var PromiseConstructorWrapper = getBuiltIn('Promise');
var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
  }
});


/***/ }),

/***/ 60825:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var getBuiltIn = __webpack_require__(97751);
var apply = __webpack_require__(18745);
var bind = __webpack_require__(30566);
var aConstructor = __webpack_require__(35548);
var anObject = __webpack_require__(28551);
var isObject = __webpack_require__(20034);
var create = __webpack_require__(2360);
var fails = __webpack_require__(79039);

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target === newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ 84864:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(43724);
var globalThis = __webpack_require__(22195);
var uncurryThis = __webpack_require__(79504);
var isForced = __webpack_require__(92796);
var inheritIfRequired = __webpack_require__(23167);
var createNonEnumerableProperty = __webpack_require__(66699);
var create = __webpack_require__(2360);
var getOwnPropertyNames = (__webpack_require__(38480).f);
var isPrototypeOf = __webpack_require__(1625);
var isRegExp = __webpack_require__(60788);
var toString = __webpack_require__(655);
var getRegExpFlags = __webpack_require__(61034);
var stickyHelpers = __webpack_require__(58429);
var proxyAccessor = __webpack_require__(11056);
var defineBuiltIn = __webpack_require__(36840);
var fails = __webpack_require__(79039);
var hasOwn = __webpack_require__(39297);
var enforceInternalState = (__webpack_require__(91181).enforce);
var setSpecies = __webpack_require__(87633);
var wellKnownSymbol = __webpack_require__(78227);
var UNSUPPORTED_DOT_ALL = __webpack_require__(83635);
var UNSUPPORTED_NCG = __webpack_require__(18814);

var MATCH = wellKnownSymbol('match');
var NativeRegExp = globalThis.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var SyntaxError = globalThis.SyntaxError;
var exec = uncurryThis(RegExpPrototype.exec);
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);
// TODO: Use only proper RegExpIdentifierName
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var BASE_FORCED = DESCRIPTORS &&
  (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {
    re2[MATCH] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    // eslint-disable-next-line sonarjs/inconsistent-function-call -- required for testing
    return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, 'i')) !== '/a/i';
  }));

var handleDotAll = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var brackets = false;
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === '\\') {
      result += chr + charAt(string, ++index);
      continue;
    }
    if (!brackets && chr === '.') {
      result += '[\\s\\S]';
    } else {
      if (chr === '[') {
        brackets = true;
      } else if (chr === ']') {
        brackets = false;
      } result += chr;
    }
  } return result;
};

var handleNCG = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var named = [];
  var names = create(null);
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = '';
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === '\\') {
      chr += charAt(string, ++index);
    } else if (chr === ']') {
      brackets = false;
    } else if (!brackets) switch (true) {
      case chr === '[':
        brackets = true;
        break;
      case chr === '(':
        result += chr;
        // ignore non-capturing groups
        if (stringSlice(string, index + 1, index + 3) === '?:') {
          continue;
        }
        if (exec(IS_NCG, stringSlice(string, index + 1))) {
          index += 2;
          ncg = true;
        }
        groupid++;
        continue;
      case chr === '>' && ncg:
        if (groupname === '' || hasOwn(names, groupname)) {
          throw new SyntaxError('Invalid capture group name');
        }
        names[groupname] = true;
        named[named.length] = [groupname, groupid];
        ncg = false;
        groupname = '';
        continue;
    }
    if (ncg) groupname += chr;
    else result += chr;
  } return [result, named];
};

// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (isForced('RegExp', BASE_FORCED)) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;

    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }

    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
    }

    pattern = pattern === undefined ? '' : toString(pattern);
    flags = flags === undefined ? '' : toString(flags);
    rawPattern = pattern;

    if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
      dotAll = !!flags && stringIndexOf(flags, 's') > -1;
      if (dotAll) flags = replace(flags, /s/g, '');
    }

    rawFlags = flags;

    if (MISSED_STICKY && 'sticky' in re1) {
      sticky = !!flags && stringIndexOf(flags, 'y') > -1;
      if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');
    }

    if (UNSUPPORTED_NCG) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }

    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);

    if (dotAll || sticky || groups.length) {
      state = enforceInternalState(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky) state.sticky = true;
      if (groups.length) state.groups = groups;
    }

    if (pattern !== rawPattern) try {
      // fails in old engines, but we have no alternatives for unsupported regex syntax
      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
    } catch (error) { /* empty */ }

    return result;
  };

  for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
  }

  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  defineBuiltIn(globalThis, 'RegExp', RegExpWrapper, { constructor: true });
}

// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ 27495:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var exec = __webpack_require__(57323);

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ 69479:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var DESCRIPTORS = __webpack_require__(43724);
var defineBuiltInAccessor = __webpack_require__(62106);
var regExpFlags = __webpack_require__(67979);
var fails = __webpack_require__(79039);

// babel-minify and Closure Compiler transpiles RegExp('.', 'd') -> /./d and it causes SyntaxError
var RegExp = globalThis.RegExp;
var RegExpPrototype = RegExp.prototype;

var FORCED = DESCRIPTORS && fails(function () {
  var INDICES_SUPPORT = true;
  try {
    RegExp('.', 'd');
  } catch (error) {
    INDICES_SUPPORT = false;
  }

  var O = {};
  // modern V8 bug
  var calls = '';
  var expected = INDICES_SUPPORT ? 'dgimsy' : 'gimsy';

  var addGetter = function (key, chr) {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(O, key, { get: function () {
      calls += chr;
      return true;
    } });
  };

  var pairs = {
    dotAll: 's',
    global: 'g',
    ignoreCase: 'i',
    multiline: 'm',
    sticky: 'y'
  };

  if (INDICES_SUPPORT) pairs.hasIndices = 'd';

  for (var key in pairs) addGetter(key, pairs[key]);

  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var result = Object.getOwnPropertyDescriptor(RegExpPrototype, 'flags').get.call(O);

  return result !== expected || calls !== expected;
});

// `RegExp.prototype.flags` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
if (FORCED) defineBuiltInAccessor(RegExpPrototype, 'flags', {
  configurable: true,
  get: regExpFlags
});


/***/ }),

/***/ 38781:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var PROPER_FUNCTION_NAME = (__webpack_require__(10350).PROPER);
var defineBuiltIn = __webpack_require__(36840);
var anObject = __webpack_require__(28551);
var $toString = __webpack_require__(655);
var fails = __webpack_require__(79039);
var getRegExpFlags = __webpack_require__(61034);

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) !== '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
    var R = anObject(this);
    var pattern = $toString(R.source);
    var flags = $toString(getRegExpFlags(R));
    return '/' + pattern + '/' + flags;
  }, { unsafe: true });
}


/***/ }),

/***/ 92405:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(16468);
var collectionStrong = __webpack_require__(86938);

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ 31415:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(92405);


/***/ }),

/***/ 27337:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var uncurryThis = __webpack_require__(79504);
var toAbsoluteIndex = __webpack_require__(35610);

var $RangeError = RangeError;
var fromCharCode = String.fromCharCode;
// eslint-disable-next-line es/no-string-fromcodepoint -- required for testing
var $fromCodePoint = String.fromCodePoint;
var join = uncurryThis([].join);

// length should be 1, old FF problem
var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;

// `String.fromCodePoint` method
// https://tc39.es/ecma262/#sec-string.fromcodepoint
$({ target: 'String', stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  fromCodePoint: function fromCodePoint(x) {
    var elements = [];
    var length = arguments.length;
    var i = 0;
    var code;
    while (length > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw new $RangeError(code + ' is not a valid code point');
      elements[i] = code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00);
    } return join(elements, '');
  }
});


/***/ }),

/***/ 21699:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var uncurryThis = __webpack_require__(79504);
var notARegExp = __webpack_require__(60511);
var requireObjectCoercible = __webpack_require__(67750);
var toString = __webpack_require__(655);
var correctIsRegExpLogic = __webpack_require__(41436);

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ }),

/***/ 47764:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(68183).charAt);
var toString = __webpack_require__(655);
var InternalStateModule = __webpack_require__(91181);
var defineIterator = __webpack_require__(51088);
var createIterResultObject = __webpack_require__(62529);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ 79978:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var call = __webpack_require__(69565);
var uncurryThis = __webpack_require__(79504);
var requireObjectCoercible = __webpack_require__(67750);
var isCallable = __webpack_require__(94901);
var isNullOrUndefined = __webpack_require__(64117);
var isRegExp = __webpack_require__(60788);
var toString = __webpack_require__(655);
var getMethod = __webpack_require__(55966);
var getRegExpFlags = __webpack_require__(61034);
var getSubstitution = __webpack_require__(2478);
var wellKnownSymbol = __webpack_require__(78227);
var IS_PURE = __webpack_require__(96395);

var REPLACE = wellKnownSymbol('replace');
var $TypeError = TypeError;
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var max = Math.max;

// `String.prototype.replaceAll` method
// https://tc39.es/ecma262/#sec-string.prototype.replaceall
$({ target: 'String', proto: true }, {
  replaceAll: function replaceAll(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
    var endOfLastMatch = 0;
    var result = '';
    if (!isNullOrUndefined(searchValue)) {
      IS_REG_EXP = isRegExp(searchValue);
      if (IS_REG_EXP) {
        flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
        if (!~indexOf(flags, 'g')) throw new $TypeError('`.replaceAll` does not allow non-global regexes');
      }
      replacer = getMethod(searchValue, REPLACE);
      if (replacer) return call(replacer, searchValue, O, replaceValue);
      if (IS_PURE && IS_REG_EXP) return replace(toString(O), searchValue, replaceValue);
    }
    string = toString(O);
    searchString = toString(searchValue);
    functionalReplace = isCallable(replaceValue);
    if (!functionalReplace) replaceValue = toString(replaceValue);
    searchLength = searchString.length;
    advanceBy = max(1, searchLength);
    position = indexOf(string, searchString);
    while (position !== -1) {
      replacement = functionalReplace
        ? toString(replaceValue(searchString, position, string))
        : getSubstitution(searchString, string, position, [], undefined, replaceValue);
      result += stringSlice(string, endOfLastMatch, position) + replacement;
      endOfLastMatch = position + searchLength;
      position = position + advanceBy > string.length ? -1 : indexOf(string, searchString, position + advanceBy);
    }
    if (endOfLastMatch < string.length) {
      result += stringSlice(string, endOfLastMatch);
    }
    return result;
  }
});


/***/ }),

/***/ 25440:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var apply = __webpack_require__(18745);
var call = __webpack_require__(69565);
var uncurryThis = __webpack_require__(79504);
var fixRegExpWellKnownSymbolLogic = __webpack_require__(89228);
var fails = __webpack_require__(79039);
var anObject = __webpack_require__(28551);
var isCallable = __webpack_require__(94901);
var isNullOrUndefined = __webpack_require__(64117);
var toIntegerOrInfinity = __webpack_require__(91291);
var toLength = __webpack_require__(18014);
var toString = __webpack_require__(655);
var requireObjectCoercible = __webpack_require__(67750);
var advanceStringIndex = __webpack_require__(57829);
var getMethod = __webpack_require__(55966);
var getSubstitution = __webpack_require__(2478);
var regExpExec = __webpack_require__(56682);
var wellKnownSymbol = __webpack_require__(78227);

var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var concat = uncurryThis([].concat);
var push = uncurryThis([].push);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = isNullOrUndefined(searchValue) ? undefined : getMethod(searchValue, REPLACE);
      return replacer
        ? call(replacer, searchValue, O, replaceValue)
        : call(nativeReplace, toString(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject(this);
      var S = toString(string);

      if (
        typeof replaceValue == 'string' &&
        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
        stringIndexOf(replaceValue, '$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = isCallable(replaceValue);
      if (!functionalReplace) replaceValue = toString(replaceValue);

      var global = rx.global;
      var fullUnicode;
      if (global) {
        fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }

      var results = [];
      var result;
      while (true) {
        result = regExpExec(rx, S);
        if (result === null) break;

        push(results, result);
        if (!global) break;

        var matchStr = toString(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString(result[0]);
        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        var replacement;
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position, S);
          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
          replacement = toString(apply(replaceValue, undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }

      return accumulatedResult + stringSlice(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);


/***/ }),

/***/ 42762:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var $trim = (__webpack_require__(43802).trim);
var forcedStringTrimMethod = __webpack_require__(60706);

// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ 66412:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(70511);

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ 6761:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);
var call = __webpack_require__(69565);
var uncurryThis = __webpack_require__(79504);
var IS_PURE = __webpack_require__(96395);
var DESCRIPTORS = __webpack_require__(43724);
var NATIVE_SYMBOL = __webpack_require__(4495);
var fails = __webpack_require__(79039);
var hasOwn = __webpack_require__(39297);
var isPrototypeOf = __webpack_require__(1625);
var anObject = __webpack_require__(28551);
var toIndexedObject = __webpack_require__(25397);
var toPropertyKey = __webpack_require__(56969);
var $toString = __webpack_require__(655);
var createPropertyDescriptor = __webpack_require__(6980);
var nativeObjectCreate = __webpack_require__(2360);
var objectKeys = __webpack_require__(71072);
var getOwnPropertyNamesModule = __webpack_require__(38480);
var getOwnPropertyNamesExternal = __webpack_require__(10298);
var getOwnPropertySymbolsModule = __webpack_require__(33717);
var getOwnPropertyDescriptorModule = __webpack_require__(77347);
var definePropertyModule = __webpack_require__(24913);
var definePropertiesModule = __webpack_require__(96801);
var propertyIsEnumerableModule = __webpack_require__(48773);
var defineBuiltIn = __webpack_require__(36840);
var defineBuiltInAccessor = __webpack_require__(62106);
var shared = __webpack_require__(25745);
var sharedKey = __webpack_require__(66119);
var hiddenKeys = __webpack_require__(30421);
var uid = __webpack_require__(33392);
var wellKnownSymbol = __webpack_require__(78227);
var wrappedWellKnownSymbolModule = __webpack_require__(1951);
var defineWellKnownSymbol = __webpack_require__(70511);
var defineSymbolToPrimitive = __webpack_require__(58242);
var setToStringTag = __webpack_require__(10687);
var InternalStateModule = __webpack_require__(91181);
var $forEach = (__webpack_require__(59213).forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = globalThis.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var RangeError = globalThis.RangeError;
var TypeError = globalThis.TypeError;
var QObject = globalThis.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var fallbackDefineProperty = function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
};

var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a !== 7;
}) ? fallbackDefineProperty : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      var $this = this === undefined ? globalThis : this;
      if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
      var descriptor = createPropertyDescriptor(1, value);
      try {
        setSymbolDescriptor($this, tag, descriptor);
      } catch (error) {
        if (!(error instanceof RangeError)) throw error;
        fallbackDefineProperty($this, tag, descriptor);
      }
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ 89463:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(46518);
var DESCRIPTORS = __webpack_require__(43724);
var globalThis = __webpack_require__(22195);
var uncurryThis = __webpack_require__(79504);
var hasOwn = __webpack_require__(39297);
var isCallable = __webpack_require__(94901);
var isPrototypeOf = __webpack_require__(1625);
var toString = __webpack_require__(655);
var defineBuiltInAccessor = __webpack_require__(62106);
var copyConstructorProperties = __webpack_require__(77740);

var NativeSymbol = globalThis.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      // eslint-disable-next-line sonarjs/inconsistent-function-call -- ok
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('description detection')) === 'Symbol(description detection)';
  var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineBuiltInAccessor(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ 81510:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var getBuiltIn = __webpack_require__(97751);
var hasOwn = __webpack_require__(39297);
var toString = __webpack_require__(655);
var shared = __webpack_require__(25745);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(91296);

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ 2259:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(70511);

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ 52675:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(6761);
__webpack_require__(81510);
__webpack_require__(97812);
__webpack_require__(33110);
__webpack_require__(49773);


/***/ }),

/***/ 97812:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var hasOwn = __webpack_require__(39297);
var isSymbol = __webpack_require__(10757);
var tryToString = __webpack_require__(16823);
var shared = __webpack_require__(25745);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(91296);

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ 45700:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(70511);
var defineSymbolToPrimitive = __webpack_require__(58242);

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ 78125:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(97751);
var defineWellKnownSymbol = __webpack_require__(70511);
var setToStringTag = __webpack_require__(10687);

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');


/***/ }),

/***/ 81630:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(79504);
var ArrayBufferViewCore = __webpack_require__(94644);
var $ArrayCopyWithin = __webpack_require__(57029);

var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ 72170:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $every = (__webpack_require__(59213).every);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 75044:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $fill = __webpack_require__(84373);
var toBigInt = __webpack_require__(75854);
var classof = __webpack_require__(36955);
var call = __webpack_require__(69565);
var uncurryThis = __webpack_require__(79504);
var fails = __webpack_require__(79039);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var slice = uncurryThis(''.slice);

// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18
var CONVERSION_BUG = fails(function () {
  var count = 0;
  // eslint-disable-next-line es/no-typed-arrays -- safe
  new Int8Array(2).fill({ valueOf: function () { return count++; } });
  return count !== 1;
});

// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  var length = arguments.length;
  aTypedArray(this);
  var actualValue = slice(classof(this), 0, 3) === 'Big' ? toBigInt(value) : +value;
  return call($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
}, CONVERSION_BUG);


/***/ }),

/***/ 69539:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $filter = (__webpack_require__(59213).filter);
var fromSameTypeAndList = __webpack_require__(29948);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSameTypeAndList(this, list);
});


/***/ }),

/***/ 89955:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $findIndex = (__webpack_require__(59213).findIndex);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 31694:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $find = (__webpack_require__(59213).find);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 34594:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Float32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 29833:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Float64Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 33206:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $forEach = (__webpack_require__(59213).forEach);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 44496:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $includes = (__webpack_require__(19617).includes);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 66651:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $indexOf = (__webpack_require__(19617).indexOf);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 72107:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Int16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int16', function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 95477:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Int32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 46594:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Int8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 12887:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var fails = __webpack_require__(79039);
var uncurryThis = __webpack_require__(79504);
var ArrayBufferViewCore = __webpack_require__(94644);
var ArrayIterators = __webpack_require__(23792);
var wellKnownSymbol = __webpack_require__(78227);

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = globalThis.Uint8Array;
var arrayValues = uncurryThis(ArrayIterators.values);
var arrayKeys = uncurryThis(ArrayIterators.keys);
var arrayEntries = uncurryThis(ArrayIterators.entries);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TypedArrayPrototype = Uint8Array && Uint8Array.prototype;

var GENERIC = !fails(function () {
  TypedArrayPrototype[ITERATOR].call([1]);
});

var ITERATOR_IS_VALUES = !!TypedArrayPrototype
  && TypedArrayPrototype.values
  && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values
  && TypedArrayPrototype.values.name === 'values';

var typedArrayValues = function values() {
  return arrayValues(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });


/***/ }),

/***/ 19369:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var uncurryThis = __webpack_require__(79504);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = uncurryThis([].join);

// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
exportTypedArrayMethod('join', function join(separator) {
  return $join(aTypedArray(this), separator);
});


/***/ }),

/***/ 66812:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var apply = __webpack_require__(18745);
var $lastIndexOf = __webpack_require__(8379);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  var length = arguments.length;
  return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
});


/***/ }),

/***/ 8995:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $map = (__webpack_require__(59213).map);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (getTypedArrayConstructor(O))(length);
  });
});


/***/ }),

/***/ 52568:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(72805);

var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;

// `%TypedArray%.of` method
// https://tc39.es/ecma262/#sec-%typedarray%.of
exportTypedArrayStaticMethod('of', function of(/* ...items */) {
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor(this))(length);
  while (length > index) result[index] = arguments[index++];
  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);


/***/ }),

/***/ 36072:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $reduceRight = (__webpack_require__(80926).right);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRight` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 31575:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $reduce = (__webpack_require__(80926).left);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 88747:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ 28845:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var call = __webpack_require__(69565);
var ArrayBufferViewCore = __webpack_require__(94644);
var lengthOfArrayLike = __webpack_require__(26198);
var toOffset = __webpack_require__(58229);
var toIndexedObject = __webpack_require__(48981);
var fails = __webpack_require__(79039);

var RangeError = globalThis.RangeError;
var Int8Array = globalThis.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  var array = new Uint8ClampedArray(2);
  call($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});

// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
  var array = new Int8Array(2);
  array.set(1);
  array.set('2', 1);
  return array[0] !== 0 || array[1] !== 2;
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var src = toIndexedObject(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike(src);
  var index = 0;
  if (len + offset > length) throw new RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);


/***/ }),

/***/ 29423:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var fails = __webpack_require__(79039);
var arraySlice = __webpack_require__(67680);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = arraySlice(aTypedArray(this), start, end);
  var C = getTypedArrayConstructor(this);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ 57301:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var $some = (__webpack_require__(59213).some);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 373:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var uncurryThis = __webpack_require__(27476);
var fails = __webpack_require__(79039);
var aCallable = __webpack_require__(79306);
var internalSort = __webpack_require__(74488);
var ArrayBufferViewCore = __webpack_require__(94644);
var FF = __webpack_require__(13709);
var IE_OR_EDGE = __webpack_require__(13763);
var V8 = __webpack_require__(39519);
var WEBKIT = __webpack_require__(3607);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var Uint16Array = globalThis.Uint16Array;
var nativeSort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);

// WebKit
var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function () {
  nativeSort(new Uint16Array(2), null);
}) && fails(function () {
  nativeSort(new Uint16Array(2), {});
}));

var STABLE_SORT = !!nativeSort && !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 74;
  if (FF) return FF < 67;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 602;

  var array = new Uint16Array(516);
  var expected = Array(516);
  var index, mod;

  for (index = 0; index < 516; index++) {
    mod = index % 4;
    array[index] = 515 - index;
    expected[index] = index - 2 * mod + 3;
  }

  nativeSort(array, function (a, b) {
    return (a / 4 | 0) - (b / 4 | 0);
  });

  for (index = 0; index < 516; index++) {
    if (array[index] !== expected[index]) return true;
  }
});

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (y !== y) return -1;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (x !== x) return 1;
    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
    return x > y;
  };
};

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  if (comparefn !== undefined) aCallable(comparefn);
  if (STABLE_SORT) return nativeSort(this, comparefn);

  return internalSort(aTypedArray(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);


/***/ }),

/***/ 86614:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(94644);
var toLength = __webpack_require__(18014);
var toAbsoluteIndex = __webpack_require__(35610);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  var C = getTypedArrayConstructor(O);
  return new C(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ 41405:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var apply = __webpack_require__(18745);
var ArrayBufferViewCore = __webpack_require__(94644);
var fails = __webpack_require__(79039);
var arraySlice = __webpack_require__(67680);

var Int8Array = globalThis.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() !== new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return apply(
    $toLocaleString,
    TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
    arraySlice(arguments)
  );
}, FORCED);


/***/ }),

/***/ 33684:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var exportTypedArrayMethod = (__webpack_require__(94644).exportTypedArrayMethod);
var fails = __webpack_require__(79039);
var globalThis = __webpack_require__(22195);
var uncurryThis = __webpack_require__(79504);

var Uint8Array = globalThis.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var join = uncurryThis([].join);

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return join(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);


/***/ }),

/***/ 3690:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Uint16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint16', function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 61740:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Uint32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint32', function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 21489:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 22134:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createTypedArrayConstructor = __webpack_require__(15823);

// `Uint8ClampedArray` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),

/***/ 65746:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var FREEZING = __webpack_require__(92744);
var globalThis = __webpack_require__(22195);
var uncurryThis = __webpack_require__(79504);
var defineBuiltIns = __webpack_require__(56279);
var InternalMetadataModule = __webpack_require__(3451);
var collection = __webpack_require__(16468);
var collectionWeak = __webpack_require__(91625);
var isObject = __webpack_require__(20034);
var enforceInternalState = (__webpack_require__(91181).enforce);
var fails = __webpack_require__(79039);
var NATIVE_WEAK_MAP = __webpack_require__(58622);

var $Object = Object;
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray = Array.isArray;
// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = $Object.isExtensible;
// eslint-disable-next-line es/no-object-isfrozen -- safe
var isFrozen = $Object.isFrozen;
// eslint-disable-next-line es/no-object-issealed -- safe
var isSealed = $Object.isSealed;
// eslint-disable-next-line es/no-object-freeze -- safe
var freeze = $Object.freeze;
// eslint-disable-next-line es/no-object-seal -- safe
var seal = $Object.seal;

var IS_IE11 = !globalThis.ActiveXObject && 'ActiveXObject' in globalThis;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap = collection('WeakMap', wrapper, collectionWeak);
var WeakMapPrototype = $WeakMap.prototype;
var nativeSet = uncurryThis(WeakMapPrototype.set);

// Chakra Edge bug: adding frozen arrays to WeakMap unfreeze them
var hasMSEdgeFreezingBug = function () {
  return FREEZING && fails(function () {
    var frozenArray = freeze([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen(frozenArray);
  });
};

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP) if (IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  defineBuiltIns(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      } return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      } return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      } return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);
      return this;
    }
  });
// Chakra Edge frozen keys fix
} else if (hasMSEdgeFreezingBug()) {
  defineBuiltIns(WeakMapPrototype, {
    set: function set(key, value) {
      var arrayIntegrityLevel;
      if (isArray(key)) {
        if (isFrozen(key)) arrayIntegrityLevel = freeze;
        else if (isSealed(key)) arrayIntegrityLevel = seal;
      }
      nativeSet(this, key, value);
      if (arrayIntegrityLevel) arrayIntegrityLevel(key);
      return this;
    }
  });
}


/***/ }),

/***/ 73772:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(65746);


/***/ }),

/***/ 62480:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(55081);


/***/ }),

/***/ 35874:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(96167);


/***/ }),

/***/ 12041:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(79978);


/***/ }),

/***/ 23500:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var DOMIterables = __webpack_require__(67400);
var DOMTokenListPrototype = __webpack_require__(79296);
var forEach = __webpack_require__(90235);
var createNonEnumerableProperty = __webpack_require__(66699);

var handlePrototype = function (CollectionPrototype) {
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype);
  }
}

handlePrototype(DOMTokenListPrototype);


/***/ }),

/***/ 62953:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(22195);
var DOMIterables = __webpack_require__(67400);
var DOMTokenListPrototype = __webpack_require__(79296);
var ArrayIteratorMethods = __webpack_require__(23792);
var createNonEnumerableProperty = __webpack_require__(66699);
var setToStringTag = __webpack_require__(10687);
var wellKnownSymbol = __webpack_require__(78227);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    setToStringTag(CollectionPrototype, COLLECTION_NAME, true);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');


/***/ }),

/***/ 15575:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);
var schedulersFix = __webpack_require__(79472);

var setInterval = schedulersFix(globalThis.setInterval, true);

// Bun / IE9- setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
$({ global: true, bind: true, forced: globalThis.setInterval !== setInterval }, {
  setInterval: setInterval
});


/***/ }),

/***/ 24599:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);
var schedulersFix = __webpack_require__(79472);

var setTimeout = schedulersFix(globalThis.setTimeout, true);

// Bun / IE9- setTimeout additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
$({ global: true, bind: true, forced: globalThis.setTimeout !== setTimeout }, {
  setTimeout: setTimeout
});


/***/ }),

/***/ 76031:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(15575);
__webpack_require__(24599);


/***/ }),

/***/ 98406:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(23792);
__webpack_require__(27337);
var $ = __webpack_require__(46518);
var globalThis = __webpack_require__(22195);
var safeGetBuiltIn = __webpack_require__(93389);
var getBuiltIn = __webpack_require__(97751);
var call = __webpack_require__(69565);
var uncurryThis = __webpack_require__(79504);
var DESCRIPTORS = __webpack_require__(43724);
var USE_NATIVE_URL = __webpack_require__(67416);
var defineBuiltIn = __webpack_require__(36840);
var defineBuiltInAccessor = __webpack_require__(62106);
var defineBuiltIns = __webpack_require__(56279);
var setToStringTag = __webpack_require__(10687);
var createIteratorConstructor = __webpack_require__(33994);
var InternalStateModule = __webpack_require__(91181);
var anInstance = __webpack_require__(90679);
var isCallable = __webpack_require__(94901);
var hasOwn = __webpack_require__(39297);
var bind = __webpack_require__(76080);
var classof = __webpack_require__(36955);
var anObject = __webpack_require__(28551);
var isObject = __webpack_require__(20034);
var $toString = __webpack_require__(655);
var create = __webpack_require__(2360);
var createPropertyDescriptor = __webpack_require__(6980);
var getIterator = __webpack_require__(70081);
var getIteratorMethod = __webpack_require__(50851);
var createIterResultObject = __webpack_require__(62529);
var validateArgumentsLength = __webpack_require__(22812);
var wellKnownSymbol = __webpack_require__(78227);
var arraySort = __webpack_require__(74488);

var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var nativeFetch = safeGetBuiltIn('fetch');
var NativeRequest = safeGetBuiltIn('Request');
var Headers = safeGetBuiltIn('Headers');
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var TypeError = globalThis.TypeError;
var encodeURIComponent = globalThis.encodeURIComponent;
var fromCharCode = String.fromCharCode;
var fromCodePoint = getBuiltIn('String', 'fromCodePoint');
var $parseInt = parseInt;
var charAt = uncurryThis(''.charAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var splice = uncurryThis([].splice);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var exec = uncurryThis(/./.exec);

var plus = /\+/g;
var FALLBACK_REPLACER = '\uFFFD';
var VALID_HEX = /^[0-9a-f]+$/i;

var parseHexOctet = function (string, start) {
  var substr = stringSlice(string, start, start + 2);
  if (!exec(VALID_HEX, substr)) return NaN;

  return $parseInt(substr, 16);
};

var getLeadingOnes = function (octet) {
  var count = 0;
  for (var mask = 0x80; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
    count++;
  }
  return count;
};

var utf8Decode = function (octets) {
  var codePoint = null;

  switch (octets.length) {
    case 1:
      codePoint = octets[0];
      break;
    case 2:
      codePoint = (octets[0] & 0x1F) << 6 | (octets[1] & 0x3F);
      break;
    case 3:
      codePoint = (octets[0] & 0x0F) << 12 | (octets[1] & 0x3F) << 6 | (octets[2] & 0x3F);
      break;
    case 4:
      codePoint = (octets[0] & 0x07) << 18 | (octets[1] & 0x3F) << 12 | (octets[2] & 0x3F) << 6 | (octets[3] & 0x3F);
      break;
  }

  return codePoint > 0x10FFFF ? null : codePoint;
};

var decode = function (input) {
  input = replace(input, plus, ' ');
  var length = input.length;
  var result = '';
  var i = 0;

  while (i < length) {
    var decodedChar = charAt(input, i);

    if (decodedChar === '%') {
      if (charAt(input, i + 1) === '%' || i + 3 > length) {
        result += '%';
        i++;
        continue;
      }

      var octet = parseHexOctet(input, i + 1);

      // eslint-disable-next-line no-self-compare -- NaN check
      if (octet !== octet) {
        result += decodedChar;
        i++;
        continue;
      }

      i += 2;
      var byteSequenceLength = getLeadingOnes(octet);

      if (byteSequenceLength === 0) {
        decodedChar = fromCharCode(octet);
      } else {
        if (byteSequenceLength === 1 || byteSequenceLength > 4) {
          result += FALLBACK_REPLACER;
          i++;
          continue;
        }

        var octets = [octet];
        var sequenceIndex = 1;

        while (sequenceIndex < byteSequenceLength) {
          i++;
          if (i + 3 > length || charAt(input, i) !== '%') break;

          var nextByte = parseHexOctet(input, i + 1);

          // eslint-disable-next-line no-self-compare -- NaN check
          if (nextByte !== nextByte) {
            i += 3;
            break;
          }
          if (nextByte > 191 || nextByte < 128) break;

          push(octets, nextByte);
          i += 2;
          sequenceIndex++;
        }

        if (octets.length !== byteSequenceLength) {
          result += FALLBACK_REPLACER;
          continue;
        }

        var codePoint = utf8Decode(octets);
        if (codePoint === null) {
          result += FALLBACK_REPLACER;
        } else {
          decodedChar = fromCodePoint(codePoint);
        }
      }
    }

    result += decodedChar;
    i++;
  }

  return result;
};

var find = /[!'()~]|%20/g;

var replacements = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replacements[match];
};

var serialize = function (it) {
  return replace(encodeURIComponent(it), find, replacer);
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    target: getInternalParamsState(params).entries,
    index: 0,
    kind: kind
  });
}, URL_SEARCH_PARAMS, function next() {
  var state = getInternalIteratorState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(undefined, true);
  }
  var entry = target[index];
  switch (state.kind) {
    case 'keys': return createIterResultObject(entry.key, false);
    case 'values': return createIterResultObject(entry.value, false);
  } return createIterResultObject([entry.key, entry.value], false);
}, true);

var URLSearchParamsState = function (init) {
  this.entries = [];
  this.url = null;

  if (init !== undefined) {
    if (isObject(init)) this.parseObject(init);
    else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
  }
};

URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function (url) {
    this.url = url;
    this.update();
  },
  parseObject: function (object) {
    var entries = this.entries;
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next, step, entryIterator, entryNext, first, second;

    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next = iterator.next;
      while (!(step = call(next, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if (
          (first = call(entryNext, entryIterator)).done ||
          (second = call(entryNext, entryIterator)).done ||
          !call(entryNext, entryIterator).done
        ) throw new TypeError('Expected sequence with length 2');
        push(entries, { key: $toString(first.value), value: $toString(second.value) });
      }
    } else for (var key in object) if (hasOwn(object, key)) {
      push(entries, { key: key, value: $toString(object[key]) });
    }
  },
  parseQuery: function (query) {
    if (query) {
      var entries = this.entries;
      var attributes = split(query, '&');
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split(attribute, '=');
          push(entries, {
            key: decode(shift(entry)),
            value: decode(join(entry, '='))
          });
        }
      }
    }
  },
  serialize: function () {
    var entries = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      push(result, serialize(entry.key) + '=' + serialize(entry.value));
    } return join(result, '&');
  },
  update: function () {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function () {
    if (this.url) this.url.update();
  }
};

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsPrototype);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var state = setInternalState(this, new URLSearchParamsState(init));
  if (!DESCRIPTORS) this.size = state.entries.length;
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

defineBuiltIns(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 2);
    push(state.entries, { key: $toString(name), value: $toString(value) });
    if (!DESCRIPTORS) this.length++;
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name /* , value */) {
    var state = getInternalParamsState(this);
    var length = validateArgumentsLength(arguments.length, 1);
    var entries = state.entries;
    var key = $toString(name);
    var $value = length < 2 ? undefined : arguments[1];
    var value = $value === undefined ? $value : $toString($value);
    var index = 0;
    while (index < entries.length) {
      var entry = entries[index];
      if (entry.key === key && (value === undefined || entry.value === value)) {
        splice(entries, index, 1);
        if (value !== undefined) break;
      } else index++;
    }
    if (!DESCRIPTORS) this.size = entries.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    var entries = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    var entries = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) push(result, entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name /* , value */) {
    var entries = getInternalParamsState(this).entries;
    var length = validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var $value = length < 2 ? undefined : arguments[1];
    var value = $value === undefined ? $value : $toString($value);
    var index = 0;
    while (index < entries.length) {
      var entry = entries[index++];
      if (entry.key === key && (value === undefined || entry.value === value)) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 1);
    var entries = state.entries;
    var found = false;
    var key = $toString(name);
    var val = $toString(value);
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) splice(entries, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push(entries, { key: key, value: val });
    if (!DESCRIPTORS) this.size = entries.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function (a, b) {
      return a.key > b.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
defineBuiltIn(URLSearchParamsPrototype, 'toString', function toString() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
  get: function size() {
    return getInternalParamsState(this).entries.length;
  },
  configurable: true,
  enumerable: true
});

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && isCallable(Headers)) {
  var headersHas = uncurryThis(HeadersPrototype.has);
  var headersSet = uncurryThis(HeadersPrototype.set);

  var wrapRequestOptions = function (init) {
    if (isObject(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers(init.headers) : new Headers();
        if (!headersHas(headers, 'content-type')) {
          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
        return create(init, {
          body: createPropertyDescriptor(0, $toString(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    } return init;
  };

  if (isCallable(nativeFetch)) {
    $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
      fetch: function fetch(input /* , init */) {
        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }

  if (isCallable(NativeRequest)) {
    var RequestConstructor = function Request(input /* , init */) {
      anInstance(this, RequestPrototype);
      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };

    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;

    $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ 48408:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(98406);


/***/ }),

/***/ 45806:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(47764);
var $ = __webpack_require__(46518);
var DESCRIPTORS = __webpack_require__(43724);
var USE_NATIVE_URL = __webpack_require__(67416);
var globalThis = __webpack_require__(22195);
var bind = __webpack_require__(76080);
var uncurryThis = __webpack_require__(79504);
var defineBuiltIn = __webpack_require__(36840);
var defineBuiltInAccessor = __webpack_require__(62106);
var anInstance = __webpack_require__(90679);
var hasOwn = __webpack_require__(39297);
var assign = __webpack_require__(44213);
var arrayFrom = __webpack_require__(97916);
var arraySlice = __webpack_require__(67680);
var codeAt = (__webpack_require__(68183).codeAt);
var toASCII = __webpack_require__(3717);
var $toString = __webpack_require__(655);
var setToStringTag = __webpack_require__(10687);
var validateArgumentsLength = __webpack_require__(22812);
var URLSearchParamsModule = __webpack_require__(98406);
var InternalStateModule = __webpack_require__(91181);

var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;

var NativeURL = globalThis.URL;
var TypeError = globalThis.TypeError;
var parseInt = globalThis.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(/./.exec);
var join = uncurryThis([].join);
var numberToString = uncurryThis(1.0.toString);
var pop = uncurryThis([].pop);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var toLowerCase = uncurryThis(''.toLowerCase);
var unshift = uncurryThis([].unshift);

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[a-z]/i;
// eslint-disable-next-line regexp/no-obscure-range -- safe
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
/* eslint-disable regexp/no-control-character -- safe */
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
/* eslint-enable regexp/no-control-character -- safe */
var EOF;

// https://url.spec.whatwg.org/#ipv4-number-parser
var parseIPv4 = function (input) {
  var parts = split(input, '.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] === '') {
    parts.length--;
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part === '') return input;
    radix = 10;
    if (part.length > 1 && charAt(part, 0) === '0') {
      radix = exec(HEX_START, part) ? 16 : 8;
      part = stringSlice(part, radix === 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
      number = parseInt(part, radix);
    }
    push(numbers, number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index === partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = pop(numbers);
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// https://url.spec.whatwg.org/#concept-ipv6-parser
// eslint-disable-next-line max-statements -- TODO
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var chr = function () {
    return charAt(input, pointer);
  };

  if (chr() === ':') {
    if (charAt(input, 1) !== ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (chr()) {
    if (pieceIndex === 8) return;
    if (chr() === ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && exec(HEX, chr())) {
      value = value * 16 + parseInt(chr(), 16);
      pointer++;
      length++;
    }
    if (chr() === '.') {
      if (length === 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (chr()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (chr() === '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!exec(DIGIT, chr())) return;
        while (exec(DIGIT, chr())) {
          number = parseInt(chr(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece === 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
      }
      if (numbersSeen !== 4) return;
      break;
    } else if (chr() === ':') {
      pointer++;
      if (!chr()) return;
    } else if (chr()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex !== 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  return currLength > maxLength ? currStart : maxIndex;
};

// https://url.spec.whatwg.org/#host-serializing
var serializeHost = function (host) {
  var result, index, compress, ignore0;

  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      unshift(result, host % 256);
      host = floor(host / 256);
    }
    return join(result, '.');
  }

  // ipv6
  if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += numberToString(host[index], 16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  }

  return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (chr, set) {
  var code = codeAt(chr, 0);
  return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
};

// https://url.spec.whatwg.org/#special-scheme
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

// https://url.spec.whatwg.org/#windows-drive-letter
var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length === 2 && exec(ALPHA, charAt(string, 0))
    && ((second = charAt(string, 1)) === ':' || (!normalized && second === '|'));
};

// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (
    string.length === 2 ||
    ((third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

// https://url.spec.whatwg.org/#single-dot-path-segment
var isSingleDot = function (segment) {
  return segment === '.' || toLowerCase(segment) === '%2e';
};

// https://url.spec.whatwg.org/#double-dot-path-segment
var isDoubleDot = function (segment) {
  segment = toLowerCase(segment);
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

var URLState = function (url, isBase, base) {
  var urlString = $toString(url);
  var baseState, failure, searchParams;
  if (isBase) {
    failure = this.parse(urlString);
    if (failure) throw new TypeError(failure);
    this.searchParams = null;
  } else {
    if (base !== undefined) baseState = new URLState(base, true);
    failure = this.parse(urlString, null, baseState);
    if (failure) throw new TypeError(failure);
    searchParams = getInternalSearchParamsState(new URLSearchParams());
    searchParams.bindURL(this);
    this.searchParams = searchParams;
  }
};

URLState.prototype = {
  type: 'URL',
  // https://url.spec.whatwg.org/#url-parsing
  // eslint-disable-next-line max-statements -- TODO
  parse: function (input, stateOverride, base) {
    var url = this;
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = '';
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints, chr, bufferCodePoints, failure;

    input = $toString(input);

    if (!stateOverride) {
      url.scheme = '';
      url.username = '';
      url.password = '';
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = replace(input, LEADING_C0_CONTROL_OR_SPACE, '');
      input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, '$1');
    }

    input = replace(input, TAB_AND_NEW_LINE, '');

    codePoints = arrayFrom(input);

    while (pointer <= codePoints.length) {
      chr = codePoints[pointer];
      switch (state) {
        case SCHEME_START:
          if (chr && exec(ALPHA, chr)) {
            buffer += toLowerCase(chr);
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;

        case SCHEME:
          if (chr && (exec(ALPHANUMERIC, chr) || chr === '+' || chr === '-' || chr === '.')) {
            buffer += toLowerCase(chr);
          } else if (chr === ':') {
            if (stateOverride && (
              (url.isSpecial() !== hasOwn(specialSchemes, buffer)) ||
              (buffer === 'file' && (url.includesCredentials() || url.port !== null)) ||
              (url.scheme === 'file' && !url.host)
            )) return;
            url.scheme = buffer;
            if (stateOverride) {
              if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
              return;
            }
            buffer = '';
            if (url.scheme === 'file') {
              state = FILE;
            } else if (url.isSpecial() && base && base.scheme === url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (url.isSpecial()) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints[pointer + 1] === '/') {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              push(url.path, '');
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer = '';
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;

        case NO_SCHEME:
          if (!base || (base.cannotBeABaseURL && chr !== '#')) return INVALID_SCHEME;
          if (base.cannotBeABaseURL && chr === '#') {
            url.scheme = base.scheme;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base.scheme === 'file' ? FILE : RELATIVE;
          continue;

        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (chr === '/' && codePoints[pointer + 1] === '/') {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          } break;

        case PATH_OR_AUTHORITY:
          if (chr === '/') {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }

        case RELATIVE:
          url.scheme = base.scheme;
          if (chr === EOF) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
          } else if (chr === '/' || (chr === '\\' && url.isSpecial())) {
            state = RELATIVE_SLASH;
          } else if (chr === '?') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = '';
            state = QUERY;
          } else if (chr === '#') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.path.length--;
            state = PATH;
            continue;
          } break;

        case RELATIVE_SLASH:
          if (url.isSpecial() && (chr === '/' || chr === '\\')) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (chr === '/') {
            state = AUTHORITY;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            state = PATH;
            continue;
          } break;

        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (chr !== '/' || charAt(buffer, pointer + 1) !== '/') continue;
          pointer++;
          break;

        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (chr !== '/' && chr !== '\\') {
            state = AUTHORITY;
            continue;
          } break;

        case AUTHORITY:
          if (chr === '@') {
            if (seenAt) buffer = '%40' + buffer;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer);
            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint === ':' && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer = '';
          } else if (
            chr === EOF || chr === '/' || chr === '?' || chr === '#' ||
            (chr === '\\' && url.isSpecial())
          ) {
            if (seenAt && buffer === '') return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer).length + 1;
            buffer = '';
            state = HOST;
          } else buffer += chr;
          break;

        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme === 'file') {
            state = FILE_HOST;
            continue;
          } else if (chr === ':' && !seenBracket) {
            if (buffer === '') return INVALID_HOST;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PORT;
            if (stateOverride === HOSTNAME) return;
          } else if (
            chr === EOF || chr === '/' || chr === '?' || chr === '#' ||
            (chr === '\\' && url.isSpecial())
          ) {
            if (url.isSpecial() && buffer === '') return INVALID_HOST;
            if (stateOverride && buffer === '' && (url.includesCredentials() || url.port !== null)) return;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (chr === '[') seenBracket = true;
            else if (chr === ']') seenBracket = false;
            buffer += chr;
          } break;

        case PORT:
          if (exec(DIGIT, chr)) {
            buffer += chr;
          } else if (
            chr === EOF || chr === '/' || chr === '?' || chr === '#' ||
            (chr === '\\' && url.isSpecial()) ||
            stateOverride
          ) {
            if (buffer !== '') {
              var port = parseInt(buffer, 10);
              if (port > 0xFFFF) return INVALID_PORT;
              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;
              buffer = '';
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;

        case FILE:
          url.scheme = 'file';
          if (chr === '/' || chr === '\\') state = FILE_SLASH;
          else if (base && base.scheme === 'file') {
            switch (chr) {
              case EOF:
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.query = base.query;
                break;
              case '?':
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.query = '';
                state = QUERY;
                break;
              case '#':
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = '';
                state = FRAGMENT;
                break;
              default:
                if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                  url.host = base.host;
                  url.path = arraySlice(base.path);
                  url.shortenPath();
                }
                state = PATH;
                continue;
            }
          } else {
            state = PATH;
            continue;
          } break;

        case FILE_SLASH:
          if (chr === '/' || chr === '\\') {
            state = FILE_HOST;
            break;
          }
          if (base && base.scheme === 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
            if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
            else url.host = base.host;
          }
          state = PATH;
          continue;

        case FILE_HOST:
          if (chr === EOF || chr === '/' || chr === '\\' || chr === '?' || chr === '#') {
            if (!stateOverride && isWindowsDriveLetter(buffer)) {
              state = PATH;
            } else if (buffer === '') {
              url.host = '';
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = url.parseHost(buffer);
              if (failure) return failure;
              if (url.host === 'localhost') url.host = '';
              if (stateOverride) return;
              buffer = '';
              state = PATH_START;
            } continue;
          } else buffer += chr;
          break;

        case PATH_START:
          if (url.isSpecial()) {
            state = PATH;
            if (chr !== '/' && chr !== '\\') continue;
          } else if (!stateOverride && chr === '?') {
            url.query = '';
            state = QUERY;
          } else if (!stateOverride && chr === '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr !== EOF) {
            state = PATH;
            if (chr !== '/') continue;
          } break;

        case PATH:
          if (
            chr === EOF || chr === '/' ||
            (chr === '\\' && url.isSpecial()) ||
            (!stateOverride && (chr === '?' || chr === '#'))
          ) {
            if (isDoubleDot(buffer)) {
              url.shortenPath();
              if (chr !== '/' && !(chr === '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else if (isSingleDot(buffer)) {
              if (chr !== '/' && !(chr === '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else {
              if (url.scheme === 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                if (url.host) url.host = '';
                buffer = charAt(buffer, 0) + ':'; // normalize windows drive letter
              }
              push(url.path, buffer);
            }
            buffer = '';
            if (url.scheme === 'file' && (chr === EOF || chr === '?' || chr === '#')) {
              while (url.path.length > 1 && url.path[0] === '') {
                shift(url.path);
              }
            }
            if (chr === '?') {
              url.query = '';
              state = QUERY;
            } else if (chr === '#') {
              url.fragment = '';
              state = FRAGMENT;
            }
          } else {
            buffer += percentEncode(chr, pathPercentEncodeSet);
          } break;

        case CANNOT_BE_A_BASE_URL_PATH:
          if (chr === '?') {
            url.query = '';
            state = QUERY;
          } else if (chr === '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr !== EOF) {
            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case QUERY:
          if (!stateOverride && chr === '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr !== EOF) {
            if (chr === "'" && url.isSpecial()) url.query += '%27';
            else if (chr === '#') url.query += '%23';
            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case FRAGMENT:
          if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
          break;
      }

      pointer++;
    }
  },
  // https://url.spec.whatwg.org/#host-parsing
  parseHost: function (input) {
    var result, codePoints, index;
    if (charAt(input, 0) === '[') {
      if (charAt(input, input.length - 1) !== ']') return INVALID_HOST;
      result = parseIPv6(stringSlice(input, 1, -1));
      if (!result) return INVALID_HOST;
      this.host = result;
    // opaque host
    } else if (!this.isSpecial()) {
      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
      result = '';
      codePoints = arrayFrom(input);
      for (index = 0; index < codePoints.length; index++) {
        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
      }
      this.host = result;
    } else {
      input = toASCII(input);
      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      this.host = result;
    }
  },
  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
  cannotHaveUsernamePasswordPort: function () {
    return !this.host || this.cannotBeABaseURL || this.scheme === 'file';
  },
  // https://url.spec.whatwg.org/#include-credentials
  includesCredentials: function () {
    return this.username !== '' || this.password !== '';
  },
  // https://url.spec.whatwg.org/#is-special
  isSpecial: function () {
    return hasOwn(specialSchemes, this.scheme);
  },
  // https://url.spec.whatwg.org/#shorten-a-urls-path
  shortenPath: function () {
    var path = this.path;
    var pathSize = path.length;
    if (pathSize && (this.scheme !== 'file' || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
      path.length--;
    }
  },
  // https://url.spec.whatwg.org/#concept-url-serializer
  serialize: function () {
    var url = this;
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port = url.port;
    var path = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ':';
    if (host !== null) {
      output += '//';
      if (url.includesCredentials()) {
        output += username + (password ? ':' + password : '') + '@';
      }
      output += serializeHost(host);
      if (port !== null) output += ':' + port;
    } else if (scheme === 'file') output += '//';
    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
    if (query !== null) output += '?' + query;
    if (fragment !== null) output += '#' + fragment;
    return output;
  },
  // https://url.spec.whatwg.org/#dom-url-href
  setHref: function (href) {
    var failure = this.parse(href);
    if (failure) throw new TypeError(failure);
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-origin
  getOrigin: function () {
    var scheme = this.scheme;
    var port = this.port;
    if (scheme === 'blob') try {
      return new URLConstructor(scheme.path[0]).origin;
    } catch (error) {
      return 'null';
    }
    if (scheme === 'file' || !this.isSpecial()) return 'null';
    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
  },
  // https://url.spec.whatwg.org/#dom-url-protocol
  getProtocol: function () {
    return this.scheme + ':';
  },
  setProtocol: function (protocol) {
    this.parse($toString(protocol) + ':', SCHEME_START);
  },
  // https://url.spec.whatwg.org/#dom-url-username
  getUsername: function () {
    return this.username;
  },
  setUsername: function (username) {
    var codePoints = arrayFrom($toString(username));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.username = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-password
  getPassword: function () {
    return this.password;
  },
  setPassword: function (password) {
    var codePoints = arrayFrom($toString(password));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.password = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-host
  getHost: function () {
    var host = this.host;
    var port = this.port;
    return host === null ? ''
      : port === null ? serializeHost(host)
      : serializeHost(host) + ':' + port;
  },
  setHost: function (host) {
    if (this.cannotBeABaseURL) return;
    this.parse(host, HOST);
  },
  // https://url.spec.whatwg.org/#dom-url-hostname
  getHostname: function () {
    var host = this.host;
    return host === null ? '' : serializeHost(host);
  },
  setHostname: function (hostname) {
    if (this.cannotBeABaseURL) return;
    this.parse(hostname, HOSTNAME);
  },
  // https://url.spec.whatwg.org/#dom-url-port
  getPort: function () {
    var port = this.port;
    return port === null ? '' : $toString(port);
  },
  setPort: function (port) {
    if (this.cannotHaveUsernamePasswordPort()) return;
    port = $toString(port);
    if (port === '') this.port = null;
    else this.parse(port, PORT);
  },
  // https://url.spec.whatwg.org/#dom-url-pathname
  getPathname: function () {
    var path = this.path;
    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
  },
  setPathname: function (pathname) {
    if (this.cannotBeABaseURL) return;
    this.path = [];
    this.parse(pathname, PATH_START);
  },
  // https://url.spec.whatwg.org/#dom-url-search
  getSearch: function () {
    var query = this.query;
    return query ? '?' + query : '';
  },
  setSearch: function (search) {
    search = $toString(search);
    if (search === '') {
      this.query = null;
    } else {
      if (charAt(search, 0) === '?') search = stringSlice(search, 1);
      this.query = '';
      this.parse(search, QUERY);
    }
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-searchparams
  getSearchParams: function () {
    return this.searchParams.facade;
  },
  // https://url.spec.whatwg.org/#dom-url-hash
  getHash: function () {
    var fragment = this.fragment;
    return fragment ? '#' + fragment : '';
  },
  setHash: function (hash) {
    hash = $toString(hash);
    if (hash === '') {
      this.fragment = null;
      return;
    }
    if (charAt(hash, 0) === '#') hash = stringSlice(hash, 1);
    this.fragment = '';
    this.parse(hash, FRAGMENT);
  },
  update: function () {
    this.query = this.searchParams.serialize() || null;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLPrototype);
  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;
  var state = setInternalState(that, new URLState(url, false, base));
  if (!DESCRIPTORS) {
    that.href = state.serialize();
    that.origin = state.getOrigin();
    that.protocol = state.getProtocol();
    that.username = state.getUsername();
    that.password = state.getPassword();
    that.host = state.getHost();
    that.hostname = state.getHostname();
    that.port = state.getPort();
    that.pathname = state.getPathname();
    that.search = state.getSearch();
    that.searchParams = state.getSearchParams();
    that.hash = state.getHash();
  }
};

var URLPrototype = URLConstructor.prototype;

var accessorDescriptor = function (getter, setter) {
  return {
    get: function () {
      return getInternalURLState(this)[getter]();
    },
    set: setter && function (value) {
      return getInternalURLState(this)[setter](value);
    },
    configurable: true,
    enumerable: true
  };
};

if (DESCRIPTORS) {
  // `URL.prototype.href` accessors pair
  // https://url.spec.whatwg.org/#dom-url-href
  defineBuiltInAccessor(URLPrototype, 'href', accessorDescriptor('serialize', 'setHref'));
  // `URL.prototype.origin` getter
  // https://url.spec.whatwg.org/#dom-url-origin
  defineBuiltInAccessor(URLPrototype, 'origin', accessorDescriptor('getOrigin'));
  // `URL.prototype.protocol` accessors pair
  // https://url.spec.whatwg.org/#dom-url-protocol
  defineBuiltInAccessor(URLPrototype, 'protocol', accessorDescriptor('getProtocol', 'setProtocol'));
  // `URL.prototype.username` accessors pair
  // https://url.spec.whatwg.org/#dom-url-username
  defineBuiltInAccessor(URLPrototype, 'username', accessorDescriptor('getUsername', 'setUsername'));
  // `URL.prototype.password` accessors pair
  // https://url.spec.whatwg.org/#dom-url-password
  defineBuiltInAccessor(URLPrototype, 'password', accessorDescriptor('getPassword', 'setPassword'));
  // `URL.prototype.host` accessors pair
  // https://url.spec.whatwg.org/#dom-url-host
  defineBuiltInAccessor(URLPrototype, 'host', accessorDescriptor('getHost', 'setHost'));
  // `URL.prototype.hostname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hostname
  defineBuiltInAccessor(URLPrototype, 'hostname', accessorDescriptor('getHostname', 'setHostname'));
  // `URL.prototype.port` accessors pair
  // https://url.spec.whatwg.org/#dom-url-port
  defineBuiltInAccessor(URLPrototype, 'port', accessorDescriptor('getPort', 'setPort'));
  // `URL.prototype.pathname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-pathname
  defineBuiltInAccessor(URLPrototype, 'pathname', accessorDescriptor('getPathname', 'setPathname'));
  // `URL.prototype.search` accessors pair
  // https://url.spec.whatwg.org/#dom-url-search
  defineBuiltInAccessor(URLPrototype, 'search', accessorDescriptor('getSearch', 'setSearch'));
  // `URL.prototype.searchParams` getter
  // https://url.spec.whatwg.org/#dom-url-searchparams
  defineBuiltInAccessor(URLPrototype, 'searchParams', accessorDescriptor('getSearchParams'));
  // `URL.prototype.hash` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hash
  defineBuiltInAccessor(URLPrototype, 'hash', accessorDescriptor('getHash', 'setHash'));
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
defineBuiltIn(URLPrototype, 'toJSON', function toJSON() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
defineBuiltIn(URLPrototype, 'toString', function toString() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));
}

setToStringTag(URLConstructor, 'URL');

$({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});


/***/ }),

/***/ 3296:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(45806);


/***/ }),

/***/ 27208:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(46518);
var call = __webpack_require__(69565);

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({ target: 'URL', proto: true, enumerable: true }, {
  toJSON: function toJSON() {
    return call(URL.prototype.toString, this);
  }
});


/***/ }),

/***/ 75120:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"سماح","CALLING_ACCEPT":"قبول","CALLING_CAMERA_OFF":"الكاميرا مغلقة","CALLING_CAMERA_PERMISSION_DENIED":"تم رفض الوصول إلى الكاميرا. قم بتمكينه في إعدادات المتصفح الخاص بك.","CALLING_CAMERA_PERMISSION_PROMPT":"السماح بالوصول إلى الكاميرا","CALLING_CAMERA_STARTING":"الكاميرا تبدأ العمل","CALLING_CANCEL":"إلغاء","CALLING_DISABLE_AUDIO":"تعطيل الصوت","CALLING_DISABLE_VIDEO":"تعطيل الفيديو","CALLING_ENABLE_AUDIO":"تمكين الصوت","CALLING_ENABLE_VIDEO":"تفعيل الفيديو","CALLING_END":"إنهاء المكالمة","CALLING_JOIN":"انضم إلى المكالمة","CALLING_JOIN_PROMPT":"يرغب وكيل الدعم في الاتصال بك.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"أنا","CALLING_MICROPHONE_PERMISSION_DENIED":"تم رفض الوصول إلى الميكروفون. فعّله في إعدادات المتصفح الخاص بك.","CALLING_MICROPHONE_PERMISSION_PROMPT":"السماح بالوصول إلى الميكروفون","CALLING_NO_DEVICES":"لا شيء","CALLING_PERMISSION_NEEDED":"مطلوب إذن","CALLING_REJECT":"رفض المكالمة","CALLING_REJOIN_PROMPT":"لديك مكالمة نشطة مع وكيل الدعم. هل تريد الانضمام مرة أخرى؟","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"الوكيل","CALLING_REQUEST":"هل تريد الانضمام إلى مكالمة الفيديو؟","CALLING_SAVE":"حفظ","CALLING_SELECT_CAMERA":"اختر الكاميرا","CALLING_SELECT_MICROPHONE":"اختر الميكروفون","CALLING_SELECT_SPEAKER":"اختر المتحدث","CALLING_SHOW_CALL_SETTINGS":"عرض إعدادات المكالمة","DENY":"رفض","END_SESSION":"إنهاء جلسة Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"يرغب وكيل الدعم في عرض شاشتك.","FULL_DEVICE_REQUEST_TITLE":"السماح بالتقاط الشاشة كاملة؟","REMOTE_CONTROL_REQUEST_DESCRIPTION":"وكيل ادعم يريد التحكم بهذه الصفحة.","REMOTE_CONTROL_REQUEST_TITLE":"السماح بالتحكم عن بُعد؟","SESSION_REQUEST_DESCRIPTION":"يرغب أحد موظفي خدمة العملاء في استخدام هذه الصفحة معك،","SESSION_REQUEST_TITLE":"السماح بالتصفح المشترك؟","UNIVERSAL_PROXY_BLOCKED":"لا يمكن عرض هذه الصفحة مع وكيل الدعم","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"يرغب وكيل الدعم في متابعتك إلى صفحات ويب أخرى.","UNIVERSAL_PROXY_REQUEST_TITLE":"السماح بمتابعة الجلسة؟"}');

/***/ }),

/***/ 97337:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Povolit","CALLING_ACCEPT":"Přijmout","CALLING_CAMERA_OFF":"Kamera je vypnutá","CALLING_CAMERA_PERMISSION_DENIED":"Přístup ke kameře odepřen. Povolit jej v nastavení prohlížeče.","CALLING_CAMERA_PERMISSION_PROMPT":"Povolit přístup ke kameře","CALLING_CAMERA_STARTING":"Kamera se spouští","CALLING_CANCEL":"Zrušit","CALLING_DISABLE_AUDIO":"Zakázat zvuk","CALLING_DISABLE_VIDEO":"Zakázat video","CALLING_ENABLE_AUDIO":"Povolit zvuk","CALLING_ENABLE_VIDEO":"Povolit video","CALLING_END":"Ukončit hovor","CALLING_JOIN":"Připojit se k hovoru","CALLING_JOIN_PROMPT":"Podpora by vás ráda kontaktovala telefonicky.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Já","CALLING_MICROPHONE_PERMISSION_DENIED":"Přístup k mikrofonu odepřen. Povolte jej v nastavení prohlížeče.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Povolit přístup k mikrofonu","CALLING_NO_DEVICES":"Žádný","CALLING_PERMISSION_NEEDED":"Vyžadováno povolení","CALLING_REJECT":"Odmítnout hovor","CALLING_REJOIN_PROMPT":"Máte aktivní hovor s podpůrným agentem. Chcete se znovu připojit?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Vstoupit do videohovoru?","CALLING_SAVE":"Uložit","CALLING_SELECT_CAMERA":"Vyberte kameru","CALLING_SELECT_MICROPHONE":"Vybrat mikrofon","CALLING_SELECT_SPEAKER":"Vyberte reproduktor","CALLING_SHOW_CALL_SETTINGS":"Zobrazit nastavení hovoru","DENY":"Odmítnout","END_SESSION":"Zastavit sdílení","FULL_DEVICE_REQUEST_DESCRIPTION":"Podpora by si ráda prohlédla celou vaši obrazovku.","FULL_DEVICE_REQUEST_TITLE":"Povolit úplné snímání obrazovky?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Podpora by ráda ovládala tuto stránku.","REMOTE_CONTROL_REQUEST_TITLE":"Povolit vzdálené ovládání?","SESSION_REQUEST_DESCRIPTION":"Podpůrný pracovník by s vámi chtěl dočasně používat tuto webovou stránku.","SESSION_REQUEST_TITLE":"Povolit společné prohlížení?","UNIVERSAL_PROXY_BLOCKED":"Tuto webovou stránku nelze zobrazit s podpůrným pracovníkem","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Agent podpory by vás rád sledoval na jiné webové stránky.","UNIVERSAL_PROXY_REQUEST_TITLE":"Povolit pokračování relace?"}');

/***/ }),

/***/ 81088:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Tillad","CALLING_ACCEPT":"Accepter","CALLING_CAMERA_OFF":"Kamera er slukket","CALLING_CAMERA_PERMISSION_DENIED":"Adgang til kamera nægtet. Aktivér det i dine browserindstillinger.","CALLING_CAMERA_PERMISSION_PROMPT":"Tillad adgang til kamera","CALLING_CAMERA_STARTING":"Kamera starter","CALLING_CANCEL":"Annuller","CALLING_DISABLE_AUDIO":"Deaktiver lyd","CALLING_DISABLE_VIDEO":"Deaktiver video","CALLING_ENABLE_AUDIO":"Aktiver lyd","CALLING_ENABLE_VIDEO":"Aktivér video","CALLING_END":"Afslut opkald","CALLING_JOIN":"Deltag i opkaldet","CALLING_JOIN_PROMPT":"En supportagent vil gerne ringe til dig.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Mig","CALLING_MICROPHONE_PERMISSION_DENIED":"Adgang til mikrofon nægtet. Aktivér det i dine browserindstillinger.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Tillad adgang til mikrofon","CALLING_NO_DEVICES":"Ingen","CALLING_PERMISSION_NEEDED":"Tilladelse nødvendig","CALLING_REJECT":"Afvis opkald","CALLING_REJOIN_PROMPT":"Du har en aktiv samtale med en supportagent. Vil du genoptage den?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Deltage i videoopkald?","CALLING_SAVE":"Gem </translateOnlyThis>","CALLING_SELECT_CAMERA":"Vælg kamera","CALLING_SELECT_MICROPHONE":"Vælg mikrofon","CALLING_SELECT_SPEAKER":"Vælg højtaler","CALLING_SHOW_CALL_SETTINGS":"Vis opkaldsindstillinger","DENY":"Nægt","END_SESSION":"Stop deling","FULL_DEVICE_REQUEST_DESCRIPTION":"En supportagent ønsker at se din hele skærm.","FULL_DEVICE_REQUEST_TITLE":"Tillad fuldskærmsoptagelse?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"En supportagent ønsker at kontrollere denne side.","REMOTE_CONTROL_REQUEST_TITLE":"Tillad fjernbetjening?","SESSION_REQUEST_DESCRIPTION":"En supportagent ønsker midlertidigt at bruge denne webside sammen med dig.","SESSION_REQUEST_TITLE":"Tillad cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Denne webside kan ikke vises sammen med en supportagent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"En supportagent vil gerne følge dig til andre websider.","UNIVERSAL_PROXY_REQUEST_TITLE":"Tillad fortsættelse af session?"}');

/***/ }),

/***/ 30428:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Erlauben","CALLING_ACCEPT":"Akzeptieren","CALLING_CAMERA_OFF":"Kamera ist ausgeschaltet","CALLING_CAMERA_PERMISSION_DENIED":"Kamerazugriff verweigert. Aktivieren Sie ihn in den Browsereinstellungen.","CALLING_CAMERA_PERMISSION_PROMPT":"Zugriff auf die Kamera erlauben","CALLING_CAMERA_STARTING":"Kamera wird gestartet","CALLING_CANCEL":"Abbrechen","CALLING_DISABLE_AUDIO":"Audio deaktivieren","CALLING_DISABLE_VIDEO":"Video deaktivieren","CALLING_ENABLE_AUDIO":"Audio aktivieren","CALLING_ENABLE_VIDEO":"Video aktivieren","CALLING_END":"Anruf beenden","CALLING_JOIN":"Anruf beitreten","CALLING_JOIN_PROMPT":"Ein Support-Mitarbeiter möchte Sie anrufen.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ich","CALLING_MICROPHONE_PERMISSION_DENIED":"Zugriff auf Mikrofon verweigert. Aktivieren Sie diesen in den Browsereinstellungen.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Zugriff auf Mikrofon erlauben","CALLING_NO_DEVICES":"Keine","CALLING_PERMISSION_NEEDED":"Berechtigung erforderlich","CALLING_REJECT":"Anruf ablehnen","CALLING_REJOIN_PROMPT":"Sie sind in einem aktiven Gespräch mit einem Support-Mitarbeiter. Möchten Sie wieder beitreten?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Videoanruf starten?","CALLING_SAVE":"Speichern","CALLING_SELECT_CAMERA":"Kamera auswählen","CALLING_SELECT_MICROPHONE":"Mikrofon auswählen","CALLING_SELECT_SPEAKER":"Sprecher auswählen","CALLING_SHOW_CALL_SETTINGS":"Anrufeinstellungen anzeigen","DENY":"Ablehnen","END_SESSION":"Cobrowse-Sitzung beenden","FULL_DEVICE_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter möchte Ihren gesamten Bildschirm anzeigen.","FULL_DEVICE_REQUEST_TITLE":"Vollständige Bildschirmaufnahme erlauben?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter möchte diese Seite steuern.","REMOTE_CONTROL_REQUEST_TITLE":"Fernsteuerung erlauben?","SESSION_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter möchte diese Webseite vorübergehend mit Ihnen nutzen.","SESSION_REQUEST_TITLE":"Cobrowsing erlauben?","UNIVERSAL_PROXY_BLOCKED":"Diese Webseite kann nicht mit einem Support-Mitarbeiter angezeigt werden","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter möchte Sie zu anderen Webseiten begleiten.","UNIVERSAL_PROXY_REQUEST_TITLE":"Sitzungsfortsetzung erlauben?"}');

/***/ }),

/***/ 45448:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Allow","CALLING_ACCEPT":"Accept","CALLING_CAMERA_OFF":"Camera is off","CALLING_CAMERA_PERMISSION_DENIED":"Camera access denied. Enable it in your browser settings.","CALLING_CAMERA_PERMISSION_PROMPT":"Allow access to camera","CALLING_CAMERA_STARTING":"Camera is starting","CALLING_CANCEL":"Cancel","CALLING_DISABLE_AUDIO":"Disable audio","CALLING_DISABLE_VIDEO":"Disable video","CALLING_ENABLE_AUDIO":"Enable audio","CALLING_ENABLE_VIDEO":"Enable video","CALLING_END":"End call","CALLING_JOIN":"Join call","CALLING_JOIN_PROMPT":"A support agent would like to call you.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Me","CALLING_MICROPHONE_PERMISSION_DENIED":"Microphone access denied. Enable it in your browser settings.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Allow access to microphone","CALLING_NO_DEVICES":"None","CALLING_PERMISSION_NEEDED":"Permission needed","CALLING_REJECT":"Reject call","CALLING_REJOIN_PROMPT":"You have an active call with a support agent. Do you want to rejoin?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Enter video call?","CALLING_SAVE":"Save","CALLING_SELECT_CAMERA":"Select camera","CALLING_SELECT_MICROPHONE":"Select microphone","CALLING_SELECT_SPEAKER":"Select speaker","CALLING_SHOW_CALL_SETTINGS":"Show call settings","DENY":"Deny","END_SESSION":"Stop Sharing","FULL_DEVICE_REQUEST_DESCRIPTION":"A support agent would like to view your entire screen.","FULL_DEVICE_REQUEST_TITLE":"Allow full screen capture?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"A support agent would like to control this page.","REMOTE_CONTROL_REQUEST_TITLE":"Allow remote control?","SESSION_REQUEST_DESCRIPTION":"A support agent would like to temporarily use this web page with you.","SESSION_REQUEST_TITLE":"Allow cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"This web page cannot be viewed with a support agent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"A support agent would like to follow you to other web pages.","UNIVERSAL_PROXY_REQUEST_TITLE":"Allow session continuation?"}');

/***/ }),

/***/ 49467:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceptar","CALLING_CAMERA_OFF":"La cámara está apagada","CALLING_CAMERA_PERMISSION_DENIED":"Acceso a la cámara denegado. Habilítelo en la configuración de su navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acceso a la cámara","CALLING_CAMERA_STARTING":"La cámara se está iniciando","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desactivar audio","CALLING_DISABLE_VIDEO":"Desactivar video","CALLING_ENABLE_AUDIO":"Habilitar audio","CALLING_ENABLE_VIDEO":"Habilitar video","CALLING_END":"Finalizar llamada","CALLING_JOIN":"Unirse a la llamada","CALLING_JOIN_PROMPT":"Un agente de soporte desea llamarle.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Yo","CALLING_MICROPHONE_PERMISSION_DENIED":"Acceso al micrófono denegado. Habilítelo en la configuración de su navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acceso al micrófono","CALLING_NO_DEVICES":"Ninguno","CALLING_PERMISSION_NEEDED":"Permiso necesario","CALLING_REJECT":"Rechazar llamada","CALLING_REJOIN_PROMPT":"Tienes una llamada activa con un agente de soporte. ¿Deseas volver a unirte?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"¿Ingresar a la videollamada?","CALLING_SAVE":"Guardar","CALLING_SELECT_CAMERA":"Seleccionar cámara","CALLING_SELECT_MICROPHONE":"Seleccionar micrófono","CALLING_SELECT_SPEAKER":"Seleccionar altavoz","CALLING_SHOW_CALL_SETTINGS":"Mostrar configuración de llamada","DENY":"Denegar","END_SESSION":"Finalizar Sesión de Navegación Conjunta","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agente de soporte quiere ver toda su pantalla.","FULL_DEVICE_REQUEST_TITLE":"¿Permitir captura completa de pantalla?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agente de soporte quiere controlar esta página.","REMOTE_CONTROL_REQUEST_TITLE":"¿Permitir control remoto?","SESSION_REQUEST_DESCRIPTION":"Un agente de soporte quiere usar temporalmente esta página web con usted.","SESSION_REQUEST_TITLE":"¿Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta página web no puede ser vista con un agente de soporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agente de soporte quiere seguirle a otras páginas web.","UNIVERSAL_PROXY_REQUEST_TITLE":"¿Permitir continuación de sesión?"}');

/***/ }),

/***/ 70831:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceptar","CALLING_CAMERA_OFF":"La cámara está apagada","CALLING_CAMERA_PERMISSION_DENIED":"Acceso a la cámara denegado. Habilítelo en la configuración de su navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acceso a la cámara","CALLING_CAMERA_STARTING":"La cámara se está iniciando","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desactivar audio","CALLING_DISABLE_VIDEO":"Desactivar vídeo","CALLING_ENABLE_AUDIO":"Activar audio","CALLING_ENABLE_VIDEO":"Habilitar vídeo","CALLING_END":"Finalizar llamada","CALLING_JOIN":"Unirse a la llamada","CALLING_JOIN_PROMPT":"Un agente de soporte desea llamarle.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Yo","CALLING_MICROPHONE_PERMISSION_DENIED":"Acceso al micrófono denegado. Habilítelo en la configuración de su navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acceso al micrófono","CALLING_NO_DEVICES":"Ninguno","CALLING_PERMISSION_NEEDED":"Permiso necesario","CALLING_REJECT":"Rechazar llamada","CALLING_REJOIN_PROMPT":"Tienes una llamada activa con un agente de soporte. ¿Quieres volver a unirte?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"¿Entrar a la videollamada?","CALLING_SAVE":"Guardar","CALLING_SELECT_CAMERA":"Seleccionar cámara","CALLING_SELECT_MICROPHONE":"Seleccionar micrófono","CALLING_SELECT_SPEAKER":"Seleccionar altavoz","CALLING_SHOW_CALL_SETTINGS":"Mostrar configuración de llamadas","DENY":"Denegar","END_SESSION":"Finalizar Sesión","FULL_DEVICE_REQUEST_DESCRIPTION":"Un asistente de soporte solicita visualizar la totalidad de su pantalla.","FULL_DEVICE_REQUEST_TITLE":"¿Permitir captura completa de pantalla?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agente de soporte desea controlar esta página.","REMOTE_CONTROL_REQUEST_TITLE":"¿Permitir control remoto?","SESSION_REQUEST_DESCRIPTION":"Un agente de soporte quiere usar temporalmente esta página web con usted.","SESSION_REQUEST_TITLE":"¿Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta página web no puede ser vista con un agente de soporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agente de soporte desea seguirle a otras páginas web.","UNIVERSAL_PROXY_REQUEST_TITLE":"¿Permitir continuación de sesión?"}');

/***/ }),

/***/ 93202:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Luba","CALLING_ACCEPT":"Nõustu","CALLING_CAMERA_OFF":"Kaamera on välja lülitatud","CALLING_CAMERA_PERMISSION_DENIED":"Kaamera ligipääs keelatud. Luba see oma brauseri seadetes.","CALLING_CAMERA_PERMISSION_PROMPT":"Luba juurdepääs kaamerale","CALLING_CAMERA_STARTING":"Kaamera käivitub","CALLING_CANCEL":"Tühista","CALLING_DISABLE_AUDIO":"Lülita heli välja","CALLING_DISABLE_VIDEO":"Keela video","CALLING_ENABLE_AUDIO":"Luba heli","CALLING_ENABLE_VIDEO":"Luba video","CALLING_END":"Lõpeta kõne","CALLING_JOIN":"Liitu kõnega","CALLING_JOIN_PROMPT":"Toetusagend soovib teid helistada.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Mina","CALLING_MICROPHONE_PERMISSION_DENIED":"Mikrofoni ligipääs keelatud. Luba see oma brauseri seadetes.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Luba mikrofoni kasutamise õigus","CALLING_NO_DEVICES":"Mitte ükski","CALLING_PERMISSION_NEEDED":"Vaja luba","CALLING_REJECT":"Keela kõne","CALLING_REJOIN_PROMPT":"Teilitate jooksval kõnel tugiteenuse esindajaga. Kas soovite uuesti ühineda?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Esindaja","CALLING_REQUEST":"Sisene videokõnesse?","CALLING_SAVE":"Salvesta","CALLING_SELECT_CAMERA":"Vali kaamera","CALLING_SELECT_MICROPHONE":"Vali mikrofon","CALLING_SELECT_SPEAKER":"Vali kõneleja","CALLING_SHOW_CALL_SETTINGS":"Kuva kõne seadeid","DENY":"Keeldu","END_SESSION":"Jaga jagamine lõpetada","FULL_DEVICE_REQUEST_DESCRIPTION":"Tugiagendi soovib teie kogu ekraani vaadata.","FULL_DEVICE_REQUEST_TITLE":"Luba täisekraani salvestuse lubamine?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Tugiteenindaja soovib seda lehte juhtida.","REMOTE_CONTROL_REQUEST_TITLE":"Lubate kaugjuhtimist?","SESSION_REQUEST_DESCRIPTION":"Toetusagent soovib seda veebilehte teiega ajutiselt kasutada.","SESSION_REQUEST_TITLE":"Luba koosturundus?","UNIVERSAL_PROXY_BLOCKED":"Seda veebilehte ei saa vaadata koos tugiesindajaga","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Toetusagendi soovib teid teistele veebilehtedele jälgida.","UNIVERSAL_PROXY_REQUEST_TITLE":"Kas lubada seansi jätkamine?"}');

/***/ }),

/***/ 34818:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Salli","CALLING_ACCEPT":"Hyväksy","CALLING_CAMERA_OFF":"Kamera on pois päältä","CALLING_CAMERA_PERMISSION_DENIED":"Kameran käyttö estetty. Ota se käyttöön selaimesi asetuksissa.","CALLING_CAMERA_PERMISSION_PROMPT":"Salli pääsy kameraan","CALLING_CAMERA_STARTING":"Kamera käynnistyy","CALLING_CANCEL":"Peruuta","CALLING_DISABLE_AUDIO":"Poista ääni käytöstä","CALLING_DISABLE_VIDEO":"Poista video käytöstä","CALLING_ENABLE_AUDIO":"Ota ääni käyttöön","CALLING_ENABLE_VIDEO":"Ota video käyttöön","CALLING_END":"Lopeta puhelu","CALLING_JOIN":"Liity puheluun","CALLING_JOIN_PROMPT":"Tukihenkilö haluaisi soittaa sinulle.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Minä","CALLING_MICROPHONE_PERMISSION_DENIED":"Mikrofonin käyttö estetty. Ota se käyttöön selaimesi asetuksissa.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Salli pääsy mikrofonille","CALLING_NO_DEVICES":"Ei mitään","CALLING_PERMISSION_NEEDED":"Lupa tarvitaan","CALLING_REJECT":"Hylkää puhelu","CALLING_REJOIN_PROMPT":"Sinulla on aktiivinen puhelu tukiedustajan kanssa. Haluatko liittyä uudelleen?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Asiakaspalvelija","CALLING_REQUEST":"Haluatko mennä videopuheluun?","CALLING_SAVE":"Tallenna","CALLING_SELECT_CAMERA":"Valitse kamera","CALLING_SELECT_MICROPHONE":"Valitse mikrofoni","CALLING_SELECT_SPEAKER":"Valitse kaiutin","CALLING_SHOW_CALL_SETTINGS":"Näytä puheluasetukset","DENY":"Estä","END_SESSION":"Lopeta jakaminen","FULL_DEVICE_REQUEST_DESCRIPTION":"Tukihenkilö haluaa nähdä koko näyttösi.","FULL_DEVICE_REQUEST_TITLE":"Sallitaanko kokoruudun tallennus?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Tukihenkilö haluaisi ohjata tätä sivua.","REMOTE_CONTROL_REQUEST_TITLE":"Sallitaanko etäohjaus?","SESSION_REQUEST_DESCRIPTION":"Asiakaspalvelija haluaisi väliaikaisesti käyttää tätä verkkosivua kanssasi.","SESSION_REQUEST_TITLE":"Salli yhteisselaus?","UNIVERSAL_PROXY_BLOCKED":"Tätä verkkosivua ei voi tarkastella tukihenkilön kanssa","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Tukihenkilö haluaa seurata sinua muille verkkosivuille.","UNIVERSAL_PROXY_REQUEST_TITLE":"Sallitaanko istunnon jatkaminen?"}');

/***/ }),

/***/ 99867:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Autoriser","CALLING_ACCEPT":"Accepter","CALLING_CAMERA_OFF":"La caméra est éteinte","CALLING_CAMERA_PERMISSION_DENIED":"Accès à la caméra refusé. Activez-le dans les paramètres de votre navigateur.","CALLING_CAMERA_PERMISSION_PROMPT":"Autoriser l\'accès à la caméra","CALLING_CAMERA_STARTING":"La caméra démarre","CALLING_CANCEL":"Annuler","CALLING_DISABLE_AUDIO":"Désactiver l\'audio","CALLING_DISABLE_VIDEO":"Désactiver la vidéo","CALLING_ENABLE_AUDIO":"Activer l\'audio","CALLING_ENABLE_VIDEO":"Activer la vidéo","CALLING_END":"Terminer l\'appel","CALLING_JOIN":"Rejoindre l\'appel","CALLING_JOIN_PROMPT":"Un agent de support souhaite vous appeler.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Moi","CALLING_MICROPHONE_PERMISSION_DENIED":"Accès au microphone refusé. Activez-le dans les paramètres de votre navigateur.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Autoriser l\'accès au microphone","CALLING_NO_DEVICES":"Aucun","CALLING_PERMISSION_NEEDED":"Permission requise","CALLING_REJECT":"Rejeter l\'appel","CALLING_REJOIN_PROMPT":"Vous êtes en communication avec un agent de support. Voulez-vous rejoindre à nouveau ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Entrer dans l\'appel vidéo ?","CALLING_SAVE":"Enregistrer","CALLING_SELECT_CAMERA":"Sélectionner la caméra","CALLING_SELECT_MICROPHONE":"Sélectionner un microphone","CALLING_SELECT_SPEAKER":"Sélectionner le haut-parleur","CALLING_SHOW_CALL_SETTINGS":"Afficher les paramètres d\'appel","DENY":"Refuser","END_SESSION":"Terminer la session de Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agent de soutien souhaiterait voir l\'intégralité de votre écran.","FULL_DEVICE_REQUEST_TITLE":"Autoriser la capture d\'écran complète ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agent du soutien souhaiterait avoir le contrôle de cette page.","REMOTE_CONTROL_REQUEST_TITLE":"Autoriser le contrôle à distance ?","SESSION_REQUEST_DESCRIPTION":"Un agent de soutien souhaiterait temporairement utiliser cette page Web avec vous.","SESSION_REQUEST_TITLE":"Autoriser le cobrowsing ?","UNIVERSAL_PROXY_BLOCKED":"Cette page Web ne peut pas être vue avec un agent de soutien","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agent de soutien souhaiterait vous suivre vers d\'autres pages Web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Autoriser la continuation de session ?"}');

/***/ }),

/***/ 87876:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"अनुमति देना","CALLING_ACCEPT":"स्वीकार करें","CALLING_CAMERA_OFF":"कैमरा बंद है","CALLING_CAMERA_PERMISSION_DENIED":"कैमरा एक्सेस अस्वीकृत। इसे अपने ब्राउज़र सेटिंग्स में सक्षम करें।","CALLING_CAMERA_PERMISSION_PROMPT":"कैमरा तक पहुंच की अनुमति दें","CALLING_CAMERA_STARTING":"कैमरा शुरू हो रहा है","CALLING_CANCEL":"रद्द करें","CALLING_DISABLE_AUDIO":"ऑडियो अक्षम करें","CALLING_DISABLE_VIDEO":"वीडियो अक्षम करें","CALLING_ENABLE_AUDIO":"ऑडियो सक्षम करें","CALLING_ENABLE_VIDEO":"वीडियो सक्षम करें","CALLING_END":"कॉल समाप्त करें","CALLING_JOIN":"कॉल में शामिल हों","CALLING_JOIN_PROMPT":"एक समर्थन एजेंट आपको कॉल करना चाहता है।","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"मैं","CALLING_MICROPHONE_PERMISSION_DENIED":"माइक्रोफोन एक्सेस अस्वीकृत। इसे अपने ब्राउज़र सेटिंग्स में सक्षम करें।","CALLING_MICROPHONE_PERMISSION_PROMPT":"माइक्रोफोन तक पहुंच की अनुमति दें","CALLING_NO_DEVICES":"कोई नहीं","CALLING_PERMISSION_NEEDED":"अनुमति आवश्यक है","CALLING_REJECT":"कॉल अस्वीकार करें","CALLING_REJOIN_PROMPT":"आपका एक सक्रिय कॉल समर्थन एजेंट के साथ है। क्या आप पुनः जुड़ना चाहते हैं?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"एजेंट","CALLING_REQUEST":"वीडियो कॉल में प्रवेश करें?","CALLING_SAVE":"सहेजें","CALLING_SELECT_CAMERA":"कैमरा चुनें","CALLING_SELECT_MICROPHONE":"माइक्रोफोन चुनें","CALLING_SELECT_SPEAKER":"वक्ता चुनें","CALLING_SHOW_CALL_SETTINGS":"कॉल सेटिंग्स दिखाएं","DENY":"अस्वीकार करना","END_SESSION":"कोब्रोसे सत्र समाप्त करें","FULL_DEVICE_REQUEST_DESCRIPTION":"एक सहायता एजेंट आपकी पूरी स्क्रीन देखना चाहेगा।","FULL_DEVICE_REQUEST_TITLE":"पूर्ण स्क्रीन कैप्चर की अनुमति दें?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"एक समर्थन एजेंट इस पेज को नियंत्रित करना चाहता है।","REMOTE_CONTROL_REQUEST_TITLE":"रिमोट कंट्रोल की अनुमति दें?","SESSION_REQUEST_DESCRIPTION":"एक सहायता एजेंट अस्थायी रूप से आपके साथ इस वेब पेज का उपयोग करना चाहेगा।","SESSION_REQUEST_TITLE":"कोब्राउज़िंग की अनुमति दें?","UNIVERSAL_PROXY_BLOCKED":"यह वेब पेज सहायता एजेंट के साथ नहीं देखा जा सकता","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"एक सहायता एजेंट आपका अन्य वेब पेजों में पीछा करना चाहेगा।","UNIVERSAL_PROXY_REQUEST_TITLE":"सत्र निरंतरता की अनुमति दें?"}');

/***/ }),

/***/ 28038:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Consenti","CALLING_ACCEPT":"Accetta","CALLING_CAMERA_OFF":"La fotocamera è spenta","CALLING_CAMERA_PERMISSION_DENIED":"Accesso alla fotocamera negato. Attivalo nelle impostazioni del tuo browser.","CALLING_CAMERA_PERMISSION_PROMPT":"Consenti l\'accesso alla fotocamera","CALLING_CAMERA_STARTING":"La fotocamera si sta avviando","CALLING_CANCEL":"Annulla","CALLING_DISABLE_AUDIO":"Disabilita audio","CALLING_DISABLE_VIDEO":"Disabilita video","CALLING_ENABLE_AUDIO":"Abilita audio","CALLING_ENABLE_VIDEO":"Abilita video","CALLING_END":"Termina chiamata","CALLING_JOIN":"Partecipa alla chiamata","CALLING_JOIN_PROMPT":"Un agente di supporto desidera chiamarla.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Me","CALLING_MICROPHONE_PERMISSION_DENIED":"Accesso al microfono negato. Abilitalo nelle impostazioni del browser.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Consenti l\'accesso al microfono","CALLING_NO_DEVICES":"Nessuno","CALLING_PERMISSION_NEEDED":"Permesso necessario","CALLING_REJECT":"Rifiuta chiamata","CALLING_REJOIN_PROMPT":"Hai una chiamata attiva con un agente di supporto. Vuoi rientrare?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Avviare la videochiamata?","CALLING_SAVE":"Salva","CALLING_SELECT_CAMERA":"Seleziona la fotocamera","CALLING_SELECT_MICROPHONE":"Seleziona microfono","CALLING_SELECT_SPEAKER":"Seleziona altoparlante","CALLING_SHOW_CALL_SETTINGS":"Mostra impostazioni chiamata","DENY":"Nega","END_SESSION":"Termina la sessione di Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agente dell\'assistenza desidera visualizzare tutto il tuo schermo.","FULL_DEVICE_REQUEST_TITLE":"Consentire cattura schermo completa?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agente dell\'assistenza desidera controllare questa pagina.","REMOTE_CONTROL_REQUEST_TITLE":"Consentire controllo remoto?","SESSION_REQUEST_DESCRIPTION":"Un agente dell\'assistenza vorrebbe utilizzare temporaneamente questa pagina web con te.","SESSION_REQUEST_TITLE":"Consentire cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Questa pagina web non può essere visualizzata con un agente dell\'assistenza","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agente dell\'assistenza vorrebbe seguirti su altre pagine web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Consentire continuazione sessione?"}');

/***/ }),

/***/ 16582:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"許可する","CALLING_ACCEPT":"承諾する","CALLING_CAMERA_OFF":"カメラはオフです","CALLING_CAMERA_PERMISSION_DENIED":"カメラのアクセスが拒否されました。ブラウザの設定で有効にしてください。","CALLING_CAMERA_PERMISSION_PROMPT":"カメラへのアクセスを許可する","CALLING_CAMERA_STARTING":"カメラが起動しています","CALLING_CANCEL":"キャンセル","CALLING_DISABLE_AUDIO":"音声を無効にする","CALLING_DISABLE_VIDEO":"ビデオを無効にする","CALLING_ENABLE_AUDIO":"音声を有効にする","CALLING_ENABLE_VIDEO":"ビデオを有効にする","CALLING_END":"通話終了","CALLING_JOIN":"通話に参加する","CALLING_JOIN_PROMPT":"サポート担当者があなたに電話をかけたいと考えています。","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"私","CALLING_MICROPHONE_PERMISSION_DENIED":"マイクへのアクセスが拒否されました。ブラウザの設定で有効にしてください。","CALLING_MICROPHONE_PERMISSION_PROMPT":"マイクへのアクセスを許可する","CALLING_NO_DEVICES":"なし","CALLING_PERMISSION_NEEDED":"許可が必要です","CALLING_REJECT":"通話を拒否する","CALLING_REJOIN_PROMPT":"サポートエージェントと通話中です。再接続しますか？","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"エージェント","CALLING_REQUEST":"ビデオ通話に参加しますか？","CALLING_SAVE":"保存","CALLING_SELECT_CAMERA":"カメラを選択してください","CALLING_SELECT_MICROPHONE":"マイクを選択してください","CALLING_SELECT_SPEAKER":"話者を選択してください","CALLING_SHOW_CALL_SETTINGS":"通話設定を表示","DENY":"拒否","END_SESSION":"共同閲覧セッションを終了","FULL_DEVICE_REQUEST_DESCRIPTION":"サポート担当者が画面全体の表示を希望しています。","FULL_DEVICE_REQUEST_TITLE":"フルスクリーンキャプチャを許可しますか？","REMOTE_CONTROL_REQUEST_DESCRIPTION":"サポートエージェントがこのページの管理を希望しています。","REMOTE_CONTROL_REQUEST_TITLE":"リモートコントロールを許可しますか？","SESSION_REQUEST_DESCRIPTION":"サポートエージェントが一時的にこのWebページを共用したいと考えています。","SESSION_REQUEST_TITLE":"コブラウジングを許可しますか？","UNIVERSAL_PROXY_BLOCKED":"このWebページはサポートエージェントと一緒に表示することはできません","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"サポートエージェントが他のWebページでもあなたをフォローしたいと考えています。","UNIVERSAL_PROXY_REQUEST_TITLE":"セッション継続を許可しますか？"}');

/***/ }),

/***/ 61753:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Рұқсат етіңіз","CALLING_ACCEPT":"Қабылдау","CALLING_CAMERA_OFF":"Камера өшірілген","CALLING_CAMERA_PERMISSION_DENIED":"Камераға кіруге тыйым салынған. Оны шолғыш параметрлерінде қосыңыз.","CALLING_CAMERA_PERMISSION_PROMPT":"Камераға кіруге рұқсат беру","CALLING_CAMERA_STARTING":"Камера іске қосылуда","CALLING_CANCEL":"Болдырмау","CALLING_DISABLE_AUDIO":"Дыбысты өшіріңіз","CALLING_DISABLE_VIDEO":"Бейнені өшіру","CALLING_ENABLE_AUDIO":"Дыбысты қосу","CALLING_ENABLE_VIDEO":"Бейне қосу","CALLING_END":"Қоңырауды аяқтау","CALLING_JOIN":"Қоңырауға қосылу","CALLING_JOIN_PROMPT":"Қолдау қызметінің өкілі сізге қоңырау шалғысы келеді.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Мен","CALLING_MICROPHONE_PERMISSION_DENIED":"Микрофонға қатынау тыйым салынды. Оны шолғыш параметрлеріңізде қосыңыз.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Микрофонға қолжетімділік беріңіз","CALLING_NO_DEVICES":"Жоқ","CALLING_PERMISSION_NEEDED":"Рұқсат қажет","CALLING_REJECT":"Қоңырауды қабылдамау","CALLING_REJOIN_PROMPT":"Сізде қолдау агентімен ағымдағы қоңырау бар. Қайта қосылғыңыз келе ме?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Агент","CALLING_REQUEST":"Бейне қоңырауға қосылу керек пе?","CALLING_SAVE":"Сақтау","CALLING_SELECT_CAMERA":"Камераны таңдаңыз","CALLING_SELECT_MICROPHONE":"Микрофонды таңдаңыз","CALLING_SELECT_SPEAKER":"Дыбысты таңдау","CALLING_SHOW_CALL_SETTINGS":"Қоңырау параметрлерін көрсету","DENY":"Бас тарту","END_SESSION":"Бірлескен шолу сеансын аяқтаңыз","FULL_DEVICE_REQUEST_DESCRIPTION":"Қолдау агенті бүкіл экраныңызды көргісі келеді.","FULL_DEVICE_REQUEST_TITLE":"Толық экранды түсіруге рұқсат етесіз бе?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Көмекші агент осы бетті бақылағысы келеді.","REMOTE_CONTROL_REQUEST_TITLE":"Қашықтан басқаруға рұқсат етесіз бе?","SESSION_REQUEST_DESCRIPTION":"Қолдау агенті осы веб-бетті сізбен уақытша пайдаланғысы келеді.","SESSION_REQUEST_TITLE":"Кобраузингке рұқсат етесіз бе?","UNIVERSAL_PROXY_BLOCKED":"Бұл веб-бетті қолдау агентімен бірге көру мүмкін емес","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Қолдау агенті сізді басқа веб-беттерге де ілесе алуға тілек білдіреді.","UNIVERSAL_PROXY_REQUEST_TITLE":"Сеансты жалғастыруға рұқсат етесіз бе?"}');

/***/ }),

/***/ 45613:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"허용하다","CALLING_ACCEPT":"수락","CALLING_CAMERA_OFF":"카메라가 꺼져 있습니다","CALLING_CAMERA_PERMISSION_DENIED":"카메라 접근이 거부되었습니다. 브라우저 설정에서 활성화하세요.","CALLING_CAMERA_PERMISSION_PROMPT":"카메라 접근 허용","CALLING_CAMERA_STARTING":"카메라가 시작되고 있습니다","CALLING_CANCEL":"취소","CALLING_DISABLE_AUDIO":"오디오 비활성화","CALLING_DISABLE_VIDEO":"비디오 비활성화","CALLING_ENABLE_AUDIO":"오디오 활성화","CALLING_ENABLE_VIDEO":"비디오 활성화","CALLING_END":"통화 종료","CALLING_JOIN":"통화 참여하기","CALLING_JOIN_PROMPT":"지원 상담원이 귀하에게 전화를 원합니다.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"나","CALLING_MICROPHONE_PERMISSION_DENIED":"마이크 접근이 거부되었습니다. 브라우저 설정에서 활성화하세요.","CALLING_MICROPHONE_PERMISSION_PROMPT":"마이크 접근 허용","CALLING_NO_DEVICES":"없음","CALLING_PERMISSION_NEEDED":"권한 필요","CALLING_REJECT":"통화 거절","CALLING_REJOIN_PROMPT":"지원 상담원과 통화 중입니다. 다시 연결하시겠습니까?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"상담원","CALLING_REQUEST":"영상 통화에 참여하시겠습니까?","CALLING_SAVE":"저장","CALLING_SELECT_CAMERA":"카메라 선택","CALLING_SELECT_MICROPHONE":"마이크 선택","CALLING_SELECT_SPEAKER":"화자 선택","CALLING_SHOW_CALL_SETTINGS":"통화 설정 표시","DENY":"부인하다","END_SESSION":"Cobrowse 세션 종료","FULL_DEVICE_REQUEST_DESCRIPTION":"지원 담당자가 귀하의 전체 화면을 보고 싶어합니다.","FULL_DEVICE_REQUEST_TITLE":"전체 화면 캡처를 허용하시겠습니까?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"지원 담당자가 이 페이지를 관리하고 싶어합니다.","REMOTE_CONTROL_REQUEST_TITLE":"원격 제어를 허용하시겠습니까?","SESSION_REQUEST_DESCRIPTION":"지원 담당자가 귀하와 함께 이 웹 페이지를 일시적으로 사용하려고 합니다.","SESSION_REQUEST_TITLE":"코브라우징을 허용하시겠습니까?","UNIVERSAL_PROXY_BLOCKED":"이 웹 페이지는 지원 담당자와 함께 볼 수 없습니다","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"지원 담당자가 다른 웹 페이지로 귀하를 따라가고 싶어합니다.","UNIVERSAL_PROXY_REQUEST_TITLE":"세션 계속을 허용하시겠습니까?"}');

/***/ }),

/***/ 32391:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Leisti","CALLING_ACCEPT":"Priimti","CALLING_CAMERA_OFF":"Kamera išjungta","CALLING_CAMERA_PERMISSION_DENIED":"Prieiga prie kameros uždrausta. Įgalinkite ją savo naršyklės nustatymuose.","CALLING_CAMERA_PERMISSION_PROMPT":"Leisti prieigą prie kameros","CALLING_CAMERA_STARTING":"Kamera pradedama veikti","CALLING_CANCEL":"Atšaukti","CALLING_DISABLE_AUDIO":"Išjungti garsą","CALLING_DISABLE_VIDEO":"Išjungti vaizdo įrašą","CALLING_ENABLE_AUDIO":"Įjungti garsą","CALLING_ENABLE_VIDEO":"Įjungti vaizdo įrašą","CALLING_END":"Baigti skambutį","CALLING_JOIN":"Prisijungti prie skambučio","CALLING_JOIN_PROMPT":"Paramaus agentas norėtų jums paskambinti.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Mano","CALLING_MICROPHONE_PERMISSION_DENIED":"Prieiga prie mikrofono atmesta. Įgalinkite ją savo naršyklės nustatymuose.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Leisti prieigą prie mikrofono","CALLING_NO_DEVICES":"Nėra","CALLING_PERMISSION_NEEDED":"Reikalinga leidimas","CALLING_REJECT":"Atmesti skambutį","CALLING_REJOIN_PROMPT":"Jūs turite aktyvų skambutį su palaikymo agentu. Ar norite vėl prisijungti?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agentas","CALLING_REQUEST":"Pradėti vaizdo skambutį?","CALLING_SAVE":"Išsaugoti","CALLING_SELECT_CAMERA":"Pasirinkite kamerą","CALLING_SELECT_MICROPHONE":"Pasirinkite mikrofoną","CALLING_SELECT_SPEAKER":"Pasirinkite kalbėtoją","CALLING_SHOW_CALL_SETTINGS":"Rodyti skambučio nustatymus","DENY":"Atmesti","END_SESSION":"Nutraukti bendrinimą","FULL_DEVICE_REQUEST_DESCRIPTION":"Pagalbos agentas norėtų peržiūrėti visą jūsų ekraną.","FULL_DEVICE_REQUEST_TITLE":"Leisti fiksuoti visą ekraną?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Palaikymo agentas norėtų valdyti šį puslapį.","REMOTE_CONTROL_REQUEST_TITLE":"Leisti nuotolinę kontrolę?","SESSION_REQUEST_DESCRIPTION":"Pagalbos agentas norėtų laikinai naudotis šiuo tinklapiu kartu su jumis.","SESSION_REQUEST_TITLE":"Leisti bendrą naršymą?","UNIVERSAL_PROXY_BLOCKED":"Šio puslapio negalima peržiūrėti su palaikymo agentu","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Pagalbos agentas norėtų jus sekti į kitas interneto svetaines.","UNIVERSAL_PROXY_REQUEST_TITLE":"Leisti tęsti sesiją?"}');

/***/ }),

/***/ 59396:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"परवानगी द्या","CALLING_ACCEPT":"स्वीकार करा","CALLING_CAMERA_OFF":"कॅमेरा बंद आहे","CALLING_CAMERA_PERMISSION_DENIED":"कॅमेरा प्रवेश नाकारण्यात आला. आपल्या ब्राउझरच्या सेटिंग्जमध्ये याला सक्षम करा.","CALLING_CAMERA_PERMISSION_PROMPT":"कॅमेऱ्याला प्रवेश देणे","CALLING_CAMERA_STARTING":"कॅमेरा सुरू होत आहे","CALLING_CANCEL":"रद्द करा","CALLING_DISABLE_AUDIO":"ऑडिओ अक्षम करा","CALLING_DISABLE_VIDEO":"व्हिडिओ अक्षम करा","CALLING_ENABLE_AUDIO":"ऑडिओ सक्षम करा","CALLING_ENABLE_VIDEO":"व्हिडिओ सक्षम करा","CALLING_END":"कॉल संपवा","CALLING_JOIN":"कॉलमध्ये सामील व्हा","CALLING_JOIN_PROMPT":"एक समर्थन एजंट आपल्याशी बोलू इच्छितो.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"मला","CALLING_MICROPHONE_PERMISSION_DENIED":"माइक्रोफोन प्रवेश नाकारला गेला आहे. आपल्या ब्राउझर सेटिंग्जमध्ये ते सक्षम करा.","CALLING_MICROPHONE_PERMISSION_PROMPT":"मायक्रोफोनसाठी प्रवेशाची परवानगी द्या","CALLING_NO_DEVICES":"शून्य","CALLING_PERMISSION_NEEDED":"अनुमती आवश्यक आहे","CALLING_REJECT":"कॉल नाकारणे","CALLING_REJOIN_PROMPT":"आपण सध्या समर्थन एजंटसोबत कॉलवर आहात. आपण पुन्हा जोडू इच्छिता?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"एजंट","CALLING_REQUEST":"व्हिडिओ कॉलमध्ये प्रवेश करायचा आहे का?","CALLING_SAVE":"जतन करा","CALLING_SELECT_CAMERA":"कॅमेरा निवडा","CALLING_SELECT_MICROPHONE":"माइक्रोफोन निवडा","CALLING_SELECT_SPEAKER":"वक्ता निवडा","CALLING_SHOW_CALL_SETTINGS":"कॉल सेटिंग्ज दाखवा","DENY":"नकार द्या","END_SESSION":"कोब्राउझ सत्र समाप्त करा","FULL_DEVICE_REQUEST_DESCRIPTION":"सपोर्ट एजंट तुमची संपूर्ण स्क्रीन पाहू इच्छितो.","FULL_DEVICE_REQUEST_TITLE":"पूर्ण स्क्रीन कॅप्चरला परवानगी द्यायची?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"एक सहाय्यक एजंट या पृष्ठावर नियंत्रण ठेवण्यास आवडेल.","REMOTE_CONTROL_REQUEST_TITLE":"रिमोट कंट्रोलला परवानगी द्यायची?","SESSION_REQUEST_DESCRIPTION":"सपोर्ट एजंट हे वेब पेज तुमच्यासोबत तात्पुरते वापरू इच्छितो.","SESSION_REQUEST_TITLE":"कोब्राउझिंगला परवानगी द्यायची?","UNIVERSAL_PROXY_BLOCKED":"हे वेब पेज समर्थन एजंटसोबत पाहिले जाऊ शकत नाही","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"एक समर्थन एजंट तुमचा इतर वेब पृष्ठांवर पाठपुरावा करू इच्छितो.","UNIVERSAL_PROXY_REQUEST_TITLE":"सत्र सातत्याला परवानगी द्यायची?"}');

/***/ }),

/***/ 8439:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Benarkan","CALLING_ACCEPT":"Terima","CALLING_CAMERA_OFF":"Kamera dimatikan","CALLING_CAMERA_PERMISSION_DENIED":"Akses kamera dinafi. Aktifkannya dalam tetapan pelayar anda.","CALLING_CAMERA_PERMISSION_PROMPT":"Benarkan akses ke kamera","CALLING_CAMERA_STARTING":"Kamera sedang dimulakan","CALLING_CANCEL":"Batal","CALLING_DISABLE_AUDIO":"Lumpuhkan audio","CALLING_DISABLE_VIDEO":"Lumpuhkan video","CALLING_ENABLE_AUDIO":"Dayakan audio","CALLING_ENABLE_VIDEO":"Dayakan video","CALLING_END":"Tamatkan panggilan","CALLING_JOIN":"Sertai panggilan","CALLING_JOIN_PROMPT":"Ejen sokongan ingin menghubungi anda.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Saya","CALLING_MICROPHONE_PERMISSION_DENIED":"Akses mikrofon ditolak. Aktifkan dalam tetapan pelayar anda.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Benarkan akses ke mikrofon","CALLING_NO_DEVICES":"Tiada","CALLING_PERMISSION_NEEDED":"Kebenaran diperlukan","CALLING_REJECT":"Tolak panggilan","CALLING_REJOIN_PROMPT":"Anda sedang dalam panggilan aktif dengan ejen sokongan. Adakah anda ingin menyertai semula?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Ejen","CALLING_REQUEST":"Masuk panggilan video?","CALLING_SAVE":"Simpan","CALLING_SELECT_CAMERA":"Pilih kamera","CALLING_SELECT_MICROPHONE":"Pilih mikrofon","CALLING_SELECT_SPEAKER":"Pilih pembesar suara","CALLING_SHOW_CALL_SETTINGS":"Tunjukkan tetapan panggilan","DENY":"Tolak","END_SESSION":"Berhenti Berkongsi","FULL_DEVICE_REQUEST_DESCRIPTION":"Ejen sokongan ingin melihat seluruh skrin anda.","FULL_DEVICE_REQUEST_TITLE":"Benarkan rakaman skrin penuh?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Ejen sokongan ingin mengawal halaman ini.","REMOTE_CONTROL_REQUEST_TITLE":"Benarkan kawalan jauh?","SESSION_REQUEST_DESCRIPTION":"Ejen sokongan ingin menggunakan halaman web ini dengan anda buat sementara waktu.","SESSION_REQUEST_TITLE":"Benarkan cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Halaman web ini tidak dapat dilihat bersama ejen sokongan","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Ejen sokongan ingin mengikuti anda ke halaman web lain.","UNIVERSAL_PROXY_REQUEST_TITLE":"Benarkan sambungan sesi?"}');

/***/ }),

/***/ 19121:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Toestaan","CALLING_ACCEPT":"Accepteren","CALLING_CAMERA_OFF":"Camera is uit","CALLING_CAMERA_PERMISSION_DENIED":"Toegang tot camera geweigerd. Schakel deze in de instellingen van uw browser in.","CALLING_CAMERA_PERMISSION_PROMPT":"Toegang tot camera toestaan","CALLING_CAMERA_STARTING":"Camera wordt gestart","CALLING_CANCEL":"Annuleren","CALLING_DISABLE_AUDIO":"Audio uitschakelen","CALLING_DISABLE_VIDEO":"Video uitschakelen","CALLING_ENABLE_AUDIO":"Audio inschakelen","CALLING_ENABLE_VIDEO":"Video inschakelen","CALLING_END":"Oproep beëindigen","CALLING_JOIN":"Deelnemen aan oproep","CALLING_JOIN_PROMPT":"Een supportmedewerker wil u bellen.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ik","CALLING_MICROPHONE_PERMISSION_DENIED":"Microfoon toegang geweigerd. Schakel dit in uw browserinstellingen in.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Toegang tot microfoon toestaan","CALLING_NO_DEVICES":"Geen","CALLING_PERMISSION_NEEDED":"Toestemming vereist","CALLING_REJECT":"Oproep weigeren","CALLING_REJOIN_PROMPT":"U bent in gesprek met een supportmedewerker. Wilt u opnieuw deelnemen?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Video-oproep starten?","CALLING_SAVE":"Opslaan","CALLING_SELECT_CAMERA":"Selecteer camera","CALLING_SELECT_MICROPHONE":"Selecteer microfoon","CALLING_SELECT_SPEAKER":"Selecteer spreker","CALLING_SHOW_CALL_SETTINGS":"Toon oproepinstellingen","DENY":"Afwijzen","END_SESSION":"Cobrowse-sessie beëindigen","FULL_DEVICE_REQUEST_DESCRIPTION":"Een support agent wilt jouw volledige scherm zien.","FULL_DEVICE_REQUEST_TITLE":"Volledige schermopname toestaan?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Een support agent wilt graag deze pagina bedienen.","REMOTE_CONTROL_REQUEST_TITLE":"Bediening op afstand toestaan?","SESSION_REQUEST_DESCRIPTION":"Een support agent wilt graag tijdelijk met u meekijken op deze webpagina.","SESSION_REQUEST_TITLE":"Cobrowsing toestaan?","UNIVERSAL_PROXY_BLOCKED":"Deze webpagina kan niet worden bekeken met een support agent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Een support agent wilt u graag volgen naar andere webpagina\'s.","UNIVERSAL_PROXY_REQUEST_TITLE":"Sessievoortzetting toestaan?"}');

/***/ }),

/***/ 85443:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Umożliwić","CALLING_ACCEPT":"Akceptuj","CALLING_CAMERA_OFF":"Kamera jest wyłączona","CALLING_CAMERA_PERMISSION_DENIED":"Odmowa dostępu do kamery. Włącz ją w ustawieniach przeglądarki.","CALLING_CAMERA_PERMISSION_PROMPT":"Zezwól na dostęp do kamery","CALLING_CAMERA_STARTING":"Kamera się uruchamia","CALLING_CANCEL":"Anuluj","CALLING_DISABLE_AUDIO":"Wyłącz dźwięk","CALLING_DISABLE_VIDEO":"Wyłącz wideo","CALLING_ENABLE_AUDIO":"Włącz dźwięk","CALLING_ENABLE_VIDEO":"Włącz wideo","CALLING_END":"Zakończ rozmowę","CALLING_JOIN":"Dołącz do rozmowy","CALLING_JOIN_PROMPT":"Agent wsparcia chciałby do Ciebie zadzwonić.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ja","CALLING_MICROPHONE_PERMISSION_DENIED":"Dostęp do mikrofonu został odmówiony. Włącz go w ustawieniach przeglądarki.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Zezwól na dostęp do mikrofonu","CALLING_NO_DEVICES":"Brak","CALLING_PERMISSION_NEEDED":"Wymagana zgoda","CALLING_REJECT":"Odrzuć połączenie","CALLING_REJOIN_PROMPT":"Masz aktywne połączenie z agentem wsparcia. Czy chcesz dołączyć ponownie?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Rozpocząć rozmowę wideo?","CALLING_SAVE":"Zapisz","CALLING_SELECT_CAMERA":"Wybierz kamerę","CALLING_SELECT_MICROPHONE":"Wybierz mikrofon","CALLING_SELECT_SPEAKER":"Wybierz głośnik","CALLING_SHOW_CALL_SETTINGS":"Pokaż ustawienia połączenia","DENY":"Zaprzeczyć","END_SESSION":"Zakończ sesję Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Pracownik działu pomocy chciałby zobaczyć cały Twój ekran.","FULL_DEVICE_REQUEST_TITLE":"Czy zezwolić na pełne przechwycenie ekranu?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Pracownik działu pomocy chciałby kontrolować tę stronę.","REMOTE_CONTROL_REQUEST_TITLE":"Czy zezwolić na zdalne sterowanie?","SESSION_REQUEST_DESCRIPTION":"Pracownik działu pomocy chciałby tymczasowo korzystać z tej strony internetowej razem z Tobą.","SESSION_REQUEST_TITLE":"Czy zezwolić na cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Ta strona internetowa nie może być oglądana z pracownikiem działu pomocy","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Pracownik działu pomocy chciałby podążać za Tobą na inne strony internetowe.","UNIVERSAL_PROXY_REQUEST_TITLE":"Czy zezwolić na kontynuację sesji?"}');

/***/ }),

/***/ 26770:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceitar","CALLING_CAMERA_OFF":"Câmera está desligada","CALLING_CAMERA_PERMISSION_DENIED":"Acesso à câmera negado. Ative-o nas configurações do seu navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acesso à câmera","CALLING_CAMERA_STARTING":"A câmera está iniciando","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desativar áudio","CALLING_DISABLE_VIDEO":"Desativar vídeo","CALLING_ENABLE_AUDIO":"Ativar áudio","CALLING_ENABLE_VIDEO":"Ativar vídeo","CALLING_END":"Encerrar chamada","CALLING_JOIN":"Entrar na chamada","CALLING_JOIN_PROMPT":"Um agente de suporte gostaria de ligar para você.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Eu","CALLING_MICROPHONE_PERMISSION_DENIED":"Acesso ao microfone negado. Ative-o nas configurações do seu navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acesso ao microfone","CALLING_NO_DEVICES":"Nenhum","CALLING_PERMISSION_NEEDED":"Permissão necessária","CALLING_REJECT":"Rejeitar chamada","CALLING_REJOIN_PROMPT":"Você está em uma ligação ativa com um agente de suporte. Deseja retornar?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Entrar na chamada de vídeo?","CALLING_SAVE":"Salvar","CALLING_SELECT_CAMERA":"Selecionar câmera","CALLING_SELECT_MICROPHONE":"Selecionar microfone","CALLING_SELECT_SPEAKER":"Selecionar orador","CALLING_SHOW_CALL_SETTINGS":"Mostrar configurações de chamada","DENY":"Negar","END_SESSION":"Terminar Sessão de Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de ver sua tela inteira.","FULL_DEVICE_REQUEST_TITLE":"Permitir captura completa de tela?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de controlar esta página.","REMOTE_CONTROL_REQUEST_TITLE":"Permitir controle remoto?","SESSION_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de usar temporariamente esta página da web com você.","SESSION_REQUEST_TITLE":"Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta página da web não pode ser visualizada com um agente de suporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de segui-lo para outras páginas da web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permitir continuação da sessão?"}');

/***/ }),

/***/ 63851:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceitar","CALLING_CAMERA_OFF":"Câmara desligada","CALLING_CAMERA_PERMISSION_DENIED":"Acesso à câmara negado. Ative-o nas definições do seu navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acesso à câmara","CALLING_CAMERA_STARTING":"Câmara a iniciar-se","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desativar áudio","CALLING_DISABLE_VIDEO":"Desativar vídeo","CALLING_ENABLE_AUDIO":"Ativar áudio","CALLING_ENABLE_VIDEO":"Ativar vídeo","CALLING_END":"Terminar chamada","CALLING_JOIN":"Entrar na chamada","CALLING_JOIN_PROMPT":"Um agente de suporte gostaria de lhe telefonar.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Eu","CALLING_MICROPHONE_PERMISSION_DENIED":"Acesso ao microfone negado. Ative-o nas definições do seu navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acesso ao microfone","CALLING_NO_DEVICES":"Nenhum","CALLING_PERMISSION_NEEDED":"Permissão necessária","CALLING_REJECT":"Recusar chamada","CALLING_REJOIN_PROMPT":"Tem uma chamada ativa com um agente de suporte. Deseja voltar a participar?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Entrar na chamada de vídeo?","CALLING_SAVE":"Guardar","CALLING_SELECT_CAMERA":"Selecionar câmara","CALLING_SELECT_MICROPHONE":"Selecionar microfone","CALLING_SELECT_SPEAKER":"Selecionar orador","CALLING_SHOW_CALL_SETTINGS":"Mostrar definições de chamada","DENY":"Negado","END_SESSION":"Terminar Sessão de Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de ver sua tela inteira.","FULL_DEVICE_REQUEST_TITLE":"Permitir captura completa de ecrã?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de controlar esta página.","REMOTE_CONTROL_REQUEST_TITLE":"Permitir controlo remoto?","SESSION_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de usar temporariamente esta página da web com você.","SESSION_REQUEST_TITLE":"Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta página da web não pode ser visualizada com um agente de suporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de segui-lo para outras páginas da web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permitir continuação da sessão?"}');

/***/ }),

/***/ 17304:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permite","CALLING_ACCEPT":"Acceptă","CALLING_CAMERA_OFF":"Camera este oprită","CALLING_CAMERA_PERMISSION_DENIED":"Accesul la cameră a fost refuzat. Activați-l în setările browserului dvs.","CALLING_CAMERA_PERMISSION_PROMPT":"Permiteți accesul la cameră","CALLING_CAMERA_STARTING":"Camera pornește","CALLING_CANCEL":"Anulează","CALLING_DISABLE_AUDIO":"Dezactivează audio-ul","CALLING_DISABLE_VIDEO":"Dezactivează video-ul","CALLING_ENABLE_AUDIO":"Activează audio","CALLING_ENABLE_VIDEO":"Activează video-ul","CALLING_END":"Încheiere apel","CALLING_JOIN":"Alăturați-vă apelului","CALLING_JOIN_PROMPT":"Un agent de suport ar dori să vă contacteze telefonic.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Eu","CALLING_MICROPHONE_PERMISSION_DENIED":"Accesul la microfon a fost refuzat. Activați-l în setările browserului dumneavoastră.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permite accesul la microfon","CALLING_NO_DEVICES":"Niciunul","CALLING_PERMISSION_NEEDED":"Permisiune necesară","CALLING_REJECT":"Respinge apelul","CALLING_REJOIN_PROMPT":"Aveți un apel activ cu un agent de suport. Doriți să vă reconectați?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Doriți să intrați în apelul video?","CALLING_SAVE":"Salvează","CALLING_SELECT_CAMERA":"Selectați camera","CALLING_SELECT_MICROPHONE":"Selectați microfonul","CALLING_SELECT_SPEAKER":"Selectați difuzorul","CALLING_SHOW_CALL_SETTINGS":"Afișați setările apelului","DENY":"Refuză","END_SESSION":"Opriți partajarea","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agent de asistență dorește să vadă întreg ecranul dumneavoastră.","FULL_DEVICE_REQUEST_TITLE":"Permite capturarea ecranului complet?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agent de suport dorește să controleze această pagină.","REMOTE_CONTROL_REQUEST_TITLE":"Permite controlul de la distanță?","SESSION_REQUEST_DESCRIPTION":"Un agent de asistență dorește să utilizeze temporar această pagină web împreună cu dumneavoastră.","SESSION_REQUEST_TITLE":"Permiteți cobrowsing-ul?","UNIVERSAL_PROXY_BLOCKED":"Această pagină web nu poate fi vizualizată împreună cu un agent de asistență","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agent de suport dorește să vă urmărească pe alte pagini web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permiteți continuarea sesiunii?"}');

/***/ }),

/***/ 86146:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Разрешить","CALLING_ACCEPT":"Принять","CALLING_CAMERA_OFF":"Камера выключена","CALLING_CAMERA_PERMISSION_DENIED":"Доступ к камере запрещён. Включите его в настройках вашего браузера.","CALLING_CAMERA_PERMISSION_PROMPT":"Разрешить доступ к камере","CALLING_CAMERA_STARTING":"Камера запускается","CALLING_CANCEL":"Отменить","CALLING_DISABLE_AUDIO":"Отключить аудио","CALLING_DISABLE_VIDEO":"Отключить видео","CALLING_ENABLE_AUDIO":"Включить аудио","CALLING_ENABLE_VIDEO":"Включить видео","CALLING_END":"Завершить звонок","CALLING_JOIN":"Присоединиться к звонку","CALLING_JOIN_PROMPT":"Служба поддержки хочет вам позвонить.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Я","CALLING_MICROPHONE_PERMISSION_DENIED":"Доступ к микрофону запрещён. Включите его в настройках браузера.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Разрешить доступ к микрофону","CALLING_NO_DEVICES":"Нет","CALLING_PERMISSION_NEEDED":"Требуется разрешение","CALLING_REJECT":"Отклонить вызов","CALLING_REJOIN_PROMPT":"У вас активный звонок с агентом поддержки. Хотите присоединиться снова?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Агент","CALLING_REQUEST":"Начать видеозвонок?","CALLING_SAVE":"Сохранить","CALLING_SELECT_CAMERA":"Выберите камеру","CALLING_SELECT_MICROPHONE":"Выберите микрофон","CALLING_SELECT_SPEAKER":"Выбрать динамик","CALLING_SHOW_CALL_SETTINGS":"Показать настройки вызова","DENY":"Отказать","END_SESSION":"Завершить сеанс совместного просмотра","FULL_DEVICE_REQUEST_DESCRIPTION":"Сотрудник службы поддержки хотел бы просмотреть весь экран.","FULL_DEVICE_REQUEST_TITLE":"Разрешить полный захват экрана?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Агент поддержки хотел бы контролировать эту страницу.","REMOTE_CONTROL_REQUEST_TITLE":"Разрешить дистанционное управление?","SESSION_REQUEST_DESCRIPTION":"Агент службы поддержки хотел бы временно использовать эту веб-страницу с вами.","SESSION_REQUEST_TITLE":"Разрешить кобраузинг?","UNIVERSAL_PROXY_BLOCKED":"Эта веб-страница не может быть просмотрена с агентом поддержки","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Агент поддержки хотел бы следовать за вами на другие веб-страницы.","UNIVERSAL_PROXY_REQUEST_TITLE":"Разрешить продолжение сеанса?"}');

/***/ }),

/***/ 35537:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Povoliť","CALLING_ACCEPT":"Prijať","CALLING_CAMERA_OFF":"Kamera je vypnutá","CALLING_CAMERA_PERMISSION_DENIED":"Prístup ku kamere odmietnutý. Povoliť ho v nastaveniach prehliadača.","CALLING_CAMERA_PERMISSION_PROMPT":"Povoliť prístup ku kamere","CALLING_CAMERA_STARTING":"Kamera sa spúšťa","CALLING_CANCEL":"Zrušiť","CALLING_DISABLE_AUDIO":"Vypnúť zvuk","CALLING_DISABLE_VIDEO":"Zakázať video","CALLING_ENABLE_AUDIO":"Povoliť zvuk","CALLING_ENABLE_VIDEO":"Povoliť video","CALLING_END":"Ukončiť hovor","CALLING_JOIN":"Pripojiť sa k hovoru","CALLING_JOIN_PROMPT":"Podporný agent vás chce kontaktovať telefonicky.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ja","CALLING_MICROPHONE_PERMISSION_DENIED":"Prístup k mikrofónu zamietnutý. Povoliť ho v nastaveniach prehliadača.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Povoliť prístup k mikrofónu","CALLING_NO_DEVICES":"Žiadne","CALLING_PERMISSION_NEEDED":"Vyžaduje sa povolenie","CALLING_REJECT":"Zamietnuť hovor","CALLING_REJOIN_PROMPT":"Máte aktívne volanie s podporným agentom. Chcete sa znova pripojiť?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Vstúpiť do videohovoru?","CALLING_SAVE":"Uložiť","CALLING_SELECT_CAMERA":"Vyberte kameru","CALLING_SELECT_MICROPHONE":"Vyberte mikrofón","CALLING_SELECT_SPEAKER":"Vybrať reproduktora","CALLING_SHOW_CALL_SETTINGS":"Zobraziť nastavenia hovoru","DENY":"Odmietnuť","END_SESSION":"Zastaviť zdieľanie","FULL_DEVICE_REQUEST_DESCRIPTION":"Podporný agent si želá zobraziť celú vašu obrazovku.","FULL_DEVICE_REQUEST_TITLE":"Povoliť úplné snímanie obrazovky?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Podporný agent by chcel ovládať túto stránku.","REMOTE_CONTROL_REQUEST_TITLE":"Povoliť vzdialenú správu?","SESSION_REQUEST_DESCRIPTION":"Podporný agent by chcel dočasne používať túto webovú stránku spolu s vami.","SESSION_REQUEST_TITLE":"Povoliť spolusurfovanie?","UNIVERSAL_PROXY_BLOCKED":"Túto webovú stránku nie je možné zobraziť so servisným agentom","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Podporný agent by vás rád sledoval na ďalšie webové stránky.","UNIVERSAL_PROXY_REQUEST_TITLE":"Povoliť pokračovanie relácie?"}');

/***/ }),

/***/ 41224:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Dovoli","CALLING_ACCEPT":"Sprejmi","CALLING_CAMERA_OFF":"Kamera je izklopljena","CALLING_CAMERA_PERMISSION_DENIED":"Dostop do kamere zavrnjen. Omogočite ga v nastavitvah brskalnika.","CALLING_CAMERA_PERMISSION_PROMPT":"Dovoli dostop do kamere","CALLING_CAMERA_STARTING":"Kamera se začenja","CALLING_CANCEL":"Prekliči","CALLING_DISABLE_AUDIO":"Onemogoči zvok","CALLING_DISABLE_VIDEO":"Onemogoči video","CALLING_ENABLE_AUDIO":"Omogoči zvok","CALLING_ENABLE_VIDEO":"Omogoči video","CALLING_END":"Končaj klic","CALLING_JOIN":"Pridruži se klicu","CALLING_JOIN_PROMPT":"Podporni agent vas želi poklicati.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Jaz","CALLING_MICROPHONE_PERMISSION_DENIED":"Dostop do mikrofona zavrnjen. Omogočite ga v nastavitvah brskalnika.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Dovoli dostop do mikrofona","CALLING_NO_DEVICES":"Noben","CALLING_PERMISSION_NEEDED":"Potrebna dovoljenja","CALLING_REJECT":"Zavrni klic","CALLING_REJOIN_PROMPT":"Imate aktivni klic s podporo. Želite ponovno pristopiti?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Želite vstopiti v video klic?","CALLING_SAVE":"Shrani","CALLING_SELECT_CAMERA":"Izberite kamero","CALLING_SELECT_MICROPHONE":"Izberite mikrofon","CALLING_SELECT_SPEAKER":"Izberite zvočnika","CALLING_SHOW_CALL_SETTINGS":"Prikaži nastavitve klica","DENY":"Zanikati","END_SESSION":"Končaj sejo Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Agent za podporo si želi ogledati vaš celoten zaslon.","FULL_DEVICE_REQUEST_TITLE":"Dovoliti zajemanje celotnega zaslona?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Podporni agent želi nadzorovati to stran.","REMOTE_CONTROL_REQUEST_TITLE":"Dovoliti daljinsko upravljanje?","SESSION_REQUEST_DESCRIPTION":"Agent za podporo želi začasno uporabljati to spletno stran z vami.","SESSION_REQUEST_TITLE":"Dovoliti cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Ta spletna stran se ne more ogledovati z agentom za podporo","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Agent za podporo vas želi slediti na druge spletne strani.","UNIVERSAL_PROXY_REQUEST_TITLE":"Dovoliti nadaljevanje seje?"}');

/***/ }),

/***/ 88978:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Tillåt","CALLING_ACCEPT":"Acceptera","CALLING_CAMERA_OFF":"Kameran är avstängd","CALLING_CAMERA_PERMISSION_DENIED":"Kameratillgång nekad. Aktivera den i dina webbläsarinställningar.","CALLING_CAMERA_PERMISSION_PROMPT":"Tillåt åtkomst till kamera","CALLING_CAMERA_STARTING":"Kameran startar","CALLING_CANCEL":"Avbryt","CALLING_DISABLE_AUDIO":"Inaktivera ljud","CALLING_DISABLE_VIDEO":"Inaktivera video","CALLING_ENABLE_AUDIO":"Aktivera ljud","CALLING_ENABLE_VIDEO":"Aktivera video","CALLING_END":"Avsluta samtal","CALLING_JOIN":"Gå med i samtal","CALLING_JOIN_PROMPT":"En supportagent vill ringa dig.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Jag","CALLING_MICROPHONE_PERMISSION_DENIED":"Mikrofontillgång nekad. Aktivera den i din webbläsarinställningar.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Tillåt åtkomst till mikrofonen","CALLING_NO_DEVICES":"Ingen","CALLING_PERMISSION_NEEDED":"Behörighet krävs","CALLING_REJECT":"Avvisa samtal","CALLING_REJOIN_PROMPT":"Du har ett aktivt samtal med en supportagent. Vill du ansluta igen?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Starta videosamtal?","CALLING_SAVE":"Spara","CALLING_SELECT_CAMERA":"Välj kamera","CALLING_SELECT_MICROPHONE":"Välj mikrofon","CALLING_SELECT_SPEAKER":"Välj talare","CALLING_SHOW_CALL_SETTINGS":"Visa samtalsinställningar","DENY":"Neka","END_SESSION":"Sluta dela","FULL_DEVICE_REQUEST_DESCRIPTION":"En supportagent vill se hela din skärm.","FULL_DEVICE_REQUEST_TITLE":"Tillåt fullskärmsinspelning?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"En supportagent vill kontrollera denna sida.","REMOTE_CONTROL_REQUEST_TITLE":"Tillåt fjärrstyrning?","SESSION_REQUEST_DESCRIPTION":"En supportagent vill tillfälligt använda denna webbsida tillsammans med dig.","SESSION_REQUEST_TITLE":"Tillåt samvisning?","UNIVERSAL_PROXY_BLOCKED":"Den här webbsidan kan inte visas tillsammans med en supportagent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"En supportagent vill följa dig till andra webbsidor.","UNIVERSAL_PROXY_REQUEST_TITLE":"Tillåt sessionens fortsättning?"}');

/***/ }),

/***/ 29250:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"อนุญาต","CALLING_ACCEPT":"ยอมรับ","CALLING_CAMERA_OFF":"กล้องปิดอยู่","CALLING_CAMERA_PERMISSION_DENIED":"การเข้าถึงกล้องถูกปฏิเสธ โปรดเปิดใช้งานในการตั้งค่าเบราว์เซอร์ของคุณ","CALLING_CAMERA_PERMISSION_PROMPT":"อนุญาตให้เข้าถึงกล้อง","CALLING_CAMERA_STARTING":"กล้องกำลังเริ่มทำงาน","CALLING_CANCEL":"ยกเลิก","CALLING_DISABLE_AUDIO":"ปิดเสียง","CALLING_DISABLE_VIDEO":"ปิดวิดีโอ","CALLING_ENABLE_AUDIO":"เปิดใช้งานเสียง","CALLING_ENABLE_VIDEO":"เปิดใช้งานวิดีโอ","CALLING_END":"ยุติการโทร","CALLING_JOIN":"เข้าร่วมการโทร","CALLING_JOIN_PROMPT":"เจ้าหน้าที่สนับสนุนต้องการโทรหาคุณ","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"ฉัน","CALLING_MICROPHONE_PERMISSION_DENIED":"ไม่อนุญาตให้เข้าถึงไมโครโฟน เปิดใช้งานได้ในการตั้งค่าเบราว์เซอร์ของคุณ","CALLING_MICROPHONE_PERMISSION_PROMPT":"อนุญาตให้เข้าถึงไมโครโฟน","CALLING_NO_DEVICES":"ไม่มี","CALLING_PERMISSION_NEEDED":"ต้องการการอนุญาต","CALLING_REJECT":"ปฏิเสธการโทร","CALLING_REJOIN_PROMPT":"คุณกำลังโทรอยู่กับเจ้าหน้าที่สนับสนุน คุณต้องการเข้าร่วมใหม่หรือไม่?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"เจ้าหน้าที่","CALLING_REQUEST":"เข้าร่วมวิดีโอคอล?","CALLING_SAVE":"บันทึก","CALLING_SELECT_CAMERA":"เลือกกล้อง","CALLING_SELECT_MICROPHONE":"เลือกไมโครโฟน","CALLING_SELECT_SPEAKER":"เลือกผู้พูด","CALLING_SHOW_CALL_SETTINGS":"แสดงการตั้งค่าการโทร","DENY":"ปฏิเสธ","END_SESSION":"หยุดแชร์","FULL_DEVICE_REQUEST_DESCRIPTION":"เจ้าหน้าที่ฝ่ายสนับสนุนต้องการดูหน้าจอของคุณทั้งหมด","FULL_DEVICE_REQUEST_TITLE":"อนุญาตให้บันทึกหน้าจอเต็มหรือไม่?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"เจ้าหน้าที่สนับสนุนต้องการควบคุมหน้านี้","REMOTE_CONTROL_REQUEST_TITLE":"อนุญาตการควบคุมระยะไกลหรือไม่?","SESSION_REQUEST_DESCRIPTION":"ตัวแทนฝ่ายสนับสนุนต้องการใช้หน้าเว็บนี้กับคุณเป็นการชั่วคราว","SESSION_REQUEST_TITLE":"อนุญาตให้ใช้โคบราวซิ่งหรือไม่?","UNIVERSAL_PROXY_BLOCKED":"หน้าเว็บนี้ไม่สามารถดูได้พร้อมกับเจ้าหน้าที่สนับสนุน","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"เจ้าหน้าที่ฝ่ายสนับสนุนต้องการติดตามคุณไปยังหน้าเว็บอื่น ๆ","UNIVERSAL_PROXY_REQUEST_TITLE":"อนุญาตให้ดำเนินการเซสชันต่อหรือไม่?"}');

/***/ }),

/***/ 80747:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"อนุญาต","CALLING_ACCEPT":"ยอมรับ","CALLING_CAMERA_OFF":"กล้องปิดอยู่","CALLING_CAMERA_PERMISSION_DENIED":"ไม่อนุญาตให้เข้าถึงกล้อง โปรดเปิดใช้งานในการตั้งค่าเบราว์เซอร์ของคุณ","CALLING_CAMERA_PERMISSION_PROMPT":"อนุญาตให้เข้าถึงกล้อง","CALLING_CAMERA_STARTING":"กำลังเริ่มกล้อง","CALLING_CANCEL":"ยกเลิก","CALLING_DISABLE_AUDIO":"ปิดเสียง","CALLING_DISABLE_VIDEO":"ปิดวิดีโอ","CALLING_ENABLE_AUDIO":"เปิดใช้งานเสียง","CALLING_ENABLE_VIDEO":"เปิดใช้งานวิดีโอ","CALLING_END":"สิ้นสุดการโทร","CALLING_JOIN":"เข้าร่วมการโทร","CALLING_JOIN_PROMPT":"เจ้าหน้าที่ฝ่ายสนับสนุนต้องการโทรหาคุณ","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"ฉัน","CALLING_MICROPHONE_PERMISSION_DENIED":"ปฏิเสธการเข้าถึงไมโครโฟน เปิดใช้งานได้ที่การตั้งค่าเบราว์เซอร์ของคุณ","CALLING_MICROPHONE_PERMISSION_PROMPT":"อนุญาตให้เข้าถึงไมโครโฟน","CALLING_NO_DEVICES":"ไม่มี","CALLING_PERMISSION_NEEDED":"ต้องการสิทธิ์การอนุญาต","CALLING_REJECT":"ปฏิเสธการโทร","CALLING_REJOIN_PROMPT":"คุณกำลังโทรอยู่กับเจ้าหน้าที่ฝ่ายสนับสนุน ต้องการเข้าร่วมใหม่หรือไม่?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"ตัวแทน","CALLING_REQUEST":"เข้าร่วมสายวิดีโอคอลหรือไม่?","CALLING_SAVE":"บันทึก","CALLING_SELECT_CAMERA":"เลือกกล้อง","CALLING_SELECT_MICROPHONE":"เลือกไมโครโฟน","CALLING_SELECT_SPEAKER":"เลือกผู้พูด","CALLING_SHOW_CALL_SETTINGS":"แสดงการตั้งค่าการโทร","DENY":"ปฏิเสธ","END_SESSION":"หยุดแชร์","FULL_DEVICE_REQUEST_DESCRIPTION":"ตัวแทนฝ่ายสนับสนุนต้องการดูหน้าจอของคุณทั้งหมด","FULL_DEVICE_REQUEST_TITLE":"อนุญาตให้จับภาพหน้าจอแบบเต็มจอหรือไม่?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"ตัวแทนฝ่ายสนับสนุนต้องการควบคุมหน้านี้","REMOTE_CONTROL_REQUEST_TITLE":"อนุญาตให้ควบคุมระยะไกลได้หรือไม่?","SESSION_REQUEST_DESCRIPTION":"ตัวแทนสนับสนุนต้องการใช้หน้าเว็บนี้กับคุณชั่วคราว","SESSION_REQUEST_TITLE":"อนุญาตให้ร่วมท่องเว็บไหม?","UNIVERSAL_PROXY_BLOCKED":"ไม่สามารถดูหน้าเว็บนี้กับเจ้าหน้าที่สนับสนุนได้","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"ตัวแทนฝ่ายสนับสนุนต้องการติดตามคุณไปยังหน้าเว็บอื่น ๆ","UNIVERSAL_PROXY_REQUEST_TITLE":"อนุญาตให้ดำเนินการต่อเซสชันไหม?"}');

/***/ }),

/***/ 31559:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Дозволити","CALLING_ACCEPT":"Прийняти","CALLING_CAMERA_OFF":"Камера вимкнена","CALLING_CAMERA_PERMISSION_DENIED":"Доступ до камери заборонено. Увімкніть його у налаштуваннях браузера.","CALLING_CAMERA_PERMISSION_PROMPT":"Дозволити доступ до камери","CALLING_CAMERA_STARTING":"Камера запускається","CALLING_CANCEL":"Скасувати","CALLING_DISABLE_AUDIO":"Вимкнути звук","CALLING_DISABLE_VIDEO":"Вимкнути відео","CALLING_ENABLE_AUDIO":"Увімкнути звук","CALLING_ENABLE_VIDEO":"Увімкнути відео","CALLING_END":"Завершити дзвінок","CALLING_JOIN":"Приєднатися до дзвінка","CALLING_JOIN_PROMPT":"Агент підтримки хоче зателефонувати вам.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Я","CALLING_MICROPHONE_PERMISSION_DENIED":"Доступ до мікрофона заборонено. Увімкніть його в налаштуваннях браузера.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Дозволити доступ до мікрофона","CALLING_NO_DEVICES":"Жоден","CALLING_PERMISSION_NEEDED":"Потрібен дозвіл","CALLING_REJECT":"Відхилити дзвінок","CALLING_REJOIN_PROMPT":"У вас активний дзвінок із агентом підтримки. Бажаєте приєднатися знову?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Агент","CALLING_REQUEST":"Почати відеодзвінок?","CALLING_SAVE":"Зберегти","CALLING_SELECT_CAMERA":"Вибрати камеру","CALLING_SELECT_MICROPHONE":"Виберіть мікрофон","CALLING_SELECT_SPEAKER":"Вибрати динамік","CALLING_SHOW_CALL_SETTINGS":"Показати налаштування дзвінка","DENY":"Заперечую","END_SESSION":"Завершити сеанс Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Агент підтримки хотів би переглянути весь ваш екран.","FULL_DEVICE_REQUEST_TITLE":"Дозволити повне захоплення екрана?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Агент підтримки хотів би контролювати цю сторінку.","REMOTE_CONTROL_REQUEST_TITLE":"Дозволити дистанційне керування?","SESSION_REQUEST_DESCRIPTION":"Агент служби підтримки хотів би тимчасово використовувати цю веб-сторінку разом з вами.","SESSION_REQUEST_TITLE":"Дозволити кобраузинг?","UNIVERSAL_PROXY_BLOCKED":"Ця веб-сторінка не може бути переглянута з агентом підтримки","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Агент підтримки хотів би слідувати за вами на інші веб-сторінки.","UNIVERSAL_PROXY_REQUEST_TITLE":"Дозволити продовження сеансу?"}');

/***/ }),

/***/ 87762:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Cho phép","CALLING_ACCEPT":"Chấp nhận","CALLING_CAMERA_OFF":"Camera đã tắt","CALLING_CAMERA_PERMISSION_DENIED":"Truy cập camera bị từ chối. Hãy bật nó trong cài đặt trình duyệt của bạn.","CALLING_CAMERA_PERMISSION_PROMPT":"Cho phép truy cập camera","CALLING_CAMERA_STARTING":"Máy ảnh đang khởi động","CALLING_CANCEL":"Hủy bỏ","CALLING_DISABLE_AUDIO":"Tắt âm thanh","CALLING_DISABLE_VIDEO":"Vô hiệu hóa video","CALLING_ENABLE_AUDIO":"Bật âm thanh","CALLING_ENABLE_VIDEO":"Bật video","CALLING_END":"Kết thúc cuộc gọi","CALLING_JOIN":"Tham gia cuộc gọi","CALLING_JOIN_PROMPT":"Một nhân viên hỗ trợ muốn gọi cho bạn.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Tôi","CALLING_MICROPHONE_PERMISSION_DENIED":"Quyền truy cập micro bị từ chối. Vui lòng bật trong cài đặt trình duyệt của bạn.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Cho phép truy cập micro","CALLING_NO_DEVICES":"Không có gì","CALLING_PERMISSION_NEEDED":"Cần quyền truy cập","CALLING_REJECT":"Từ chối cuộc gọi","CALLING_REJOIN_PROMPT":"Bạn đang có một cuộc gọi đang hoạt động với nhân viên hỗ trợ. Bạn có muốn tham gia lại không?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Đại lý","CALLING_REQUEST":"Tham gia gọi video?","CALLING_SAVE":"Lưu","CALLING_SELECT_CAMERA":"Chọn camera","CALLING_SELECT_MICROPHONE":"Chọn micro","CALLING_SELECT_SPEAKER":"Chọn người nói","CALLING_SHOW_CALL_SETTINGS":"Hiển thị cài đặt cuộc gọi","DENY":"Từ chối","END_SESSION":"Kết thúc phiên Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Một tổng đài viên hỗ trợ muốn xem toàn bộ màn hình của bạn.","FULL_DEVICE_REQUEST_TITLE":"Cho phép chụp toàn bộ màn hình?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Một tổng đài viên hỗ trợ muốn kiểm soát trang này.","REMOTE_CONTROL_REQUEST_TITLE":"Cho phép điều khiển từ xa?","SESSION_REQUEST_DESCRIPTION":"Một tổng đài viên muốn tạm thời sử dụng trang web này với bạn.","SESSION_REQUEST_TITLE":"Cho phép cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Trang web này không thể được xem cùng với một tổng đài viên hỗ trợ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Một tổng đài viên hỗ trợ muốn theo dõi bạn đến các trang web khác.","UNIVERSAL_PROXY_REQUEST_TITLE":"Cho phép tiếp tục phiên?"}');

/***/ }),

/***/ 84181:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"允許","CALLING_ACCEPT":"接受","CALLING_CAMERA_OFF":"攝影機已關閉","CALLING_CAMERA_PERMISSION_DENIED":"相機存取被拒。請在瀏覽器設定中啟用。","CALLING_CAMERA_PERMISSION_PROMPT":"允許存取相機","CALLING_CAMERA_STARTING":"攝影機正在啟動","CALLING_CANCEL":"取消","CALLING_DISABLE_AUDIO":"停用音訊","CALLING_DISABLE_VIDEO":"停用影片","CALLING_ENABLE_AUDIO":"啟用音訊","CALLING_ENABLE_VIDEO":"啟用影片","CALLING_END":"結束通話","CALLING_JOIN":"加入通話","CALLING_JOIN_PROMPT":"支援代理想要致電給您。","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"我","CALLING_MICROPHONE_PERMISSION_DENIED":"麥克風存取被拒。請在您的瀏覽器設定中啟用。","CALLING_MICROPHONE_PERMISSION_PROMPT":"允許存取麥克風","CALLING_NO_DEVICES":"無","CALLING_PERMISSION_NEEDED":"需要權限","CALLING_REJECT":"拒絕通話","CALLING_REJOIN_PROMPT":"您目前正與客服代理通話。您要重新加入嗎？","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"代理","CALLING_REQUEST":"進入視訊通話？","CALLING_SAVE":"儲存","CALLING_SELECT_CAMERA":"選擇攝影機","CALLING_SELECT_MICROPHONE":"選擇麥克風","CALLING_SELECT_SPEAKER":"選擇講者","CALLING_SHOW_CALL_SETTINGS":"顯示通話設定","DENY":"拒絕","END_SESSION":"結束共同瀏覽會話","FULL_DEVICE_REQUEST_DESCRIPTION":"一位支援代理想檢視您的整個畫面。","FULL_DEVICE_REQUEST_TITLE":"允許全螢幕截圖？","REMOTE_CONTROL_REQUEST_DESCRIPTION":"一位支援代理希望控制此頁面。","REMOTE_CONTROL_REQUEST_TITLE":"允許遠程控制？","SESSION_REQUEST_DESCRIPTION":"支援人員希望暫時與您一起使用此網頁。","SESSION_REQUEST_TITLE":"允許協同瀏覽？","UNIVERSAL_PROXY_BLOCKED":"此網頁無法與客服代理一起檢視","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"客服代理希望跟隨您訪問其他網頁。","UNIVERSAL_PROXY_REQUEST_TITLE":"允許會話繼續？"}');

/***/ }),

/***/ 81606:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"允许","CALLING_ACCEPT":"接受","CALLING_CAMERA_OFF":"摄像头已关闭","CALLING_CAMERA_PERMISSION_DENIED":"摄像头访问被拒绝。请在您的浏览器设置中启用。","CALLING_CAMERA_PERMISSION_PROMPT":"允许访问摄像头","CALLING_CAMERA_STARTING":"摄像头正在启动","CALLING_CANCEL":"取消","CALLING_DISABLE_AUDIO":"禁用音频","CALLING_DISABLE_VIDEO":"禁用视频","CALLING_ENABLE_AUDIO":"启用音频","CALLING_ENABLE_VIDEO":"启用视频","CALLING_END":"结束通话","CALLING_JOIN":"加入通话","CALLING_JOIN_PROMPT":"支持代理想要给您打电话。","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"我","CALLING_MICROPHONE_PERMISSION_DENIED":"麦克风访问被拒绝。请在您的浏览器设置中启用。","CALLING_MICROPHONE_PERMISSION_PROMPT":"允许访问麦克风","CALLING_NO_DEVICES":"无","CALLING_PERMISSION_NEEDED":"需要权限","CALLING_REJECT":"拒绝通话","CALLING_REJOIN_PROMPT":"您当前正与一位支持代理通话。您想重新加入吗？","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"坐席","CALLING_REQUEST":"开始视频通话？","CALLING_SAVE":"保存","CALLING_SELECT_CAMERA":"选择摄像头","CALLING_SELECT_MICROPHONE":"选择麦克风","CALLING_SELECT_SPEAKER":"选择说话者","CALLING_SHOW_CALL_SETTINGS":"显示通话设置","DENY":"拒绝","END_SESSION":"结束共同浏览会话","FULL_DEVICE_REQUEST_DESCRIPTION":"客服代理希望查看您的整个屏幕。","FULL_DEVICE_REQUEST_TITLE":"允许全屏截图？","REMOTE_CONTROL_REQUEST_DESCRIPTION":"客服代理希望控制此页面。","REMOTE_CONTROL_REQUEST_TITLE":"允许远程控制？","SESSION_REQUEST_DESCRIPTION":"客服代理希望与您暂时共享此网页。","SESSION_REQUEST_TITLE":"允许协同浏览？","UNIVERSAL_PROXY_BLOCKED":"此网页无法与客服代理一起查看","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"客服代理希望跟随您访问其他网页。","UNIVERSAL_PROXY_REQUEST_TITLE":"允许会话继续？"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + {"246":"pdf-viewer","660":"elevenlabs"}[chunkId] + ".chunk.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "CobrowseIO:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			792: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkCobrowseIO"] = self["webpackChunkCobrowseIO"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports["default"] = void 0;
__webpack_require__(25477);
var _cocom = __webpack_require__(63439);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(85620));
var _iframes = _interopRequireDefault(__webpack_require__(77966));
var _NativeSelect = _interopRequireDefault(__webpack_require__(51112));
var _Session = _interopRequireDefault(__webpack_require__(52404));
var _protected = _interopRequireDefault(__webpack_require__(37609));
var _redaction = __webpack_require__(16566);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// normally we avoid polyfills, but some customer sites use a Promise
// polyfill that replaces the implementation and omits allSettled

const e = _CobrowseIO.default;
if (window.__cobrowse_io_loaded) {
  // eslint-disable-next-line no-import-assign
  _CobrowseIO.default = (null, function () {
    throw new Error('"' + "CobrowseIO" + '" is read-only.');
  }());
  throw new Error('CobrowseIO already loaded. This usually means you included the snippet multiple times.');
}
window.__cobrowse_io_loaded = true;
let hasIFrameSession = false;
const nativeSelect = new _NativeSelect.default({
  shouldShowSelect: () => {
    var _CobrowseIO$currentSe;
    return ((_CobrowseIO$currentSe = _CobrowseIO.default.currentSession) === null || _CobrowseIO$currentSe === void 0 ? void 0 : _CobrowseIO$currentSe.isActive()) || hasIFrameSession;
  },
  isRedacted: target => {
    var _RedactionIndexProvid;
    return (_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid === void 0 ? void 0 : _RedactionIndexProvid.isRedacted(target);
  }
});
nativeSelect.track(window);
_iframes.default.on('iframe_discovered', iframe => {
  if ((0, _cocom.isxdoc)(iframe)) return;
  nativeSelect.track(iframe.contentWindow);
});
_iframes.default.on('session', serializedSession => {
  const currentSession = new _Session.default(e);
  currentSession[_protected.default].deserialize(serializedSession);
  hasIFrameSession = currentSession.isActive();
});
var _default = exports["default"] = e;
})();

CobrowseIO = __webpack_exports__["default"];
/******/ })()
;
;window.__cbio_sdk_styles = ".HighlightOverlay-module__overlay___IwXTu{animation:HighlightOverlay-module__highlightOverlayFadeIn___gxAX9 .4s cubic-bezier(.25,.46,.45,.94) forwards,HighlightOverlay-module__highlightOverlayPulse___fW7eg 2.5s cubic-bezier(.25,.46,.45,.94) .4s infinite;box-shadow:var(--cbio-color-highlight-backdrop) 0 0 0 5000px;opacity:0;pointer-events:none;position:absolute;transform-origin:center;transition:all .3s ease-in-out;z-index:2147483646}.HighlightOverlay-module__disableAnimations___vQPvb{transition:none!important}@media (prefers-reduced-motion:reduce){.HighlightOverlay-module__overlay___IwXTu{animation:none;opacity:1;outline:3px solid #8481f8cc;transition:none}}@keyframes HighlightOverlay-module__highlightOverlayFadeIn___gxAX9{0%{opacity:0}to{opacity:1}}@keyframes HighlightOverlay-module__highlightOverlayPulse___fW7eg{0%,to{box-shadow:0 0 0 3px #8481f8cc,0 0 0 5000px var(--cbio-color-highlight-backdrop);transform:scaleX(1) scaleY(1)}50%{box-shadow:0 0 0 3px #8481f8,0 0 0 5000px var(--cbio-color-highlight-backdrop);transform:scaleX(var(--cbio-padded-x)) scaleY(var(--cbio-padded-y))}}.Tooltip-module__tooltip___IL4dx{background-color:var(--cbio-color-background-primary);border:1px solid var(--cbio-color-border);border-radius:var(--cbio-radius-md);box-sizing:border-box;left:0;max-width:400px;opacity:0;position:absolute;top:0;transition:opacity .4s ease-out,top .4s ease-out;width:max-content;z-index:2147483646}.Tooltip-module__tooltipVisible___a7Zvs{opacity:1}@media (prefers-reduced-motion:reduce){.Tooltip-module__tooltip___IL4dx{transition:none}}.Tooltip-module__tooltipTitle___gG75M{background-color:var(--cbio-color-background-primary);border-radius:var(--cbio-radius-md);color:var(--cbio-color-text-secondary);font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);line-height:var(--cbio-line-height-sm);padding:12px;position:relative;z-index:1}.Tooltip-module__tooltipArrow___kPSXv{background-color:var(--cbio-color-background-primary);border-bottom:1px solid var(--cbio-color-border);border-radius:2px;border-right:1px solid var(--cbio-color-border);height:12px;position:absolute;transform:rotate(45deg);width:12px}:host,:root{--cbio-font-family-base:Helvetica Neue,Helvetica,Arial,sans-serif;--cbio-font-size-sm:14px;--cbio-line-height-sm:20px;--cbio-font-size-md:18px;--cbio-line-height-md:130%;--cbio-font-size-lg:20px;--cbio-line-height-lg:24px;--cbio-radius-md:8px;--cbio-radius-lg:24px;--cbio-radius-pill:9999px;--cbio-color-text-primary:#26252c;--cbio-color-text-secondary:#6f6d82;--cbio-color-text-muted:#92909d;--cbio-color-text-strong:#0e0c26;--cbio-color-text-light:#f5f6fb;--cbio-color-text-white:#fff;--cbio-color-background-primary:#fff;--cbio-color-background-secondary:#36008e;--cbio-color-background-light:#eeeff1;--cbio-color-modal-backdrop:#00000059;--cbio-color-highlight-backdrop:#29284199;--cbio-color-accent-primary:#6556f0;--cbio-color-accent-primary-hover:#4126a7;--cbio-color-danger:#dc2626;--cbio-color-danger-hover:#b91c1c;--cbio-color-danger-hover-soft:#fca5a5;--cbio-color-border:#bcc1d4;--cbio-shadow-buttons:0px 4px 12px #00000059}.cbio-sr-only{height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;clip:rect(0,0,0,0);border-width:0;white-space:nowrap}.Button-module__base___PvaYv{appearance:none;border:none;border-radius:var(--cbio-radius-md);cursor:pointer;font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);line-height:var(--cbio-line-height-sm);padding:10px 16px;user-select:none;white-space:nowrap}.Button-module__primary___jyGbF{background-color:var(--cbio-color-accent-primary);color:var(--cbio-color-text-light);font-weight:700}.Button-module__primary___jyGbF:hover{background-color:var(--cbio-color-accent-primary-hover)}.Button-module__secondary___V1ksJ{background-color:var(--cbio-color-background-light);color:var(--cbio-color-text-strong)}.Button-module__secondary___V1ksJ:hover{background-color:initial}.IconButton-module__base___wAyLz{align-items:center;background:none;border:none;cursor:pointer;display:flex;justify-content:center;margin:0;padding:0}.Modal-module__container___G4Twz{align-items:center;background:var(--cbio-color-modal-backdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:2147483647}.Modal-module__content___tkuQp{border-radius:var(--cbio-radius-md);box-shadow:0 4px 4px #00000040;box-sizing:border-box;color:var(--cbio-color-text-secondary);margin:24px;padding:24px;position:fixed;z-index:2147483647}.Modal-module__content___tkuQp,.Select-module__base___YM7TJ{background-color:var(--cbio-color-background-primary);font-family:var(--cbio-font-family-base)}.Select-module__base___YM7TJ{appearance:none;background-repeat:no-repeat;background-size:16px;border:none;border-radius:var(--cbio-radius-md);color:#393842;cursor:pointer;font-size:var(--cbio-font-size-sm);overflow:hidden;text-overflow:ellipsis;text-wrap:nowrap;width:100%}.Select-module__base___YM7TJ:disabled{cursor:not-allowed}.Select-module__base___YM7TJ:not(:disabled):hover{box-shadow:inset 0 0 0 1px #c7cbfe}.Select-module__noIcon___nzh9A{background-position:right 4px center;padding:8px 16px 8px 8px}.SessionStateOverlay-module__sessionStateOverlay___pCowu{bottom:20px;display:flex;gap:12px;left:50%;position:fixed;transform:translateX(-50%);z-index:2147483647}.SessionStateOverlay-module__endSessionButton___pUtd7{align-items:center;appearance:none;background:var(--cbio-color-danger);border:none;border-radius:var(--cbio-radius-md);box-shadow:var(--cbio-shadow-buttons);color:var(--cbio-color-text-light);cursor:pointer;display:flex;font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);font-weight:700;gap:8px;line-height:var(--cbio-line-height-sm);padding:10px 16px;user-select:none;white-space:nowrap}.SessionStateOverlay-module__endSessionButton___pUtd7:hover{background:var(--cbio-color-danger-hover)}.SessionStateOverlay-module__endSessionIcon___vLhgE{height:24px;width:24px}.SessionStateOverlay-module__callingControlsContainer___UYdU1{border-radius:var(--cbio-radius-md);box-shadow:var(--cbio-shadow-buttons);color:var(--cbio-color-text-light);display:flex;overflow:hidden}.SessionStateOverlay-module__callingControlsToggleContainer___jmNM6{align-items:center;background-color:#292841;display:flex;gap:10px;padding:10px 12px}.SessionStateOverlay-module__callingControlsToggle___ry4m0{height:24px;width:24px}.SessionStateOverlay-module__callingControlsToggleOff___jxwB4{color:#ef4444}.SessionStateOverlay-module__callingControlsToggleOff___jxwB4:hover{color:var(--cbio-color-danger-hover-soft)}.SessionStateOverlay-module__callingControlsToggleOn___FUuRG{color:var(--cbio-color-text-light)}.SessionStateOverlay-module__callingControlsToggleOn___FUuRG:hover{color:var(--cbio-color-border)}.SessionStateOverlay-module__callingControlsIcon___OWYpc{height:24px;width:24px}.SessionStateOverlay-module__callingControlsEnd___t4Xky{background-color:var(--cbio-color-danger)!important;height:100%;width:44px}.SessionStateOverlay-module__callingControlsEnd___t4Xky:hover{background-color:var(--cbio-color-danger-hover)!important}.ConsentDialog-module__content___fUfL3{max-width:400px}.ConsentDialog-module__title___MTrAq{color:var(--cbio-color-text-primary);font-size:var(--cbio-font-size-lg);font-weight:700;line-height:var(--cbio-line-height-lg);margin-bottom:6px;margin-top:0}.ConsentDialog-module__body___FtS5W{color:var(--cbio-color-text-muted);display:flex;flex-direction:column;font-size:var(--cbio-font-size-md);line-height:var(--cbio-line-height-md)}.ConsentDialog-module__confirmation___v7fj3{color:var(--cbio-color-text-primary);margin:0}.ConsentDialog-module__description___eSwUl{margin:0}.ConsentDialog-module__buttons___nToO7{display:flex;gap:8px;justify-content:end;margin-top:32px}.CallParticipants-module__container___JHyh3{display:grid;gap:12px;grid-auto-rows:min-content;padding:12px;width:300px}.CallParticipants-module__participantContainer___WEeET{border-radius:var(--cbio-radius-md);box-shadow:0 0 8px #00000040;overflow:hidden;position:relative}.CallParticipants-module__participantSpeaking___aovg8{outline:2px solid var(--cbio-color-accent-primary);outline-offset:2px}.CallParticipants-module__videoContainer___cuUmK{aspect-ratio:16/9;height:100%;position:relative;width:100%}.CallParticipants-module__video___osVRK{background-color:var(--cbio-color-background-secondary);height:100%;transform:scaleX(-1);width:100%}.CallParticipants-module__videoOverlay___x1yb0{align-items:center;background-color:var(--cbio-color-background-secondary);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}.CallParticipants-module__statusContainer___Vrvvr{align-items:center;bottom:0;color:var(--cbio-color-text-white);display:flex;gap:8px;justify-content:center;padding:8px;position:absolute;user-select:none}.CallParticipants-module__statusTitle___puKch{font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);text-shadow:0 0 4px #000}.CallParticipants-module__statusIcon____w42b{filter:drop-shadow(0 0 4px black);height:20px;width:20px}.CallParticipants-module__videoOverlayIcon___Fph1m{color:var(--cbio-color-danger);height:24px;width:24px}.MediaPreview-module__content___4fxuk{display:flex;flex-direction:column;max-width:500px}.MediaPreview-module__header___E2CcH{display:flex;flex-direction:column;gap:35px}.MediaPreview-module__media___kmkmo{display:flex;flex-direction:column;gap:12px}.MediaPreview-module__body___VPagd{color:var(--cbio-color-text-muted);display:flex;flex-direction:column;font-size:var(--cbio-font-size-md);line-height:var(--cbio-line-height-md);margin-top:8px}.MediaPreview-module__title___uSKCr{color:var(--cbio-color-text-primary);font-size:var(--cbio-font-size-lg);font-weight:700;line-height:var(--cbio-line-height-lg);margin:0}.MediaPreview-module__description___IPolu{margin:0}.MediaPreview-module__previewContainer___hZF98{position:relative}.MediaPreview-module__videoContainer____O8KD{aspect-ratio:16/9;border-radius:var(--cbio-radius-md);height:100%;overflow:hidden;position:relative;width:100%}.MediaPreview-module__video___DnVpX{background-color:#000;height:100%;transform:scaleX(-1);width:100%}.MediaPreview-module__videoOverlay___Wy27K{align-items:center;bottom:0;color:var(--cbio-color-text-white);display:flex;font-size:var(--cbio-font-size-md);justify-content:center;left:0;position:absolute;right:0;top:0}.MediaPreview-module__videoOverlaySolid___Ifi1O{background-color:#000}.MediaPreview-module__videoOverlayTransparent___vPzQr{background-color:#0006}.MediaPreview-module__videoOverlayText___kzAHr{padding:0 12px;text-align:center}.MediaPreview-module__deviceContainer___MEdwh{display:flex;flex-direction:row;gap:12px}.MediaPreview-module__buttonContainer___aXcOQ{display:flex;gap:8px;justify-content:flex-end;margin-top:35px}@media (max-width:768px){.MediaPreview-module__deviceContainer___MEdwh{flex-direction:column}}.MediaPreview-module__voiceVideoControls___qTsRx{background-color:var(--cbio-color-background-primary);border-radius:var(--cbio-radius-lg);bottom:12px;display:flex;left:50%;position:absolute;transform:translateX(-50%)}.MediaPreview-module__voiceVideoControlsToggle___prGk3{border-radius:var(--cbio-radius-pill);height:36px;width:36px}.MediaPreview-module__voiceVideoControlsToggle___prGk3:disabled{cursor:not-allowed}.MediaPreview-module__voiceVideoControlsToggleOff___ql_2k{color:var(--cbio-color-danger)}.MediaPreview-module__voiceVideoControlsToggleOff___ql_2k:not(:disabled):hover{background-color:var(--cbio-color-background-light)}.MediaPreview-module__voiceVideoControlsToggleOn___URkye{color:var(--cbio-color-text-strong)}.MediaPreview-module__voiceVideoControlsToggleOn___URkye:not(:disabled):hover{background-color:var(--cbio-color-background-light)}.MediaPreview-module__voiceVideoControlsIcon___yrQoV{height:24px;width:24px}";