(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CobrowseIO"] = factory();
	else
		root["CobrowseIO"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 565:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EbmlElementId = void 0;
exports.getEbmlElementIdLength = getEbmlElementIdLength;
exports.getEbmlElementLevel = getEbmlElementLevel;
exports.getEbmlElementName = getEbmlElementName;
exports.readEbmlElementId = readEbmlElementId;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class EbmlElementId {}
exports.EbmlElementId = EbmlElementId;
_defineProperty(EbmlElementId, "Ebml", 0x1a45dfa3);
_defineProperty(EbmlElementId, "EbmlVersion", 0x4286);
_defineProperty(EbmlElementId, "EbmlReadVersion", 0x42f7);
_defineProperty(EbmlElementId, "EbmlMaxIdLength", 0x42f2);
_defineProperty(EbmlElementId, "EbmlMaxSizeLength", 0x42f3);
_defineProperty(EbmlElementId, "DocType", 0x4282);
_defineProperty(EbmlElementId, "DocTypeVersion", 0x4287);
_defineProperty(EbmlElementId, "DocTypeReadVersion", 0x4285);
_defineProperty(EbmlElementId, "Void", 0xec);
_defineProperty(EbmlElementId, "Segment", 0x18538067);
_defineProperty(EbmlElementId, "SeekHead", 0x114d9b74);
_defineProperty(EbmlElementId, "Seek", 0x4dbb);
_defineProperty(EbmlElementId, "SeekID", 0x53ab);
_defineProperty(EbmlElementId, "SeekPosition", 0x53ac);
_defineProperty(EbmlElementId, "Info", 0x1549a966);
_defineProperty(EbmlElementId, "TimestampScale", 0x2ad7b1);
_defineProperty(EbmlElementId, "Duration", 0x4489);
_defineProperty(EbmlElementId, "DateUTC", 0x4461);
_defineProperty(EbmlElementId, "Title", 0x7ba9);
_defineProperty(EbmlElementId, "MuxingApp", 0x4d80);
_defineProperty(EbmlElementId, "WritingApp", 0x5741);
_defineProperty(EbmlElementId, "Cluster", 0x1f43b675);
_defineProperty(EbmlElementId, "Timestamp", 0xe7);
_defineProperty(EbmlElementId, "SimpleBlock", 0xa3);
_defineProperty(EbmlElementId, "SegmentUID", 0x73a4);
_defineProperty(EbmlElementId, "Tracks", 0x1654ae6b);
_defineProperty(EbmlElementId, "TrackEntry", 0xae);
_defineProperty(EbmlElementId, "TrackNumber", 0xd7);
_defineProperty(EbmlElementId, "TrackUID", 0x73c5);
_defineProperty(EbmlElementId, "TrackType", 0x83);
_defineProperty(EbmlElementId, "FlagEnabled", 0xb9);
_defineProperty(EbmlElementId, "FlagDefault", 0x88);
_defineProperty(EbmlElementId, "FlagForced", 0x55aa);
_defineProperty(EbmlElementId, "FlagLacing", 0x9c);
_defineProperty(EbmlElementId, "MinCache", 0x6de7);
_defineProperty(EbmlElementId, "MaxBlockAdditionID", 0x55ee);
_defineProperty(EbmlElementId, "CodecID", 0x86);
_defineProperty(EbmlElementId, "CodecDecodeAll", 0xaa);
_defineProperty(EbmlElementId, "SeekPreRoll", 0x56bb);
_defineProperty(EbmlElementId, "Video", 0xe0);
_defineProperty(EbmlElementId, "FlagInterlaced", 0x9a);
_defineProperty(EbmlElementId, "PixelWidth", 0xb0);
_defineProperty(EbmlElementId, "PixelHeight", 0xba);
_defineProperty(EbmlElementId, "DefaultDuration", 0x23e383);
_defineProperty(EbmlElementId, "TrackTimestampScale", 0x23314f);
_defineProperty(EbmlElementId, "CodecName", 0x258688);
_defineProperty(EbmlElementId, "CodecPrivate", 0x63a2);
_defineProperty(EbmlElementId, "Audio", 0xe1);
_defineProperty(EbmlElementId, "SamplingFrequency", 0xb5);
_defineProperty(EbmlElementId, "Channels", 0x9f);
_defineProperty(EbmlElementId, "Cues", 0x1c53bb6b);
_defineProperty(EbmlElementId, "CuePoint", 0xbb);
_defineProperty(EbmlElementId, "CueTime", 0xb3);
_defineProperty(EbmlElementId, "CueTrackPositions", 0xb7);
_defineProperty(EbmlElementId, "CueTrack", 0xf7);
_defineProperty(EbmlElementId, "CueClusterPosition", 0xf1);
_defineProperty(EbmlElementId, "CueRefTime", 0x96);
_defineProperty(EbmlElementId, "CueBlockNumber", 0x5378);
_defineProperty(EbmlElementId, "Position", 0xa7);
_defineProperty(EbmlElementId, "Colour", 0x55b0);
function getEbmlElementIdLength(firstByteOfEbmlElementId) {
  for (var position = 7; position > 3; position--) {
    if (firstByteOfEbmlElementId & 1 << position) {
      return 8 - position;
    }
  }
  throw Error("invalid ebml element id");
}
function getEbmlElementName(ebmlElementId) {
  switch (ebmlElementId) {
    case EbmlElementId.Ebml:
      return "EBML";
    case EbmlElementId.EbmlVersion:
      return "EBMLVersion";
    case EbmlElementId.EbmlReadVersion:
      return "EBMLReadVersion";
    case EbmlElementId.EbmlMaxIdLength:
      return "EBMLMaxIDLength";
    case EbmlElementId.EbmlMaxSizeLength:
      return "EBMLMaxSizeLength";
    case EbmlElementId.DocType:
      return "DocType";
    case EbmlElementId.DocTypeVersion:
      return "DocTypeVersion";
    case EbmlElementId.DocTypeReadVersion:
      return "DocTypeReadVersion";
    case EbmlElementId.Void:
      return "Void";
    case EbmlElementId.Segment:
      return "Segment";
    case EbmlElementId.SeekHead:
      return "SeekHead";
    case EbmlElementId.Seek:
      return "Seek";
    case EbmlElementId.SeekID:
      return "SeekID";
    case EbmlElementId.SeekPosition:
      return "SeekPosition";
    case EbmlElementId.Info:
      return "Info";
    case EbmlElementId.TimestampScale:
      return "TimestampScale";
    case EbmlElementId.Duration:
      return "Duration";
    case EbmlElementId.DateUTC:
      return "DateUTC";
    case EbmlElementId.Title:
      return "Title";
    case EbmlElementId.MuxingApp:
      return "MuxingApp";
    case EbmlElementId.WritingApp:
      return "WritinApp";
    case EbmlElementId.Cluster:
      return "Cluster";
    case EbmlElementId.Timestamp:
      return "Timestamp";
    case EbmlElementId.SimpleBlock:
      return "SimpleBlock";
    case EbmlElementId.SegmentUID:
      return "SegmentUID (unsupported by WebM)";
    case EbmlElementId.Tracks:
      return "Tracks";
    case EbmlElementId.TrackEntry:
      return "TrackEntry";
    case EbmlElementId.TrackNumber:
      return "TrackNumber";
    case EbmlElementId.TrackUID:
      return "TrackUID";
    case EbmlElementId.TrackType:
      return "TrackType";
    case EbmlElementId.FlagEnabled:
      return "FlagEnabled";
    case EbmlElementId.FlagDefault:
      return "FlagDefault";
    case EbmlElementId.FlagForced:
      return "FlagForced";
    case EbmlElementId.FlagLacing:
      return "FlagLacing";
    case EbmlElementId.MinCache:
      return "MinCache";
    case EbmlElementId.MaxBlockAdditionID:
      return "MaxBlockAdditionID";
    case EbmlElementId.CodecID:
      return "CodecID";
    case EbmlElementId.CodecDecodeAll:
      return "CodecDecodeAll";
    case EbmlElementId.SeekPreRoll:
      return "SeekPreRoll";
    case EbmlElementId.Video:
      return "Video";
    case EbmlElementId.FlagInterlaced:
      return "FlagInterlaced";
    case EbmlElementId.PixelWidth:
      return "PixelWidth";
    case EbmlElementId.PixelHeight:
      return "PixelHeight";
    case EbmlElementId.DefaultDuration:
      return "DefaultDuration";
    case EbmlElementId.TrackTimestampScale:
      return "TrackTimestampScale";
    case EbmlElementId.CodecName:
      return "CodecName";
    case EbmlElementId.CodecPrivate:
      return "CodecPrivate";
    case EbmlElementId.Audio:
      return "Audio";
    case EbmlElementId.SamplingFrequency:
      return "SamplingFrequency";
    case EbmlElementId.Channels:
      return "Channels";
    case EbmlElementId.Cues:
      return "Cues";
    case EbmlElementId.CuePoint:
      return "CuePoint";
    case EbmlElementId.CueTime:
      return "CueTime";
    case EbmlElementId.CueTrackPositions:
      return "CueTrackPositions";
    case EbmlElementId.CueTrack:
      return "CueTrack";
    case EbmlElementId.CueClusterPosition:
      return "CueClusterPosition";
    case EbmlElementId.CueRefTime:
      return "CueRefTime";
    case EbmlElementId.CueBlockNumber:
      return "CueBlockNumber";
    case EbmlElementId.Position:
      return "Position";
    case EbmlElementId.Colour:
      return "Colour";
    default:
      return "";
  }
}
function getEbmlElementLevel(ebmlElementId) {
  switch (ebmlElementId) {
    case EbmlElementId.Ebml:
    case EbmlElementId.Segment:
      return 0;
    case EbmlElementId.Cluster:
    case EbmlElementId.Cues:
    case EbmlElementId.DocType:
    case EbmlElementId.DocTypeReadVersion:
    case EbmlElementId.DocTypeVersion:
    case EbmlElementId.EbmlMaxIdLength:
    case EbmlElementId.EbmlMaxSizeLength:
    case EbmlElementId.EbmlReadVersion:
    case EbmlElementId.EbmlVersion:
    case EbmlElementId.Info:
    case EbmlElementId.SeekHead:
    case EbmlElementId.Tracks:
      return 1;
    case EbmlElementId.CuePoint:
    case EbmlElementId.DateUTC:
    case EbmlElementId.Duration:
    case EbmlElementId.MuxingApp:
    case EbmlElementId.Position:
    case EbmlElementId.SegmentUID:
    case EbmlElementId.Seek:
    case EbmlElementId.SimpleBlock:
    case EbmlElementId.Timestamp:
    case EbmlElementId.TimestampScale:
    case EbmlElementId.Title:
    case EbmlElementId.TrackEntry:
    case EbmlElementId.WritingApp:
      return 2;
    case EbmlElementId.Audio:
    case EbmlElementId.CodecDecodeAll:
    case EbmlElementId.CodecID:
    case EbmlElementId.CodecName:
    case EbmlElementId.CodecPrivate:
    case EbmlElementId.CueTime:
    case EbmlElementId.CueTrackPositions:
    case EbmlElementId.DefaultDuration:
    case EbmlElementId.FlagDefault:
    case EbmlElementId.FlagEnabled:
    case EbmlElementId.FlagForced:
    case EbmlElementId.FlagLacing:
    case EbmlElementId.MaxBlockAdditionID:
    case EbmlElementId.MinCache:
    case EbmlElementId.SeekID:
    case EbmlElementId.SeekPosition:
    case EbmlElementId.SeekPreRoll:
    case EbmlElementId.TrackNumber:
    case EbmlElementId.TrackTimestampScale:
    case EbmlElementId.TrackType:
    case EbmlElementId.TrackUID:
    case EbmlElementId.Video:
      return 3;
    case EbmlElementId.Channels:
    case EbmlElementId.CueBlockNumber:
    case EbmlElementId.CueClusterPosition:
    case EbmlElementId.CueTrack:
    case EbmlElementId.FlagInterlaced:
    case EbmlElementId.PixelHeight:
    case EbmlElementId.PixelWidth:
    case EbmlElementId.SamplingFrequency:
    case EbmlElementId.Colour:
      return 4;
    case EbmlElementId.CueRefTime:
      return 5;
    case EbmlElementId.Void:
      return -1;
    default:
      throw Error("cannot determine level of unknown ebml element with id ".concat(ebmlElementId));
  }
}
function readEbmlElementId(uint8ArrayAggregator, ebmlElement) {
  const ebmlElementIdLength = getEbmlElementIdLength(uint8ArrayAggregator.current);
  if (ebmlElementIdLength > uint8ArrayAggregator.bytesAvailable) {
    return false;
  }
  let ebmlElementId = uint8ArrayAggregator.current;
  for (var ebmlElementTrailingByteIndex = 0; ebmlElementTrailingByteIndex < ebmlElementIdLength - 1; ++ebmlElementTrailingByteIndex) {
    ebmlElementId = ebmlElementId << 8 | uint8ArrayAggregator.nextUnsafe();
  }
  uint8ArrayAggregator.nextUnsafe();
  uint8ArrayAggregator.checkBounds();
  ebmlElement.id = ebmlElementId;
  ebmlElement.idLength = ebmlElementIdLength;
  return true;
}

/***/ }),

/***/ 5260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EbmlElementType = void 0;
exports.getEbmlElementType = getEbmlElementType;
var _ebmlElementId = __webpack_require__(565);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class EbmlElementType {}
exports.EbmlElementType = EbmlElementType;
_defineProperty(EbmlElementType, "Unknown", 0);
_defineProperty(EbmlElementType, "Master", 1);
_defineProperty(EbmlElementType, "UnsignedInteger", 2);
_defineProperty(EbmlElementType, "SignedInteger", 3);
_defineProperty(EbmlElementType, "String", 4);
_defineProperty(EbmlElementType, "Utf8String", 5);
_defineProperty(EbmlElementType, "Binary", 6);
_defineProperty(EbmlElementType, "Float", 7);
_defineProperty(EbmlElementType, "Date", 8);
function getEbmlElementType(ebmlElementId) {
  switch (ebmlElementId) {
    case _ebmlElementId.EbmlElementId.Segment:
    case _ebmlElementId.EbmlElementId.Ebml:
    case _ebmlElementId.EbmlElementId.SeekHead:
    case _ebmlElementId.EbmlElementId.Seek:
    case _ebmlElementId.EbmlElementId.Cluster:
    case _ebmlElementId.EbmlElementId.Info:
    case _ebmlElementId.EbmlElementId.Tracks:
    case _ebmlElementId.EbmlElementId.TrackEntry:
    case _ebmlElementId.EbmlElementId.Video:
    case _ebmlElementId.EbmlElementId.Audio:
    case _ebmlElementId.EbmlElementId.Cues:
    case _ebmlElementId.EbmlElementId.CuePoint:
    case _ebmlElementId.EbmlElementId.CueTrackPositions:
    case _ebmlElementId.EbmlElementId.Colour:
      return EbmlElementType.Master;
    case _ebmlElementId.EbmlElementId.EbmlVersion:
    case _ebmlElementId.EbmlElementId.EbmlReadVersion:
    case _ebmlElementId.EbmlElementId.EbmlMaxIdLength:
    case _ebmlElementId.EbmlElementId.EbmlMaxSizeLength:
    case _ebmlElementId.EbmlElementId.DocTypeVersion:
    case _ebmlElementId.EbmlElementId.DocTypeReadVersion:
    case _ebmlElementId.EbmlElementId.SeekPosition:
    case _ebmlElementId.EbmlElementId.TimestampScale:
    case _ebmlElementId.EbmlElementId.Timestamp:
    case _ebmlElementId.EbmlElementId.TrackNumber:
    case _ebmlElementId.EbmlElementId.TrackUID:
    case _ebmlElementId.EbmlElementId.TrackType:
    case _ebmlElementId.EbmlElementId.FlagEnabled:
    case _ebmlElementId.EbmlElementId.FlagDefault:
    case _ebmlElementId.EbmlElementId.FlagForced:
    case _ebmlElementId.EbmlElementId.FlagLacing:
    case _ebmlElementId.EbmlElementId.MinCache:
    case _ebmlElementId.EbmlElementId.MaxBlockAdditionID:
    case _ebmlElementId.EbmlElementId.CodecDecodeAll:
    case _ebmlElementId.EbmlElementId.SeekPreRoll:
    case _ebmlElementId.EbmlElementId.FlagInterlaced:
    case _ebmlElementId.EbmlElementId.PixelWidth:
    case _ebmlElementId.EbmlElementId.PixelHeight:
    case _ebmlElementId.EbmlElementId.DefaultDuration:
    case _ebmlElementId.EbmlElementId.Channels:
    case _ebmlElementId.EbmlElementId.CueTime:
    case _ebmlElementId.EbmlElementId.CueTrack:
    case _ebmlElementId.EbmlElementId.CueClusterPosition:
    case _ebmlElementId.EbmlElementId.CueRefTime:
    case _ebmlElementId.EbmlElementId.CueBlockNumber:
    case _ebmlElementId.EbmlElementId.Position:
      return EbmlElementType.UnsignedInteger;
    case _ebmlElementId.EbmlElementId.DocType:
    case _ebmlElementId.EbmlElementId.CodecID:
      return EbmlElementType.String;
    case _ebmlElementId.EbmlElementId.Void:
    case _ebmlElementId.EbmlElementId.SeekID:
    case _ebmlElementId.EbmlElementId.SimpleBlock:
    case _ebmlElementId.EbmlElementId.SegmentUID:
    case _ebmlElementId.EbmlElementId.CodecPrivate:
      return EbmlElementType.Binary;
    case _ebmlElementId.EbmlElementId.Duration:
    case _ebmlElementId.EbmlElementId.TrackTimestampScale:
    case _ebmlElementId.EbmlElementId.SamplingFrequency:
      return EbmlElementType.Float;
    case _ebmlElementId.EbmlElementId.DateUTC:
      return EbmlElementType.Date;
    case _ebmlElementId.EbmlElementId.Title:
    case _ebmlElementId.EbmlElementId.MuxingApp:
    case _ebmlElementId.EbmlElementId.WritingApp:
    case _ebmlElementId.EbmlElementId.CodecName:
      return EbmlElementType.Utf8String;
    default:
      throw Error("cannot determine type of unknown ebml element with id ".concat(ebmlElementId));
  }
}

/***/ }),

/***/ 415:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.epochTimestampOffset = exports.EbmlElement = void 0;
exports.getEbmlElementSizeLength = getEbmlElementSizeLength;
exports.getEbmlElementValue = getEbmlElementValue;
exports.readEbmlLementSize = readEbmlLementSize;
var _ebmlElementId = __webpack_require__(565);
var _ebmlElementType = __webpack_require__(5260);
var _utilities = __webpack_require__(2087);
const epochTimestampOffset = exports.epochTimestampOffset = 978307200;
class EbmlElement {
  get elementSize() {
    return this.idLength + this.sizeLength + this.size;
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this.name = (0, _ebmlElementId.getEbmlElementName)(this._id);
    this.type = (0, _ebmlElementType.getEbmlElementType)(this._id);
  }
}
exports.EbmlElement = EbmlElement;
function getEbmlElementSizeLength(firstByteOfEbmlElementSize) {
  if (firstByteOfEbmlElementSize == 1) return 8;
  for (var position = 7; position > 0; position--) {
    if (firstByteOfEbmlElementSize & 1 << position) {
      return 8 - position;
    }
  }
  throw Error("invalid ebml element size");
}
function readEbmlLementSize(uint8ArrayAggregator, ebmlElement) {
  const ebmlElementSizeLength = getEbmlElementSizeLength(uint8ArrayAggregator.current);
  if (ebmlElementSizeLength > uint8ArrayAggregator.bytesAvailable) {
    return false;
  }
  let ebmlElementSize = uint8ArrayAggregator.current - (1 << 8 - ebmlElementSizeLength);
  for (var ebmlElementSizeTrailingByteIndex = 0; ebmlElementSizeTrailingByteIndex < ebmlElementSizeLength - 1; ++ebmlElementSizeTrailingByteIndex) {
    ebmlElementSize = ebmlElementSize << 8 | uint8ArrayAggregator.nextUnsafe();
  }
  uint8ArrayAggregator.nextUnsafe();
  uint8ArrayAggregator.checkBounds();
  ebmlElement.sizeLength = ebmlElementSizeLength;
  /*
      it does not make sense to use more than a single byte to signal unknown length but still let's
      keep a proper check instead of checking (ebmlElementSizeLength === 1 && ebmlElementSize === 0x7f)
  */
  if (ebmlElementSize === 1 << ebmlElementSizeLength * 8 - 1) ebmlElement.size = -1;else ebmlElement.size = ebmlElementSize;
  return true;
}
function getEbmlElementValue(type, data) {
  switch (type) {
    case _ebmlElementType.EbmlElementType.UnsignedInteger:
    case _ebmlElementType.EbmlElementType.SignedInteger:
      return (0, _utilities.readBigEndianNumber)(data);
    case _ebmlElementType.EbmlElementType.String:
      return String.fromCharCode.apply(null, data);
    case _ebmlElementType.EbmlElementType.Utf8String:
    case _ebmlElementType.EbmlElementType.Float:
      // do not bother with these until they are really needed
      throw new Error("cannot read value of element with type ".concat(type));
    case _ebmlElementType.EbmlElementType.Date:
      return epochTimestampOffset + (0, _utilities.readBigEndianNumber)(data);
    case _ebmlElementType.EbmlElementType.Binary:
      return data;
  }
}

/***/ }),

/***/ 2343:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "MediaInfo", ({
  enumerable: true,
  get: function () {
    return _mediaInfo.MediaInfo;
  }
}));
Object.defineProperty(exports, "MediaPacket", ({
  enumerable: true,
  get: function () {
    return _mediaPacket.MediaPacket;
  }
}));
Object.defineProperty(exports, "MediaRecorderDemuxer", ({
  enumerable: true,
  get: function () {
    return _mediaRecorderDemuxer.MediaRecorderDemuxer;
  }
}));
Object.defineProperty(exports, "MediaRecorderDemuxerEvents", ({
  enumerable: true,
  get: function () {
    return _mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents;
  }
}));
Object.defineProperty(exports, "createMediaRecorderDemuxer", ({
  enumerable: true,
  get: function () {
    return _mediaRecorderDemuxerFactory.createMediaRecorderDemuxer;
  }
}));
var _mediaRecorderDemuxer = __webpack_require__(3142);
var _mediaRecorderDemuxerEvents = __webpack_require__(8538);
var _mediaRecorderDemuxerFactory = __webpack_require__(5457);
var _mediaPacket = __webpack_require__(440);
var _mediaInfo = __webpack_require__(7472);

/***/ }),

/***/ 7472:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MediaInfo = void 0;
class MediaInfo {
  constructor() {
    this.videoTrack = {};
    this.audioTrack = {};
  }
}
exports.MediaInfo = MediaInfo;

/***/ }),

/***/ 440:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MediaPacket = void 0;
class MediaPacket {
  constructor(data, ptsMs) {
    this.data = data;
    this.ptsMs = ptsMs;
  }
}
exports.MediaPacket = MediaPacket;

/***/ }),

/***/ 8538:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MediaRecorderDemuxerEvents = void 0;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class MediaRecorderDemuxerEvents {}
exports.MediaRecorderDemuxerEvents = MediaRecorderDemuxerEvents;
_defineProperty(MediaRecorderDemuxerEvents, "Error", 'error');
_defineProperty(MediaRecorderDemuxerEvents, "MediaInfo", 'media-info');
_defineProperty(MediaRecorderDemuxerEvents, "MediaPacket", 'media-packet');

/***/ }),

/***/ 5457:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createMediaRecorderDemuxer = createMediaRecorderDemuxer;
var _webmMediaRecorderDemuxer = __webpack_require__(4112);
var _mediaRecorderDemuxerEvents = __webpack_require__(8538);
// if export default is used then webpack fails to expose the function when used with libraryTarget: 'var'
function createMediaRecorderDemuxer(mediaSource, options) {
  // Check for media recorder support
  let mediaRecorderSupported = typeof MediaRecorder !== 'undefined';
  if (mediaRecorderSupported === false) return null;

  // Choose suitable demuxer depending on supported mime types
  let mediaRecorderDemuxer;
  // Safari currently does not have MediaRecorder.isTypeSupported
  const hasMediaRecorderIsTypeSupported = typeof MediaRecorder.isTypeSupported === 'function';
  if (hasMediaRecorderIsTypeSupported === false || MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
    const mediaRecorderOptions = {
      mimeType: 'video/webm;codecs=h264'
    };
    mediaRecorderDemuxer = new _webmMediaRecorderDemuxer.WebmMediaRecorderDemuxer(new MediaRecorder(mediaSource, mediaRecorderOptions), options);
  }
  return mediaRecorderDemuxer;
}

/***/ }),

/***/ 3142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultMediaRecorderOptions = exports.MediaRecorderDemuxer = void 0;
var _mediaInfo = __webpack_require__(7472);
var _mediaRecorderDemuxerEvents = __webpack_require__(8538);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const EventEmitter = __webpack_require__(6261);
const defaultMediaRecorderOptions = exports.defaultMediaRecorderOptions = {
  timerInterval: 100,
  logCallback: null
};
class MediaRecorderDemuxer extends EventEmitter {
  constructor(mediaRecorder, options) {
    super();
    this.options = options ? _objectSpread(_objectSpread({}, defaultMediaRecorderOptions), options) : defaultMediaRecorderOptions;
    this.mediaRecorder = mediaRecorder;
    this.mediaInfo = new _mediaInfo.MediaInfo();
    this.mediaRecorder.addEventListener('dataavailable', async event => {
      this.addBlob(event.data);
    });
    this.mediaRecorder.addEventListener('error', event => {
      this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.Error, event.error);
    });
  }
  start() {
    this.mediaRecorder.start();
    // Safari emits dataavailable only after stopping, so do a stop/start there
    if (typeof this.mediaRecorder.requestData === 'function') {
      this.timer = window.setInterval(() => {
        this.mediaRecorder.requestData();
      }, this.options.timerInterval);
    } else {
      this.timer = window.setTimeout(() => {
        this.mediaRecorder.stop();
      }, this.options.timerInterval);
    }
  }
  stop() {
    if (this.mediaRecorder.state === "recording") this.mediaRecorder.stop();
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
  static isSupported(mediaType) {
    return typeof MediaRecorder !== 'undefined' /* check if we have MediaRecorder as a type */ && typeof MediaRecorder.prototype.requestData === 'function' /* check if requestData is available */ && typeof MediaRecorder.isTypeSupported === 'function' /* check if isTypeSupported is available */ && MediaRecorder.isTypeSupported(mediaType); /* check if the media is supported */
  }
}
exports.MediaRecorderDemuxer = MediaRecorderDemuxer;

/***/ }),

/***/ 4112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.webmVideoTrackType = exports.webmAudioTrackType = exports.WebmMediaRecorderDemuxer = void 0;
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(9316);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
var _mediaRecorderDemuxer = __webpack_require__(3142);
var _ebmlElementId = __webpack_require__(565);
var _ebmlElement = __webpack_require__(415);
var _utilities = __webpack_require__(2087);
var _ebmlElementType = __webpack_require__(5260);
var _mediaRecorderDemuxerEvents = __webpack_require__(8538);
var _mediaPacket = __webpack_require__(440);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const webmVideoTrackType = exports.webmVideoTrackType = 1;
const webmAudioTrackType = exports.webmAudioTrackType = 2;

// https://gist.github.com/hanayashiki/8dac237671343e7f0b15de617b0051bd
function blobToArrayBuffer() {
  // this: Blob
  return new Promise(resolve => {
    let fr = new FileReader();
    fr.onload = () => {
      resolve(fr.result);
    };
    fr.readAsArrayBuffer(this);
  });
}
class WebmMediaRecorderDemuxer extends _mediaRecorderDemuxer.MediaRecorderDemuxer {
  constructor(mediaRecorder, options) {
    super(mediaRecorder, options);
    this.state = WebmMediaRecorderDemuxer.stateParseElementId;
    this.currentEbmlElement = new _ebmlElement.EbmlElement();
    this.uint8ArrayAggregator = new _utilities.Uint8ArrayAggregator();
    this.clusterTimestamp = 0;
    /*
        https://www.matroska.org/technical/elements.html
         TimestampScale is mandatory but still initialize the ms scale and set the default value from the spec,
        the default scale is 1000000, thus pts in the container being expressed in ms, so the ms scale is 1
     */
    this.timestampMsScale = 1;
    this.ebmlElementStack = [];
    Blob.prototype.arrayBuffer = Blob.prototype.arrayBuffer || blobToArrayBuffer;
  }
  async addBlob(blob) {
    try {
      this.uint8ArrayAggregator.addArray(new Uint8Array(await blob.arrayBuffer()));
      while (this.uint8ArrayAggregator.bytesAvailable) {
        switch (this.state) {
          case WebmMediaRecorderDemuxer.stateParseElementId:
            if ((0, _ebmlElementId.readEbmlElementId)(this.uint8ArrayAggregator, this.currentEbmlElement)) {
              this.options.logCallback == null || this.options.logCallback("got new current ebml element (id: ".concat(this.currentEbmlElement.id, ", name: ").concat(this.currentEbmlElement.name, ")"));
            } else {
              break;
            }
            this.state = WebmMediaRecorderDemuxer.stateParseElementLength;
            break;
          case WebmMediaRecorderDemuxer.stateParseElementLength:
            if ((0, _ebmlElement.readEbmlLementSize)(this.uint8ArrayAggregator, this.currentEbmlElement)) {
              this.options.logCallback == null || this.options.logCallback("got size ".concat(this.currentEbmlElement.size, " for current ebml element (id: ").concat(this.currentEbmlElement.id, ", name: ").concat(this.currentEbmlElement.name, ")"));
            } else {
              break;
            }
            if (this.ebmlElementStack.length) {
              if (this.currentEbmlElement.size == -1) {
                // if there is a nested element with size -1 all of the stack logic falls apart so just evict the stack
                this.ebmlElementStack = [];
              }
            }
            this.state = WebmMediaRecorderDemuxer.stateParseElementValue;
            break;
          case WebmMediaRecorderDemuxer.stateParseElementValue:
            const currentEbmlElementType = (0, _ebmlElementType.getEbmlElementType)(this.currentEbmlElement.id);
            let canSkip = currentEbmlElementType !== _ebmlElementType.EbmlElementType.Master || this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.Colour;
            if (currentEbmlElementType === _ebmlElementType.EbmlElementType.Master && this.currentEbmlElement.size !== -1) {
              this.ebmlElementStack.push({
                element: Object.assign(new _ebmlElement.EbmlElement(), this.currentEbmlElement),
                bytesRemaining: this.currentEbmlElement.size
              });
            }
            if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.CodecID) {
              canSkip = false;
              let codecIdBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (codecIdBytes == null) break;
              const codecName = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, codecIdBytes);
              if (this.currentTrackType === webmVideoTrackType) {
                this.mediaInfo.videoTrack.codecName = codecName;
              } else if (this.currentTrackType === webmAudioTrackType) {
                this.mediaInfo.audioTrack.codecName = codecName;
              }
              this.options.logCallback == null || this.options.logCallback("got codec id ".concat(codecName));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.CodecPrivate) {
              canSkip = false;
              let codecExtradataBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (codecExtradataBytes == null) break;
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.TimestampScale) {
              canSkip = false;
              let timestampScaleBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (timestampScaleBytes == null) break;
              this.mediaInfo.timestampScale = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, timestampScaleBytes);
              this.timestampMsScale = this.mediaInfo.timestampScale / 1000000;
              this.options.logCallback == null || this.options.logCallback("got timestamp scale ".concat(this.mediaInfo.timestampScale));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.Timestamp) {
              canSkip = false;
              let timestampBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (timestampBytes == null) break;
              this.clusterTimestamp = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, timestampBytes);
              this.options.logCallback == null || this.options.logCallback("got cluser timestamp ".concat(this.clusterTimestamp));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.TrackType) {
              canSkip = false;
              let trackTypeBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (trackTypeBytes == null) break;
              this.currentTrackType = (0, _ebmlElement.getEbmlElementValue)(this.currentEbmlElement.type, trackTypeBytes);
              this.options.logCallback == null || this.options.logCallback("got track with type ".concat(this.currentTrackType));
            } else if (this.currentEbmlElement.id === _ebmlElementId.EbmlElementId.SimpleBlock) {
              canSkip = false;
              let simpleBlockBytes = this.uint8ArrayAggregator.extract(this.currentEbmlElement.size);
              if (simpleBlockBytes == null) break;
              let uint8ArrayAggregator = new _utilities.Uint8ArrayAggregator();
              uint8ArrayAggregator.addArray(simpleBlockBytes);
              let ebmlElement = {};
              (0, _ebmlElement.readEbmlLementSize)(uint8ArrayAggregator, ebmlElement);
              const trackNumber = ebmlElement.size;
              let relativeTimestamp = (0, _utilities.readBigEndianNumber)(uint8ArrayAggregator.extract(2));
              let flags = uint8ArrayAggregator.current;
              uint8ArrayAggregator.next();
              uint8ArrayAggregator.trim();
              let ptsMs = (this.clusterTimestamp + relativeTimestamp) * this.timestampMsScale;
              this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.MediaPacket, new _mediaPacket.MediaPacket(uint8ArrayAggregator.array, ptsMs));
            }
            canSkip && this.uint8ArrayAggregator.skip(this.currentEbmlElement.size);

            // check if by parsing the current element we have completed any elements up in the stack
            if (currentEbmlElementType !== _ebmlElementType.EbmlElementType.Master && this.ebmlElementStack.length) {
              this.ebmlElementStack[this.ebmlElementStack.length - 1].bytesRemaining -= this.currentEbmlElement.elementSize;
              do {
                if (this.ebmlElementStack[this.ebmlElementStack.length - 1].bytesRemaining === 0) {
                  var entry = this.ebmlElementStack.pop();
                  if (this.ebmlElementStack.length) this.ebmlElementStack[this.ebmlElementStack.length - 1].bytesRemaining -= entry.element.elementSize;
                  if (entry.element.id === _ebmlElementId.EbmlElementId.Tracks) this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.MediaInfo, this.mediaInfo);
                } else {
                  break;
                }
              } while (this.ebmlElementStack.length);
            }
            this.state = WebmMediaRecorderDemuxer.stateParseElementId;
            break;
        }
      }
      this.uint8ArrayAggregator.trim();
    } catch (error) {
      this.stop();
      this.emit(_mediaRecorderDemuxerEvents.MediaRecorderDemuxerEvents.Error, error);
    }
  }
}
exports.WebmMediaRecorderDemuxer = WebmMediaRecorderDemuxer;
_defineProperty(WebmMediaRecorderDemuxer, "stateParseElementId", 1);
_defineProperty(WebmMediaRecorderDemuxer, "stateParseElementLength", 2);
_defineProperty(WebmMediaRecorderDemuxer, "stateParseElementValue", 3);

/***/ }),

/***/ 2087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Uint8ArrayAggregator = void 0;
exports.readBigEndianNumber = readBigEndianNumber;
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
function readBigEndianNumber(bytes) {
  let number = 0;
  bytes.forEach(byte => {
    number = number << 8 | byte;
  });
  return number;
}
class Uint8ArrayAggregator {
  constructor() {
    this.array = null;
    this.current = null;
    this.offset = 0;
  }
  addArray(array) {
    if (array == null || array.length == 0) return;
    if (this.bytesToSkip >= array.length) {
      this.bytesToSkip -= array.length;
      return;
    } else if (this.bytesToSkip) {
      array = array.slice(this.bytesToSkip);
    }
    if (this.array) {
      let newArray = new Uint8Array(this.array.length - this.offset + array.length);
      newArray.set(this.offset ? this.array.slice(this.offset) : this.array, 0);
      newArray.set(array, this.array.length - this.offset);
      this.array = newArray;
      this.offset = 0;
    } else {
      this.array = array;
    }
    this.current = this.array[0];
  }
  checkBounds() {
    if (this.offset === this.array.length) {
      this.offset = 0;
      this.current = null;
      this.array = null;
    } else if (this.offset < this.array.length) {
      this.current = this.array[this.offset];
    } else {
      throw Error("invalid Uint8ArrayAggregator state, offset (".concat(this.offset, ") is larger than bytes in the current array (").concat(this.array.length, ")"));
    }
  }
  next() {
    if (this.array) {
      this.offset++;
      this.checkBounds();
      return this.current;
    }
    return null;
  }
  nextUnsafe() {
    this.offset++;
    this.current = this.array[this.offset];
    return this.current;
  }
  get bytesAvailable() {
    return this.array ? this.array.length - this.offset : 0;
  }
  trim() {
    if (this.array) {
      if (this.offset < this.array.length) {
        this.array = this.array.slice(this.offset);
        this.offset = 0;
        this.current = this.array[0];
      } else if (this.offset > this.array.length) {
        throw Error("invalid Uint8ArrayAggregator state, offset (".concat(this.offset, ") is larger than bytes in the current array (").concat(this.array.length, ")"));
      } else {
        this.array = null;
        this.offset = 0;
        this.current = null;
      }
    }
  }
  extract(count) {
    if (this.bytesAvailable >= count) {
      const start = this.offset;
      let bytes = this.array.slice(start, start + count);
      this.offset += count;
      this.current = this.array[this.offset];
      this.checkBounds();
      return bytes;
    }
    return null;
  }
  skip(count) {
    if (this.bytesAvailable >= count) {
      this.offset += count;
      this.current = this.array[this.offset];
      this.checkBounds();
      return;
    } else {
      count -= this.bytesAvailable;
      this.array = null;
      this.offset = 0;
      this.current = null;
    }
    this.bytesToSkip = count;
  }
}
exports.Uint8ArrayAggregator = Uint8ArrayAggregator;

/***/ }),

/***/ 7513:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class CompressionError {
  constructor(message, node) {
    this._message = message;
    this._node = node;
  }
  get message() {
    return this._message;
  }
  get node() {
    return this._node;
  }
}
exports["default"] = CompressionError;

/***/ }),

/***/ 2798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
class PropertyObserver {
  constructor(onPropertySet) {
    this.onPropertySet = onPropertySet;
    this._klasses = new Set();
  }
  _trackObserver(Klass) {
    if (!Klass.__cbio_observers) Klass.__cbio_observers = new Set();
    Klass.__cbio_observers.add(this);
  }
  _untrackObserver(Klass) {
    if (Klass.__cbio_observers) {
      Klass.__cbio_observers.delete(this);
    }
  }
  _tap(Klass, property) {
    if (Klass["__cbio_override_".concat(property)]) return;
    const descriptor = Object.getOwnPropertyDescriptor(Klass.prototype, property);
    if (!descriptor) return;
    Klass["__cbio_override_".concat(property)] = true;
    const originalSet = descriptor.set;
    descriptor.set = function (val) {
      originalSet.call(this, val);
      if (Klass.__cbio_observers) {
        Klass.__cbio_observers.forEach(observer => {
          observer.onPropertySet(this, property, val);
        });
      }
    };
    Object.defineProperty(Klass.prototype, property, descriptor);
  }
  observe(Klass, property) {
    this._klasses.add(Klass);
    this._trackObserver(Klass);
    this._tap(Klass, property);
  }
  disconnect() {
    this._klasses.forEach(Klass => this._untrackObserver(Klass));
    this._klasses.clear();
  }
}
exports["default"] = PropertyObserver;

/***/ }),

/***/ 4216:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3697);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _depthFirst = _interopRequireWildcard(__webpack_require__(136));
var _CompressionError = _interopRequireDefault(__webpack_require__(7513));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class VirtualDOM {
  constructor(id) {
    this._id = id;
    this._dom = {
      id,
      childNodes: []
    };
    this._mapping = {};
  }
  get id() {
    return this._id;
  }
  get document() {
    return this._dom;
  }
  node(id) {
    return this._mapping[id];
  }
  applyPatch(patch) {
    const {
      dom,
      mapping
    } = VirtualDOM.applyPatch(this._dom, patch);
    this._dom = dom;
    this._mapping = mapping;
    return this;
  }
  static createMapping(node) {
    const mapping = {};
    (0, _depthFirst.default)(node, n => {
      if (!n.id) console.warn('node missing id', n);else mapping[n.id] = n;
    });
    return mapping;
  }
  static applyPatch(document, patch) {
    // first build an index of the nodes id we need to
    // update so we can quickly look them up.
    const nodeIdMap = this.createMapping(document);

    // then apply the diffs to the existing nodes,
    // and also create new node records for discovered
    // nodes if we need to.
    const modifiedNodesMap = {};
    patch.forEach(diff => {
      if (!diff.id) console.warn('diff missing id', diff);else {
        const existing = nodeIdMap[diff.id] || {};
        nodeIdMap[diff.id] = _objectSpread(_objectSpread({}, existing), diff);
        modifiedNodesMap[diff.id] = true;
      }
    });

    // then make sure all the node id's in the childNodes
    // arrays have been expanded into their denormalized form
    // and the childNodes arrays are using the modified nodes
    Object.values(nodeIdMap).forEach(n => {
      n.childNodes = (n.childNodes || []).map(child => {
        const id = child.id || child;
        const node = nodeIdMap[id];
        if (!node) throw new _CompressionError.default("denormalisation failed for child ".concat(id), n);
        return node;
      });
    });

    // for all modified nodes we want to make sure
    // all parent nodes also appear changed on equalty
    // comparison
    const root = nodeIdMap[document.id];
    const result = (0, _depthFirst.depthFirstPostOrder)(root, (n, children) => {
      // make sure we're using any updated nodes returned from
      // our children
      n.childNodes = children;

      // work out of any of our chidren were modified
      const modified = children.map(c => modifiedNodesMap[c.id]);
      const childWasModified = modified.reduce((a, b) => a || b, false);
      if (childWasModified) {
        // if a child was modified, we count as modified too, so make sure
        // the ndoe is marked in the modification table
        modifiedNodesMap[n.id] = true;
        // if the node was modified or a child of the node was modified
        // then we need to ensure the current node will fail equality checks
        const updated = _objectSpread({}, n);
        nodeIdMap[n.id] = updated;
        return updated;
      }
      return n;
    });

    // retain the latest node id mapping for quick lookups
    return {
      dom: result,
      mapping: this.createMapping(result)
    };
  }
}
exports["default"] = VirtualDOM;

/***/ }),

/***/ 136:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = depthFirstPreOrder;
exports.depthFirstPostOrder = depthFirstPostOrder;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function depthFirstPreOrder(node, visitor) {
  let children = node.childNodes;
  const mapped = visitor(node, function () {
    let replacementChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    children = replacementChildren;
  });
  if (!children || !children.length) return mapped;
  return _objectSpread(_objectSpread({}, mapped), {}, {
    childNodes: Array.from(children).map(child => {
      return depthFirstPreOrder(child, visitor);
    })
  });
}
function depthFirstPostOrder(node, visitor) {
  const children = Array.from(node.childNodes || []);
  const childResults = children.map(child => depthFirstPostOrder(child, visitor));
  return visitor(node, childResults);
}

/***/ }),

/***/ 9501:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3697);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "CompressionError", ({
  enumerable: true,
  get: function () {
    return _CompressionError.default;
  }
}));
Object.defineProperty(exports, "PropertyObserver", ({
  enumerable: true,
  get: function () {
    return _PropertyObserver.default;
  }
}));
Object.defineProperty(exports, "VirtualDOM", ({
  enumerable: true,
  get: function () {
    return _VirtualDOM.default;
  }
}));
Object.defineProperty(exports, "depthFirst", ({
  enumerable: true,
  get: function () {
    return _depthFirst.default;
  }
}));
Object.defineProperty(exports, "depthFirstPostOrder", ({
  enumerable: true,
  get: function () {
    return _depthFirst.depthFirstPostOrder;
  }
}));
Object.defineProperty(exports, "isxdoc", ({
  enumerable: true,
  get: function () {
    return _isxdoc.default;
  }
}));
Object.defineProperty(exports, "parents", ({
  enumerable: true,
  get: function () {
    return _parents.default;
  }
}));
var _CompressionError = _interopRequireDefault(__webpack_require__(7513));
var _VirtualDOM = _interopRequireDefault(__webpack_require__(4216));
var _depthFirst = _interopRequireWildcard(__webpack_require__(136));
var _isxdoc = _interopRequireDefault(__webpack_require__(663));
var _parents = _interopRequireDefault(__webpack_require__(9324));
var _PropertyObserver = _interopRequireDefault(__webpack_require__(2798));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 663:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isxdoc;
function windowIsXdoc(window) {
  try {
    // try to access a property on the window
    return !window.document && false;
  } catch (e) {
    return true;
  }
}
function isxdoc(node) {
  if (windowIsXdoc(node)) {
    return true;
  } else if (node.tagName === 'IFRAME') {
    if (windowIsXdoc(node.contentWindow)) {
      return true;
    }
  }
  return false;
}

/***/ }),

/***/ 9324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parents;
__webpack_require__(3697);
function parents(node, stopNode) {
  const found = [];
  let current = node;
  while (current.parentNode && current.parentNode !== stopNode) {
    found.push(current.parentNode);
    current = current.parentNode;
  }
  if (current instanceof ShadowRoot) return [...found, current.host, ...parents(current.host, stopNode)];
  const iframe = current.defaultView && current.defaultView.frameElement;
  if (iframe) return [...found, iframe, ...parents(iframe)];
  return found;
}

/***/ }),

/***/ 6009:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(1631);
__webpack_require__(3697);
__webpack_require__(483);
__webpack_require__(1631);
__webpack_require__(2864);
__webpack_require__(5366);
__webpack_require__(8742);
__webpack_require__(660);
__webpack_require__(1774);
__webpack_require__(8922);
__webpack_require__(2065);
__webpack_require__(5435);
__webpack_require__(8263);
__webpack_require__(7057);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ActivityDetection = void 0;
__webpack_require__(4602);
__webpack_require__(7043);
__webpack_require__(9062);
__webpack_require__(2718);
__webpack_require__(3697);
__webpack_require__(8615);
var _events = __webpack_require__(6261);
var _throttle = _interopRequireDefault(__webpack_require__(6770));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var debug = (0, _debug["default"])('cbio.ActivityDetection');
var _started = /*#__PURE__*/new WeakMap();
var _active = /*#__PURE__*/new WeakMap();
var _activeTimeout = /*#__PURE__*/new WeakMap();
var _inactiveTime = /*#__PURE__*/new WeakMap();
var _onActivity = /*#__PURE__*/new WeakMap();
var _makeActive = /*#__PURE__*/new WeakMap();
var _makeInactive = /*#__PURE__*/new WeakMap();
var ActivityDetection = exports.ActivityDetection = /*#__PURE__*/function (_EventEmitter) {
  function ActivityDetection(timeout) {
    var _this;
    _classCallCheck(this, ActivityDetection);
    _this = _callSuper(this, ActivityDetection);
    _classPrivateFieldInitSpec(_this, _started, false);
    _classPrivateFieldInitSpec(_this, _active, false);
    _classPrivateFieldInitSpec(_this, _activeTimeout, null);
    _classPrivateFieldInitSpec(_this, _inactiveTime, 15 * 60 * 1000);
    _defineProperty(_this, "start", function () {
      if (_classPrivateFieldGet(_started, _this)) return;
      _classPrivateFieldSet(_started, _this, true);
      debug('started');
      document.addEventListener('mouseenter', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('mouseleave', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('mousemove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchstart', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchend', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchmove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.addEventListener('visibilitychange', _classPrivateFieldGet(_onActivity, _this), {
        capture: true
      });

      // page load counts as possible activity
      _classPrivateFieldGet(_onActivity, _this).call(_this);
    });
    _defineProperty(_this, "stop", function () {
      _classPrivateFieldSet(_active, _this, false);
      _classPrivateFieldSet(_started, _this, false);
      debug('stopped');
      clearTimeout(_classPrivateFieldGet(_activeTimeout, _this));
      _this.removeAllListeners();
      document.removeEventListener('mouseenter', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('mouseleave', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('mousemove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchstart', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchend', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchmove', _classPrivateFieldGet(_onActivity, _this), {
        capture: true,
        passive: true
      });
      document.removeEventListener('visibilitychange', _classPrivateFieldGet(_onActivity, _this), {
        capture: true
      });
    });
    _defineProperty(_this, "isActive", function () {
      return _classPrivateFieldGet(_active, _this);
    });
    _classPrivateFieldInitSpec(_this, _onActivity, (0, _throttle["default"])(function () {
      _classPrivateFieldGet(_makeActive, _this).call(_this);
      clearTimeout(_classPrivateFieldGet(_activeTimeout, _this));
      _classPrivateFieldSet(_activeTimeout, _this, setTimeout(_classPrivateFieldGet(_makeInactive, _this), _classPrivateFieldGet(_inactiveTime, _this)));
      _this.emit('activity');
    }, 500, {
      trailing: false
    }));
    _classPrivateFieldInitSpec(_this, _makeActive, function () {
      // skip if already active
      if (_classPrivateFieldGet(_active, _this)) return;
      // or if the browser thinks it's not visible
      if (document.hidden) {
        debug('window is hidden, not becoming active');
        return;
      }
      // then mark as active and emit event
      _classPrivateFieldSet(_active, _this, true);
      debug('became active');
      _this.emit('active');
    });
    _classPrivateFieldInitSpec(_this, _makeInactive, function () {
      if (_classPrivateFieldGet(_active, _this)) {
        _classPrivateFieldSet(_active, _this, false);
        debug('became inactive');
        _this.emit('inactive');
      }
    });
    if (timeout) _classPrivateFieldSet(_inactiveTime, _this, timeout);
    return _this;
  }
  _inherits(ActivityDetection, _EventEmitter);
  return _createClass(ActivityDetection);
}(_events.EventEmitter);

/***/ }),

/***/ 1055:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(1631);
__webpack_require__(3697);
__webpack_require__(483);
__webpack_require__(1631);
__webpack_require__(2864);
__webpack_require__(5366);
__webpack_require__(8742);
__webpack_require__(660);
__webpack_require__(1774);
__webpack_require__(8922);
__webpack_require__(2065);
__webpack_require__(5435);
__webpack_require__(8263);
__webpack_require__(7057);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IFrameBridge = void 0;
__webpack_require__(7436);
__webpack_require__(1945);
__webpack_require__(2765);
__webpack_require__(6612);
__webpack_require__(687);
__webpack_require__(4602);
__webpack_require__(7043);
__webpack_require__(7007);
__webpack_require__(1779);
__webpack_require__(9062);
__webpack_require__(2718);
__webpack_require__(9198);
__webpack_require__(3697);
var _events = __webpack_require__(6261);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var debug = (0, _debug["default"])('cbio.IFrameBridge');
var _parentSource = /*#__PURE__*/new WeakMap();
var _sources = /*#__PURE__*/new WeakMap();
var _iframes = /*#__PURE__*/new WeakMap();
var _processMessage = /*#__PURE__*/new WeakMap();
var _hasParent = /*#__PURE__*/new WeakMap();
var _isCobrowseMessage = /*#__PURE__*/new WeakMap();
var _isTrustedOrigin = /*#__PURE__*/new WeakMap();
var _iframeForSource = /*#__PURE__*/new WeakMap();
var IFrameBridge = exports.IFrameBridge = /*#__PURE__*/function (_EventEmitter) {
  function IFrameBridge(parent) {
    var _this;
    _classCallCheck(this, IFrameBridge);
    _this = _callSuper(this, IFrameBridge);
    // These are the user defined origins to trust
    _defineProperty(_this, "trustedOrigins", []);
    _defineProperty(_this, "automaticTrustedOrigins", []);
    // Save details about the nearest xdoc parent that we discover
    // We save the window object for the parent.
    _classPrivateFieldInitSpec(_this, _parentSource, null);
    // Keep a mapping from sources to the origins they contain.
    _classPrivateFieldInitSpec(_this, _sources, new WeakMap());
    // Keep a record of our child iframes for broadcast methods
    // and mapping messages back to a sepecific iframe (by contentWindow
    // comparison)
    _classPrivateFieldInitSpec(_this, _iframes, new Set());
    _defineProperty(_this, "start", function () {
      // set up a postMessage listener to handle incoming cobrowse events
      window.removeEventListener('message', _classPrivateFieldGet(_processMessage, _this));
      window.addEventListener('message', _classPrivateFieldGet(_processMessage, _this));

      // send init message to our parent, we might not know the origin of our
      // parent yet, so we should send to all untrusted origins
      if (_classPrivateFieldGet(_parentSource, _this)) _this.send(_classPrivateFieldGet(_parentSource, _this), 'init', null, {
        trustedOnly: false
      });
    });
    _defineProperty(_this, "stop", function () {
      window.removeEventListener('message', _classPrivateFieldGet(_processMessage, _this));
    });
    _classPrivateFieldInitSpec(_this, _processMessage, function (message) {
      // ignore any messages that are definitely not cobrowse messages
      if (!_classPrivateFieldGet(_isCobrowseMessage, _this).call(_this, message)) {
        return debug('ignoring message, not a cobrowse message', message.data);
      }

      // keep a record of the origin associated with each source we recieve
      // messages from
      _this.establishTrust(message.source, message.origin);

      // Deconstruct the message and forward on event
      var _message$data = message.data,
        trustedOnly = _message$data.trustedOnly,
        event = _message$data.event,
        data = _message$data.data;

      // emit locally so we can attach handlers for validated messages
      _this.emit(event, data, {
        source: message.source,
        origin: message.origin,
        trusted: _this.isTrusted(message.source),
        iframe: _classPrivateFieldGet(_iframeForSource, _this).call(_this, message.source),
        fromParent: _classPrivateFieldGet(_hasParent, _this).call(_this, message.source),
        trustedOnly: trustedOnly
      });
    });
    _classPrivateFieldInitSpec(_this, _hasParent, function (target) {
      var current = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.parent;
      if (target === current) return true;
      if (current.parent === current) return false;
      return _classPrivateFieldGet(_hasParent, _this).call(_this, target, current.parent);
    });
    _classPrivateFieldInitSpec(_this, _isCobrowseMessage, function (message) {
      if (!message.data) return false;
      var _message$data2 = message.data,
        cobrowseio = _message$data2.cobrowseio,
        event = _message$data2.event;
      if (!cobrowseio) return false;
      if (!event) return false;
      return true;
    });
    _classPrivateFieldInitSpec(_this, _isTrustedOrigin, function (origin) {
      return _this.automaticTrustedOrigins.includes(origin) || _this.trustedOrigins.includes(origin);
    });
    _defineProperty(_this, "isTrusted", function (source) {
      var origin = _classPrivateFieldGet(_sources, _this).get(source);
      if (!origin) return false;
      return _classPrivateFieldGet(_isTrustedOrigin, _this).call(_this, origin);
    });
    _classPrivateFieldInitSpec(_this, _iframeForSource, function (source) {
      var iframes = Array.from(_classPrivateFieldGet(_iframes, _this));
      return iframes.find(function (i) {
        return i.contentWindow === source;
      });
    });
    _defineProperty(_this, "send", function (w, event, data) {
      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$trustedOnly = _ref.trustedOnly,
        trustedOnly = _ref$trustedOnly === void 0 ? true : _ref$trustedOnly,
        targetOrigin = _ref.targetOrigin;
      // if we have an explcit origin provided we should always try to use that
      // otherwise we'll try to auto-fill the origin from the source tracking
      var origin = targetOrigin || _classPrivateFieldGet(_sources, _this).get(w);
      // check if trust is required, and if the origin is trusted, if not we just bail
      // on sending anything
      if (trustedOnly && !_classPrivateFieldGet(_isTrustedOrigin, _this).call(_this, origin)) {
        return debug("not sending ".concat(event, " as target source is not trusted: ").concat(origin));
      }
      // if trust is not required and we don't have any explcit origin to send to
      // then we should fallback to *
      if (!trustedOnly && !origin) origin = '*';
      w.postMessage({
        trustedOnly: trustedOnly,
        cobrowseio: true,
        event: event,
        data: data
      }, origin);
    });
    _defineProperty(_this, "sendToParent", function (event, data) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$trustedOnly = _ref2.trustedOnly,
        trustedOnly = _ref2$trustedOnly === void 0 ? true : _ref2$trustedOnly;
      if (_classPrivateFieldGet(_parentSource, _this)) _this.send(_classPrivateFieldGet(_parentSource, _this), event, data, {
        trustedOnly: trustedOnly
      });
    });
    _defineProperty(_this, "broadcastToChildren", function (event, data) {
      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref3$trustedOnly = _ref3.trustedOnly,
        trustedOnly = _ref3$trustedOnly === void 0 ? true : _ref3$trustedOnly;
      _classPrivateFieldGet(_iframes, _this).forEach(function (iframe) {
        // when a same origin iframe is reloaded any children iframes
        // can be left orphaned which results in a null contentWindow
        if (iframe.contentWindow) _this.send(iframe.contentWindow, event, data, {
          trustedOnly: trustedOnly
        });
      });
    });
    _defineProperty(_this, "track", function (iframe) {
      if (!_classPrivateFieldGet(_iframes, _this).has(iframe)) {
        _classPrivateFieldGet(_iframes, _this).add(iframe);
        _this.emit('iframe_discovered', iframe);
      }
    });
    _defineProperty(_this, "remove", function (iframe) {
      _classPrivateFieldGet(_iframes, _this)["delete"](iframe);
    });
    _defineProperty(_this, "establishTrust", function (source, origin) {
      if (!source) return;
      _classPrivateFieldGet(_sources, _this).set(source, origin);
    });
    _defineProperty(_this, "breakTrust", function (source) {
      if (_classPrivateFieldGet(_sources, _this).has(source)) _classPrivateFieldGet(_sources, _this).set(source, null);
    });
    _classPrivateFieldSet(_parentSource, _this, parent);
    debug('iframe bridge constructed in', document, 'with parent', _classPrivateFieldGet(_parentSource, _this));
    return _this;
  }
  _inherits(IFrameBridge, _EventEmitter);
  return _createClass(IFrameBridge);
}(_events.EventEmitter);

/***/ }),

/***/ 4203:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(1631);
__webpack_require__(6126);
__webpack_require__(9199);
__webpack_require__(3697);
__webpack_require__(483);
__webpack_require__(1631);
__webpack_require__(6126);
__webpack_require__(2864);
__webpack_require__(5366);
__webpack_require__(1309);
__webpack_require__(2765);
__webpack_require__(6612);
__webpack_require__(2868);
__webpack_require__(6592);
__webpack_require__(8742);
__webpack_require__(7234);
__webpack_require__(660);
__webpack_require__(5780);
__webpack_require__(6235);
__webpack_require__(8151);
__webpack_require__(1774);
__webpack_require__(8922);
__webpack_require__(2065);
__webpack_require__(5435);
__webpack_require__(8263);
__webpack_require__(7057);
__webpack_require__(9199);
__webpack_require__(2589);
__webpack_require__(9198);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IFrameRPC = void 0;
__webpack_require__(4602);
__webpack_require__(3769);
__webpack_require__(7043);
__webpack_require__(9062);
__webpack_require__(2718);
__webpack_require__(3697);
__webpack_require__(8615);
var _events = __webpack_require__(6261);
var _uuid = __webpack_require__(5392);
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return r;
  };
  var t,
    r = {},
    e = Object.prototype,
    n = e.hasOwnProperty,
    o = "function" == typeof Symbol ? Symbol : {},
    i = o.iterator || "@@iterator",
    a = o.asyncIterator || "@@asyncIterator",
    u = o.toStringTag || "@@toStringTag";
  function c(t, r, e, n) {
    Object.defineProperty(t, r, {
      value: e,
      enumerable: !n,
      configurable: !n,
      writable: !n
    });
  }
  try {
    c({}, "");
  } catch (t) {
    c = function c(t, r, e) {
      return t[r] = e;
    };
  }
  function h(r, e, n, o) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype);
    return c(a, "_invoke", function (r, e, n) {
      var o = 1;
      return function (i, a) {
        if (3 === o) throw Error("Generator is already running");
        if (4 === o) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var u = n.delegate;
          if (u) {
            var c = d(u, n);
            if (c) {
              if (c === f) continue;
              return c;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (1 === o) throw o = 4, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = 3;
          var h = s(r, e, n);
          if ("normal" === h.type) {
            if (o = n.done ? 4 : 2, h.arg === f) continue;
            return {
              value: h.arg,
              done: n.done
            };
          }
          "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg);
        }
      };
    }(r, n, new Context(o || [])), !0), a;
  }
  function s(t, r, e) {
    try {
      return {
        type: "normal",
        arg: t.call(r, e)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  r.wrap = h;
  var f = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var l = {};
  c(l, i, function () {
    return this;
  });
  var p = Object.getPrototypeOf,
    y = p && p(p(x([])));
  y && y !== e && n.call(y, i) && (l = y);
  var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
  function g(t) {
    ["next", "throw", "return"].forEach(function (r) {
      c(t, r, function (t) {
        return this._invoke(r, t);
      });
    });
  }
  function AsyncIterator(t, r) {
    function e(o, i, a, u) {
      var c = s(t[o], t, i);
      if ("throw" !== c.type) {
        var h = c.arg,
          f = h.value;
        return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) {
          e("next", t, a, u);
        }, function (t) {
          e("throw", t, a, u);
        }) : r.resolve(f).then(function (t) {
          h.value = t, a(h);
        }, function (t) {
          return e("throw", t, a, u);
        });
      }
      u(c.arg);
    }
    var o;
    c(this, "_invoke", function (t, n) {
      function i() {
        return new r(function (r, o) {
          e(t, n, r, o);
        });
      }
      return o = o ? o.then(i, i) : i();
    }, !0);
  }
  function d(r, e) {
    var n = e.method,
      o = r.i[n];
    if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f;
    var i = s(o, r.i, e.arg);
    if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f;
    var a = i.arg;
    return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f);
  }
  function w(t) {
    this.tryEntries.push(t);
  }
  function m(r) {
    var e = r[4] || {};
    e.type = "normal", e.arg = t, r[4] = e;
  }
  function Context(t) {
    this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0);
  }
  function x(r) {
    if (null != r) {
      var e = r[i];
      if (e) return e.call(r);
      if ("function" == typeof r.next) return r;
      if (!isNaN(r.length)) {
        var o = -1,
          a = function e() {
            for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e;
            return e.value = t, e.done = !0, e;
          };
        return a.next = a;
      }
    }
    throw new TypeError(_typeof(r) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), c(GeneratorFunctionPrototype, u, GeneratorFunction.displayName = "GeneratorFunction"), r.isGeneratorFunction = function (t) {
    var r = "function" == typeof t && t.constructor;
    return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name));
  }, r.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t;
  }, r.awrap = function (t) {
    return {
      __await: t
    };
  }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () {
    return this;
  }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(h(t, e, n, o), i);
    return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, g(v), c(v, u, "Generator"), c(v, i, function () {
    return this;
  }), c(v, "toString", function () {
    return "[object Generator]";
  }), r.keys = function (t) {
    var r = Object(t),
      e = [];
    for (var n in r) e.unshift(n);
    return function t() {
      for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t;
      return t.done = !0, t;
    };
  }, r.values = x, Context.prototype = {
    constructor: Context,
    reset: function reset(r) {
      if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0][4];
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(r) {
      if (this.done) throw r;
      var e = this;
      function n(t) {
        a.type = "throw", a.arg = r, e.next = t;
      }
      for (var o = e.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i[4],
          u = this.prev,
          c = i[1],
          h = i[2];
        if (-1 === i[0]) return n("end"), !1;
        if (!c && !h) throw Error("try statement without catch or finally");
        if (null != i[0] && i[0] <= u) {
          if (u < c) return this.method = "next", this.arg = t, n(c), !0;
          if (u < h) return n(h), !1;
        }
      }
    },
    abrupt: function abrupt(t, r) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) {
          var o = n;
          break;
        }
      }
      o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null);
      var i = o ? o[4] : {};
      return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i);
    },
    complete: function complete(t, r) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f;
    },
    finish: function finish(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[2] === t) return this.complete(e[4], e[3]), m(e), f;
      }
    },
    "catch": function _catch(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[0] === t) {
          var n = e[4];
          if ("throw" === n.type) {
            var o = n.arg;
            m(e);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(r, e, n) {
      return this.delegate = {
        i: x(r),
        r: e,
        n: n
      }, "next" === this.method && (this.arg = t), f;
    }
  }, r;
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var _bridge = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _pendingRequests = /*#__PURE__*/new WeakMap();
var _onRpcRequest = /*#__PURE__*/new WeakMap();
var _onRpcResponse = /*#__PURE__*/new WeakMap();
var IFrameRPC = exports.IFrameRPC = /*#__PURE__*/function (_EventEmitter) {
  function IFrameRPC(bridge, target) {
    var _this;
    _classCallCheck(this, IFrameRPC);
    _this = _callSuper(this, IFrameRPC);
    _classPrivateFieldInitSpec(_this, _bridge, void 0);
    _classPrivateFieldInitSpec(_this, _target, void 0);
    _classPrivateFieldInitSpec(_this, _pendingRequests, new Map());
    _defineProperty(_this, "send", function (method, data) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$timeout = _ref.timeout,
        timeout = _ref$timeout === void 0 ? 0 : _ref$timeout,
        _ref$trustedOnly = _ref.trustedOnly,
        trustedOnly = _ref$trustedOnly === void 0 ? true : _ref$trustedOnly;
      return new Promise(function (resolve, reject) {
        var id = (0, _uuid.v4)();
        _classPrivateFieldGet(_pendingRequests, _this).set(id, {
          resolve: resolve,
          reject: reject
        });
        var rpcRequest = {
          id: id,
          method: method,
          data: data
        };
        _classPrivateFieldGet(_bridge, _this).send(_classPrivateFieldGet(_target, _this), 'rpc:request', rpcRequest, {
          trustedOnly: trustedOnly
        });
        if (!timeout) return;
        setTimeout(function () {
          var request = _classPrivateFieldGet(_pendingRequests, _this).get(id);
          if (!request) return;
          request.reject(new Error('Request timed out'));
          _classPrivateFieldGet(_pendingRequests, _this)["delete"](id);
        }, timeout);
      });
    });
    _classPrivateFieldInitSpec(_this, _onRpcRequest, /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(rpcRequest, _ref2) {
        var source, trusted, trustedOnly, id, method, data, listeners, _listeners, listener, res;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              source = _ref2.source, trusted = _ref2.trusted, trustedOnly = _ref2.trustedOnly;
              id = rpcRequest.id, method = rpcRequest.method, data = rpcRequest.data;
              listeners = _this.listeners(method);
              if (!(listeners.length > 1)) {
                _context.next = 5;
                break;
              }
              throw new Error('only a single RPC listener is allowed per event');
            case 5:
              if (!(listeners.length === 0)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return");
            case 7:
              _listeners = _slicedToArray(listeners, 1), listener = _listeners[0];
              _context.prev = 8;
              _context.next = 11;
              return listener(data, {
                trusted: trusted
              });
            case 11:
              res = _context.sent;
              _classPrivateFieldGet(_bridge, _this).send(source, 'rpc:response', {
                id: id,
                data: res
              }, {
                trustedOnly: trustedOnly
              });
              _context.next = 18;
              break;
            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](8);
              _classPrivateFieldGet(_bridge, _this).send(source, 'rpc:response', {
                id: id,
                error: _context.t0
              }, {
                trustedOnly: trustedOnly
              });
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[8, 15]]);
      }));
      return function (_x, _x2) {
        return _ref3.apply(this, arguments);
      };
    }());
    _classPrivateFieldInitSpec(_this, _onRpcResponse, function (rpcResponse, _ref4) {
      var trusted = _ref4.trusted,
        trustedOnly = _ref4.trustedOnly;
      if (trustedOnly && !trusted) return;
      var error = rpcResponse.error,
        id = rpcResponse.id,
        data = rpcResponse.data;
      var request = _classPrivateFieldGet(_pendingRequests, _this).get(id);
      if (request) {
        if (error) request.reject(error);else request.resolve(data);
        _classPrivateFieldGet(_pendingRequests, _this)["delete"](id);
      }
    });
    _classPrivateFieldSet(_bridge, _this, bridge);
    _classPrivateFieldSet(_target, _this, target);
    _classPrivateFieldGet(_bridge, _this).on('rpc:request', _classPrivateFieldGet(_onRpcRequest, _this));
    _classPrivateFieldGet(_bridge, _this).on('rpc:response', _classPrivateFieldGet(_onRpcResponse, _this));
    return _this;
  }
  _inherits(IFrameRPC, _EventEmitter);
  return _createClass(IFrameRPC);
}(_events.EventEmitter);

/***/ }),

/***/ 6817:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(2065);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.closestXdocParent = closestXdocParent;
var _isxdoc = __webpack_require__(636);
function closestXdocParent() {
  var parent = window;
  do {
    parent = parent.parent;
    if ((0, _isxdoc.isxdoc)(parent)) return parent;
  } while (parent !== parent.parent);
  return null;
}

/***/ }),

/***/ 636:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(2065);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isxdoc = isxdoc;
function windowIsXdoc(window) {
  try {
    // try to access a property on the window
    return !window.document && false;
  } catch (e) {
    return true;
  }
}
function isxdoc(node) {
  if (windowIsXdoc(node)) {
    return true;
  } else if (node.tagName === 'IFRAME') {
    if (windowIsXdoc(node.contentWindow)) {
      return true;
    }
  }
  return false;
}

/***/ }),

/***/ 3439:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(2065);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ActivityDetection", ({
  enumerable: true,
  get: function get() {
    return _ActivityDetection.ActivityDetection;
  }
}));
Object.defineProperty(exports, "CBORSocket", ({
  enumerable: true,
  get: function get() {
    return _CBORSocket.CBORSocket;
  }
}));
Object.defineProperty(exports, "IFrameBridge", ({
  enumerable: true,
  get: function get() {
    return _IFrameBridge.IFrameBridge;
  }
}));
Object.defineProperty(exports, "IFrameRPC", ({
  enumerable: true,
  get: function get() {
    return _IFrameRPC.IFrameRPC;
  }
}));
Object.defineProperty(exports, "closestXdocParent", ({
  enumerable: true,
  get: function get() {
    return _closestXdocParent.closestXdocParent;
  }
}));
Object.defineProperty(exports, "isxdoc", ({
  enumerable: true,
  get: function get() {
    return _isxdoc.isxdoc;
  }
}));
var _ActivityDetection = __webpack_require__(6009);
var _CBORSocket = __webpack_require__(9641);
var _IFrameBridge = __webpack_require__(1055);
var _IFrameRPC = __webpack_require__(4203);
var _isxdoc = __webpack_require__(636);
var _closestXdocParent = __webpack_require__(6817);

/***/ }),

/***/ 9641:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(1631);
__webpack_require__(6126);
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(9199);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
__webpack_require__(3697);
__webpack_require__(483);
__webpack_require__(1631);
__webpack_require__(6126);
__webpack_require__(2864);
__webpack_require__(5366);
__webpack_require__(1309);
__webpack_require__(2765);
__webpack_require__(6612);
__webpack_require__(2868);
__webpack_require__(6592);
__webpack_require__(8742);
__webpack_require__(7234);
__webpack_require__(660);
__webpack_require__(5780);
__webpack_require__(6235);
__webpack_require__(8151);
__webpack_require__(1774);
__webpack_require__(8922);
__webpack_require__(2065);
__webpack_require__(5435);
__webpack_require__(8263);
__webpack_require__(7057);
__webpack_require__(9199);
__webpack_require__(2589);
__webpack_require__(9198);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CBORSocket = void 0;
__webpack_require__(7436);
__webpack_require__(8434);
__webpack_require__(4602);
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(8549);
__webpack_require__(7081);
__webpack_require__(7043);
__webpack_require__(9062);
__webpack_require__(1417);
__webpack_require__(6736);
__webpack_require__(5284);
__webpack_require__(9670);
__webpack_require__(4211);
__webpack_require__(2880);
__webpack_require__(7939);
__webpack_require__(5640);
__webpack_require__(6330);
__webpack_require__(7387);
__webpack_require__(2591);
__webpack_require__(769);
__webpack_require__(7342);
__webpack_require__(8435);
__webpack_require__(5599);
__webpack_require__(6066);
__webpack_require__(2411);
__webpack_require__(973);
__webpack_require__(9367);
__webpack_require__(3973);
__webpack_require__(8213);
__webpack_require__(6904);
__webpack_require__(8973);
__webpack_require__(2422);
__webpack_require__(2718);
__webpack_require__(3697);
__webpack_require__(8615);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _indexNoEval = __webpack_require__(9284);
var _events = __webpack_require__(6261);
var _SocketMetrics = __webpack_require__(9400);
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return r;
  };
  var t,
    r = {},
    e = Object.prototype,
    n = e.hasOwnProperty,
    o = "function" == typeof Symbol ? Symbol : {},
    i = o.iterator || "@@iterator",
    a = o.asyncIterator || "@@asyncIterator",
    u = o.toStringTag || "@@toStringTag";
  function c(t, r, e, n) {
    Object.defineProperty(t, r, {
      value: e,
      enumerable: !n,
      configurable: !n,
      writable: !n
    });
  }
  try {
    c({}, "");
  } catch (t) {
    c = function c(t, r, e) {
      return t[r] = e;
    };
  }
  function h(r, e, n, o) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype);
    return c(a, "_invoke", function (r, e, n) {
      var o = 1;
      return function (i, a) {
        if (3 === o) throw Error("Generator is already running");
        if (4 === o) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var u = n.delegate;
          if (u) {
            var c = d(u, n);
            if (c) {
              if (c === f) continue;
              return c;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (1 === o) throw o = 4, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = 3;
          var h = s(r, e, n);
          if ("normal" === h.type) {
            if (o = n.done ? 4 : 2, h.arg === f) continue;
            return {
              value: h.arg,
              done: n.done
            };
          }
          "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg);
        }
      };
    }(r, n, new Context(o || [])), !0), a;
  }
  function s(t, r, e) {
    try {
      return {
        type: "normal",
        arg: t.call(r, e)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  r.wrap = h;
  var f = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var l = {};
  c(l, i, function () {
    return this;
  });
  var p = Object.getPrototypeOf,
    y = p && p(p(x([])));
  y && y !== e && n.call(y, i) && (l = y);
  var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
  function g(t) {
    ["next", "throw", "return"].forEach(function (r) {
      c(t, r, function (t) {
        return this._invoke(r, t);
      });
    });
  }
  function AsyncIterator(t, r) {
    function e(o, i, a, u) {
      var c = s(t[o], t, i);
      if ("throw" !== c.type) {
        var h = c.arg,
          f = h.value;
        return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) {
          e("next", t, a, u);
        }, function (t) {
          e("throw", t, a, u);
        }) : r.resolve(f).then(function (t) {
          h.value = t, a(h);
        }, function (t) {
          return e("throw", t, a, u);
        });
      }
      u(c.arg);
    }
    var o;
    c(this, "_invoke", function (t, n) {
      function i() {
        return new r(function (r, o) {
          e(t, n, r, o);
        });
      }
      return o = o ? o.then(i, i) : i();
    }, !0);
  }
  function d(r, e) {
    var n = e.method,
      o = r.i[n];
    if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f;
    var i = s(o, r.i, e.arg);
    if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f;
    var a = i.arg;
    return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f);
  }
  function w(t) {
    this.tryEntries.push(t);
  }
  function m(r) {
    var e = r[4] || {};
    e.type = "normal", e.arg = t, r[4] = e;
  }
  function Context(t) {
    this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0);
  }
  function x(r) {
    if (null != r) {
      var e = r[i];
      if (e) return e.call(r);
      if ("function" == typeof r.next) return r;
      if (!isNaN(r.length)) {
        var o = -1,
          a = function e() {
            for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e;
            return e.value = t, e.done = !0, e;
          };
        return a.next = a;
      }
    }
    throw new TypeError(_typeof(r) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), c(GeneratorFunctionPrototype, u, GeneratorFunction.displayName = "GeneratorFunction"), r.isGeneratorFunction = function (t) {
    var r = "function" == typeof t && t.constructor;
    return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name));
  }, r.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t;
  }, r.awrap = function (t) {
    return {
      __await: t
    };
  }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () {
    return this;
  }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(h(t, e, n, o), i);
    return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, g(v), c(v, u, "Generator"), c(v, i, function () {
    return this;
  }), c(v, "toString", function () {
    return "[object Generator]";
  }), r.keys = function (t) {
    var r = Object(t),
      e = [];
    for (var n in r) e.unshift(n);
    return function t() {
      for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t;
      return t.done = !0, t;
    };
  }, r.values = x, Context.prototype = {
    constructor: Context,
    reset: function reset(r) {
      if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0][4];
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(r) {
      if (this.done) throw r;
      var e = this;
      function n(t) {
        a.type = "throw", a.arg = r, e.next = t;
      }
      for (var o = e.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i[4],
          u = this.prev,
          c = i[1],
          h = i[2];
        if (-1 === i[0]) return n("end"), !1;
        if (!c && !h) throw Error("try statement without catch or finally");
        if (null != i[0] && i[0] <= u) {
          if (u < c) return this.method = "next", this.arg = t, n(c), !0;
          if (u < h) return n(h), !1;
        }
      }
    },
    abrupt: function abrupt(t, r) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) {
          var o = n;
          break;
        }
      }
      o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null);
      var i = o ? o[4] : {};
      return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i);
    },
    complete: function complete(t, r) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f;
    },
    finish: function finish(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[2] === t) return this.complete(e[4], e[3]), m(e), f;
      }
    },
    "catch": function _catch(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[0] === t) {
          var n = e[4];
          if ("throw" === n.type) {
            var o = n.arg;
            m(e);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(r, e, n) {
      return this.delegate = {
        i: x(r),
        r: e,
        n: n
      }, "next" === this.method && (this.arg = t), f;
    }
  }, r;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var debug = (0, _debug["default"])('cbio.CBORSocket');
var _delegate = /*#__PURE__*/new WeakMap();
var _closed = /*#__PURE__*/new WeakMap();
var _socket = /*#__PURE__*/new WeakMap();
var _attempts = /*#__PURE__*/new WeakMap();
var _maxDelay = /*#__PURE__*/new WeakMap();
var _minDelay = /*#__PURE__*/new WeakMap();
var _pingInterval = /*#__PURE__*/new WeakMap();
var _openSuccessTimeout = /*#__PURE__*/new WeakMap();
var _reconnectTimeout = /*#__PURE__*/new WeakMap();
var _messageId = /*#__PURE__*/new WeakMap();
var _lastMessageAck = /*#__PURE__*/new WeakMap();
var _metrics = /*#__PURE__*/new WeakMap();
var _createSocket = /*#__PURE__*/new WeakMap();
var _resetSocket = /*#__PURE__*/new WeakMap();
var _handleOffline = /*#__PURE__*/new WeakMap();
var _handleOpen = /*#__PURE__*/new WeakMap();
var _handleAck = /*#__PURE__*/new WeakMap();
var _handleMessage = /*#__PURE__*/new WeakMap();
var _reconnectDelay = /*#__PURE__*/new WeakMap();
var _reconnect = /*#__PURE__*/new WeakMap();
var _handleClose = /*#__PURE__*/new WeakMap();
var _handleError = /*#__PURE__*/new WeakMap();
var _sendPing = /*#__PURE__*/new WeakMap();
var CBORSocket = exports.CBORSocket = /*#__PURE__*/function (_EventEmitter) {
  function CBORSocket(delegate) {
    var _this;
    _classCallCheck(this, CBORSocket);
    _this = _callSuper(this, CBORSocket);
    _classPrivateFieldInitSpec(_this, _delegate, void 0);
    _classPrivateFieldInitSpec(_this, _closed, false);
    _classPrivateFieldInitSpec(_this, _socket, void 0);
    _classPrivateFieldInitSpec(_this, _attempts, 0);
    _classPrivateFieldInitSpec(_this, _maxDelay, 60 * 1000);
    _classPrivateFieldInitSpec(_this, _minDelay, 1000 + Math.floor(1000 * Math.random()));
    _classPrivateFieldInitSpec(_this, _pingInterval, void 0);
    _classPrivateFieldInitSpec(_this, _openSuccessTimeout, void 0);
    _classPrivateFieldInitSpec(_this, _reconnectTimeout, void 0);
    // message IDs for flow control
    _classPrivateFieldInitSpec(_this, _messageId, 0);
    _classPrivateFieldInitSpec(_this, _lastMessageAck, 0);
    _classPrivateFieldInitSpec(_this, _metrics, new _SocketMetrics.SocketMetrics());
    _classPrivateFieldInitSpec(_this, _createSocket, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _classPrivateFieldGet2, _classPrivateFieldGet3;
      var url, protocols, socket;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!_classPrivateFieldGet(_socket, _this)) {
              _context.next = 3;
              break;
            }
            console.error('Socket already exists');
            return _context.abrupt("return");
          case 3:
            debug('creating ws');
            // Generate the URL. Important: this might be an
            // asynchronous operation (e.g. getting the server
            // to generate a token). So we need to be careful
            // to re-check the intended state of the socket
            // after a successful url generation
            _context.next = 6;
            return _classPrivateFieldGet(_delegate, _this).getUrl();
          case 6:
            url = _context.sent;
            _context.t0 = ['cbor'];
            _context.t1 = _toConsumableArray;
            _context.next = 11;
            return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(_delegate, _this)).getProtocols) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.call(_classPrivateFieldGet3);
          case 11:
            _context.t2 = _context.sent;
            if (_context.t2) {
              _context.next = 14;
              break;
            }
            _context.t2 = [];
          case 14:
            _context.t3 = _context.t2;
            _context.t4 = (0, _context.t1)(_context.t3);
            protocols = _context.t0.concat.call(_context.t0, _context.t4).filter(Boolean);
            if (url) {
              _context.next = 19;
              break;
            }
            return _context.abrupt("return");
          case 19:
            if (!_classPrivateFieldGet(_closed, _this)) {
              _context.next = 21;
              break;
            }
            return _context.abrupt("return");
          case 21:
            if (!_classPrivateFieldGet(_socket, _this)) {
              _context.next = 23;
              break;
            }
            return _context.abrupt("return");
          case 23:
            // otherwise we have the URL so create the underlying
            // WebSocket instance
            socket = _classPrivateFieldGet(_delegate, _this).createWebSocket ? _classPrivateFieldGet(_delegate, _this).createWebSocket(url, protocols) : new WebSocket(url, protocols);
            socket.binaryType = 'arraybuffer';
            socket.addEventListener('open', _classPrivateFieldGet(_handleOpen, _this));
            socket.addEventListener('message', _classPrivateFieldGet(_handleMessage, _this));
            socket.addEventListener('close', _classPrivateFieldGet(_handleClose, _this));
            socket.addEventListener('error', _classPrivateFieldGet(_handleError, _this));

            // save the socket on the instance
            _classPrivateFieldSet(_socket, _this, socket);
            _classPrivateFieldGet(_metrics, _this).reset();
          case 31:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })));
    _classPrivateFieldInitSpec(_this, _resetSocket, function () {
      if (_classPrivateFieldGet(_socket, _this)) {
        try {
          var _classPrivateFieldGet4;
          (_classPrivateFieldGet4 = _classPrivateFieldGet(_socket, _this)).close.apply(_classPrivateFieldGet4, arguments);
        } catch (e) {
          debug('error closing socket', e);
        }
      }
      _classPrivateFieldSet(_socket, _this, null);
    });
    _classPrivateFieldInitSpec(_this, _handleOffline, function () {
      // If the navigator thinks it goes offline,
      // then we will kill the socket connection to
      // kick it into reconnect mode
      // This is necessary because the websocket
      // might not notify us on some platforms
      debug('navigator went offline');
      _classPrivateFieldGet(_resetSocket, _this).call(_this);
      _classPrivateFieldGet(_reconnect, _this).call(_this);
    });
    _classPrivateFieldInitSpec(_this, _handleOpen, function () {
      debug('ws opened');
      _this.emit('open');
      clearTimeout(_classPrivateFieldGet(_openSuccessTimeout, _this));
      // require socket to be held opne for a little time before
      // resetting the backoff algorithm
      _classPrivateFieldSet(_openSuccessTimeout, _this, setTimeout(function () {
        debug('counting open as success');
        _classPrivateFieldSet(_attempts, _this, 0);
      }, 5 * 1000));
    });
    _classPrivateFieldInitSpec(_this, _handleAck, function (ack) {
      _classPrivateFieldSet(_lastMessageAck, _this, ack);
      _classPrivateFieldGet(_metrics, _this).onReceived(ack);
    });
    _classPrivateFieldInitSpec(_this, _handleMessage, function (message) {
      try {
        var _cborDecode = (0, _indexNoEval.decode)(new Uint8Array(message.data)),
          event = _cborDecode.event,
          data = _cborDecode.data,
          ack = _cborDecode.ack;
        if (ack) return _classPrivateFieldGet(_handleAck, _this).call(_this, ack);
        if (!event) return console.error('Socket received message without event', message);
        return _this.emit('event', event, data);
      } catch (e) {
        return console.error('Error processing message', message.data, e.stack);
      }
    });
    _classPrivateFieldInitSpec(_this, _reconnectDelay, function (attempt) {
      if (attempt === 0) return 0;
      var randomFactor = 1 + 0.5 * Math.random();
      var delay = Math.floor(Math.pow(300 * attempt, 1.2) * randomFactor);
      return Math.min(Math.max(_classPrivateFieldGet(_minDelay, _this), delay), _classPrivateFieldGet(_maxDelay, _this));
    });
    _classPrivateFieldInitSpec(_this, _reconnect, function () {
      // if the socket was destroyed then don't try to reconnect
      if (_classPrivateFieldGet(_closed, _this)) {
        debug('reconnect skipped as socket was closed');
        return;
      }

      // never try to schedule multiple reconnects
      if (_classPrivateFieldGet(_reconnectTimeout, _this)) {
        debug('reconnect skipped as reconnect already scheduled');
        return;
      }

      // if we're offline then don't try to reconnect yet, just wait a bit
      // and try again
      if (typeof navigator !== 'undefined' && navigator.onLine === false) {
        debug('navigator offline');
        _classPrivateFieldSet(_reconnectTimeout, _this, setTimeout(function () {
          _classPrivateFieldSet(_reconnectTimeout, _this, null);
          _classPrivateFieldGet(_reconnect, _this).call(_this);
        }, 1000));
        return;
      }

      // otherwise work out the backoff delay and schedule reconnection
      var delay = _classPrivateFieldGet(_reconnectDelay, _this).call(_this, _classPrivateFieldGet(_attempts, _this));
      debug('reconnecting in', delay, 'attempts', _classPrivateFieldGet(_attempts, _this));
      _classPrivateFieldSet(_reconnectTimeout, _this, setTimeout(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _classPrivateFieldSet(_reconnectTimeout, _this, null);
              if (!_classPrivateFieldGet(_closed, _this)) {
                _context2.next = 5;
                break;
              }
              console.warn('tried to reconnect after close');
              _context2.next = 9;
              break;
            case 5:
              _classPrivateFieldSet(_socket, _this, null);
              _context2.next = 8;
              return _classPrivateFieldGet(_createSocket, _this).call(_this)["catch"](_classPrivateFieldGet(_handleError, _this));
            case 8:
              // if the socket failed to create for some reason, but the
              // we've not been explictly closed then we'll enter the
              // reconnect loop here.
              if (!_classPrivateFieldGet(_socket, _this) && !_classPrivateFieldGet(_closed, _this)) _classPrivateFieldGet(_reconnect, _this).call(_this);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      })), delay));
      _classPrivateFieldSet(_attempts, _this, _classPrivateFieldGet(_attempts, _this) + 1);
    });
    _classPrivateFieldInitSpec(_this, _handleClose, function () {
      debug('ws closed');
      _this.emit('close');
      debug('resetting message acks');
      _classPrivateFieldSet(_messageId, _this, 0);
      _classPrivateFieldSet(_lastMessageAck, _this, 0);
      _classPrivateFieldGet(_metrics, _this).onReceived(0);

      // backoff reconnection
      if (!_classPrivateFieldGet(_closed, _this)) _classPrivateFieldGet(_reconnect, _this).call(_this);

      // cancel pending success timeout
      clearTimeout(_classPrivateFieldGet(_openSuccessTimeout, _this));
    });
    _classPrivateFieldInitSpec(_this, _handleError, function (error) {
      if (_classPrivateFieldGet(_closed, _this)) {
        // when the socket is closed we remove all listeners so we can't emit
        // as that would cause an unhandled error. this should be safe though
        // and probably a consequence of the different catch blocks calling this
        console.info('CobrowseIO: Called error after close.', error);
        return;
      }
      if (_this.listenerCount('error') === 0) {
        // this should never occur and if it does it means means we remove the error
        // listener before we call this method. this is a bug and the stack trace should give us
        // some additional information to fix it
        console.warn('CobrowseIO: Called handleError without listeners. Please report this.', error);
        return;
      }
      _this.emit('error', error);
    });
    _classPrivateFieldInitSpec(_this, _sendPing, function () {
      _this.send('ping');
    });
    _defineProperty(_this, "messageLag", function () {
      // if no ack received at all, then don't count as lagging
      // could mean server doesn't support acks or something
      if (!_classPrivateFieldGet(_lastMessageAck, _this)) return 0;
      return _classPrivateFieldGet(_messageId, _this) - _classPrivateFieldGet(_lastMessageAck, _this);
    });
    _defineProperty(_this, "setMaxReconnectDelay", function (delay) {
      debug('set max delay', delay);
      _classPrivateFieldSet(_maxDelay, _this, delay);
    });
    _defineProperty(_this, "setMinReconnectDelay", function (delay) {
      debug('set min delay', delay);
      _classPrivateFieldSet(_minDelay, _this, delay);
    });
    _defineProperty(_this, "send", function (event, data) {
      if (!_this.connected) return false;
      _classPrivateFieldSet(_messageId, _this, _classPrivateFieldGet(_messageId, _this) + 1);
      _classPrivateFieldGet(_metrics, _this).onSent(_classPrivateFieldGet(_messageId, _this));
      var start = Date.now();
      var payload = (0, _indexNoEval.encode)(data
      // The server attempts to extract event and id from the CBOR payload
      // without having to parse the data, which can be 10's of thousands of
      // JS objects and take up to a minute on really big sites. For this to
      // be possible, the event and id must come before data in insertion
      // order
      ? {
        event: event,
        id: _classPrivateFieldGet(_messageId, _this),
        data: data
      } : {
        event: event
      });
      debug('encoded', event, "".concat(payload.byteLength, " bytes"), 'in', "".concat(Date.now() - start, "ms"));
      _classPrivateFieldGet(_socket, _this).send(payload);
      return true;
    });
    _defineProperty(_this, "close", function () {
      var _classPrivateFieldGet5;
      debug('close');
      _classPrivateFieldSet(_closed, _this, true);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_classPrivateFieldGet5 = _classPrivateFieldGet(_resetSocket, _this)).call.apply(_classPrivateFieldGet5, [_this].concat(args));

      // clear any pending timers before removing listeners
      clearTimeout(_classPrivateFieldGet(_reconnectTimeout, _this));
      clearInterval(_classPrivateFieldGet(_pingInterval, _this));
      _this.removeAllListeners();
      if (typeof window !== 'undefined') {
        window.removeEventListener('unload', _this.close);
        window.addEventListener('offline', _classPrivateFieldGet(_handleOffline, _this));
      }
    });
    debug('created cbor socket');
    _classPrivateFieldSet(_delegate, _this, delegate);
    _classPrivateFieldSet(_pingInterval, _this, setInterval(_classPrivateFieldGet(_sendPing, _this), 60 * 1000));
    if (typeof window !== 'undefined') {
      window.addEventListener('unload', _this.close);
      window.addEventListener('offline', _classPrivateFieldGet(_handleOffline, _this));
    }
    _this.on('error', function (e) {
      return debug('ws errored', e);
    });
    _classPrivateFieldGet(_reconnect, _this).call(_this);
    return _this;
  }
  _inherits(CBORSocket, _EventEmitter);
  return _createClass(CBORSocket, [{
    key: "bufferedAmount",
    get: function get() {
      if (!_classPrivateFieldGet(_socket, this)) return Infinity;
      return _classPrivateFieldGet(_socket, this).bufferedAmount;
    }
  }, {
    key: "connected",
    get: function get() {
      if (_classPrivateFieldGet(_socket, this)) return _classPrivateFieldGet(_socket, this).readyState === _classPrivateFieldGet(_socket, this).OPEN;else return false;
    }
  }, {
    key: "metrics",
    get: function get() {
      return _classPrivateFieldGet(_metrics, this);
    }
  }]);
}(_events.EventEmitter);

/***/ }),

/***/ 9400:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(1631);
__webpack_require__(3697);
__webpack_require__(483);
__webpack_require__(1631);
__webpack_require__(2864);
__webpack_require__(5366);
__webpack_require__(8742);
__webpack_require__(1774);
__webpack_require__(2065);
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SocketMetrics = void 0;
__webpack_require__(4602);
__webpack_require__(7081);
__webpack_require__(7043);
__webpack_require__(9062);
__webpack_require__(2718);
__webpack_require__(3697);
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldSet(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
var LATENCY_FILTERING_SMOOTHING_FACTOR = 0.125;
var smoothen = function smoothen(current, base) {
  if (!base) return current;
  // exponential moving average
  return LATENCY_FILTERING_SMOOTHING_FACTOR * current + (1 - LATENCY_FILTERING_SMOOTHING_FACTOR) * base;
};
var _lastMessage = /*#__PURE__*/new WeakMap();
var _lastMessageTimestamp = /*#__PURE__*/new WeakMap();
var _lastAck = /*#__PURE__*/new WeakMap();
var _lastAckTimestamp = /*#__PURE__*/new WeakMap();
var _filteredLatency = /*#__PURE__*/new WeakMap();
var SocketMetrics = exports.SocketMetrics = /*#__PURE__*/_createClass(function SocketMetrics() {
  var _this = this;
  _classCallCheck(this, SocketMetrics);
  _classPrivateFieldInitSpec(this, _lastMessage, void 0);
  _classPrivateFieldInitSpec(this, _lastMessageTimestamp, void 0);
  _classPrivateFieldInitSpec(this, _lastAck, void 0);
  _classPrivateFieldInitSpec(this, _lastAckTimestamp, void 0);
  _classPrivateFieldInitSpec(this, _filteredLatency, void 0);
  _defineProperty(this, "reset", function () {
    _classPrivateFieldSet(_lastMessage, _this, 0);
    _classPrivateFieldSet(_lastMessageTimestamp, _this, 0);
    _classPrivateFieldSet(_lastAck, _this, 0);
    _classPrivateFieldSet(_lastAckTimestamp, _this, 0);
    _classPrivateFieldSet(_filteredLatency, _this, 0);
  });
  _defineProperty(this, "latency", function () {
    // Nothing has been sent yet
    if (_classPrivateFieldGet(_lastMessage, _this) === 0) return 0;

    // if we're not awaiting an ack then we can just use the filtered latency
    // we're tracking and updating on receiving acks.
    if (_classPrivateFieldGet(_filteredLatency, _this) > 0 && _classPrivateFieldGet(_lastMessage, _this) === _classPrivateFieldGet(_lastAck, _this)) return _classPrivateFieldGet(_filteredLatency, _this);
    var currentLatency = Date.now() - _classPrivateFieldGet(_lastMessageTimestamp, _this);
    if (currentLatency > _classPrivateFieldGet(_filteredLatency, _this)) {
      // we can apply filter to the return value but don't persist it yet!
      // if we get an ACK eventually, the filter will get applied to the persisted value
      // using the regular ack logic.
      return smoothen(currentLatency, _classPrivateFieldGet(_filteredLatency, _this));
    }
    return _classPrivateFieldGet(_filteredLatency, _this);
  });
  _defineProperty(this, "onSent", function (messageId) {
    // track one id / ack pair at a time, i.e. when SEND 1 happens,
    // ignore all other sends until ACK 1 (or a higher ack)
    if (_classPrivateFieldGet(_lastAck, _this) < _classPrivateFieldGet(_lastMessage, _this)) return;
    _classPrivateFieldSet(_lastMessage, _this, messageId);
    _classPrivateFieldSet(_lastMessageTimestamp, _this, Date.now());
  });
  _defineProperty(this, "onReceived", function (ackId) {
    // as soon as we get an ack for an ID we can assume all lower IDs have also been ack'ed
    _classPrivateFieldSet(_lastAck, _this, ackId);
    _classPrivateFieldSet(_lastAckTimestamp, _this, Date.now());
    var currentLatency;
    if (_classPrivateFieldGet(_lastMessage, _this) === 0 || _classPrivateFieldGet(_lastAck, _this) === 0) {
      currentLatency = 0;
    } else if (_classPrivateFieldGet(_lastMessage, _this) === _classPrivateFieldGet(_lastAck, _this)) {
      // The message was sent and received back as ack
      currentLatency = _classPrivateFieldGet(_lastAckTimestamp, _this) - _classPrivateFieldGet(_lastMessageTimestamp, _this);
    } else {
      // Received back a message which is not the one that was recently sent, dropping it
      return;
    }
    _classPrivateFieldSet(_filteredLatency, _this, smoothen(currentLatency, _classPrivateFieldGet(_filteredLatency, _this)));
  });
  this.reset();
});

/***/ }),

/***/ 1227:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(9199);
__webpack_require__(1722);
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
  let warned = false;
  return () => {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
})();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }
  let m;

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  // eslint-disable-next-line no-return-assign
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  const c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, match => {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  let r;
  try {
    r = exports.storage.getItem('debug');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = __webpack_require__(8630)(exports);
const {
  formatters
} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ 8630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(9316);
__webpack_require__(3697);
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(2736);
  createDebug.destroy = destroy;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    let hash = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      const self = debug;

      // Set `diff` timestamp
      const curr = Number(new Date());
      const ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: v => {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
    for (const ns of split) {
      if (ns[0] === '-') {
        createDebug.skips.push(ns.slice(1));
      } else {
        createDebug.names.push(ns);
      }
    }
  }

  /**
   * Checks if the given string matches a namespace template, honoring
   * asterisks as wildcards.
   *
   * @param {String} search
   * @param {String} template
   * @return {Boolean}
   */
  function matchesTemplate(search, template) {
    let searchIndex = 0;
    let templateIndex = 0;
    let starIndex = -1;
    let matchIndex = 0;
    while (searchIndex < search.length) {
      if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
        // Match character or proceed with wildcard
        if (template[templateIndex] === '*') {
          starIndex = templateIndex;
          matchIndex = searchIndex;
          templateIndex++; // Skip the '*'
        } else {
          searchIndex++;
          templateIndex++;
        }
      } else if (starIndex !== -1) {
        // eslint-disable-line no-negated-condition
        // Backtrack to the last '*' and try to match more characters
        templateIndex = starIndex + 1;
        matchIndex++;
        searchIndex = matchIndex;
      } else {
        return false; // No match
      }
    }

    // Handle trailing '*' in template
    while (templateIndex < template.length && template[templateIndex] === '*') {
      templateIndex++;
    }
    return templateIndex === template.length;
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    const namespaces = [...createDebug.names, ...createDebug.skips.map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    for (const skip of createDebug.skips) {
      if (matchesTemplate(name, skip)) {
        return false;
      }
    }
    for (const ns of createDebug.names) {
      if (matchesTemplate(name, ns)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

/***/ }),

/***/ 5620:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.CobrowseIO = void 0;
__webpack_require__(2298);
__webpack_require__(9199);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _throttle = _interopRequireDefault(__webpack_require__(6770));
var _src = __webpack_require__(9501);
var _events = __webpack_require__(6261);
var _activity2 = __webpack_require__(5264);
var _cocom = __webpack_require__(3439);
var _rest = __webpack_require__(492);
var _device2 = __webpack_require__(1667);
var _sessions = __webpack_require__(2176);
var _ui = __webpack_require__(3035);
var _integrations = _interopRequireDefault(__webpack_require__(5160));
var _checkVersion = _interopRequireDefault(__webpack_require__(923));
var _iframes = _interopRequireWildcard(__webpack_require__(7966));
var _ua = _interopRequireDefault(__webpack_require__(1354));
var _SessionStorage = __webpack_require__(3531);
var _LocalSessionStorage = __webpack_require__(1312);
var _Locale = _interopRequireDefault(__webpack_require__(7988));
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _NodeTree = _interopRequireDefault(__webpack_require__(2588));
var timers = _interopRequireWildcard(__webpack_require__(706));
var _TabOverlay = _interopRequireDefault(__webpack_require__(198));
var _Navigation = __webpack_require__(4661);
var _splitNameFromTarget = __webpack_require__(2117);
var _virtualagent = __webpack_require__(3177);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.CobrowseIO');
var _activity = /*#__PURE__*/new WeakMap();
var _currentContext = /*#__PURE__*/new WeakMap();
var _restoredSession = /*#__PURE__*/new WeakMap();
var _started = /*#__PURE__*/new WeakMap();
var _registration = /*#__PURE__*/new WeakMap();
var _localSessionStorage = /*#__PURE__*/new WeakMap();
var _sessionStorageFactory = /*#__PURE__*/new WeakMap();
var _sessionStorage = /*#__PURE__*/new WeakMap();
var _customData = /*#__PURE__*/new WeakMap();
var _capabilities = /*#__PURE__*/new WeakMap();
var _device = /*#__PURE__*/new WeakMap();
var _sessionConsent = /*#__PURE__*/new WeakMap();
var _remoteControlConsent = /*#__PURE__*/new WeakMap();
var _fullDeviceConsent = /*#__PURE__*/new WeakMap();
var _openConsent = /*#__PURE__*/new WeakMap();
var _redactedViews = /*#__PURE__*/new WeakMap();
var _unredactedViews = /*#__PURE__*/new WeakMap();
var _ignoredViews = /*#__PURE__*/new WeakMap();
var _pdfLinks = /*#__PURE__*/new WeakMap();
var _universalLinks = /*#__PURE__*/new WeakMap();
var _acceptedUniversalNavigation = /*#__PURE__*/new WeakMap();
var _destroyIframeBridge = /*#__PURE__*/new WeakMap();
var _virtualAgent = /*#__PURE__*/new WeakMap();
var _open = /*#__PURE__*/new WeakMap();
var _loadSession = /*#__PURE__*/new WeakMap();
var _setCurrentSession = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _onSessionMetricsUpdated = /*#__PURE__*/new WeakMap();
var _showSessionControlsFn = /*#__PURE__*/new WeakMap();
var _throttledCustomDataUpdate = /*#__PURE__*/new WeakMap();
var _applySettingsFrom = /*#__PURE__*/new WeakMap();
var _loadVirtualAgent = /*#__PURE__*/new WeakMap();
class CobrowseIO extends _events.EventEmitter {
  constructor() {
    var _this;
    let {
      sessionStorageFactory = (trustedOrigins, api, _ref) => {
        let {
          localStorage
        } = _ref;
        return _SessionStorage.SessionStorage.create(trustedOrigins, api, {
          localStorage
        });
      }
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super();
    _this = this;
    _classPrivateFieldInitSpec(this, _activity, new _cocom.ActivityDetection());
    _classPrivateFieldInitSpec(this, _currentContext, void 0);
    _classPrivateFieldInitSpec(this, _restoredSession, void 0);
    _classPrivateFieldInitSpec(this, _started, false);
    _classPrivateFieldInitSpec(this, _registration, true);
    _classPrivateFieldInitSpec(this, _localSessionStorage, new _LocalSessionStorage.LocalSessionStorage());
    _classPrivateFieldInitSpec(this, _sessionStorageFactory, void 0);
    _classPrivateFieldInitSpec(this, _sessionStorage, void 0);
    _classPrivateFieldInitSpec(this, _customData, {});
    _classPrivateFieldInitSpec(this, _capabilities, _device2.Device.info.capabilities);
    _classPrivateFieldInitSpec(this, _device, new _device2.Device(this));
    _classPrivateFieldInitSpec(this, _sessionConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _remoteControlConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _fullDeviceConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _openConsent, new _ui.ConsentDialog());
    _classPrivateFieldInitSpec(this, _redactedViews, void 0);
    _classPrivateFieldInitSpec(this, _unredactedViews, void 0);
    _classPrivateFieldInitSpec(this, _ignoredViews, void 0);
    _classPrivateFieldInitSpec(this, _pdfLinks, void 0);
    _classPrivateFieldInitSpec(this, _universalLinks, void 0);
    _classPrivateFieldInitSpec(this, _acceptedUniversalNavigation, void 0);
    _classPrivateFieldInitSpec(this, _destroyIframeBridge, void 0);
    _classPrivateFieldInitSpec(this, _virtualAgent, void 0);
    _defineProperty(this, "start", async function () {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      debug('start()', options, 'in', document);

      // Usually headless browsers would not be useful (crawlers etc...)
      // but the tests run in a headless browser, so we need a way to allow
      // them sometimes.
      if (_ua.default.isHeadless() && !options.allowHeadless) {
        console.warn('CobrowseIO: Not starting Cobrowse in a headless browser');
        return;
      }

      // If we're running in an iframe, we need to decide how cobrowse
      // should run, if at all.
      if (window.self !== window.top) {
        // Sometimes we want to force Cobrowse to run as the "main" instance
        // even when in an iframe (for example the demo page)
        if (options.allowIFrameStart) {
          _activity2.WindowTracking.setTracksIframes(true);
        } else if ((0, _src.isxdoc)(window.parent)) {
          // if we're running in a cross document iframe (i.e. the parent page)
          // can't access our content diretly, we run cobrowse in iframe bridge mode
          // which means that content is serialised and sent over postMessage to
          // the parent
          if (_classPrivateFieldGet(_destroyIframeBridge, _this)) _classPrivateFieldGet(_destroyIframeBridge, _this).call(_this);
          _classPrivateFieldSet(_destroyIframeBridge, _this, (0, _iframes.initIframeBridgeAsChild)(_this));
          debug('Starting Cobrowse in Iframe bridge mode with trusted origins:', _iframes.default.trustedOrigins, 'for', document);
          return;
        } else {
          // Most of the time, when we're trying to start in an iframe, the parent
          // page is the one that actually contains the "main" cobrowse snippet, so
          // we don't need to do anything in this iframe.
          debug('Not starting Cobrowse for same-origin iframe', document);
          return;
        }
      }
      if (_classPrivateFieldGet(_destroyIframeBridge, _this)) _classPrivateFieldGet(_destroyIframeBridge, _this).call(_this);
      _classPrivateFieldSet(_destroyIframeBridge, _this, (0, _iframes.initIframeBridgeAsParent)(_this, {
        open: _classPrivateFieldGet(_open, _this)
      }));
      if (!_this.license) {
        console.error('CobrowseIO.license must be set before calling start');
        return;
      }
      if (!_classPrivateFieldGet(_started, _this)) {
        var _this$currentSession;
        // integrations are initialized before #started is set so that
        // any custom data updates made in the integrations don't cause
        // multiple separate PUT requests
        _integrations.default.initialize();
        _activity2.WindowTracking.start();
        (0, _checkVersion.default)(CobrowseIO.version).catch(() => {});
        _classPrivateFieldSet(_sessionStorage, _this, _classPrivateFieldGet(_sessionStorageFactory, _this).call(_this, _this.trustedOrigins, _this.api, {
          localStorage: _classPrivateFieldGet(_localSessionStorage, _this)
        }));
        console.log('CobrowseIO started', CobrowseIO.version);
        _classPrivateFieldSet(_started, _this, true);

        // ensure the new and legacy registration APIs are in sync, this can be
        // removed once the start() options version is removed
        // TODO: options.register is a legacy API and will be removed at some point
        if (typeof options.register === 'boolean') _classPrivateFieldSet(_registration, _this, options.register);

        // start and stop the registration loop based on user activity on the page
        if (_this.registration) {
          _classPrivateFieldGet(_activity, _this).on('active', () => _classPrivateFieldGet(_device, _this).runRegistrationLoop());
          _classPrivateFieldGet(_activity, _this).on('inactive', () => _classPrivateFieldGet(_device, _this).pauseRegistrationLoop());
        }
        _classPrivateFieldGet(_activity, _this).start();

        // Load a restored session if we have it
        debug('attempting to restore session after start');
        await _classPrivateFieldGet(_loadSession, _this).call(_this);
        _classPrivateFieldSet(_restoredSession, _this, null);
        // Once the updated session has been loaded, and the temporary restoredSession cleared
        // we can re-evaluate whether the session control should actually be shown
        // This is a special case as we may call the showSessionControls when the function is first
        // configured by the user (as another special case), so we need to be careful to clean up.
        if (!((_this$currentSession = _this.currentSession) !== null && _this$currentSession !== void 0 && _this$currentSession.isActive())) _this.hideSessionControls();
        timers.mark('start');
        await _classPrivateFieldGet(_loadVirtualAgent, _this).call(_this);
      }
    });
    _defineProperty(this, "stop", async () => {
      var _classPrivateFieldGet2;
      if (this.currentSession && !this.currentSession.isEnded()) {
        await this.currentSession.end().catch(e => {
          console.warn('CobrowseIO: Failed to end session on stop', e);
        });
      }
      _classPrivateFieldGet(_setCurrentSession, this).call(this, null);
      _activity2.WindowTracking.stop();
      _classPrivateFieldGet(_activity, this).stop();
      await _classPrivateFieldGet(_device, this).destroy();
      await ((_classPrivateFieldGet2 = _classPrivateFieldGet(_sessionStorage, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.destroy());
      _classPrivateFieldSet(_sessionStorage, this, undefined);
      _classPrivateFieldSet(_started, this, false);
      if (_classPrivateFieldGet(_destroyIframeBridge, this)) {
        _classPrivateFieldGet(_destroyIframeBridge, this).call(this);
        _classPrivateFieldSet(_destroyIframeBridge, this, null);
      }
      return this;
    });
    _defineProperty(this, "open", function (url, target, windowFeatures) {
      let {
        type
      } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return _classPrivateFieldGet(_open, _this).call(_this, url, target, windowFeatures, {
        type
      });
    });
    _classPrivateFieldInitSpec(this, _open, (url, target, windowFeatures, options) => {
      const go = () => window.open(url, target, windowFeatures);
      if (!_classPrivateFieldGet(_currentContext, this)) return go();
      const {
        target: newTarget,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)(target, '_blank');
      const newOptions = _objectSpread(_objectSpread({}, options), {}, {
        name,
        go
      });
      const {
        rewrittenUrl,
        windowProxy
      } = _classPrivateFieldGet(_currentContext, this).handleNavigation(url, newTarget, windowFeatures, newOptions);
      if (rewrittenUrl) return window.open(rewrittenUrl, target, windowFeatures);
      return windowProxy;
    });
    _classPrivateFieldInitSpec(this, _loadSession, async () => {
      const session = await _classPrivateFieldGet(_sessionStorage, this).load(this);
      if (session) {
        try {
          _classPrivateFieldGet(_setCurrentSession, this).call(this, session, {
            invalidateFrames: true
          });
        } catch (e) {
          console.warn('CobrowseIO: Failed to fetch restored session', e);
        }
      }
      return null;
    });
    _classPrivateFieldInitSpec(this, _setCurrentSession, function (session) {
      var _classPrivateFieldGet3;
      let {
        invalidateFrames = false
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      debug('setting current session', session);

      // updating to same session as current is noop
      if (session && _classPrivateFieldGet(_currentContext, _this)) {
        const currentSession = _classPrivateFieldGet(_currentContext, _this).session;
        if (currentSession.id() === session.id()) return;
      }

      // clean up any default consent prompts that might still be showing
      _classPrivateFieldGet(_sessionConsent, _this).hide();
      _classPrivateFieldGet(_remoteControlConsent, _this).hide();
      _classPrivateFieldGet(_fullDeviceConsent, _this).hide();
      _classPrivateFieldGet(_openConsent, _this).hide();
      const forwardControlEvents = (type, event) => _iframes.default.broadcastToChildren('control', [type, event]);
      const forwardRemoteErrorEvents = data => _iframes.default.broadcastToChildren('remote-error', data);

      // tear down and replace existing context if it exists
      if (_classPrivateFieldGet(_currentContext, _this)) {
        _classPrivateFieldGet(_currentContext, _this).session.off('updated', _classPrivateFieldGet(_onSessionUpdated, _this));
        _classPrivateFieldGet(_currentContext, _this).session.off('ended', _classPrivateFieldGet(_onSessionEnded, _this));
        _classPrivateFieldGet(_currentContext, _this).session.off('control', forwardControlEvents);
        _classPrivateFieldGet(_currentContext, _this).session.off('remote-error', forwardRemoteErrorEvents);
        _classPrivateFieldGet(_currentContext, _this).session.off('metrics.updated', _classPrivateFieldGet(_onSessionMetricsUpdated, _this));
        _classPrivateFieldGet(_currentContext, _this).destroy();
        _classPrivateFieldSet(_currentContext, _this, null);
      }

      // Ensure the session storage is up to date. Note that session might be null here, which
      // will clear the stored session.
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_sessionStorage, _this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.store(session);

      // build new session context
      if (session) {
        _classPrivateFieldSet(_currentContext, _this, new _sessions.SessionContext(session, _this));

        // if the session is loaded (i.e. not still just an id) then emit an update
        // on the main API. If the session is not laoded yet, we'll get another
        // updated event when it is.
        if (session.state()) _classPrivateFieldGet(_onSessionUpdated, _this).call(_this, session);
        session.on('updated', _classPrivateFieldGet(_onSessionUpdated, _this));
        session.once('ended', _classPrivateFieldGet(_onSessionEnded, _this));
        session.on('sync', () => _this.emit('session.sync'));
        session.on('control', forwardControlEvents);
        session.on('remote-error', forwardRemoteErrorEvents);
        session.on('metrics.updated', _classPrivateFieldGet(_onSessionMetricsUpdated, _this));
        if (invalidateFrames) _classPrivateFieldGet(_currentContext, _this).invalidateFrames();
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, session => {
      _classPrivateFieldGet(_sessionStorage, this).store(session);
      if (!session.fullDevice()) _classPrivateFieldGet(_fullDeviceConsent, this).hide();
      if (session.remoteControl() !== 'requested') _classPrivateFieldGet(_remoteControlConsent, this).hide();
      if (!session.isAuthorizing()) _classPrivateFieldGet(_sessionConsent, this).hide();
      this.emit('session.updated', session);
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, session => {
      this.emit('session.ended', session);
      // clear the session context if the session ends
      _classPrivateFieldGet(_setCurrentSession, this).call(this, null);
      _classPrivateFieldSet(_acceptedUniversalNavigation, this, false);
    });
    _classPrivateFieldInitSpec(this, _onSessionMetricsUpdated, session => {
      this.emit('session.metrics.updated', session);
    });
    _classPrivateFieldInitSpec(this, _showSessionControlsFn, void 0);
    _defineProperty(this, "hideSessionControls", () => {
      _ui.SessionStateOverlay.hideSessionControls();
    });
    _classPrivateFieldInitSpec(this, _throttledCustomDataUpdate, (0, _throttle.default)(() => {
      if (_classPrivateFieldGet(_device, this).hasPendingUpdates() && _classPrivateFieldGet(_started, this) && this.registration) {
        _classPrivateFieldGet(_device, this).updateRegistration().catch(e => {
          console.warn('CobrowseIO: updating customData failed', e);
        });
      }
    }, 8 * 1000, {
      leading: true,
      trailing: true
    }));
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmRemoteControl", async () => {
      return _classPrivateFieldGet(_remoteControlConsent, this).show(_Locale.default.tr('REMOTE_CONTROL_REQUEST_TITLE'), _Locale.default.tr('REMOTE_CONTROL_REQUEST_DESCRIPTION'));
    });
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmFullDevice", async () => {
      return _classPrivateFieldGet(_fullDeviceConsent, this).show(_Locale.default.tr('FULL_DEVICE_REQUEST_TITLE'), _Locale.default.tr('FULL_DEVICE_REQUEST_DESCRIPTION'));
    });
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmSession", async () => {
      return _classPrivateFieldGet(_sessionConsent, this).show(_Locale.default.tr('SESSION_REQUEST_TITLE'), _Locale.default.tr('SESSION_REQUEST_DESCRIPTION'));
    });
    // this is intended as a hook for people to provide
    // a confirmation dialog if they wish.
    _defineProperty(this, "confirmOpen", (url, type) => {
      if (type !== _Navigation.NAVIGATION_TYPE.UNIVERSAL) return true;
      if (_classPrivateFieldGet(_acceptedUniversalNavigation, this)) return true;
      const consentResult = _classPrivateFieldGet(_openConsent, this).show(_Locale.default.tr('UNIVERSAL_PROXY_REQUEST_TITLE'), _Locale.default.tr('UNIVERSAL_PROXY_REQUEST_DESCRIPTION'));
      consentResult.then(accepted => {
        if (accepted) _classPrivateFieldSet(_acceptedUniversalNavigation, this, true);
      });
      return consentResult;
    });
    // this is intended as a hook for people to provide
    // their own UI for Universal Proxy or PDF Viewer if they wish.
    _defineProperty(this, "showDocument", document => {
      if (document.target !== '_blank' && _TabOverlay.default.getTabCount() === 0) {
        _TabOverlay.default.enterFullScreen();
      } else {
        _TabOverlay.default.exitFullScreen();
      }
      const confirmUnload = document.type === _Navigation.NAVIGATION_TYPE.UNIVERSAL;
      const tab = _TabOverlay.default.newTab(document.element, '', document.url, document.isLoading, document.close, confirmUnload);
      if (document.isBlocked) tab.showBanner(_Locale.default.tr('UNIVERSAL_PROXY_BLOCKED'));
      const onDocumentUpdated = () => {
        tab.setIcon(document.icon);
        tab.setTitle(document.title || document.url);
        tab.setIsLoading(document.isLoading);
        tab.setContent(document.element);
        document.isBlocked ? tab.showBanner(_Locale.default.tr('UNIVERSAL_PROXY_BLOCKED')) : tab.hideBanner();
      };
      document.on('updated', onDocumentUpdated);
      document.once('closed', () => {
        document.off('updated', onDocumentUpdated);
        tab.close();
      });
    });
    _defineProperty(this, "getSession", async idOrCode => {
      if (!_classPrivateFieldGet(_started, this)) throw new Error('CobrowseIO not started. Call CobrowseIO.start()');
      // if we've already fetched this session, then update the same object and return it
      if (this.currentSession && (this.currentSession.id() === idOrCode || this.currentSession.code() === idOrCode)) {
        return this.currentSession.fetch();
      }
      const session = new _sessions.Session(this).updateResource({
        id: idOrCode
      });
      _classPrivateFieldGet(_setCurrentSession, this).call(this, session);
      await session.fetch();
      this.emit('session.loaded', session);
      return session;
    });
    _defineProperty(this, "createSession", async () => {
      if (!_classPrivateFieldGet(_started, this)) throw new Error('CobrowseIO not started. Call CobrowseIO.start()');
      if (this.currentSession && (this.currentSession.isActive() || this.currentSession.isAuthorizing())) {
        throw new Error('Already in a session');
      }
      if (timers.delta('load') < 8000) {
        console.warn('Six digit codes have a short expiry time. You should wait to generate a code until it is required! Do not generate codes on page load.');
      }
      const session = new _sessions.Session(this);
      _classPrivateFieldGet(_setCurrentSession, this).call(this, session);
      await session.update({
        custom_data: this.customData,
        device: _device2.Device.info
      });
      this.emit('session.loaded', session);
      return session;
    });
    // also provide a simplified wrapper for just creating a session code
    _defineProperty(this, "createSessionCode", async () => {
      const session = await this.createSession();
      return session.code();
    });
    _defineProperty(this, "client", async () => {
      return this;
    });
    _classPrivateFieldInitSpec(this, _applySettingsFrom, target => {
      if (!target) return;
      ['license', 'api', 'registration', 'customData', 'showSessionControls', 'hideSessionControls', 'confirmSession', 'confirmRemoteControl', 'confirmFullDevice', 'trustedOrigins', 'redactedViews', 'unredactedViews', 'ignoredViews', 'capabilities', 'pdfLinks', 'universalLinks', 'confirmOpen', 'showDocument', 'highlightElement', 'virtualAgent'].forEach(prop => {
        if (target[prop] !== undefined) this[prop] = target[prop];
      });
    });
    _classPrivateFieldInitSpec(this, _loadVirtualAgent, async () => {
      if (_classPrivateFieldGet(_virtualAgent, this)) {
        await (0, _virtualagent.initializeVirtualAgent)(_classPrivateFieldGet(_virtualAgent, this), this);
      }
    });
    debug('interface constructed in', document);
    _classPrivateFieldSet(_sessionStorageFactory, this, sessionStorageFactory);
    this.api = 'https://api.cobrowse.io';

    // The snippet will set up a basic CobrowseIO object
    // before the main JS blob has been loaded. The user might
    // have set some properties on this object that we need to
    // retrospectively apply.
    _classPrivateFieldGet(_applySettingsFrom, this).call(this, window && window.CobrowseIO);

    // Restore any active saved session from localstorage
    // sesisons are saved across pageloads so the same session
    // continues without interuption
    _classPrivateFieldSet(_restoredSession, this, _classPrivateFieldGet(_localSessionStorage, this).load(this));

    // Listen for notifications that contain requests from agents
    // to start a cobrowse session. The push notifications contain
    // the ID of a session which we can load through the regular
    // public getSession API.
    _classPrivateFieldGet(_device, this).on('notification', notification => {
      const code = notification['cobrowseio-code'];
      if (code) this.getSession(code).catch(err => {
        console.warn('CobrowseIO: session fetch failed:', err);
      });
    });
  }
  deviceId() {
    return _device2.Device.deviceId();
  }
  get currentSession() {
    if (_classPrivateFieldGet(_currentContext, this)) return _classPrivateFieldGet(_currentContext, this).session;
    return _classPrivateFieldGet(_restoredSession, this);
  }
  set showSessionControls(fn) {
    _classPrivateFieldSet(_showSessionControlsFn, this, fn);
    _ui.SessionStateOverlay.hideSessionControls();
    if (this.currentSession && this.currentSession.isActive()) {
      _classPrivateFieldGet(_showSessionControlsFn, this).call(this);
    }
  }
  get showSessionControls() {
    if (_classPrivateFieldGet(_showSessionControlsFn, this)) return _classPrivateFieldGet(_showSessionControlsFn, this);else return _ui.SessionStateOverlay.showSessionControls;
  }
  set license(license) {
    if (_classPrivateFieldGet(_started, this) && this.license !== license) throw new Error('Cannot change license once Cobrowse is started');
    _rest.RESTResource.setHeader('X-CobrowseLicense', license);
  }
  get license() {
    return _rest.RESTResource.getHeader('X-CobrowseLicense');
  }
  set api(api) {
    if (_classPrivateFieldGet(_started, this) && _rest.RESTResource.api !== api) throw new Error('Cannot change API once Cobrowse is started');
    _rest.RESTResource.api = api;
  }
  get api() {
    return _rest.RESTResource.api;
  }
  set registration(state) {
    if (_classPrivateFieldGet(_started, this) && _classPrivateFieldGet(_registration, this) !== state) throw new Error('Cannot change auto-registration state once Cobrowse is started');
    _classPrivateFieldSet(_registration, this, state);
  }
  get registration() {
    return !!_classPrivateFieldGet(_registration, this);
  }
  set redactedViews(redactedViews) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set redacted views after Cobrowse is started');
    _classPrivateFieldSet(_redactedViews, this, redactedViews);
  }
  get redactedViews() {
    return _classPrivateFieldGet(_redactedViews, this);
  }
  set unredactedViews(unredactedViews) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set unredacted views after Cobrowse is started');
    _classPrivateFieldSet(_unredactedViews, this, unredactedViews);
  }
  get unredactedViews() {
    return _classPrivateFieldGet(_unredactedViews, this);
  }
  set ignoredViews(ignoredViews) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set ignored views after Cobrowse is started');
    _classPrivateFieldSet(_ignoredViews, this, ignoredViews);
    _NodeTree.default.setIgnoredViews(ignoredViews);
  }
  get ignoredViews() {
    return _classPrivateFieldGet(_ignoredViews, this);
  }
  set capabilities(capabilities) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set capabilities after Cobrowse is started');
    if (!Array.isArray(capabilities)) throw new Error('Capabilities should be an array');
    _classPrivateFieldSet(_capabilities, this, capabilities.filter(capability => {
      if (!_device2.Device.info.capabilities.includes(capability)) {
        console.warn("Capability '".concat(capability, "' not supported. Ignoring..."));
        return false;
      }
      return true;
    }));
  }
  get capabilities() {
    var _this$currentSession$, _this$currentSession2;
    // if there's an active session, return the capabilities from the session
    // otherwise return the capabilities set by the user
    return (_this$currentSession$ = (_this$currentSession2 = this.currentSession) === null || _this$currentSession2 === void 0 ? void 0 : _this$currentSession2.capabilities) !== null && _this$currentSession$ !== void 0 ? _this$currentSession$ : _classPrivateFieldGet(_capabilities, this);
  }
  set customData(customData) {
    if (typeof customData !== 'object') throw new Error('Custom data must be an object');
    _classPrivateFieldSet(_customData, this, _objectSpread(_objectSpread({}, _classPrivateFieldGet(_customData, this)), customData));
    // setTimeout will allow coalescing of multiple custom data setting
    if (_classPrivateFieldGet(_started, this)) setTimeout(_classPrivateFieldGet(_throttledCustomDataUpdate, this), 0);

    // if there's an active session in progress, apply custom data udpates immediately
    if (this.currentSession && this.currentSession.isActive()) {
      const existing = this.currentSession.resource.custom_data;
      const changed = Object.keys(customData).find(key => existing[key] !== customData[key]);
      if (!changed) {
        debug('no changes to session custom data');
        return;
      }
      this.currentSession.update({
        custom_data: customData
      }).catch(() => {
        console.warn('CobrowseIO: failed to update custom data on active session');
      });
    }
  }
  get customData() {
    return _objectSpread(_objectSpread({}, _classPrivateFieldGet(_device, this).customData), _classPrivateFieldGet(_customData, this));
  }
  set trustedOrigins(origins) {
    const validated = origins.map(o => {
      try {
        return new URL(o).origin;
      } catch (e) {
        console.warn('CobrowseIO: Invalid URL in trustedOrigins:', o);
        return null;
      }
    }).filter(v => v);
    _iframes.default.trustedOrigins = validated;
  }
  get trustedOrigins() {
    return _iframes.default.trustedOrigins;
  }
  set pdfLinks(links) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set pdfLinks after Cobrowse is started');
    const validLinks = links.map(link => {
      if (link instanceof RegExp || typeof link === 'string') return link;
      console.warn('CobrowseIO: Invalid link in pdfLinks:', link);
      return null;
    }).filter(link => link);
    _classPrivateFieldSet(_pdfLinks, this, validLinks);
  }
  get pdfLinks() {
    return _classPrivateFieldGet(_pdfLinks, this);
  }
  set universalLinks(links) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set universalLinks after Cobrowse is started');
    const validLinks = links.map(link => {
      if (link instanceof RegExp || typeof link === 'string') return link;
      console.warn('CobrowseIO: Invalid link in universalLinks:', link);
      return null;
    }).filter(link => link);
    _classPrivateFieldSet(_universalLinks, this, validLinks);
  }
  get universalLinks() {
    return _classPrivateFieldGet(_universalLinks, this);
  }
  set virtualAgent(slug) {
    if (_classPrivateFieldGet(_started, this)) throw new Error('Cannot set virtualAgent after Cobrowse is started');
    _classPrivateFieldSet(_virtualAgent, this, slug);
  }
  get virtualAgent() {
    return _classPrivateFieldGet(_virtualAgent, this);
  }
  static get version() {
    return _device2.Device.info.sdk_version;
  }
  get version() {
    return CobrowseIO.version;
  }
}
exports.CobrowseIO = CobrowseIO;
_rest.RESTResource.setHeader('Content-Type', 'application/json');
_rest.RESTResource.setHeader('X-CobrowsePlatform', 'web');
_rest.RESTResource.setHeader('X-CobrowseSDKVersion', CobrowseIO.version);
_rest.RESTResource.setHeader('X-CobrowseDevice', _device2.Device.deviceId());
_rest.RESTResource.setHeader('X-CobrowseAPIVersion', '1.63.3');
var _default = exports["default"] = new CobrowseIO();

/***/ }),

/***/ 3147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Dynamics');
function swizzle() {
  const deviceId = _CobrowseIO.default.deviceId();
  let hasInitialized = false;
  function setContextProvider(deviceId) {
    window.Microsoft.Omnichannel.LiveChatWidget.SDK.setContextProvider(() => ({
      'cobrowse-device': {
        value: deviceId,
        isDisplayable: true
      }
    }));
    hasInitialized = true;
    debug('Dynamics initialized');
  }
  _CobrowseIO.default.customData = {
    cobrowse_device_id: deviceId
  };

  // The chat context provider can only be set once the SDK has bootstrapped
  // itself.
  window.addEventListener('lcw:ready', () => {
    if (!hasInitialized) {
      setContextProvider(deviceId);
    }
  });

  // It's possible the SDK had already bootstrapped itself, so try immediately
  // here and swallow any errors if it's not ready yet. Don't be tempted to use
  // the lcw:maximize event as there seem to be race conditions on setting the
  // context at that point.
  try {
    setContextProvider(deviceId);
  } catch (_) {}
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Freshchat');
async function saveCustomData() {
  const deviceId = _CobrowseIO.default.deviceId();
  window.fcWidget.user.setProperties({
    cobrowse_device_id: deviceId
  });
  const userData = await window.fcWidget.user.get();
  if (userData.success) {
    debug('Freshchat initialized');
    const user = userData.data;
    const customData = {
      freshchat_numeric_user_id: user.id + '',
      freshchat_user_id: user.alias,
      cobrowse_device_id: deviceId
    };

    // Freshchat adds a randomly generated name to a new user until either the
    // agent or the user updates it. We don't want to send this name to Cobrowse
    // as it's not the user's real name.
    if (!user.isNameGenerated) {
      customData.freshchat_user_first_name = user.firstName;
      customData.freshchat_user_last_name = user.lastName;
    }
    if (user.email) {
      customData.freshchat_user_email = user.email;
    }
    _CobrowseIO.default.customData = customData;
  }
}
async function swizzle() {
  if (!window.fcWidget) {
    debug('Freshchat not found');
    return;
  }

  // The user:created event is triggered on load as well as when the user
  // sends its first message. It usually fails when it's triggered on load
  // so we need to wait until the next successful trigger occurs.
  window.fcWidget.on('user:created', e => {
    if (!e.success) {
      return;
    }
    saveCustomData();
  });
  window.fcWidget.on('widget:opened', async () => {
    const userExists = await window.fcWidget.user.isExists();
    if (userExists.data === true) {
      await saveCustomData();
    }
  });
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 1809:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.TE = chat;
__webpack_unused_export__ = void 0;
exports.BV = messaging;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Genesys');
async function requestCobrowse(ext) {
  debug('Requesting cobrowse');
  // create a code a display it to the user using your own UI
  const code = await _CobrowseIO.default.createSessionCode();
  debug("Generated session code: ".concat(code));
  ext.command('WebChatService.sendFilteredMessage', {
    message: "Customer requests Cobrowse session with code: ".concat(code.substr(0, 3), " ").concat(code.substr(3)),
    regex: /Customer requests Cobrowse session with code:.*/
  }).done(function (e) {
    debug('CobrowseIOExtension.WebChatService sent filtered message successfully', e);
  }).fail(function (e) {
    debug('CobrowseIOExtension.WebChatService failed to send filtered message', e);
  });
}
function updateUserData(ext) {
  ext.command('WebChatService.updateUserData', {
    cobrowse_device_id: _CobrowseIO.default.deviceId()
  }).done(function (e) {
    debug('CobrowseIOExtension.WebChatService.updateUserData succeeded', e);
  }).fail(function (e) {
    debug('CobrowseIOExtension.WebChatService.updateUserData failed', e);
  });
}
function addCobrowseIOButtons(ext) {
  const cobrowseButton = document.querySelector('.cx-menu .cx-cobrowseio');
  // button is already added, so no-op
  if (cobrowseButton) return;
  const cxMenu = document.getElementsByClassName('cx-menu')[0];
  cxMenu.insertAdjacentHTML('beforeend', '<li role="none"><div class="cx-menu-item cx-cobrowseio cx-icon" role="button" data-icon="cobrowseio" tabindex="0" aria-label="Start Co-browse Opens the Co-browse session" title="Start Co-browse" style="display: block/;"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" viewBox="0 0 100 100" focusable="false" role="img" aria-hidden="true" alt="" data-gcb-service-node="true"><g class="cx-svg-icon-tone1" data-gcb-service-node="true"><path d="M11.5000001,3 L85.4166665,3 L87.6666668,3 C90.2624998,3 97,3.75367965 97,8.36940835 L97,30.4776335 L4.16666671,30.4776335 L4.16666671,70.4963922 C4.16666671,78.8021647 9.0333332,80.6810966 11.3333336,80.6810966 L88.6666664,80.6810966 C90.9625002,80.6810966 92.8333333,78.8021647 92.8333333,76.4963922 L92.8333333,41.8470419 L97,41.8470419 L97,79.5093796 C97,84.1251081 93.2624998,84.8787879 91.6666668,84.8787879 L8.3333332,84.8787879 C3.73750015,84.8787879 1,81.1251081 0,75.5093796 L0,8.36940835 C3,3.75367965 2.73750015,3 8.3333332,3 L8.5000001,3 Z M18.0297398,7.03030303 L5.9962825,7.03030303 C5.79033476,7.03030303 3.99999999,8.59607987 3.99999999,10.5175565 L3.999999,26.1125541 L93,26.1125541 L93,10.5175565 C93,8.59607987 91.2056692,7.03030303 89.0037175,7.03030303 L81.9702602,7.03030303 L18.0297398,7.03030303 Z M42.3451929,54.7727663 L42.3451929,68.6904309 L35,68.6904309 L35,47.7138693 C35,44.657411 37.4676761,42.1818182 40.5082059,42.1818182 L61.3971055,42.1818182 L61.3971055,49.5560425 L47.5394308,49.5560425 L66.3971054,67.9373646 L61.202867,73.154089 L42.3451929,54.7727663 Z" id="Fill-1-Copy""></path></g></svg></div></li>');
  document.getElementsByClassName('cx-cobrowseio')[0].onclick = () => requestCobrowse(ext);
}
let ext;
function chat() {
  if (ext) return;
  try {
    var _window;
    const bus = window.CXBus || ((_window = window) === null || _window === void 0 || (_window = _window._genesys) === null || _window === void 0 || (_window = _window.widgets) === null || _window === void 0 ? void 0 : _window.bus);
    if (!bus) throw new Error('Genesys bus not found');
    ext = bus.registerPlugin('CobrowseIOExtension');
    window.oCobrowseIOExtension = ext;
    debug('CobrowseIOExtension', ext);
    ext.subscribe('WebChat.opened', function (e) {
      debug('CobrowseIOExtension.WebChat.opened', e);
      addCobrowseIOButtons(ext);
      updateUserData(ext);
    });
    ext.subscribe('WebChatService.started', function (e) {
      try {
        debug('CobrowseIOExtension.WebChatService.started', e);
        const customData = {
          cobrowse_device_id: _CobrowseIO.default.deviceId()
        };
        if (e && e.data) {
          if (e.data.data && e.data.data.conversationId) customData.genesys_conversation_id = e.data.data.conversationId;
          if (e.data.userId && e.data.userId !== 'deprecated') customData.genesys_user_id = e.data.userId;
          if (e.data.sessionID && e.data.sessionID !== 'deprecated') customData.genesys_session_id = e.data.sessionID;
        }
        _CobrowseIO.default.customData = customData;
      } catch (error) {
        debug('Error during CobrowseIOExtension.WebChatService.started', error);
      }
    });
    ext.subscribe('WebChatService.agentConnected', function (e) {
      debug('CobrowseIOExtension.WebChatService.agentConnected', e);
    });
    ext.subscribe('WebChatService.clientConnected', function (e) {
      debug('CobrowseIOExtension.WebChatService.clientConnected', e);
    });
    ext.subscribe('WebChatService.restored', function (e) {
      debug('CobrowseIOExtension.WebChatService.restored', e);
    });
    ext.subscribe('WebChatService.ended', function (e) {
      debug('CobrowseIOExtension.WebChatService.ended', e);
      if (_CobrowseIO.default.currentSession && !_CobrowseIO.default.currentSession.isEnded()) {
        _CobrowseIO.default.currentSession.end();
      }
    });
    ext.subscribe('WebChat.started', function (e) {
      try {
        debug('CobrowseIOExtension.WebChat.started', e);
        if (e && e.data && e.data.form) {
          debug('e.data.form', e.data.form);
          const customData = e.data.form || {};
          customData.device_name = e.data.form.firstname ? "".concat(e.data.form.firstname, "'s device") : 'WebChat User\'s Device';
          _CobrowseIO.default.customData = customData;
        }
      } catch (error) {
        debug('Error during CobrowseIOExtension.WebChat.started', error);
      }
    });
    ext.republish('ready');
    ext.ready();
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Genesys, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}
function messaging() {
  try {
    window.Genesys('subscribe', 'Database.ready', () => {
      const deviceId = _CobrowseIO.default.deviceId();
      _CobrowseIO.default.customData = {
        cobrowse_device_id: deviceId
      };
      window.Genesys('command', 'Database.set', {
        messaging: {
          customAttributes: {
            cobrowse_device_id: deviceId
          }
        }
      });
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Genesys, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}
var _default = __webpack_unused_export__ = {
  messaging,
  chat
};

/***/ }),

/***/ 5160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations');
class Integrations {
  static watchProperty(obj, property, onSet) {
    let value = obj[property];
    const watch = () => {
      debug("monitoring changes to ".concat(property), obj);
      Object.defineProperty(obj, property, {
        configurable: true,
        set: newValue => {
          debug('CobrowseIO detected', property, 'as', newValue);
          value = newValue;
          Object.defineProperty(obj, property, {
            configurable: true,
            writable: true,
            value: newValue
          });
          setTimeout(() => onSet(watch), 0);
        },
        get: () => value
      });
    };
    if (value) {
      debug("".concat(property, " already exists as ").concat(obj[property]));
      onSet(watch);
    } else {
      watch();
    }
  }
  static initialize() {
    debug('Initializing integrations');
    this.watchProperty(window, 'Intercom', () => (__webpack_require__(3110)/* ["default"] */ .A)());
    this.watchProperty(window, '$zopim', () => (__webpack_require__(7319).zopim)());
    this.watchProperty(window, 'embedded_svc', () => this.watchProperty(window.embedded_svc, 'liveAgentAPI', () => {
      (__webpack_require__(9278)/* .embeddedSVC */ .th)();
    }));
    this.watchProperty(window, 'embeddedservice_bootstrap', () => (__webpack_require__(9278)/* .embeddedserviceBootstrap */ .MR)());
    this.initializeGenesys((__webpack_require__(1809)/* .messaging */ .BV), (__webpack_require__(1809)/* .chat */ .TE));
    this.initializeZendesk((__webpack_require__(7319).messenger), (__webpack_require__(7319).classic), (__webpack_require__(7319).sunshine));
    this.initializeFreshchat((__webpack_require__(961)/* .swizzle */ .hA));
    this.initializeNice((__webpack_require__(2532)/* .swizzle */ .hA));
    this.initializeDynamics((__webpack_require__(3147)/* .swizzle */ .hA));
    this.initializeServiceNow((__webpack_require__(4244)/* .swizzle */ .hA));
    this.initializeTalkdesk((__webpack_require__(6726)/* .swizzle */ .hA));
  }
  static initializeGenesys(swizzleMessagingFn, swizzleChatFn) {
    this.watchProperty(window, 'Genesys', () => swizzleMessagingFn());
    this.watchProperty(window, 'CXBus', () => swizzleChatFn());
    this.watchProperty(window, '_genesys', () => this.watchProperty(window._genesys, 'widgets', () => this.watchProperty(window._genesys.widgets, 'bus', () => {
      setTimeout(() => {
        swizzleChatFn();
      }, 0);
    })));
  }
  static initializeFreshchat(swizzleFn) {
    this.watchProperty(window, 'fcWidget', () => swizzleFn());
  }
  static initializeTalkdesk(swizzleFn) {
    this.watchProperty(window, 'TalkdeskChatSDK', () => this.watchProperty(window, 'webchat', () => this.watchProperty(window.webchat, 'setContextParam', () => swizzleFn())));
  }
  static initializeZendesk(swizzleMessengerFn, swizzleClassicFn, swizzleSunshineFn) {
    this.watchProperty(window, 'zE', rewatch => {
      // check if the zendesk snippet is fully loaded or, just the initial zE is set
      if (!window.zE.widget) {
        return rewatch();
      }
      if (window.zE.widget === 'messenger') {
        swizzleMessengerFn();
      } else {
        swizzleClassicFn();
      }
    });
    this.watchProperty(window, 'Smooch', () => swizzleSunshineFn());
  }
  static initializeNice(swizzleFn) {
    this.watchProperty(window, 'cxone', rewatch => {
      if (!window.cxone.guide) {
        this.watchProperty(window.cxone, 'guide', () => swizzleFn());
        return rewatch();
      }
      swizzleFn();
    });
  }
  static initializeDynamics(swizzleFn) {
    this.watchProperty(window, 'Microsoft', () => this.watchProperty(window.Microsoft, 'Omnichannel', () => this.watchProperty(window.Microsoft.Omnichannel, 'LiveChatWidget', () => this.watchProperty(window.Microsoft.Omnichannel.LiveChatWidget, 'SDK', () => {
      swizzleFn();
    }))));
  }
  static initializeServiceNow(swizzleFn) {
    this.watchProperty(window, 'ServiceNowChat', () => swizzleFn());
  }
}
exports["default"] = Integrations;

/***/ }),

/***/ 3110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.A = _default;
var _throttle = _interopRequireDefault(__webpack_require__(6770));
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Intercom');
function update() {
  debug('Updating intercom integration');
  if (!window.intercomSettings) window.intercomSettings = {};
  window.intercomSettings.CobrowseID = _CobrowseIO.default.deviceId();
  window.Intercom('update', {
    CobrowseID: _CobrowseIO.default.deviceId()
  });
  _CobrowseIO.default.on('session.loaded', function (session) {
    window.Intercom('update', {
      CobrowseSessionID: session.id()
    });
  });
}
function _default() {
  try {
    if (window.Intercom && typeof window.Intercom === 'function') {
      debug('Initializing intercom integration');
      update();
      window.Intercom('onShow', (0, _throttle.default)(update, 2 * 60 * 1000, {
        trailing: false
      }));
    } else {
      throw new Error('expected window.Intercom to be a function');
    }
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Intercom, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 2532:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
__webpack_require__(9316);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Nice');
async function swizzle() {
  debug('Swizzling started');
  const deviceId = _CobrowseIO.default.deviceId();

  // Set the cobrowse_device_id custom field (needs to exist in Nice CX first)
  try {
    window.cxone('chat', 'setCustomerCustomField', 'cobrowse_device_id', deviceId);
  } catch (e) {
    console.log('Error setting Nice CX custom field', e);
  }
  window.cxone('chat', 'onAnyPushUpdate', _ref => {
    var _CobrowseIO$currentSe;
    let {
      data,
      eventType
    } = _ref;
    if (eventType === 'CaseCreated') {
      var _caseData$authorEndUs;
      debug('Nice case created');
      const {
        case: caseData
      } = data;
      const caseId = caseData.id + '';
      const userName = (_caseData$authorEndUs = caseData.authorEndUserIdentity.fullName) === null || _caseData$authorEndUs === void 0 ? void 0 : _caseData$authorEndUs.trim();
      const userId = caseData.authorEndUserIdentity.idOnExternalPlatform;
      _CobrowseIO.default.customData = {
        nice_case_id: caseId,
        nice_external_contact_id: userId,
        cobrowse_device_id: deviceId,
        user_name: userName
      };
    } else if (eventType === 'CaseStatusChanged' && data.case.status === 'closed' && (_CobrowseIO$currentSe = _CobrowseIO.default.currentSession) !== null && _CobrowseIO$currentSe !== void 0 && _CobrowseIO$currentSe.isActive()) {
      debug('Nice case closed');
      _CobrowseIO.default.currentSession.end();
    }
  });
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 9278:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.th = embeddedSVC;
exports.MR = embeddedserviceBootstrap;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Salesforce');

// The legacy chat implementation
// https://developer.salesforce.com/docs/atlas.en-us.live_agent_dev.meta/live_agent_dev/live_agent_dev_guide_intro.htm
function embeddedSVC() {
  try {
    if (typeof window.embedded_svc !== 'object') throw new Error('expected window.embedded_svc to a be an object');
    if (window.embedded_svc && !window.embedded_svc.liveAgentAPI) throw new Error('expected liveAgentAPI on embedded_svc');
    debug('Initializing salesforce legacy integration');
    window.embedded_svc.addEventHandler('onChatRequestSuccess', function (data) {
      if (data && data.liveAgentSessionKey) _CobrowseIO.default.customData = {
        salesforce_liveAgentSessionKey: data.liveAgentSessionKey
      };
    });
    window.embedded_svc.addEventHandler('onChatEndedByAgent', function () {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
    window.embedded_svc.addEventHandler('onChatEndedByChasitor', function () {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Salesforce Chat, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

// Convert a case sensitive 15 character id to a 18 character, case insensitve id
// https://help.salesforce.com/s/articleView?id=000385066&type=1
function salesforceEnsureCaseInsensitiveId(input) {
  if (input.length === 18) return input;
  if (input.length !== 15) throw Error("Invalid salesforce id: ".concat(input));
  let addon = '';
  for (let block = 0; block < 3; block++) {
    let loop = 0;
    for (let position = 0; position < 5; position++) {
      const current = input.charAt(block * 5 + position);
      if (current >= 'A' && current <= 'Z') {
        loop += 1 << position;
      }
    }
    addon += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ012345'.charAt(loop);
  }
  return input + addon;
}

// Enhanced messaging integration
// https://developer.salesforce.com/docs/service/messaging-web/guide/event-listeners.html
function embeddedserviceBootstrap() {
  try {
    if (typeof window.embeddedservice_bootstrap !== 'object') throw new Error('expected window.embeddedservice_bootstrap to a be an object');
    debug('Initializing salesforce enhanced messaging integration');
    // Extract the messaging session id from the event
    window.addEventListener('onEmbeddedMessagingConversationRouted', event => {
      var _event$detail;
      const entryPayloadJSON = event === null || event === void 0 || (_event$detail = event.detail) === null || _event$detail === void 0 || (_event$detail = _event$detail.conversationEntry) === null || _event$detail === void 0 ? void 0 : _event$detail.entryPayload;
      if (!entryPayloadJSON) throw new Error('No entry payload found');
      const entryPayload = JSON.parse(entryPayloadJSON);
      const messagingSessionId = entryPayload === null || entryPayload === void 0 ? void 0 : entryPayload.recordId; // this is a 15 character id
      if (!messagingSessionId) throw new Error('No messaging Session Id found in entry payload');
      const caseInsensitiveMessagingId = salesforceEnsureCaseInsensitiveId(messagingSessionId);
      _CobrowseIO.default.customData = {
        salesforce_MessagingSessionId: caseInsensitiveMessagingId
      };
    });
    window.addEventListener('onEmbeddedMessagingConversationClosed', event => {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
    window.addEventListener('onEmbeddedMessagingWindowClosed', event => {
      if (_CobrowseIO.default.currentSession) _CobrowseIO.default.currentSession.end();
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Salesforce Chat, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 4244:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.ServiceNow');
function swizzle() {
  const deviceId = _CobrowseIO.default.deviceId();
  _CobrowseIO.default.customData = {
    cobrowse_device_id: deviceId
  };
  debug('ServiceNow initialized');
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 6726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = void 0;
exports.hA = swizzle;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Talkdesk');
let hasInitialized = false;
function swizzle() {
  if (typeof TalkdeskChatSDK !== 'function') {
    console.warn('TalkdeskChatSDK is not a function, ignoring as Talkdesk widget might not be present.');
    return;
  }
  if (!window.webchat) {
    console.warn('Talkdesk not found in variable "webchat". Please load Talkdesk using:');
    console.warn('window.webchat = TalkdeskChatSDK(node, props)');
    return;
  }
  if (typeof window.webchat.setContextParam !== 'function') {
    console.warn('window.webchat.setContextParam is missing or of an unexpected value. Please load Talkdesk using:');
    console.warn('window.webchat = TalkdeskChatSDK(node, props)');
    return;
  }
  if (!hasInitialized) {
    const customData = {
      cobrowse_device_id: _CobrowseIO.default.deviceId()
    };
    _CobrowseIO.default.customData = customData;
    window.webchat.setContextParam(customData);
    hasInitialized = true;
    debug('Talkdesk initialized');
  }
}
var _default = __webpack_unused_export__ = {
  swizzle
};

/***/ }),

/***/ 1907:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.classic = classic;
exports.updateCustomData = updateCustomData;
__webpack_require__(3697);
var _ = __webpack_require__(7319);
// eslint-disable-next-line complexity
function updateCustomData(cmd, props) {
  let customData = {};
  if (cmd === 'identify' && props) {
    if (props.name) customData.user_name = props.name;
    if (props.email) customData.user_email = props.email;
    if (props.organization) customData.user_organization = props.organization;
  } else if (cmd === 'prefill' && props) {
    if (props.name && props.name.value) customData.user_name = props.name.value;
    if (props.email && props.email.value) customData.user_email = props.email.value;
    if (props.phone && props.phone.value) customData.user_phone = props.phone.value;
  } else if (cmd === 'logout') {
    customData = {
      user_name: null,
      user_email: null,
      user_organization: null,
      user_phone: null
    };
  }
  (0, _.fillCustomData)(customData);
}
function swizzle() {
  if (window.zE && window.zE.identify) {
    (0, _.swizzlezE)();

    // swizzle zE.identify
    const zEIdentifySuper = window.zE.identify;
    window.zE.identify = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const [props] = args;
      updateCustomData('identify', props);
      return zEIdentifySuper(...args);
    };
  } else {
    throw new Error('missing window.zE or window.zE.identify');
  }
}
function classic() {
  try {
    swizzle();
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk (classic), please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 7319:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.POLLING_INTERVAL = void 0;
Object.defineProperty(exports, "classic", ({
  enumerable: true,
  get: function () {
    return _classic.classic;
  }
}));
exports["default"] = void 0;
exports.fillCustomData = fillCustomData;
Object.defineProperty(exports, "messenger", ({
  enumerable: true,
  get: function () {
    return _messenger.messenger;
  }
}));
Object.defineProperty(exports, "sunshine", ({
  enumerable: true,
  get: function () {
    return _sunshine.sunshine;
  }
}));
exports.swizzlezE = swizzlezE;
Object.defineProperty(exports, "zopim", ({
  enumerable: true,
  get: function () {
    return _zopim.zopim;
  }
}));
__webpack_require__(3697);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _zopim = __webpack_require__(4808);
var _classic = __webpack_require__(1907);
var _messenger = __webpack_require__(6040);
var _sunshine = __webpack_require__(70);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const POLLING_INTERVAL = exports.POLLING_INTERVAL = 2000;
function fillCustomData(customData) {
  if (Object.keys(customData).length) {
    _CobrowseIO.default.customData = customData;
  }
}
function swizzlezE() {
  const zEsuper = window.zE;
  window.zE = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const [tgt, cmd, props] = args;
    if (tgt === 'webWidget') (0, _classic.updateCustomData)(cmd, props);
    if (tgt === 'messenger') (0, _messenger.updateCustomData)(cmd, props);

    // It is possible that some tags are being set externally and currently the
    // zE API does not allow us to get the current tags. We need to catch that
    // external call here and add our own tags to the list. We also need to
    // prevent the tags from being overridden by any subsequent calls we make.
    if (tgt === 'messenger:set' && cmd === 'conversationTags') {
      let tags = props;
      if (tags && tags.length) {
        const deviceId = _CobrowseIO.default.deviceId();
        tags = [...tags, "cobrowseio_deviceid_".concat(deviceId)];
        args[2] = tags;
        window.zE.__cobrowseio_zendesk_tags_set = true;
      }
    }
    return zEsuper(...args);
  };

  // copy all properties of the zE function
  // eslint-disable-next-line guard-for-in,no-restricted-syntax
  for (const k in zEsuper) window.zE[k] = zEsuper[k];
}
var _default = exports["default"] = {
  messenger: _messenger.messenger,
  classic: _classic.classic,
  sunshine: _sunshine.sunshine,
  zopim: _zopim.zopim
};

/***/ }),

/***/ 6040:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.messenger = messenger;
exports.updateCustomData = updateCustomData;
__webpack_require__(9199);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _ = __webpack_require__(7319);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
let storage = window.localStorage;
function updateCustomData(cmd, props) {
  let customData = {};

  // There's no such thing as an `identify` method on the messenger web widget
  // but for our use case it serves for the same purpose
  if (cmd === 'identify' && props) {
    customData = {
      zendesk_web_user_id: props.appUserId,
      cobrowseio_deviceid: props.deviceId
    };
  } else if (cmd === 'logoutUser') {
    // Clear old data possibly set by the classic widget as well as the user ID
    customData = {
      user_name: null,
      user_email: null,
      user_organization: null,
      user_phone: null,
      zendesk_web_user_id: null,
      zendesk_user_id: null,
      zendesk_ticket_id: null
    };
  }
  (0, _.fillCustomData)(customData);
}
function addTags() {
  // The `messenger:set` method was called externally to set the tags and our zE
  // swizzling code should already have added the device ID. We don't want to
  // override any other tags set by the external call.
  if (window.zE.__cobrowseio_zendesk_tags_set) {
    return;
  }
  window.zE('messenger:set', 'conversationTags', ["cobrowseio_deviceid_".concat(_CobrowseIO.default.deviceId())]);
}
function swizzle() {
  // The only user identifying ID present on both the agent and the user side
  // is the App User ID. To retrieve it on this side we need to look for the
  // client ID set by the widget, then find the instance ID and finally
  // retrieve the App User ID. There could be situations where there are more
  // than one set of data stored in the user's local storage so we need to
  // retrieve the currently used one by starting to look at the `ZD-buid` item.

  const clientId = getClientId();
  if (!clientId) {
    throw new Error('Missing client ID (ZD-buid)');
  }
  const instanceId = getInstanceId(clientId);
  if (!instanceId) {
    throw new Error('Instance ID could not be found');
  }
  const appUserId = getMessengerAppUserId(instanceId);
  addTags();
  updateCustomData('identify', {
    appUserId,
    deviceId: _CobrowseIO.default.deviceId()
  });
}
function getClientId() {
  return storage.getItem('ZD-buid');
}
function getInstanceId(clientId) {
  var _Object$keys$find;
  return (_Object$keys$find = Object.keys(storage).find(key => key.match(/\w+\.clientId/) && storage[key] === clientId)) === null || _Object$keys$find === void 0 || (_Object$keys$find = _Object$keys$find.split('.')) === null || _Object$keys$find === void 0 ? void 0 : _Object$keys$find[0];
}
function getMessengerAppUserId(instanceId) {
  return storage.getItem("".concat(instanceId, ".appUserId"));
}

// ZD-widgetOpen is always stored in session storage
function isWidgetOpen() {
  return sessionStorage.getItem('ZD-widgetOpen') === 'true';
}
function setStorageType() {
  if (sessionStorage.getItem('ZD-buid')) {
    storage = window.sessionStorage;
  } else {
    storage = window.localStorage;
  }
}
function pollAppUserId() {
  const checkAppUserId = (resolve, reject) => {
    // Zendesk can be configured to remember or forget chat history when a user
    // comes back to the site. If set to remember, the chat widget will store
    // its data in local storage, otherwise it will use session storage.
    setStorageType();
    const appUserId = getMessengerAppUserId(getInstanceId(getClientId()));
    if (appUserId) {
      resolve(appUserId);
    } else {
      setTimeout(checkAppUserId, _.POLLING_INTERVAL, resolve, reject);
    }
  };
  return new Promise(checkAppUserId);
}
function messenger() {
  (0, _.swizzlezE)();
  try {
    // The local storage key we require to extract the App User ID won't
    // be set on the first page load, it gets set after the chat has begun
    // (when the first messages load in the widget). We can't simply use the
    // `open` event because it fires before this data is made available to
    // us. Additionally, this event won't be triggered if the user had opened
    // the chat previously in this session so we need to start the polling
    // manually in this situation.
    if (isWidgetOpen()) {
      pollAppUserId().then(swizzle);
    } else {
      window.zE('messenger:on', 'open', () => {
        pollAppUserId().then(swizzle);
      });
    }
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk (messenger), please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 70:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.sunshine = sunshine;
var _ = __webpack_require__(7319);
function updateCustomData(props) {
  const customData = {
    zendesk_web_user_id: props.appUserId
  };
  (0, _.fillCustomData)(customData);
}
function swizzle() {
  updateCustomData({
    appUserId: getAppUserId()
  });
}
function getAppUserId() {
  var _window$Smooch$getUse;
  return (_window$Smooch$getUse = window.Smooch.getUser()) === null || _window$Smooch$getUse === void 0 ? void 0 : _window$Smooch$getUse.id;
}
function pollAppUserId() {
  const checkAppUserId = (resolve, reject) => {
    const appUserId = getAppUserId();
    if (appUserId) {
      resolve(appUserId);
    } else {
      setTimeout(checkAppUserId, _.POLLING_INTERVAL, resolve, reject);
    }
  };
  return new Promise(checkAppUserId);
}
function sunshine() {
  try {
    window.Smooch.on('widget:opened', () => {
      pollAppUserId().then(swizzle);
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk (Sunshine Conversations), please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 4808:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.zopim = zopim;
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.Integrations.Zendesk');
function zopim() {
  try {
    if (typeof window.$zopim !== 'function') throw new Error('expected window.$zopim to a be a function');
    window.$zopim(function () {
      debug('Initializing zendesk integration');
      window.$zopim.livechat.addTags("cobrowseio_deviceid_".concat(_CobrowseIO.default.deviceId()));
      _CobrowseIO.default.customData = {
        cobrowseio_deviceid: _CobrowseIO.default.deviceId()
      };
    });
  } catch (error) {
    console.error('Error syncing Cobrowse.io with Zendesk Chat, please contact hello@cobrowse.io for help!');
    console.warn(error);
  }
}

/***/ }),

/***/ 4033:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _WindowTaps = _interopRequireDefault(__webpack_require__(4153));
var _UniversalHooks = _interopRequireDefault(__webpack_require__(1191));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const getIcon = () => {
  const icons = document.querySelectorAll('link[rel="icon"]');
  if (icons.length > 0) return icons[0].href;
  return '/favicon.ico';
};
var _onChange = /*#__PURE__*/new WeakMap();
var _onPageChange = /*#__PURE__*/new WeakMap();
class DocumentObserver {
  constructor(onChange) {
    _classPrivateFieldInitSpec(this, _onChange, void 0);
    _classPrivateFieldInitSpec(this, _onPageChange, () => {
      const url = _UniversalHooks.default.unproxify(window.location.href);
      const icon = new URL(getIcon(), url).href;
      _classPrivateFieldGet(_onChange, this).call(this, {
        url,
        icon: _UniversalHooks.default.proxify(icon),
        title: document.title,
        isLoading: document.readyState !== 'complete',
        isBlocked: false
      });
    });
    _defineProperty(this, "sendLoading", url => {
      _classPrivateFieldGet(_onChange, this).call(this, {
        url,
        icon: '',
        title: '',
        isLoading: true,
        isBlocked: false
      });
    });
    _defineProperty(this, "sendBlocked", url => {
      _classPrivateFieldGet(_onChange, this).call(this, {
        url,
        icon: '',
        title: '',
        isLoading: false,
        isBlocked: true
      });
    });
    _defineProperty(this, "destroy", () => {
      _WindowTaps.default.off('navigate', _classPrivateFieldGet(_onPageChange, this));
      window.removeEventListener('popstate', _classPrivateFieldGet(_onPageChange, this), {
        capture: true
      });
      document.removeEventListener('readystatechange', _classPrivateFieldGet(_onPageChange, this), {
        capture: true
      });
    });
    _classPrivateFieldSet(_onChange, this, onChange);
    _WindowTaps.default.on('navigate', _classPrivateFieldGet(_onPageChange, this));
    window.addEventListener('popstate', _classPrivateFieldGet(_onPageChange, this), {
      capture: true
    });
    document.addEventListener('readystatechange', _classPrivateFieldGet(_onPageChange, this), {
      capture: true
    });
    _classPrivateFieldGet(_onPageChange, this).call(this);
  }
}
exports["default"] = DocumentObserver;

/***/ }),

/***/ 6913:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _events = __webpack_require__(6261);
var _pick = _interopRequireDefault(__webpack_require__(751));
var _nodes = __webpack_require__(6938);
const _excluded = ["id", "redaction"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _getNode = /*#__PURE__*/new WeakMap();
var _serializeTarget = /*#__PURE__*/new WeakMap();
var _onClick = /*#__PURE__*/new WeakMap();
var _onChange = /*#__PURE__*/new WeakMap();
class InteractionTracking extends _events.EventEmitter {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "track", node => {
      node.addEventListener('click', _classPrivateFieldGet(_onClick, this), {
        capture: true,
        passive: true
      });
      node.addEventListener('change', _classPrivateFieldGet(_onChange, this), {
        capture: true,
        passive: true
      });
    });
    _defineProperty(this, "untrack", node => {
      node.removeEventListener('click', _classPrivateFieldGet(_onClick, this), {
        capture: true,
        passive: true
      });
      node.removeEventListener('change', _classPrivateFieldGet(_onChange, this), {
        capture: true,
        passive: true
      });
    });
    _classPrivateFieldInitSpec(this, _getNode, target => {
      const nodeId = _nodes.NodeTracker.get(target);
      if (!nodeId) return undefined;
      const serialized = _nodes.NodeSerializer.serialize(target, undefined, {
        skipChildren: true
      });
      if (serialized) return serialized;
      return {
        id: nodeId,
        redaction: true
      };
    });
    _classPrivateFieldInitSpec(this, _serializeTarget, function (target) {
      let includeValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const node = _classPrivateFieldGet(_getNode, _this).call(_this, target);
      if (!node) return node;
      const {
          id,
          redaction
        } = node,
        rest = _objectWithoutProperties(node, _excluded);
      return _objectSpread({
        id,
        redacted: Boolean(redaction)
      }, includeValue && (0, _pick.default)(rest, ['value', 'checked']));
    });
    _classPrivateFieldInitSpec(this, _onClick, event => {
      const serializedTarget = _classPrivateFieldGet(_serializeTarget, this).call(this, event.target);
      this.emit('click', serializedTarget);
    });
    _classPrivateFieldInitSpec(this, _onChange, event => {
      const serializedTarget = _classPrivateFieldGet(_serializeTarget, this).call(this, event.target, true);
      this.emit('change', serializedTarget);
    });
  }
}
var _default = exports["default"] = new InteractionTracking();

/***/ }),

/***/ 6350:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _throttle = _interopRequireDefault(__webpack_require__(6770));
var _src = __webpack_require__(9501);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class MouseTracking {
  constructor() {
    _defineProperty(this, "_mousePosition", {
      x: -1,
      y: -1
    });
    _defineProperty(this, "_mouseIsDown", false);
    _defineProperty(this, "_mouseIsIn", false);
    _defineProperty(this, "track", node => {
      node.addEventListener('mousedown', this._onMouseDown, {
        capture: true,
        passive: true
      });
      node.addEventListener('mouseup', this._onMouseUp, {
        capture: true,
        passive: true
      });
      node.addEventListener('mouseenter', this._onMouseEnter, {
        capture: true,
        passive: true
      });
      node.addEventListener('mouseleave', this._onMouseLeave, {
        capture: true,
        passive: true
      });
      node.addEventListener('mousemove', this._onMouseMove, {
        capture: true,
        passive: true
      });
    });
    _defineProperty(this, "untrack", node => {
      node.removeEventListener('mousedown', this._onMouseDown, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mouseup', this._onMouseUp, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mouseenter', this._onMouseEnter, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mouseleave', this._onMouseLeave, {
        capture: true,
        passive: true
      });
      node.removeEventListener('mousemove', this._onMouseMove, {
        capture: true,
        passive: true
      });
    });
    _defineProperty(this, "isDown", () => {
      return this._mouseIsDown;
    });
    _defineProperty(this, "setDown", down => {
      this._mouseIsDown = down;
      if (this.onChange) this.onChange(this.state());
    });
    _defineProperty(this, "isIn", () => {
      return this._mouseIsIn > 0;
    });
    _defineProperty(this, "position", () => {
      return this._mousePosition;
    });
    _defineProperty(this, "setPosition", (x, y, iframe) => {
      if (iframe) {
        // work out the iframe offset, taking into account iframes can be nested
        const iframes = [iframe, ...(0, _src.parents)(iframe).filter(n => {
          var _n$matches;
          return (_n$matches = n.matches) === null || _n$matches === void 0 ? void 0 : _n$matches.call(n, 'iframe');
        })];
        const offset = iframes.map(n => n.getBoundingClientRect()).reduce((a, b) => {
          return {
            x: a.x + b.x,
            y: a.y + b.y
          };
        }, {
          x: 0,
          y: 0
        });
        x += Math.round(offset.x);
        y += Math.round(offset.y);
      }
      this._mousePosition = {
        x,
        y
      };
      if (this.onChange) this.onChange(this.state());
    });
    _defineProperty(this, "state", () => {
      return _objectSpread(_objectSpread({}, this.position()), {}, {
        down: this.isDown(),
        in: this.isIn()
      });
    });
    _defineProperty(this, "_onMouseDown", e => {
      if (!e.isTrusted) return;
      this.setDown(true);
    });
    _defineProperty(this, "_onMouseUp", e => {
      if (!e.isTrusted) return;
      this.setDown(false);
    });
    _defineProperty(this, "_onMouseEnter", e => {
      if (!e.isTrusted) return;
      this._mouseIsIn += 1;
    });
    _defineProperty(this, "_onMouseLeave", e => {
      if (!e.isTrusted) return;
      if (e.target !== e.currentTarget) return;
      this._mouseIsIn -= 1;
    });
    _defineProperty(this, "_onMouseMove", (0, _throttle.default)(e => {
      if (!e.isTrusted) return;
      const {
        clientX,
        clientY
      } = e;
      const iframe = e.view && e.view.frameElement;
      this.setPosition(clientX, clientY, iframe);
    }, 100));
  }
}
var _default = exports["default"] = new MouseTracking();

/***/ }),

/***/ 7771:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _events = __webpack_require__(6261);
var _uuid = __webpack_require__(5392);
var _storage = _interopRequireDefault(__webpack_require__(6542));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.WindowTracking');
const ActiveWindowPath = '_cobrowse_window_id';
var _id = /*#__PURE__*/new WeakMap();
var _tracksIframes = /*#__PURE__*/new WeakMap();
var _started = /*#__PURE__*/new WeakMap();
var _evaluateActive = /*#__PURE__*/new WeakMap();
class WindowTracking extends _events.EventEmitter {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec(this, _id, _generateId._.call(WindowTracking));
    _classPrivateFieldInitSpec(this, _tracksIframes, false);
    _classPrivateFieldInitSpec(this, _started, false);
    _defineProperty(this, "start", () => {
      if (_classPrivateFieldGet(_started, this)) return;
      _classPrivateFieldSet(_started, this, true);
      debug('started');
      _classPrivateFieldGet(_evaluateActive, this).call(this);
      document.addEventListener('visibilitychange', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
      document.addEventListener('mouseover', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
    });
    _defineProperty(this, "stop", () => {
      debug('stopped');
      this.removeAllListeners();
      _classPrivateFieldSet(_started, this, false);
      document.removeEventListener('visibilitychange', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
      document.removeEventListener('mouseover', _classPrivateFieldGet(_evaluateActive, this), {
        capture: true
      });
    });
    _defineProperty(this, "isActive", () => {
      return (0, _storage.default)().getItem(ActiveWindowPath) === this.id;
    });
    _defineProperty(this, "setTracksIframes", trackIframes => {
      _classPrivateFieldSet(_tracksIframes, this, trackIframes);
      _classPrivateFieldGet(_evaluateActive, this).call(this);
    });
    _defineProperty(this, "shouldTrack", () => {
      if (document.hidden) return false;
      const isFrame = window.self !== window.top;
      if (isFrame) return _classPrivateFieldGet(_tracksIframes, this);
      return true;
    });
    _defineProperty(this, "makeActive", () => {
      if (!this.isActive()) {
        debug('making active', window);
        (0, _storage.default)().setItem(ActiveWindowPath, this.id);
        this.emit('activate', window);
      }
    });
    _defineProperty(this, "resignActive", () => {
      if (this.isActive()) {
        debug('resigning active', window);
        (0, _storage.default)().setItem(ActiveWindowPath, null);
      }
    });
    _classPrivateFieldInitSpec(this, _evaluateActive, () => {
      if (this.shouldTrack()) this.makeActive();
      this.emit('updated');
    });
  }
  get id() {
    return _classPrivateFieldGet(_id, this);
  }
}
var _generateId = {
  _: () => {
    document.__cobrowse_window_id = document.__cobrowse_window_id || (0, _uuid.v4)();
    return document.__cobrowse_window_id;
  }
};
var _default = exports["default"] = new WindowTracking();

/***/ }),

/***/ 5264:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "InteractionTracking", ({
  enumerable: true,
  get: function () {
    return _InteractionTracking.default;
  }
}));
Object.defineProperty(exports, "MouseTracking", ({
  enumerable: true,
  get: function () {
    return _MouseTracking.default;
  }
}));
Object.defineProperty(exports, "WindowTracking", ({
  enumerable: true,
  get: function () {
    return _WindowTracking.default;
  }
}));
var _MouseTracking = _interopRequireDefault(__webpack_require__(6350));
var _WindowTracking = _interopRequireDefault(__webpack_require__(7771));
var _InteractionTracking = _interopRequireDefault(__webpack_require__(6913));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 2863:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _mountComponent = __webpack_require__(9103);
var _ui = __webpack_require__(3035);
var _CallSession = _interopRequireDefault(__webpack_require__(4383));
var _MediaSettings = _interopRequireWildcard(__webpack_require__(3646));
var _Signalling = _interopRequireDefault(__webpack_require__(7323));
var _IceServers = _interopRequireDefault(__webpack_require__(3130));
var _MediaPreview = __webpack_require__(4037);
var _activity = __webpack_require__(5264);
var _storage2 = _interopRequireDefault(__webpack_require__(6542));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const MEDIA_SETTINGS_STORAGE_KEY = '_cobrowse_media_settings';

/**
 * CallHandler manages the lifecycle of a CallSession. It is instantiated by SessionContext when
 * the stream socket has opened, this ensures the socket we receive is in the correct state.
 *
 * It coordinates:
 * - Session state changes (e.g. requested, on, rejected, off)
 * - Dynamic mounting / unmounting of UI components (e.g. MediaPreview, CallParticipants)
 * - Media setting changes (e.g. toggle audio / video, change of device, etc)
 * - Client presence events (e.g. join, leave)
 *
 * CallHandler acts as the glue between the Session and Socket implementation in the SDK and the
 * common Calling modules. It is the entry point for Calling.
 */
var _storage = /*#__PURE__*/new WeakMap();
var _mediaPreviewComponent = /*#__PURE__*/new WeakMap();
var _callParticipantsComponent = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
var _clientTracker = /*#__PURE__*/new WeakMap();
var _signalling = /*#__PURE__*/new WeakMap();
var _mediaSettings = /*#__PURE__*/new WeakMap();
var _iceServers = /*#__PURE__*/new WeakMap();
var _calling = /*#__PURE__*/new WeakMap();
var _callSession = /*#__PURE__*/new WeakMap();
var _isCallAccepted = /*#__PURE__*/new WeakMap();
var _saveMediaSettings = /*#__PURE__*/new WeakMap();
var _onWindowActivate = /*#__PURE__*/new WeakMap();
var _onJoin = /*#__PURE__*/new WeakMap();
var _onLeave = /*#__PURE__*/new WeakMap();
var _fetchIceServers = /*#__PURE__*/new WeakMap();
var _onAudioInputSettingsUpdated = /*#__PURE__*/new WeakMap();
var _onVideoInputSettingsUpdated = /*#__PURE__*/new WeakMap();
var _onSessionStateOverlayClick = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _callingOff = /*#__PURE__*/new WeakMap();
var _callingRequested = /*#__PURE__*/new WeakMap();
var _callingOn = /*#__PURE__*/new WeakMap();
var _showMediaPreview = /*#__PURE__*/new WeakMap();
class CallHandler {
  constructor(_session2, clientTracker, socket) {
    _classPrivateFieldInitSpec(this, _storage, (0, _storage2.default)());
    _classPrivateFieldInitSpec(this, _mediaPreviewComponent, void 0);
    _classPrivateFieldInitSpec(this, _callParticipantsComponent, void 0);
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _clientTracker, void 0);
    _classPrivateFieldInitSpec(this, _signalling, void 0);
    _classPrivateFieldInitSpec(this, _mediaSettings, void 0);
    _classPrivateFieldInitSpec(this, _iceServers, void 0);
    _classPrivateFieldInitSpec(this, _calling, void 0);
    _classPrivateFieldInitSpec(this, _callSession, void 0);
    _classPrivateFieldInitSpec(this, _isCallAccepted, false);
    _classPrivateFieldInitSpec(this, _saveMediaSettings, settings => {
      _classPrivateFieldGet(_storage, this).setItem(MEDIA_SETTINGS_STORAGE_KEY, settings);
    });
    _classPrivateFieldInitSpec(this, _onWindowActivate, async () => {
      if (_classPrivateFieldGet(_calling, this) !== 'on') return;
      _classPrivateFieldGet(_mediaSettings, this).update(_classPrivateFieldGet(_storage, this).getItem(MEDIA_SETTINGS_STORAGE_KEY));
      if (_classPrivateFieldGet(_callSession, this)) {
        const remoteParticipants = Array.from(_classPrivateFieldGet(_callSession, this).participants.values()).filter(participant => !participant.isLocal);
        await Promise.all(remoteParticipants.map(participant => _classPrivateFieldGet(_callSession, this).reconnectParticipant(participant.id)));
        return;
      }
      await _classPrivateFieldGet(_callingOn, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onJoin, async _ref => {
      let {
        id,
        agent
      } = _ref;
      if (!_classPrivateFieldGet(_callSession, this)) return;
      await _classPrivateFieldGet(_callSession, this).addParticipant(id, agent);
    });
    _classPrivateFieldInitSpec(this, _onLeave, id => {
      if (!_classPrivateFieldGet(_callSession, this)) return;
      _classPrivateFieldGet(_callSession, this).removeParticipant(id);
    });
    _classPrivateFieldInitSpec(this, _fetchIceServers, async () => {
      try {
        await _classPrivateFieldGet(_iceServers, this).create();
        return _classPrivateFieldGet(_iceServers, this).resource.iceServers;
      } catch (err) {
        console.warn('failed to fetch ice servers', err);
        return [];
      }
    });
    _classPrivateFieldInitSpec(this, _onAudioInputSettingsUpdated, async settings => {
      if (!_classPrivateFieldGet(_callSession, this)) return;
      _ui.SessionStateOverlay.showCallingControls(settings);
      if (!settings.audioEnabled) return _classPrivateFieldGet(_callSession, this).unpublishAudioTrack();
      if (!navigator.mediaDevices) {
        console.warn('CobrowseIO: Failed to start audio, mediaDevices is not available');
        _classPrivateFieldGet(_mediaSettings, this).update({
          audioEnabled: false
        });
        return;
      }
      try {
        const constraints = (0, _MediaSettings.createAudioConstraints)(settings);
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        _classPrivateFieldGet(_callSession, this).publishStreamTracks(stream);
      } catch (err) {
        console.warn('CobrowseIO: Failed to get audio', err);
        _classPrivateFieldGet(_mediaSettings, this).update({
          audioEnabled: false
        });
      }
    });
    _classPrivateFieldInitSpec(this, _onVideoInputSettingsUpdated, async settings => {
      if (!_classPrivateFieldGet(_callSession, this)) return;
      _ui.SessionStateOverlay.showCallingControls(settings);
      if (!settings.videoEnabled) return _classPrivateFieldGet(_callSession, this).unpublishVideoTrack();
      if (!navigator.mediaDevices) {
        console.warn('CobrowseIO: Failed to start video, mediaDevices is not available');
        _classPrivateFieldGet(_mediaSettings, this).update({
          videoEnabled: false
        });
        return;
      }
      try {
        const constraints = (0, _MediaSettings.createVideoConstraints)(settings);
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        _classPrivateFieldGet(_callSession, this).publishStreamTracks(stream);
      } catch (err) {
        console.warn('CobrowseIO: Failed to get video', err);
        _classPrivateFieldGet(_mediaSettings, this).update({
          videoEnabled: false
        });
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionStateOverlayClick, target => {
      if (target === 'audio') _classPrivateFieldGet(_mediaSettings, this).toggleAudio();
      if (target === 'video') _classPrivateFieldGet(_mediaSettings, this).toggleVideo();
      if (target === 'settings') _classPrivateFieldGet(_showMediaPreview, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, (session, prevSession) => {
      _classPrivateFieldSet(_calling, this, session.calling());
      if (_classPrivateFieldGet(_calling, this) !== (prevSession === null || prevSession === void 0 ? void 0 : prevSession.calling())) {
        if (_classPrivateFieldGet(_calling, this) === 'off') _classPrivateFieldGet(_callingOff, this).call(this);
        if (_classPrivateFieldGet(_calling, this) === 'requested' && _activity.WindowTracking.isActive()) _classPrivateFieldGet(_callingRequested, this).call(this);
        if (_classPrivateFieldGet(_calling, this) === 'on' && _activity.WindowTracking.isActive()) _classPrivateFieldGet(_callingOn, this).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, () => {
      _ui.SessionStateOverlay.hideCallingControls();
    });
    _classPrivateFieldInitSpec(this, _callingOff, () => {
      var _classPrivateFieldGet2, _classPrivateFieldGet3, _classPrivateFieldGet4;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_callParticipantsComponent, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      _classPrivateFieldSet(_callParticipantsComponent, this, null);
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_mediaPreviewComponent, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.unmount();
      _classPrivateFieldSet(_mediaPreviewComponent, this, null);
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_callSession, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.destroy();
      _classPrivateFieldSet(_callSession, this, null);
      _ui.SessionStateOverlay.hideCallingControls();
    });
    _classPrivateFieldInitSpec(this, _callingRequested, async () => {
      _classPrivateFieldSet(_isCallAccepted, this, await _classPrivateFieldGet(_showMediaPreview, this).call(this));
      _classPrivateFieldGet(_session, this).update({
        calling: _classPrivateFieldGet(_isCallAccepted, this) ? 'on' : 'rejected'
      });
    });
    _classPrivateFieldInitSpec(this, _callingOn, async () => {
      const {
        videoEnabled,
        audioEnabled
      } = _classPrivateFieldGet(_mediaSettings, this).settings;
      if (!_classPrivateFieldGet(_isCallAccepted, this)) {
        // the browser won't autoplay other participants if there is
        // no getUserMedia or user interaction on refresh. To solve
        // this we show the media preview to force a user interaction
        // if there is no audio or video enabled in the media settings
        if (!videoEnabled && !audioEnabled) {
          const acceptedRejoin = await _classPrivateFieldGet(_showMediaPreview, this).call(this);
          if (!acceptedRejoin) return _classPrivateFieldGet(_session, this).update({
            calling: 'off'
          });
        }
        _classPrivateFieldSet(_isCallAccepted, this, true);
      }
      const iceServers = await _classPrivateFieldGet(_fetchIceServers, this).call(this);
      _classPrivateFieldSet(_callSession, this, new _CallSession.default(_classPrivateFieldGet(_clientTracker, this).id, null, iceServers, _classPrivateFieldGet(_signalling, this)));
      await Promise.all(_classPrivateFieldGet(_clientTracker, this).all().map(_ref2 => {
        let {
          id,
          agent
        } = _ref2;
        return _classPrivateFieldGet(_callSession, this).addParticipant(id, agent);
      }));
      if (videoEnabled || audioEnabled) {
        try {
          const constraints = _objectSpread(_objectSpread({}, (0, _MediaSettings.createAudioConstraints)(_classPrivateFieldGet(_mediaSettings, this).settings)), (0, _MediaSettings.createVideoConstraints)(_classPrivateFieldGet(_mediaSettings, this).settings));
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          _classPrivateFieldGet(_callSession, this).publishStreamTracks(stream);
        } catch (err) {
          console.warn('CobrowseIO: Failed to get media', err);
          _classPrivateFieldGet(_mediaSettings, this).update({
            videoEnabled: false,
            audioEnabled: false
          });
        }
      }
      _ui.SessionStateOverlay.showCallingControls(_classPrivateFieldGet(_mediaSettings, this).settings);
      _classPrivateFieldSet(_callParticipantsComponent, this, (0, _mountComponent.mountComponent)(_ui.CallParticipants, {
        mediaSettings: _classPrivateFieldGet(_mediaSettings, this),
        callSession: _classPrivateFieldGet(_callSession, this)
      }, true, true));
    });
    _classPrivateFieldInitSpec(this, _showMediaPreview, () => {
      return new Promise(resolve => {
        const close = () => {
          var _classPrivateFieldGet5;
          (_classPrivateFieldGet5 = _classPrivateFieldGet(_mediaPreviewComponent, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.unmount();
          _classPrivateFieldSet(_mediaPreviewComponent, this, null);
        };
        const getStatus = () => {
          if (_classPrivateFieldGet(_calling, this) === 'requested') return _MediaPreview.MEDIA_PREVIEW_STATUS.REQUESTED;
          if (_classPrivateFieldGet(_calling, this) === 'on' && !_classPrivateFieldGet(_isCallAccepted, this)) return _MediaPreview.MEDIA_PREVIEW_STATUS.REJOINING;
          return _MediaPreview.MEDIA_PREVIEW_STATUS.UPDATING;
        };
        const initialProps = {
          settings: _classPrivateFieldGet(_mediaSettings, this).settings,
          status: getStatus(),
          isCallAccepted: _classPrivateFieldGet(_isCallAccepted, this),
          accept: settings => {
            _classPrivateFieldGet(_mediaSettings, this).update(settings);
            close();
            resolve(true);
          },
          reject: () => {
            close();
            resolve(false);
          }
        };
        _classPrivateFieldSet(_mediaPreviewComponent, this, (0, _mountComponent.mountComponent)(_ui.MediaPreview, initialProps, true, true));
      });
    });
    _defineProperty(this, "destroy", () => {
      var _classPrivateFieldGet6, _classPrivateFieldGet7, _classPrivateFieldGet8, _classPrivateFieldGet9;
      _activity.WindowTracking.off('activate', _classPrivateFieldGet(_onWindowActivate, this));
      _classPrivateFieldGet(_clientTracker, this).off('leave', _classPrivateFieldGet(_onLeave, this));
      _classPrivateFieldGet(_clientTracker, this).off('join', _classPrivateFieldGet(_onJoin, this));
      _classPrivateFieldGet(_mediaSettings, this).off('videoInputSettings.updated', _classPrivateFieldGet(_onVideoInputSettingsUpdated, this));
      _classPrivateFieldGet(_mediaSettings, this).off('audioInputSettings.updated', _classPrivateFieldGet(_onAudioInputSettingsUpdated, this));
      _ui.SessionStateOverlay.off('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
      _classPrivateFieldGet(_session, this).off('updated', _classPrivateFieldGet(_onSessionUpdated, this));
      _classPrivateFieldGet(_session, this).off('ended', _classPrivateFieldGet(_onSessionEnded, this));
      (_classPrivateFieldGet6 = _classPrivateFieldGet(_callParticipantsComponent, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.unmount();
      _classPrivateFieldSet(_callParticipantsComponent, this, null);
      (_classPrivateFieldGet7 = _classPrivateFieldGet(_mediaPreviewComponent, this)) === null || _classPrivateFieldGet7 === void 0 || _classPrivateFieldGet7.unmount();
      _classPrivateFieldSet(_mediaPreviewComponent, this, null);
      _classPrivateFieldSet(_mediaSettings, this, null);
      (_classPrivateFieldGet8 = _classPrivateFieldGet(_callSession, this)) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.destroy();
      _classPrivateFieldSet(_callSession, this, null);
      (_classPrivateFieldGet9 = _classPrivateFieldGet(_signalling, this)) === null || _classPrivateFieldGet9 === void 0 || _classPrivateFieldGet9.destroy();
      _classPrivateFieldSet(_signalling, this, null);
    });
    _classPrivateFieldSet(_session, this, _session2);
    _classPrivateFieldSet(_clientTracker, this, clientTracker);
    const shouldProcessSignal = _ref3 => {
      let {
        clientId
      } = _ref3;
      return clientTracker.id === clientId && _activity.WindowTracking.isActive();
    };
    _classPrivateFieldSet(_signalling, this, new _Signalling.default(socket, shouldProcessSignal));
    _classPrivateFieldSet(_mediaSettings, this, new _MediaSettings.default(_classPrivateFieldGet(_storage, this).getItem(MEDIA_SETTINGS_STORAGE_KEY), _classPrivateFieldGet(_saveMediaSettings, this)));
    _classPrivateFieldSet(_iceServers, this, new _IceServers.default(_session2));
    _classPrivateFieldGet(_session, this).on('ended', _classPrivateFieldGet(_onSessionEnded, this));
    _classPrivateFieldGet(_session, this).on('updated', _classPrivateFieldGet(_onSessionUpdated, this));
    _classPrivateFieldGet(_onSessionUpdated, this).call(this, _session2);
    _ui.SessionStateOverlay.on('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
    _classPrivateFieldGet(_mediaSettings, this).on('audioInputSettings.updated', _classPrivateFieldGet(_onAudioInputSettingsUpdated, this));
    _classPrivateFieldGet(_mediaSettings, this).on('videoInputSettings.updated', _classPrivateFieldGet(_onVideoInputSettingsUpdated, this));
    _classPrivateFieldGet(_clientTracker, this).on('join', _classPrivateFieldGet(_onJoin, this));
    _classPrivateFieldGet(_clientTracker, this).on('leave', _classPrivateFieldGet(_onLeave, this));
    _activity.WindowTracking.on('activate', _classPrivateFieldGet(_onWindowActivate, this));
  }
}
exports["default"] = CallHandler;

/***/ }),

/***/ 4383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _events = _interopRequireDefault(__webpack_require__(6261));
var _PeerManager = _interopRequireDefault(__webpack_require__(5836));
var _Participant = _interopRequireDefault(__webpack_require__(7354));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * CallSession abstracts the management of individual Peer connections through a higher
 * level Participants interface. It is instantiated when a call becomes active (calling: on),
 * and destroyed when the call ends (calling: off).
 *
 * It coordinates:
 * - Participant addition and removal from ClientTracker (join, leave)
 * - Publishing tracks to a local stream and remote peers
 * - Unpublishing tracks from a local stream and remote peers
 * - Translation of Peer connection and track events into Participants
 *
 * CallSession acts as the glue between a Peer and a Participant.
 */

const debug = (0, _debug.default)('cbio.Calling.CallSession');
var _localPeerId = /*#__PURE__*/new WeakMap();
var _signalling = /*#__PURE__*/new WeakMap();
var _peerManager = /*#__PURE__*/new WeakMap();
var _participants = /*#__PURE__*/new WeakMap();
var _CallSession_brand = /*#__PURE__*/new WeakSet();
var _removeTracksByKind = /*#__PURE__*/new WeakMap();
var _onPeerCreated = /*#__PURE__*/new WeakMap();
var _onPeerConnected = /*#__PURE__*/new WeakMap();
var _onPeerDisconnected = /*#__PURE__*/new WeakMap();
var _onTrackAdded = /*#__PURE__*/new WeakMap();
var _onTrackRemoved = /*#__PURE__*/new WeakMap();
class CallSession extends _events.default {
  constructor(localPeerId, _agent, iceServers, signalling) {
    super();
    _classPrivateMethodInitSpec(this, _CallSession_brand);
    _classPrivateFieldInitSpec(this, _localPeerId, void 0);
    _classPrivateFieldInitSpec(this, _signalling, void 0);
    _classPrivateFieldInitSpec(this, _peerManager, void 0);
    _classPrivateFieldInitSpec(this, _participants, new Map());
    _defineProperty(this, "publishStreamTracks", stream => {
      stream.getTracks().forEach(_classPrivateGetter(_CallSession_brand, this, _get_localParticipant).addTrack);
      _classPrivateFieldGet(_peerManager, this).remotePeerIds.forEach(remotePeerId => {
        _classPrivateFieldGet(_peerManager, this).addStreamToRemotePeer(remotePeerId, _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).stream);
      });
    });
    _defineProperty(this, "unpublishVideoTrack", () => _classPrivateFieldGet(_removeTracksByKind, this).call(this, 'video'));
    _defineProperty(this, "unpublishAudioTrack", () => _classPrivateFieldGet(_removeTracksByKind, this).call(this, 'audio'));
    _defineProperty(this, "addParticipant", async (remotePeerId, agent) => {
      debug('adding participant', remotePeerId);
      if (_classPrivateFieldGet(_participants, this).has(remotePeerId)) return debug('participant already exists', remotePeerId);
      _classPrivateFieldGet(_participants, this).set(remotePeerId, new _Participant.default(remotePeerId, agent));
      const lastOffer = _classPrivateFieldGet(_signalling, this).takeLastOffer(remotePeerId);
      await _classPrivateFieldGet(_peerManager, this).createPeer(_classPrivateFieldGet(_localPeerId, this), remotePeerId, lastOffer);
      this.emit('participants.added', this.participants);
    });
    _defineProperty(this, "removeParticipant", remotePeerId => {
      debug('removing participant', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (!participant) return debug('unknown participant', remotePeerId);
      participant.destroy();
      _classPrivateFieldGet(_participants, this).delete(remotePeerId);
      _classPrivateFieldGet(_peerManager, this).disconnectFromPeer(remotePeerId);
      this.emit('participants.removed', this.participants);
    });
    _defineProperty(this, "reconnectParticipant", async remotePeerId => {
      debug('reconnecting participant', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (!participant) return debug('unknown participant', remotePeerId);
      _classPrivateFieldGet(_peerManager, this).disconnectFromPeer(remotePeerId);
      await _classPrivateFieldGet(_peerManager, this).createPeer(_classPrivateFieldGet(_localPeerId, this), remotePeerId);
    });
    _classPrivateFieldInitSpec(this, _removeTracksByKind, kind => {
      _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).removeTracksByKind(kind);
      _classPrivateFieldGet(_peerManager, this).remotePeerIds.forEach(remotePeerId => {
        _classPrivateFieldGet(_peerManager, this).removeTracksByKindFromRemotePeer(remotePeerId, kind);
      });
    });
    _classPrivateFieldInitSpec(this, _onPeerCreated, remotePeerId => {
      debug('peer created', remotePeerId);
      if (_classPrivateGetter(_CallSession_brand, this, _get_localParticipant).hasVideo || _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).hasAudio) {
        // syncing media will trigger a negotiation of the connection
        _classPrivateFieldGet(_peerManager, this).addStreamToRemotePeer(remotePeerId, _classPrivateGetter(_CallSession_brand, this, _get_localParticipant).stream);
      } else {
        // we trigger a connection so we can receive media
        _classPrivateFieldGet(_peerManager, this).connectToPeer(remotePeerId);
      }
    });
    _classPrivateFieldInitSpec(this, _onPeerConnected, remotePeerId => {
      debug('peer connected', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.isConnected = true;
    });
    _classPrivateFieldInitSpec(this, _onPeerDisconnected, remotePeerId => {
      debug('peer disconnected', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.isConnected = false;
    });
    _classPrivateFieldInitSpec(this, _onTrackAdded, (track, remotePeerId) => {
      debug('track added', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.addTrack(track);
    });
    _classPrivateFieldInitSpec(this, _onTrackRemoved, (track, remotePeerId) => {
      debug('track removed', remotePeerId);
      const participant = _classPrivateFieldGet(_participants, this).get(remotePeerId);
      if (participant) participant.removeTrackById(track.id);
    });
    _defineProperty(this, "destroy", () => {
      _classPrivateFieldGet(_peerManager, this).off('track.removed', _classPrivateFieldGet(_onTrackRemoved, this));
      _classPrivateFieldGet(_peerManager, this).off('track.added', _classPrivateFieldGet(_onTrackAdded, this));
      _classPrivateFieldGet(_peerManager, this).off('peer.disconnected', _classPrivateFieldGet(_onPeerDisconnected, this));
      _classPrivateFieldGet(_peerManager, this).off('peer.connected', _classPrivateFieldGet(_onPeerConnected, this));
      _classPrivateFieldGet(_peerManager, this).off('peer.created', _classPrivateFieldGet(_onPeerCreated, this));
      _classPrivateFieldGet(_participants, this).forEach(participant => participant.destroy());
      _classPrivateFieldGet(_participants, this).clear();
      _classPrivateFieldGet(_peerManager, this).destroy();
      _classPrivateFieldSet(_peerManager, this, null);
      _classPrivateFieldGet(_signalling, this).flushLastOfferCache();
    });
    _classPrivateFieldSet(_localPeerId, this, localPeerId);
    _classPrivateFieldGet(_participants, this).set(localPeerId, new _Participant.default(localPeerId, _agent, true));
    _classPrivateFieldSet(_signalling, this, signalling);
    _classPrivateFieldSet(_peerManager, this, new _PeerManager.default(signalling, iceServers));
    _classPrivateFieldGet(_peerManager, this).on('peer.created', _classPrivateFieldGet(_onPeerCreated, this));
    _classPrivateFieldGet(_peerManager, this).on('peer.connected', _classPrivateFieldGet(_onPeerConnected, this));
    _classPrivateFieldGet(_peerManager, this).on('peer.disconnected', _classPrivateFieldGet(_onPeerDisconnected, this));
    _classPrivateFieldGet(_peerManager, this).on('track.added', _classPrivateFieldGet(_onTrackAdded, this));
    _classPrivateFieldGet(_peerManager, this).on('track.removed', _classPrivateFieldGet(_onTrackRemoved, this));
  }
  get participants() {
    return _classPrivateFieldGet(_participants, this);
  }
}
exports["default"] = CallSession;
function _get_localParticipant(_this) {
  return _classPrivateFieldGet(_participants, _this).get(_classPrivateFieldGet(_localPeerId, _this));
}

/***/ }),

/***/ 3130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _rest = __webpack_require__(492);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _sessionId = /*#__PURE__*/new WeakMap();
class IceServers extends _rest.RESTResource {
  constructor(session) {
    super();
    _classPrivateFieldInitSpec(this, _sessionId, void 0);
    _classPrivateFieldSet(_sessionId, this, session.id());
    this.setHeader('X-CobrowseDeviceToken', session.getHeader('X-CobrowseDeviceToken'));
  }
  url() {
    return new URL("api/1/sessions/".concat(_classPrivateFieldGet(_sessionId, this), "/ice"), IceServers.api).toString();
  }
}
exports["default"] = IceServers;

/***/ }),

/***/ 3646:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.createVideoConstraints = exports.createAudioConstraints = void 0;
__webpack_require__(3697);
var _events = _interopRequireDefault(__webpack_require__(6261));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * MediaSettings persists the video and audio configuration chosen by the user
 * and synchronises updates to settings.
 *
 * Configurable settings:
 * - Video Enabled
 * - Video Input Device ID (Camera)
 * - Audio Enabled
 * - Audio Input Device ID (Microphone)
 * - Audio Output Device ID (Speaker)
 */

const AUDIO_INPUT_KEYS = ['audioEnabled', 'audioInputDeviceId'];
const AUDIO_OUTPUT_KEYS = ['audioOutputDeviceId'];
const VIDEO_INPUT_KEYS = ['videoEnabled', 'videoInputDeviceId'];
const DEFAULT_SETTINGS = {
  videoEnabled: false,
  videoInputDeviceId: 'default',
  audioEnabled: false,
  audioInputDeviceId: 'default',
  audioOutputDeviceId: 'default'
};
const VIDEO_RESOLUTION = {
  width: {
    ideal: 1280
  },
  height: {
    ideal: 720
  }
};
const createAudioConstraints = _ref => {
  let {
    audioEnabled,
    audioInputDeviceId
  } = _ref;
  const deviceId = audioInputDeviceId || 'default';
  const deviceConstraint = deviceId === 'default' ? 'ideal' : 'exact';
  return {
    audio: audioEnabled ? {
      deviceId: {
        [deviceConstraint]: audioInputDeviceId
      }
    } : false
  };
};
exports.createAudioConstraints = createAudioConstraints;
const createVideoConstraints = _ref2 => {
  let {
    videoEnabled,
    videoInputDeviceId
  } = _ref2;
  const deviceId = videoInputDeviceId || 'default';
  const deviceConstraint = deviceId === 'default' ? 'ideal' : 'exact';
  return {
    video: videoEnabled ? _objectSpread(_objectSpread({}, VIDEO_RESOLUTION), {}, {
      deviceId: {
        [deviceConstraint]: videoInputDeviceId
      }
    }) : false
  };
};
exports.createVideoConstraints = createVideoConstraints;
var _settings = /*#__PURE__*/new WeakMap();
var _save = /*#__PURE__*/new WeakMap();
class MediaSettings extends _events.default {
  constructor(settings, save) {
    super();
    _classPrivateFieldInitSpec(this, _settings, null);
    _classPrivateFieldInitSpec(this, _save, void 0);
    _classPrivateFieldSet(_settings, this, _objectSpread(_objectSpread({}, DEFAULT_SETTINGS), settings));
    _classPrivateFieldSet(_save, this, save);
  }
  get settings() {
    return _objectSpread({}, _classPrivateFieldGet(_settings, this));
  }
  update(settings) {
    var _classPrivateFieldGet2;
    const changedSettings = [];
    for (const [key, value] of Object.entries(settings)) {
      if (value !== undefined && key in _classPrivateFieldGet(_settings, this)) {
        if (_classPrivateFieldGet(_settings, this)[key] !== value) {
          _classPrivateFieldGet(_settings, this)[key] = value;
          changedSettings.push(key);
        }
      }
    }
    if (changedSettings.length === 0) return;
    (_classPrivateFieldGet2 = _classPrivateFieldGet(_save, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this, _classPrivateFieldGet(_settings, this));
    if (changedSettings.some(key => VIDEO_INPUT_KEYS.includes(key))) {
      this.emit('videoInputSettings.updated', this.settings);
    }
    if (changedSettings.some(key => AUDIO_INPUT_KEYS.includes(key))) {
      this.emit('audioInputSettings.updated', this.settings);
    }
    if (changedSettings.some(key => AUDIO_OUTPUT_KEYS.includes(key))) {
      this.emit('audioOutputSettings.updated', this.settings);
    }
  }
  toggleAudio() {
    this.update({
      audioEnabled: !_classPrivateFieldGet(_settings, this).audioEnabled
    });
  }
  toggleVideo() {
    this.update({
      videoEnabled: !_classPrivateFieldGet(_settings, this).videoEnabled
    });
  }
}
exports["default"] = MediaSettings;

/***/ }),

/***/ 7688:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
__webpack_require__(3697);
var _events = __webpack_require__(6261);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const FFT_SIZE = 256;
var _audioContext = /*#__PURE__*/new WeakMap();
var _mediaStreamSource = /*#__PURE__*/new WeakMap();
var _analyser = /*#__PURE__*/new WeakMap();
var _hasNoise = /*#__PURE__*/new WeakMap();
var _requestAnimationFrameHandle = /*#__PURE__*/new WeakMap();
var _isDestroyed = /*#__PURE__*/new WeakMap();
class NoiseAnalyser extends _events.EventEmitter {
  constructor(stream, threshold) {
    super();
    _classPrivateFieldInitSpec(this, _audioContext, void 0);
    _classPrivateFieldInitSpec(this, _mediaStreamSource, void 0);
    _classPrivateFieldInitSpec(this, _analyser, void 0);
    _classPrivateFieldInitSpec(this, _hasNoise, void 0);
    _classPrivateFieldInitSpec(this, _requestAnimationFrameHandle, void 0);
    _classPrivateFieldInitSpec(this, _isDestroyed, false);
    if (!window.AudioContext) return;
    if (!stream || !stream.getAudioTracks().length) return;
    _classPrivateFieldSet(_audioContext, this, new window.AudioContext());
    _classPrivateFieldSet(_mediaStreamSource, this, _classPrivateFieldGet(_audioContext, this).createMediaStreamSource(stream));
    _classPrivateFieldSet(_analyser, this, _classPrivateFieldGet(_audioContext, this).createAnalyser());
    _classPrivateFieldGet(_analyser, this).fftSize = FFT_SIZE;
    _classPrivateFieldGet(_mediaStreamSource, this).connect(_classPrivateFieldGet(_analyser, this));
    const checkVolume = () => {
      if (_classPrivateFieldGet(_isDestroyed, this)) return;
      const frequencyData = new Uint8Array(_classPrivateFieldGet(_analyser, this).frequencyBinCount);
      _classPrivateFieldGet(_analyser, this).getByteFrequencyData(frequencyData);
      const total = frequencyData.reduce((a, b) => a + b, 0);
      const average = total / _classPrivateFieldGet(_analyser, this).frequencyBinCount;
      const hasNoise = average > threshold;
      if (_classPrivateFieldGet(_hasNoise, this) !== hasNoise) {
        _classPrivateFieldSet(_hasNoise, this, hasNoise);
        this.emit('noise.updated', hasNoise);
      }
      if (!_classPrivateFieldGet(_hasNoise, this)) {
        _classPrivateFieldSet(_requestAnimationFrameHandle, this, requestAnimationFrame(checkVolume));
        return;
      }
      setTimeout(() => {
        _classPrivateFieldSet(_requestAnimationFrameHandle, this, requestAnimationFrame(checkVolume));
      }, 250);
    };
    checkVolume();
  }
  get hasNoise() {
    return _classPrivateFieldGet(_hasNoise, this) || false;
  }
  destroy() {
    var _classPrivateFieldGet2, _classPrivateFieldGet3, _classPrivateFieldGet4;
    _classPrivateFieldSet(_isDestroyed, this, true);
    cancelAnimationFrame(_classPrivateFieldGet(_requestAnimationFrameHandle, this));
    (_classPrivateFieldGet2 = _classPrivateFieldGet(_mediaStreamSource, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.disconnect();
    _classPrivateFieldSet(_mediaStreamSource, this, null);
    (_classPrivateFieldGet3 = _classPrivateFieldGet(_analyser, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.disconnect();
    _classPrivateFieldSet(_analyser, this, null);
    (_classPrivateFieldGet4 = _classPrivateFieldGet(_audioContext, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.close();
    _classPrivateFieldSet(_audioContext, this, null);
  }
}
exports["default"] = NoiseAnalyser;

/***/ }),

/***/ 7354:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _events = __webpack_require__(6261);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Participant provides an abstraction over a Peer connection. It relies on its own
 * MediaStream and enforces a single track of a particular kind (e.g. video, audio).
 * This ensures that during the addition and removal of tracks from the Peer
 * connection we don't have to deal with stale or ended tracks.
 */
var _id = /*#__PURE__*/new WeakMap();
var _agent = /*#__PURE__*/new WeakMap();
var _isLocal = /*#__PURE__*/new WeakMap();
var _isConnected = /*#__PURE__*/new WeakMap();
var _stream = /*#__PURE__*/new WeakMap();
var _removeTracksByKind = /*#__PURE__*/new WeakMap();
class Participant extends _events.EventEmitter {
  constructor(_id2, agent) {
    let isLocal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    super();
    _classPrivateFieldInitSpec(this, _id, void 0);
    _classPrivateFieldInitSpec(this, _agent, void 0);
    _classPrivateFieldInitSpec(this, _isLocal, void 0);
    _classPrivateFieldInitSpec(this, _isConnected, void 0);
    _classPrivateFieldInitSpec(this, _stream, void 0);
    _defineProperty(this, "addTrack", track => {
      if (_classPrivateFieldGet(_stream, this).getTrackById(track.id)) return;
      _classPrivateFieldGet(_removeTracksByKind, this).call(this, track.kind);
      _classPrivateFieldGet(_stream, this).addTrack(track);
      this.emit('track.added');
    });
    _defineProperty(this, "removeTrackById", id => {
      const track = _classPrivateFieldGet(_stream, this).getTrackById(id);
      if (!track) return;
      track.stop();
      _classPrivateFieldGet(_stream, this).removeTrack(track);
      this.emit('track.removed');
    });
    _defineProperty(this, "removeTracksByKind", kind => {
      if (_classPrivateFieldGet(_removeTracksByKind, this).call(this, kind)) this.emit('track.removed');
    });
    _classPrivateFieldInitSpec(this, _removeTracksByKind, kind => {
      var _classPrivateFieldGet2;
      const tracksOfKind = ((_classPrivateFieldGet2 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.getTracks().filter(track => track.kind === kind)) || [];
      tracksOfKind.forEach(track => {
        track.stop();
        _classPrivateFieldGet(_stream, this).removeTrack(track);
      });
      return tracksOfKind.length > 0;
    });
    _defineProperty(this, "destroy", () => {
      var _classPrivateFieldGet3;
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.getTracks().forEach(track => {
        track.stop();
        _classPrivateFieldGet(_stream, this).removeTrack(track);
      });
      _classPrivateFieldSet(_stream, this, null);
    });
    _classPrivateFieldSet(_id, this, _id2);
    _classPrivateFieldSet(_agent, this, agent);
    _classPrivateFieldSet(_isLocal, this, isLocal);
    _classPrivateFieldSet(_isConnected, this, isLocal || false);
    _classPrivateFieldSet(_stream, this, new MediaStream());
  }
  get id() {
    return _classPrivateFieldGet(_id, this);
  }
  get isAgent() {
    return !!_classPrivateFieldGet(_agent, this);
  }
  get isLocal() {
    return _classPrivateFieldGet(_isLocal, this);
  }
  get isConnected() {
    return _classPrivateFieldGet(_isConnected, this);
  }
  set isConnected(value) {
    if (_classPrivateFieldGet(_isLocal, this)) return;
    _classPrivateFieldSet(_isConnected, this, value);
    this.emit('connection.changed', _classPrivateFieldGet(_isConnected, this));
  }
  get stream() {
    return _classPrivateFieldGet(_stream, this);
  }
  get hasAudio() {
    var _classPrivateFieldGet4;
    return ((_classPrivateFieldGet4 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.getAudioTracks().some(track => track.readyState === 'live')) || false;
  }
  get hasVideo() {
    var _classPrivateFieldGet5;
    return ((_classPrivateFieldGet5 = _classPrivateFieldGet(_stream, this)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.getVideoTracks().some(track => track.readyState === 'live')) || false;
  }
}
exports["default"] = Participant;

/***/ }),

/***/ 5836:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(2832);
__webpack_require__(4428);
__webpack_require__(3697);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _events = __webpack_require__(6261);
var _uuid = __webpack_require__(5392);
var _Signalling = __webpack_require__(7323);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * PeerManager only handles RTCPeerConnections.
 *
 * It's responsible for:
 * - Creating new RTCPeerConnections
 * - Negotiating connections (using SDP offers, SDP answers, ice candidates)
 * - Syncing a local stream to a remote RTCPeerConnection
 * - Syncing remote RTCPeerConnection tracks to a Participant
 *
 * PeerManager uses deterministic glare resolution to avoid offer conflicts by
 * consistently assigning polite / impolite roles based on sorted peer IDs.
 */

const debug = (0, _debug.default)('cbio.Calling.PeerManager');
var _signalling = /*#__PURE__*/new WeakMap();
var _iceServers = /*#__PURE__*/new WeakMap();
var _remotePeers = /*#__PURE__*/new WeakMap();
var _reconnectToPeerUsingOffer = /*#__PURE__*/new WeakMap();
var _onSDP = /*#__PURE__*/new WeakMap();
var _handleOffer = /*#__PURE__*/new WeakMap();
var _handleAnswer = /*#__PURE__*/new WeakMap();
var _onCandidate = /*#__PURE__*/new WeakMap();
class PeerManager extends _events.EventEmitter {
  constructor(signalling, iceServers) {
    super();
    _classPrivateFieldInitSpec(this, _signalling, void 0);
    _classPrivateFieldInitSpec(this, _iceServers, void 0);
    _classPrivateFieldInitSpec(this, _remotePeers, new Map());
    _defineProperty(this, "createPeer", async (localPeerId, remotePeerId, offer) => {
      debug('creating peer', remotePeerId);
      const localEndpoint = {
        clientId: localPeerId,
        connectionId: (0, _uuid.v4)()
      };
      const remoteEndpoint = {
        clientId: remotePeerId,
        connectionId: offer ? offer.from.connectionId : null
      };
      const peer = {
        connection: new RTCPeerConnection({
          iceServers: _classPrivateFieldGet(_iceServers, this)
        }),
        makingOffer: false,
        bePolite: [localPeerId, remotePeerId].sort()[0] === localPeerId,
        iceCandidateQueue: [],
        localEndpoint,
        remoteEndpoint
      };
      peer.connection.onnegotiationneeded = async () => {
        debug('negotiation needed for peer', remotePeerId);
        await this.connectToPeer(remotePeerId);
      };
      const onRemoveTrack = event => {
        debug('removing track with kind', event.track.kind, 'from peer', remotePeerId);
        this.emit('track.removed', event.track, remotePeerId);
      };
      peer.connection.ontrack = event => {
        debug('adding track with kind', event.track.kind, 'from peer', remotePeerId);
        const stream = event.streams[0];
        stream.removeEventListener('removetrack', onRemoveTrack);
        stream.addEventListener('removetrack', onRemoveTrack);
        this.emit('track.added', event.track, remotePeerId);
      };
      peer.connection.onicecandidate = event => {
        if (!event.candidate) return;
        _classPrivateFieldGet(_signalling, this).sendCandidate(localEndpoint, remoteEndpoint, event.candidate);
      };
      peer.connection.oniceconnectionstatechange = () => {
        if (peer.connection.iceConnectionState === 'failed') {
          debug('connection failed for peer', remotePeerId, 'restarting');
          peer.connection.restartIce();
        }
      };
      peer.connection.onconnectionstatechange = () => {
        if (peer.connection.connectionState === 'connected') {
          debug('connected to peer', remotePeerId);
          this.emit('peer.connected', remotePeerId);
        }
        if (peer.connection.connectionState === 'disconnected') {
          debug('disconnected from peer', remotePeerId);
          this.emit('peer.disconnected', remotePeerId);
        }
      };
      _classPrivateFieldGet(_remotePeers, this).set(remotePeerId, peer);
      if (offer) {
        debug('using last offer from peer', remotePeerId);
        await _classPrivateFieldGet(_handleOffer, this).call(this, offer.from, offer.to, offer.sdp);
      }
      this.emit('peer.created', remotePeerId);
    });
    _defineProperty(this, "connectToPeer", async remotePeerId => {
      debug('connecting to peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      try {
        peer.makingOffer = true;
        const offer = await peer.connection.createOffer();
        await peer.connection.setLocalDescription(offer);
        _classPrivateFieldGet(_signalling, this).sendSDP(localEndpoint, remoteEndpoint, peer.connection.localDescription);
      } finally {
        peer.makingOffer = false;
      }
    });
    _defineProperty(this, "disconnectFromPeer", remotePeerId => {
      debug('disconnecting from peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const senders = peer.connection.getSenders();
      senders.forEach(sender => peer.connection.removeTrack(sender));
      peer.connection.close();
      _classPrivateFieldGet(_remotePeers, this).delete(remotePeerId);
    });
    _defineProperty(this, "removeTracksByKindFromRemotePeer", (remotePeerId, kind) => {
      debug('removing tracks with kind', kind, 'from peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const senders = peer.connection.getSenders();
      senders.forEach(sender => {
        var _sender$track;
        if (((_sender$track = sender.track) === null || _sender$track === void 0 ? void 0 : _sender$track.kind) === kind) peer.connection.removeTrack(sender);
      });
    });
    _defineProperty(this, "addStreamToRemotePeer", (remotePeerId, stream) => {
      debug('adding stream to peer', remotePeerId);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(remotePeerId);
      if (!peer) return debug('unknown peer', remotePeerId);
      const senders = peer.connection.getSenders();
      stream.getTracks().forEach(track => {
        const trackExists = senders.some(sender => {
          var _sender$track2;
          return ((_sender$track2 = sender.track) === null || _sender$track2 === void 0 ? void 0 : _sender$track2.id) === track.id;
        });
        if (!trackExists) {
          debug('adding track with kind', track.kind, 'to peer', remotePeerId);
          peer.connection.addTrack(track, stream);
        }
      });
    });
    _classPrivateFieldInitSpec(this, _reconnectToPeerUsingOffer, async (from, to, sdp) => {
      debug('reconnecting to', from, 'using offer');
      this.disconnectFromPeer(from.clientId);
      await this.createPeer(to.clientId, from.clientId, {
        from,
        to,
        sdp
      });
    });
    _classPrivateFieldInitSpec(this, _onSDP, (from, to, sdp) => {
      if (sdp.type === 'offer') {
        // flush the cached offer since we are handling it
        _classPrivateFieldGet(_signalling, this).takeLastOffer(from.clientId);
        _classPrivateFieldGet(_handleOffer, this).call(this, from, to, sdp);
      }
      if (sdp.type === 'answer') _classPrivateFieldGet(_handleAnswer, this).call(this, from, to, sdp);
    });
    _classPrivateFieldInitSpec(this, _handleOffer, async (from, to, sdp) => {
      debug('receiving offer from', from);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(from.clientId);
      if (!peer) return debug('unknown peer', from.clientId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      if (localEndpoint.connectionId !== to.connectionId && to.connectionId) return debug('offer intended for different connection');
      if (!remoteEndpoint.connectionId) remoteEndpoint.connectionId = from.connectionId;
      if (remoteEndpoint.connectionId !== from.connectionId) {
        debug('offer from', from, 'has a different connection id');
        return await _classPrivateFieldGet(_reconnectToPeerUsingOffer, this).call(this, from, to, sdp);
      }
      const offerCollision = peer.makingOffer || peer.connection.signalingState !== 'stable';
      const ignoreOffer = !peer.bePolite && offerCollision;
      if (ignoreOffer) return debug('offer ignored as the impolite peer');
      await peer.connection.setRemoteDescription(sdp);
      const queuedIceCandidateCount = peer.iceCandidateQueue.length;
      if (queuedIceCandidateCount > 0) {
        debug('adding ice candidates from queue', queuedIceCandidateCount);
        await Promise.allSettled(peer.iceCandidateQueue.map(candidate => peer.connection.addIceCandidate(candidate)));
        peer.iceCandidateQueue.length = 0;
      }
      const answer = await peer.connection.createAnswer();
      await peer.connection.setLocalDescription(answer);
      _classPrivateFieldGet(_signalling, this).sendSDP(localEndpoint, remoteEndpoint, peer.connection.localDescription);
    });
    _classPrivateFieldInitSpec(this, _handleAnswer, async (from, to, sdp) => {
      debug('receiving answer from', from);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(from.clientId);
      if (!peer) return debug('unknown peer', from.clientId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      if (localEndpoint.connectionId !== to.connectionId) return debug('answer intended for different connection');
      if (!remoteEndpoint.connectionId) remoteEndpoint.connectionId = from.connectionId;
      if (remoteEndpoint.connectionId !== from.connectionId) return debug('answer from different connection ignored');
      await peer.connection.setRemoteDescription(sdp);
      const queuedIceCandidateCount = peer.iceCandidateQueue.length;
      if (queuedIceCandidateCount > 0) {
        debug('adding ice candidates from queue', queuedIceCandidateCount);
        await Promise.allSettled(peer.iceCandidateQueue.map(candidate => peer.connection.addIceCandidate(candidate)));
        peer.iceCandidateQueue.length = 0;
      }
    });
    _classPrivateFieldInitSpec(this, _onCandidate, async (from, to, candidate) => {
      debug('receiving ice candidate from', from);
      const peer = _classPrivateFieldGet(_remotePeers, this).get(from.clientId);
      if (!peer) return debug('unknown peer', from.clientId);
      const {
        localEndpoint,
        remoteEndpoint
      } = peer;
      if (localEndpoint.connectionId !== to.connectionId) return debug('ice candidate intended for different connection');
      if (remoteEndpoint.connectionId !== from.connectionId) return debug('ice candidate from different connection ignored');
      if (peer.connection.remoteDescription) {
        await peer.connection.addIceCandidate(candidate);
      } else {
        peer.iceCandidateQueue.push(candidate);
      }
    });
    _defineProperty(this, "destroy", () => {
      _classPrivateFieldGet(_signalling, this).off(_Signalling.SIGNAL.CANDIDATE, _classPrivateFieldGet(_onCandidate, this));
      _classPrivateFieldGet(_signalling, this).off(_Signalling.SIGNAL.SDP, _classPrivateFieldGet(_onSDP, this));
      _classPrivateFieldGet(_remotePeers, this).forEach((_, remotePeerId) => this.disconnectFromPeer(remotePeerId));
      _classPrivateFieldGet(_remotePeers, this).clear();
    });
    _classPrivateFieldSet(_signalling, this, signalling);
    _classPrivateFieldSet(_iceServers, this, iceServers);
    _classPrivateFieldGet(_signalling, this).on(_Signalling.SIGNAL.SDP, _classPrivateFieldGet(_onSDP, this));
    _classPrivateFieldGet(_signalling, this).on(_Signalling.SIGNAL.CANDIDATE, _classPrivateFieldGet(_onCandidate, this));
  }
  get remotePeerIds() {
    return [..._classPrivateFieldGet(_remotePeers, this).keys()];
  }
}
exports["default"] = PeerManager;

/***/ }),

/***/ 7323:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.SIGNAL = void 0;
__webpack_require__(3697);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _events = __webpack_require__(6261);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Signalling provides an abstraction over a CBORSocket which
 * handles sending and receiving SDP events and ice candidates,
 * and ensures that incoming events are filtered based on the
 * intended peer.
 *
 * These events are used during the negotiation process
 * of an RTCPeerConnection:
 * - sdp (with a type of either offer or answer)
 * - icecandidate
 *
 * Signalling has a lifecycle close to that of the CBORSocket that
 * it abstracts. This means that offers could be processed by Signalling
 * before the CallSession has instantiated. To mitigate this, Signalling
 * keeps the last offer from each peer in a cache in case it is missed.
 */

const debug = (0, _debug.default)('cbio.Calling.Signalling');
const SIGNAL = exports.SIGNAL = {
  SDP: 'sdp',
  CANDIDATE: 'icecandidate'
};
var _socket = /*#__PURE__*/new WeakMap();
var _shouldProcessSignal = /*#__PURE__*/new WeakMap();
var _lastOfferCache = /*#__PURE__*/new WeakMap();
var _onEvent = /*#__PURE__*/new WeakMap();
var _handleSDP = /*#__PURE__*/new WeakMap();
var _handleCandidate = /*#__PURE__*/new WeakMap();
class Signalling extends _events.EventEmitter {
  constructor(socket, shouldProcessSignal) {
    super();
    _classPrivateFieldInitSpec(this, _socket, void 0);
    _classPrivateFieldInitSpec(this, _shouldProcessSignal, void 0);
    _classPrivateFieldInitSpec(this, _lastOfferCache, new Map());
    _defineProperty(this, "sendSDP", (from, to, sdp) => {
      debug('sending sdp with type', sdp.type, 'to', to);
      _classPrivateFieldGet(_socket, this).send(SIGNAL.SDP, {
        from,
        to,
        sdp: JSON.stringify(sdp)
      });
    });
    _defineProperty(this, "sendCandidate", (from, to, candidate) => {
      debug('sending ice candidate', 'to', to);
      _classPrivateFieldGet(_socket, this).send(SIGNAL.CANDIDATE, {
        from,
        to,
        candidate: JSON.stringify(candidate)
      });
    });
    _defineProperty(this, "takeLastOffer", clientId => {
      const lastOffer = _classPrivateFieldGet(_lastOfferCache, this).get(clientId);
      _classPrivateFieldGet(_lastOfferCache, this).delete(clientId);
      return lastOffer;
    });
    _defineProperty(this, "flushLastOfferCache", () => {
      _classPrivateFieldGet(_lastOfferCache, this).clear();
    });
    _classPrivateFieldInitSpec(this, _onEvent, (event, data) => {
      if (event === SIGNAL.SDP) _classPrivateFieldGet(_handleSDP, this).call(this, data);
      if (event === SIGNAL.CANDIDATE) _classPrivateFieldGet(_handleCandidate, this).call(this, data);
    });
    _classPrivateFieldInitSpec(this, _handleSDP, _ref => {
      let {
        from,
        to,
        sdp
      } = _ref;
      if (!_classPrivateFieldGet(_shouldProcessSignal, this).call(this, to)) return;
      const sdpObject = JSON.parse(sdp);
      debug('receiving sdp with type', sdpObject.type, 'from', from);
      if (sdpObject.type === 'offer') _classPrivateFieldGet(_lastOfferCache, this).set(from.clientId, {
        from,
        to,
        sdp: sdpObject
      });
      this.emit(SIGNAL.SDP, from, to, sdpObject);
    });
    _classPrivateFieldInitSpec(this, _handleCandidate, _ref2 => {
      let {
        from,
        to,
        candidate
      } = _ref2;
      if (!_classPrivateFieldGet(_shouldProcessSignal, this).call(this, to)) return;
      debug('receiving ice candidate', 'from', from);
      this.emit(SIGNAL.CANDIDATE, from, to, JSON.parse(candidate));
    });
    _defineProperty(this, "destroy", () => {
      _classPrivateFieldGet(_socket, this).off('event', _classPrivateFieldGet(_onEvent, this));
      this.flushLastOfferCache();
    });
    _classPrivateFieldSet(_socket, this, socket);
    _classPrivateFieldSet(_shouldProcessSignal, this, shouldProcessSignal);
    _classPrivateFieldGet(_socket, this).on('event', _classPrivateFieldGet(_onEvent, this));
  }
}
exports["default"] = Signalling;

/***/ }),

/***/ 4719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "CallHandler", ({
  enumerable: true,
  get: function () {
    return _CallHandler.default;
  }
}));
var _CallHandler = _interopRequireDefault(__webpack_require__(2863));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 1789:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.RegistrationPath = exports.DeviceIdPath = void 0;
__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(9377);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _uuid = __webpack_require__(5392);
var _rest = __webpack_require__(492);
var _cocom = __webpack_require__(3439);
var _storage = _interopRequireDefault(__webpack_require__(6542));
var _makeSocketUrl = _interopRequireDefault(__webpack_require__(6851));
var _RateLimiter = _interopRequireDefault(__webpack_require__(8781));
var _SessionCapabilityTypes = __webpack_require__(7089);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.Device');
const DeviceIdPath = exports.DeviceIdPath = '_cobrowse_device_id';
const RegistrationPath = exports.RegistrationPath = '_cobrowse_device_registration';
var _socket = /*#__PURE__*/new WeakMap();
var _rateLimiter = /*#__PURE__*/new WeakMap();
var _registrationTimeout = /*#__PURE__*/new WeakMap();
var _registrationLoaded = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _storageKey = /*#__PURE__*/new WeakMap();
var _loop = /*#__PURE__*/new WeakMap();
var _socketUrl = /*#__PURE__*/new WeakMap();
var _socketProtocols = /*#__PURE__*/new WeakMap();
var _openNotificationSocket = /*#__PURE__*/new WeakMap();
var _closeNotificationSocket = /*#__PURE__*/new WeakMap();
var _updateNotificationSocket = /*#__PURE__*/new WeakMap();
class Device extends _rest.RESTResource {
  constructor(delegate) {
    var _this;
    super();
    _this = this;
    _classPrivateFieldInitSpec(this, _socket, void 0);
    _classPrivateFieldInitSpec(this, _rateLimiter, void 0);
    _classPrivateFieldInitSpec(this, _registrationTimeout, void 0);
    _classPrivateFieldInitSpec(this, _registrationLoaded, false);
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _defineProperty(this, "url", () => {
      return new URL("api/1/devices/".concat(this.id()), Device.api).toString();
    });
    _defineProperty(this, "reset", function () {
      let preserveRegistration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      debug('resetting device');

      // prevent the registration loop triggering
      clearTimeout(_classPrivateFieldGet(_registrationTimeout, _this));
      _classPrivateFieldSet(_registrationTimeout, _this, null);
      // wipe any pending custom data changes unless
      // it's requested that these should be retained
      if (!preserveRegistration) {
        // clear the saved registration information
        (0, _storage.default)().removeItem(RegistrationPath);
      }
      // stop the socket updates
      if (_classPrivateFieldGet(_socket, _this)) {
        _classPrivateFieldGet(_socket, _this).close();
        _classPrivateFieldSet(_socket, _this, null);
      }
    });
    _defineProperty(this, "destroy", async () => {
      debug('destroying device');

      // reset all the state, including wiping any locally stored custom data
      this.reset();
      // destroy the server record too
      return super.destroy();
    });
    _defineProperty(this, "hasPendingUpdates", () => {
      const existing = this.field('custom_data') || {};
      const modifications = _classPrivateFieldGet(_delegate, this).customData || {};
      const changed = Object.keys(modifications).find(key => existing[key] !== modifications[key]);
      return !!changed;
    });
    _classPrivateFieldInitSpec(this, _storageKey, () => {
      if (!_classPrivateFieldGet(_delegate, this).license) throw new Error('License required to generate storage key');
      return "".concat(_classPrivateFieldGet(_delegate, this).license, ":").concat(Device.api);
    });
    _defineProperty(this, "_saveRegistration", () => {
      const nextUpdateIn = this.field('next_registration') || 60 * 60;
      const time = new Date().getTime();
      // sanity checking date return values
      // believe it or not, some people override these things to return weird values
      if (typeof Date.now() !== 'number') console.error("Unexpected type returned for Date.now(), expecting number got ".concat(typeof Date.now()));
      if (typeof time !== 'number') console.error("Unexpected type for getTime() of Date, expecting number got ".concat(typeof time));
      const reg = {
        notification_url: this.field('notification_url'),
        notification_token: this.field('notification_token'),
        custom_data: this.field('custom_data'),
        next_registration_time: time + nextUpdateIn * 1000
      };
      // next registration time isn't a field the server sends, it's generated
      // as part of the local resource only, so need to update it manually
      this.cache({
        next_registration_time: reg.next_registration_time
      });
      (0, _storage.default)(_classPrivateFieldGet(_storageKey, this).call(this)).setItem(RegistrationPath, reg);
      return this;
    });
    _defineProperty(this, "_loadRegistration", () => {
      if (_classPrivateFieldGet(_registrationLoaded, this)) return;
      _classPrivateFieldSet(_registrationLoaded, this, true);
      const storedRegistration = (0, _storage.default)(_classPrivateFieldGet(_storageKey, this).call(this)).getItem(RegistrationPath);
      // restore the last known url and token so we can try to
      // connect a socket before a re-registration isn't due yet
      if (storedRegistration) {
        debug('restoring registration', storedRegistration);
        this.cache(storedRegistration);
      }
    });
    _defineProperty(this, "updateRegistration", async query => {
      if (_classPrivateFieldGet(_rateLimiter, this).limit()) throw new Error('Cobrowse update rate limit exceeded. Maybe you\'re updating custom data too often?');
      debug('updating registration');
      await this.update({
        device: Device.info,
        custom_data: _classPrivateFieldGet(_delegate, this).customData
      }, query);
      _classPrivateFieldGet(_updateNotificationSocket, this).call(this);
      this._saveRegistration();
      this.emit('register');
      return this;
    });
    _defineProperty(this, "runRegistrationLoop", async () => {
      debug('starting registrations');

      // on the first load we need to load some state into the
      // device resource from local storage
      this._loadRegistration();

      // disconnect any active socket and stop any registration
      // loop that might still be running, but leave in place any
      // existing saved registration data, or pending custom data
      this.reset(true);

      // pending updates to custom data can short circuit the
      // registration loop to force an immediate (re)registration
      // but only on the first registration attempt after a page load
      if (this.hasPendingUpdates() || this.nextRegistration() <= 0) {
        await this.updateRegistration().catch(() => {});
      }

      // ensure any tokens we have stored have been used to try and reconnect
      // the sockets immediately. This will also be done on a sucessful registration
      _classPrivateFieldGet(_updateNotificationSocket, this).call(this);

      // kick off the background loop
      _classPrivateFieldGet(_loop, this).call(this);
    });
    _defineProperty(this, "pauseRegistrationLoop", async () => {
      debug('pausing registrations');

      // stop the loop and disconnect the socket but keep the
      // registration data in case the loop is restarted later on
      this.reset(true);
    });
    _defineProperty(this, "nextRegistration", () => {
      // We cache registrations to storage, so we can re-load the last registration,
      // if there has been one. If it was recent, we don't need to re-register.
      // We also store the last known notification url and token so we can attempt
      // to connect the socket immeditately
      const nextRegistrationDue = this.field('next_registration_time');
      return (nextRegistrationDue || 0) - new Date().getTime();
    });
    _defineProperty(this, "clone", () => {
      const copy = new Device(_classPrivateFieldGet(_delegate, this));
      super.clone(copy);
      return copy;
    });
    _defineProperty(this, "_nextUpdate", function () {
      let attemptNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // apply backoff
      return Math.max(Math.min(60 * 1000 * attemptNumber, 60 * 60 * 1000), _this.nextRegistration());
    });
    _classPrivateFieldInitSpec(this, _loop, function () {
      let attemptNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // prevent multiple loops running in parallel
      if (_classPrivateFieldGet(_registrationTimeout, _this)) {
        console.error('CobrowseIO: tried to schedule registration while already scheduled');
        return;
      }

      // set up the registration loop timeout, with a bacoff based on
      // number of unsuccesful attempts since the last registration
      const timeout = _this._nextUpdate(attemptNumber);
      _classPrivateFieldSet(_registrationTimeout, _this, setTimeout(async () => {
        if (!_classPrivateFieldGet(_registrationTimeout, _this)) return console.error('Registration loop cancelled');
        try {
          await _this.updateRegistration();
          _classPrivateFieldSet(_registrationTimeout, _this, false);
          return _classPrivateFieldGet(_loop, _this).call(_this);
        } catch (e) {
          console.warn('CobrowseIO: registration failed', e);
          _classPrivateFieldSet(_registrationTimeout, _this, false);
          return _classPrivateFieldGet(_loop, _this).call(_this, attemptNumber + 1);
        }
      }, Math.max(1000, timeout)));
    });
    _classPrivateFieldInitSpec(this, _socketUrl, () => {
      const url = this.field('notification_url');
      return (0, _makeSocketUrl.default)(url);
    });
    _classPrivateFieldInitSpec(this, _socketProtocols, () => {
      const token = this.field('notification_token');
      return ["cbio.http.headers.authorization.bearer.".concat(window.btoa(token).replaceAll('=', ''))];
    });
    _classPrivateFieldInitSpec(this, _openNotificationSocket, () => {
      if (_classPrivateFieldGet(_socket, this)) return;
      _classPrivateFieldSet(_socket, this, new _cocom.CBORSocket({
        getUrl: _classPrivateFieldGet(_socketUrl, this),
        getProtocols: _classPrivateFieldGet(_socketProtocols, this)
      }));
      _classPrivateFieldGet(_socket, this).setMaxReconnectDelay(60 * 1000);
      _classPrivateFieldGet(_socket, this).on('error', err => {
        if (err) console.warn('CobrowseIO notification socket error:', err);
      });
      _classPrivateFieldGet(_socket, this).on('event', (event, data) => {
        if (event === 'notification') this.emit('notification', data);else if (event === 'probe') _classPrivateFieldGet(_socket, this).send('alive', data);
      });
      _classPrivateFieldGet(_socket, this).on('open', () => {
        _classPrivateFieldGet(_socket, this).send('filter', {
          events: ['probe', 'notification']
        });
      });
    });
    _classPrivateFieldInitSpec(this, _closeNotificationSocket, () => {
      if (_classPrivateFieldGet(_socket, this)) {
        console.log('CobrowseIO: Closing socket');
        _classPrivateFieldGet(_socket, this).close();
        _classPrivateFieldSet(_socket, this, null);
      }
    });
    _classPrivateFieldInitSpec(this, _updateNotificationSocket, () => {
      const url = this.field('notification_url');
      const token = this.field('notification_token');
      if (url && token) _classPrivateFieldGet(_openNotificationSocket, this).call(this);else _classPrivateFieldGet(_closeNotificationSocket, this).call(this);
    });
    debug('constructed');
    if (!delegate) throw new Error('Device delegate is required');
    _classPrivateFieldSet(_delegate, this, delegate);

    // allow 10 requests per 2 minutes
    _classPrivateFieldSet(_rateLimiter, this, new _RateLimiter.default(10, 2 * 60 * 1000));
  }
  id() {
    return Device.deviceId();
  }
  get customData() {
    return this.field('custom_data') || {};
  }
  static deviceCredentials() {
    let credentials = (0, _storage.default)().getItem(DeviceIdPath) || {};
    // previously we just stored the id as a string, so migrate that
    if (typeof credentials === 'string') credentials = {
      id: credentials
    };
    if (typeof credentials !== 'object') credentials = {};
    if (!credentials.id) credentials.id = (0, _uuid.v4)();
    if (!credentials.token) credentials.token = (0, _uuid.v4)();
    (0, _storage.default)().setItem(DeviceIdPath, credentials);
    return credentials;
  }
  static deviceId() {
    return this.deviceCredentials().id;
  }
  static deviceToken() {
    return this.deviceCredentials().token;
  }
  static get info() {
    if (false) {}
    const capabilities = [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SCROLL, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SELECT, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DRAWING, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_ARROWS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_RECTANGLES, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_LASER, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_CURSOR, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_UNIVERSAL, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_HIGHLIGHT, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_CALLING];
    if (!/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(window.navigator.userAgent)) {
      capabilities.push(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_FULL_DEVICE);
    }
    return {
      platform: 'web',
      device: window.navigator.userAgent,
      device_locale: window.navigator.language,
      device_timezone: window.Intl.DateTimeFormat().resolvedOptions().timeZone,
      os_version: window.navigator.platform,
      app_id: window.location.origin,
      app_name: window.document.title,
      app_build_configuration: 'release',
      // eslint-disable-next-line
      sdk_version: '3.13.0',
      capabilities
    };
  }
}
exports["default"] = Device;

/***/ }),

/***/ 1667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Device", ({
  enumerable: true,
  get: function () {
    return _Device.default;
  }
}));
var _Device = _interopRequireDefault(__webpack_require__(1789));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 1260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _events = _interopRequireDefault(__webpack_require__(6261));
var _parseWindowFeatures = __webpack_require__(8567);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _target = /*#__PURE__*/new WeakMap();
var _url = /*#__PURE__*/new WeakMap();
var _element = /*#__PURE__*/new WeakMap();
var _type = /*#__PURE__*/new WeakMap();
var _icon = /*#__PURE__*/new WeakMap();
var _title = /*#__PURE__*/new WeakMap();
var _isLoading = /*#__PURE__*/new WeakMap();
var _isBlocked = /*#__PURE__*/new WeakMap();
var _isClosed = /*#__PURE__*/new WeakMap();
class Document extends _events.default {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _classPrivateFieldInitSpec(this, _target, void 0);
    _classPrivateFieldInitSpec(this, _url, void 0);
    _classPrivateFieldInitSpec(this, _element, void 0);
    _classPrivateFieldInitSpec(this, _type, void 0);
    _classPrivateFieldInitSpec(this, _icon, void 0);
    _classPrivateFieldInitSpec(this, _title, void 0);
    _classPrivateFieldInitSpec(this, _isLoading, void 0);
    _classPrivateFieldInitSpec(this, _isBlocked, void 0);
    _classPrivateFieldInitSpec(this, _isClosed, false);
    _defineProperty(this, "load", function (url, target, windowFeatures) {
      let {
        element,
        type
      } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      _classPrivateFieldSet(_url, _this, url);
      const features = (0, _parseWindowFeatures.parseWindowFeatures)(windowFeatures);
      _classPrivateFieldSet(_target, _this, features.popup ? '_blank' : target);
      _classPrivateFieldSet(_element, _this, element);
      _classPrivateFieldSet(_type, _this, type);
      _classPrivateFieldSet(_icon, _this, '');
      _classPrivateFieldSet(_title, _this, '');
      _classPrivateFieldSet(_isLoading, _this, true);
      _classPrivateFieldSet(_isBlocked, _this, false);
      _this.emit('updated', _this);
    });
    _defineProperty(this, "close", () => {
      if (_classPrivateFieldGet(_isClosed, this)) return;
      _classPrivateFieldSet(_isClosed, this, true);
      this.emit('closed', this);
    });
    _defineProperty(this, "serialize", () => ({
      url: this.url,
      icon: this.icon,
      title: this.title,
      isLoading: this.isLoading,
      isBlocked: this.isBlocked,
      isClosed: this.isClosed
    }));
  }
  get target() {
    return _classPrivateFieldGet(_target, this);
  }
  get url() {
    return _classPrivateFieldGet(_url, this);
  }
  set url(state) {
    if (this.url === state) return;
    _classPrivateFieldSet(_url, this, state);
    this.emit('updated', this);
  }
  get element() {
    return _classPrivateFieldGet(_element, this);
  }
  get type() {
    return _classPrivateFieldGet(_type, this);
  }
  get icon() {
    return _classPrivateFieldGet(_icon, this);
  }
  set icon(state) {
    if (_classPrivateFieldGet(_icon, this) === state) return;
    _classPrivateFieldSet(_icon, this, state);
    this.emit('updated', this);
  }
  get title() {
    return _classPrivateFieldGet(_title, this);
  }
  set title(state) {
    if (_classPrivateFieldGet(_title, this) === state) return;
    _classPrivateFieldSet(_title, this, state);
    this.emit('updated', this);
  }
  get isLoading() {
    return _classPrivateFieldGet(_isLoading, this);
  }
  set isLoading(state) {
    if (_classPrivateFieldGet(_isLoading, this) === state) return;
    _classPrivateFieldSet(_isLoading, this, state);
    this.emit('updated', this);
  }
  get isBlocked() {
    return _classPrivateFieldGet(_isBlocked, this);
  }
  set isBlocked(state) {
    if (_classPrivateFieldGet(_isBlocked, this) === state) return;
    _classPrivateFieldSet(_isBlocked, this, state);
    this.emit('updated', this);
  }
  get isClosed() {
    return _classPrivateFieldGet(_isClosed, this);
  }
  get windowProxy() {
    const instance = this;
    return {
      close: () => this.close(),
      get closed() {
        return _classPrivateFieldGet(_isClosed, instance);
      }
    };
  }
}
exports["default"] = Document;

/***/ }),

/***/ 8756:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _uuid = __webpack_require__(5392);
var _iframes = _interopRequireDefault(__webpack_require__(7966));
var _Document = _interopRequireDefault(__webpack_require__(1260));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _handleDocumentMap = /*#__PURE__*/new WeakMap();
var _documentHandleMap = /*#__PURE__*/new WeakMap();
var _nameHandleMap = /*#__PURE__*/new WeakMap();
var _handleNameMap = /*#__PURE__*/new WeakMap();
var _onDocumentAdded = /*#__PURE__*/new WeakMap();
var _onDocument = /*#__PURE__*/new WeakMap();
var _removeDocument = /*#__PURE__*/new WeakMap();
var _trackDocument = /*#__PURE__*/new WeakMap();
class DocumentCollection {
  constructor(_ref) {
    let {
      onDocumentAdded
    } = _ref;
    _classPrivateFieldInitSpec(this, _handleDocumentMap, new Map());
    _classPrivateFieldInitSpec(this, _documentHandleMap, new Map());
    _classPrivateFieldInitSpec(this, _nameHandleMap, new Map());
    _classPrivateFieldInitSpec(this, _handleNameMap, new Map());
    _classPrivateFieldInitSpec(this, _onDocumentAdded, void 0);
    _classPrivateFieldInitSpec(this, _onDocument, (_ref2, _ref3) => {
      let {
        handle,
        document
      } = _ref2;
      let {
        trusted
      } = _ref3;
      if (!trusted) return;
      const existingDocument = this.getDocumentByHandle(handle);
      if (!existingDocument) return;
      if (!existingDocument.isClosed && document.isClosed) {
        existingDocument.close(true);
      }
    });
    _classPrivateFieldInitSpec(this, _removeDocument, document => {
      const handle = _classPrivateFieldGet(_documentHandleMap, this).get(document);
      _classPrivateFieldGet(_handleDocumentMap, this).delete(handle);
      _classPrivateFieldGet(_documentHandleMap, this).delete(document);
      const name = _classPrivateFieldGet(_handleNameMap, this).get(handle);
      _classPrivateFieldGet(_handleNameMap, this).delete(handle);
      if (name) _classPrivateFieldGet(_nameHandleMap, this).delete(name);
    });
    _classPrivateFieldInitSpec(this, _trackDocument, (handle, document) => {
      const onDocumentUpdated = () => {
        const payload = {
          handle,
          document: document.serialize()
        };
        if (document.element) {
          _iframes.default.broadcastToChildren('document', payload);
        } else {
          _iframes.default.sendToParent('document', payload);
        }
      };
      document.on('updated', onDocumentUpdated);
      onDocumentUpdated();
      document.once('closed', () => {
        document.off('updated', onDocumentUpdated);
        onDocumentUpdated();
        _classPrivateFieldGet(_removeDocument, this).call(this, document);
      });
    });
    _defineProperty(this, "addDocument", (handle, name, document) => {
      var _classPrivateFieldGet2;
      if (_classPrivateFieldGet(_handleDocumentMap, this).has(handle)) return;
      if (document.isClosed) return;
      _classPrivateFieldGet(_handleDocumentMap, this).set(handle, document);
      _classPrivateFieldGet(_documentHandleMap, this).set(document, handle);
      if (name) {
        _classPrivateFieldGet(_nameHandleMap, this).set(name, handle);
        _classPrivateFieldGet(_handleNameMap, this).set(handle, name);
      }
      _classPrivateFieldGet(_trackDocument, this).call(this, handle, document);
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_onDocumentAdded, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this, document);
    });
    _defineProperty(this, "closeAllDocuments", () => {
      for (const [, document] of _classPrivateFieldGet(_handleDocumentMap, this)) {
        document.close();
        _classPrivateFieldGet(_removeDocument, this).call(this, document);
      }
    });
    _defineProperty(this, "getDocumentByHandle", handle => _classPrivateFieldGet(_handleDocumentMap, this).get(handle));
    _defineProperty(this, "resolveDocumentHandle", name => {
      const existingHandle = _classPrivateFieldGet(_nameHandleMap, this).get(name);
      if (existingHandle) return existingHandle;
      return (0, _uuid.v4)();
    });
    _defineProperty(this, "resolveDocument", (handle, name) => {
      const resolvedHandle = handle || this.resolveDocumentHandle(name);
      const resolvedDocument = this.getDocumentByHandle(resolvedHandle);
      return {
        handle: resolvedHandle,
        document: resolvedDocument || new _Document.default()
      };
    });
    _defineProperty(this, "destroy", () => {
      _iframes.default.off('document', _classPrivateFieldGet(_onDocument, this));
    });
    _classPrivateFieldSet(_onDocumentAdded, this, onDocumentAdded);
    _iframes.default.on('document', _classPrivateFieldGet(_onDocument, this));
  }
}
exports["default"] = DocumentCollection;

/***/ }),

/***/ 9689:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Document", ({
  enumerable: true,
  get: function () {
    return _Document.default;
  }
}));
Object.defineProperty(exports, "DocumentCollection", ({
  enumerable: true,
  get: function () {
    return _DocumentCollection.default;
  }
}));
var _Document = _interopRequireDefault(__webpack_require__(1260));
var _DocumentCollection = _interopRequireDefault(__webpack_require__(8756));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 8374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _src = __webpack_require__(9501);
var _activity = __webpack_require__(5264);
var _WindowTaps = _interopRequireDefault(__webpack_require__(4153));
var _unpolyfill = __webpack_require__(9883);
var _navigation = __webpack_require__(9715);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class MutatingEventObserver {
  constructor(onModification) {
    var _this = this;
    _defineProperty(this, "_init", () => {
      if (!this._propertyWatcher) {
        this._propertyWatcher = new _src.PropertyObserver(this._onPropertySet);
        _WindowTaps.default.on('stylechange', this._onStyleSheetChange);
        _WindowTaps.default.on('navigate', this._onNavigation);
        _WindowTaps.default.on('canvaschange', this._onCanvasChange);
      }
    });
    _defineProperty(this, "observe", root => {
      if (this._observing.has(root)) return;

      // some handlers only get attached once globally after the first observe()
      this._init();

      // lightning components will not bubble events, when they happen on the fake shadow root
      const {
        value: addEventListener = root.addEventListener
      } = Object.getOwnPropertyDescriptor(_unpolyfill.EventTarget.prototype, 'addEventListener');
      addEventListener.call(root, 'scroll', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'focus', this._onFocusChange, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'blur', this._onFocusChange, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'change', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'keydown', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'keyup', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'keypress', this._onInputEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'selectionchange', this._onSelectionEvent, {
        capture: true,
        passive: true
      });

      // input and textarea elements selection behaves different than regular text selection
      // so we subscribe to the selection event as well to handle these scenarios
      addEventListener.call(root, 'select', this._onSelectionEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mouseenter', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mouseleave', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mousedown', this._onEvent, {
        capture: true,
        passive: true
      });
      addEventListener.call(root, 'mouseup', this._onEvent, {
        capture: true,
        passive: true
      });
      _activity.MouseTracking.track(root);
      _activity.InteractionTracking.track(root);
      _navigation.NavigationTracking.track(root);
      this._observing.add(root);
      const window = (root.ownerDocument || root).defaultView;
      if (window && !this._windows.has(window)) {
        this._windows.add(window);
        _WindowTaps.default.tap(window);
        _navigation.NavigationTracking.tap(window);
        this._propertyWatcher.observe(window.HTMLInputElement, 'value');
        this._propertyWatcher.observe(window.HTMLInputElement, 'checked');
        this._propertyWatcher.observe(window.HTMLTextAreaElement, 'value');
        this._propertyWatcher.observe(window.ShadowRoot, 'adoptedStyleSheets');
        this._propertyWatcher.observe(window.Document, 'adoptedStyleSheets');
        if (window.addEventListener) {
          window.addEventListener('hashchange', this._onEvent, {
            capture: true,
            passive: true
          });
          window.addEventListener('resize', this._onEvent, {
            capture: true,
            passive: true
          });
        }
      }
    });
    _defineProperty(this, "disconnect", () => {
      this._observing.forEach(root => {
        const {
          value: removeEventListener = root.removeEventListener
        } = Object.getOwnPropertyDescriptor(_unpolyfill.EventTarget.prototype, 'removeEventListener');
        removeEventListener.call(root, 'scroll', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'focus', this._onFocusChange, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'blur', this._onFocusChange, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'change', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'keydown', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'keyup', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'keypress', this._onInputEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'selectionchange', this._onSelectionEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'select', this._onSelectionEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mouseenter', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mouseleave', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mousedown', this._onEvent, {
          capture: true,
          passive: true
        });
        removeEventListener.call(root, 'mouseup', this._onEvent, {
          capture: true,
          passive: true
        });
        _activity.MouseTracking.untrack(root);
        _activity.InteractionTracking.untrack(root);
        _navigation.NavigationTracking.untrack(root);
      });
      this._observing.clear();
      this._windows.forEach(window => {
        _WindowTaps.default.untap(window);
        _navigation.NavigationTracking.untap(window);
        if (window && !(0, _src.isxdoc)(window) && window.removeEventListener) {
          window.removeEventListener('hashchange', this._onEvent, {
            capture: true,
            passive: true
          });
          window.removeEventListener('resize', this._onEvent, {
            capture: true,
            passive: true
          });
        }
      });
      this._windows.clear();
      if (this._propertyWatcher) {
        this._propertyWatcher.disconnect();
        this._propertyWatcher = null;
        _WindowTaps.default.off('stylechange', this._onStyleSheetChange);
        _WindowTaps.default.off('navigate', this._onNavigation);
        _WindowTaps.default.off('canvaschange', this._onCanvasChange);
      }
    });
    // Salesforce Lightning overwrites the Event target getter so we need to use the unpollyfilled version
    _defineProperty(this, "_getActualTarget", e => {
      const {
        get: target
      } = Object.getOwnPropertyDescriptor(_unpolyfill.Event.prototype, 'target');
      return target.apply(e);
    });
    _defineProperty(this, "_target", e => {
      const eventTarget = this._getActualTarget(e);
      return eventTarget && eventTarget.document || eventTarget;
    });
    _defineProperty(this, "_onEvent", function (e) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _this._onModification(_this._target(e), _objectSpread(_objectSpread({}, options), {}, {
        type: e.type
      }));
    });
    _defineProperty(this, "_onSelectionEvent", e => {
      var _eventTarget$ownerDoc;
      const eventTarget = this._getActualTarget(e);
      const parentDoc = (_eventTarget$ownerDoc = eventTarget.ownerDocument) !== null && _eventTarget$ownerDoc !== void 0 ? _eventTarget$ownerDoc : eventTarget;

      // if there's been an agent selection less than 100ms ago then we skip the event to prevent text
      // selection loops
      if (parentDoc.__last_agent_selection_ts > Date.now() - 100) return;

      // When a user unselects text within an input/textarea elements we only get a `selectionchange`
      // event on the document level which doesn't contain enough information to understand which input
      // has had text unselected.
      // As such, when we receive an event of type `selectionchange`, we check if the focused element
      // is of type input/textarea and if so serialize that element selection as well
      // and input/textarea
      if (e.type === 'selectionchange') {
        var _parentDoc$activeElem;
        if (['INPUT', 'TEXTAREA'].includes((_parentDoc$activeElem = parentDoc.activeElement) === null || _parentDoc$activeElem === void 0 ? void 0 : _parentDoc$activeElem.tagName)) {
          parentDoc.activeElement.__cobrowse_user_selection_timestamp = Date.now();
          this._onModification(parentDoc.activeElement, {
            type: e.type
          });
        } else {
          eventTarget.__cobrowse_user_selection_timestamp = Date.now();
          this._onModification(eventTarget, {
            type: e.type
          });
        }
      }
      if (e.type === 'select') {
        eventTarget.__cobrowse_user_selection_timestamp = Date.now();
        this._onModification(eventTarget, {
          type: e.type
        });
      }
    });
    _defineProperty(this, "_onStyleSheetChange", sheet => {
      // for <style> tags, we can trigger a modification on the ownerNode
      if (sheet.ownerNode) this._onModification(sheet.ownerNode, {
        type: 'stylesheet'
      });
      // but for constucted style sheets (those using new CSSStyleSheet())
      // we need to be a bit more thorough as they can be shared in multiple places
      for (const root of this._observing) {
        var _root$adoptedStyleShe;
        if ((_root$adoptedStyleShe = root.adoptedStyleSheets) !== null && _root$adoptedStyleShe !== void 0 && _root$adoptedStyleShe.includes(sheet)) {
          this._onModification(root, {
            type: 'adoptedstylesheet'
          });
        }
      }
    });
    _defineProperty(this, "_onNavigation", window => {
      this._onModification(window.document, {
        type: 'navigation'
      });
    });
    _defineProperty(this, "_onCanvasChange", canvas => {
      this._onModification(canvas, {
        type: 'canvas'
      });
    });
    _defineProperty(this, "_onFocusChange", e => {
      const eventTarget = this._getActualTarget(e);
      if (eventTarget == null) {
        return;
      }
      // We serialise the target to ensure that input text selections gets unselected when the user
      // unselects it
      this._onModification(eventTarget, {
        type: e.type
      });
      if (eventTarget.ownerDocument) {
        this._onModification(eventTarget.ownerDocument, {
          type: e.type
        });
      }
    });
    _defineProperty(this, "_onInputEvent", e => {
      const eventTarget = this._getActualTarget(e);
      if (eventTarget.tagName === 'SELECT' || eventTarget.tagName === 'TEXTAREA') {
        this._onModification(this._target(e), {
          recursive: true,
          type: e.type
        });
      } else if (eventTarget.tagName === 'INPUT') {
        if (eventTarget.type === 'radio' && eventTarget.name) {
          const container = eventTarget.closest('form') || eventTarget.ownerDocument;
          const radiogroup = container.querySelectorAll("input[type=radio][name=".concat(eventTarget.name, "]"));
          radiogroup.forEach(el => this._onModification(el, {
            type: e.type
          }));
        } else this._onModification(this._target(e), {
          recursive: true,
          type: e.type
        });
      }
    });
    _defineProperty(this, "_onPropertySet", target => {
      this._onModification(target, {
        type: 'property'
      });
    });
    // most of the events here are caught in the capture phase, so any synchronous effect
    // of handlers in user code likely will not have been applied, so we delay to the next
    // tick to capture them
    this._onModification = function () {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      return setTimeout(() => onModification(...params), 0);
    };
    this._observing = new Set();
    this._windows = new Set();
  }
}
exports["default"] = MutatingEventObserver;

/***/ }),

/***/ 5596:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _fastDeepEqual = _interopRequireDefault(__webpack_require__(7078));
var _src = __webpack_require__(9501);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class PatchCompressor {
  constructor(id) {
    _defineProperty(this, "_difference", (object, base) => {
      if (!base) return _objectSpread({}, object);
      const changes = Object.keys(object).map(key => {
        if ((0, _fastDeepEqual.default)(object[key], base[key])) return false;
        return {
          [key]: object[key]
        };
      }).filter(v => v);
      // reduce back into an object
      return changes.reduce((a, b) => {
        return _objectSpread(_objectSpread({}, a), b);
      }, {});
    });
    _defineProperty(this, "compress", () => {
      // then work out what's actually changed since the last state was persisted
      const compressed = Object.values(this.modified).map(modified => {
        const state = this.state.node(modified.id);
        const diff = this._difference(modified, this._flatten(state || {}));
        const changed = _objectSpread({
          id: modified.id
        }, diff);
        if (Object.keys(changed).length === 1) return false;
        return changed;
      }).filter(v => v);
      return compressed;
    });
    _defineProperty(this, "mark", () => {
      this.state.applyPatch(Object.values(this.modified));
      this.modified = {};
      return this;
    });
    _defineProperty(this, "_flatten", node => {
      return node.childNodes ? _objectSpread(_objectSpread({}, node), {}, {
        childNodes: node.childNodes.map(n => ({
          id: n.id
        }))
      }) : node;
    });
    _defineProperty(this, "push", patch => {
      if (!(patch && patch.modified)) {
        console.error('invalid patch', patch);
        return this;
      }
      patch.modified.filter(v => v).forEach(diff => {
        (0, _src.depthFirst)(diff, node => {
          this.modified[node.id] = _objectSpread(_objectSpread({}, this.modified[node.id]), this._flatten(node));
        });
      });
      return this;
    });
    _defineProperty(this, "reset", newState => {
      this.state = new _src.VirtualDOM(this._id);
      this.modified = {};
      if (newState) this.push({
        _t: 'reset',
        modified: [newState]
      });
      return this;
    });
    this._id = id;
    this.reset();
  }
}
exports["default"] = PatchCompressor;

/***/ }),

/***/ 3221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _events = __webpack_require__(6261);
var _src = __webpack_require__(9501);
var _redaction = __webpack_require__(6566);
var _nodes = __webpack_require__(6938);
var _MutatingEventObserver = _interopRequireDefault(__webpack_require__(8374));
var _unpolyfill = __webpack_require__(9883);
var _iframes = _interopRequireDefault(__webpack_require__(7966));
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _discoverNodes = __webpack_require__(8091);
var _WindowTaps = _interopRequireDefault(__webpack_require__(4153));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.PatchStream');
class PatchStream extends _events.EventEmitter {
  constructor(_root) {
    var _this;
    super();
    _this = this;
    _defineProperty(this, "start", () => {
      debug('starting patch stream for', this._root);

      // create a collection to track which document we're subscribed observers to
      this._documents = new Set();
      // listen for cross doc messages from third party iframes that support cobrowse
      this._iframeBridge.on('patch', this._onXDocIframeUpdate);
      // discover the nodes, track iframe etc...
      this._observe(this._root);
      // discover shadowRoots that are attached after the host is tracked
      _WindowTaps.default.on('attachshadow', this._onAttachShadow);
    });
    _defineProperty(this, "forceUpdate", () => {
      debug('forcing entire state update from', this._root);
      this.emit('patch', {
        _t: 'pre-force',
        flush: true,
        modified: [_objectSpread(_objectSpread({}, _nodes.NodeSerializer.serialize(this._root)), {}, {
          // If we're not sending the body, we should also suppress the scroll position as
          // the page content won't be large enough to be scrollable yet.
          scroll: undefined,
          childNodes: [_objectSpread(_objectSpread({}, _nodes.NodeSerializer.serialize(this._root.documentElement)), {}, {
            childNodes: [_nodes.NodeTree.depthFirst(this._root.head, _nodes.NodeSerializer.serialize)]
          })]
        })]
      });
      const serializerOptions = {
        rasterizeCanvas: true
      };
      this.emit('patch', {
        _t: 'forced',
        modified: [_nodes.NodeTree.depthFirst(this._root, (root, overrideChildren) => _nodes.NodeSerializer.serialize(root, overrideChildren, serializerOptions))]
      });
    });
    _defineProperty(this, "partialSync", nodeId => {
      const node = _nodes.NodeTracker.getById(nodeId);
      if (!node) return;
      this.emit('patch', {
        _t: 'partialsync',
        modified: [_nodes.NodeSerializer.serialize(node)]
      });
    });
    _defineProperty(this, "stop", () => {
      debug('stopping patch stream for', this._root);
      this._eventObserver.disconnect();
      this._mutationObserver.disconnect();
      this._iframeBridge.removeListener('patch', this._onXDocIframeUpdate);
      if (this._documents) this._documents.clear();
      this._documents = null;
      _WindowTaps.default.off('attachshadow', this._onAttachShadow);
    });
    _defineProperty(this, "destroy", () => {
      debug('destroying patch stream for', this._root);
      this.stop();
      this.removeAllListeners();
      _nodes.NodeTree.depthFirst(this._root, this._untrack);
      this._mutationObserver = null;
      this._eventObserver = null;
      this._iframeBridge = null;
      this._root = null;
    });
    // we need to track all the nodes that have been added or removed from the
    // DOM at any point. This is because we get some events for nodes that may
    // not have been passed to the mutation observer yet (due to batching done
    // by the browser). So we need to know when we should ignore those changes.
    // They'll get picked up later when the node is found by the DOM observation.
    _defineProperty(this, "_track", node => {
      if (!_nodes.NodeUtils.isDOMNode(node)) return;
      _nodes.NodeTracker.track(node);

      // top level document nodes (including those in accessible
      // iframes should be added to the various observers)
      if (node.nodeType === window.Node.DOCUMENT_NODE) {
        this._observe(node);
      }
      if (node.nodeType === window.Node.DOCUMENT_FRAGMENT_NODE) {
        this._observe(node);
      }

      // attach a load listener to iframes so we know when to
      // re-serialize its content on navigation or reload
      if (node.tagName === 'IFRAME') {
        this._iframeBridge.track(node);
        node.removeEventListener('load', this._onIframeLoad, {
          capture: true
        });
        node.addEventListener('load', this._onIframeLoad, {
          capture: true
        });
      }
    });
    _defineProperty(this, "_untrack", node => {
      _nodes.NodeTracker.forget(node);
      if (_nodes.NodeUtils.isDOMNode(node) && node.tagName === 'IFRAME') {
        node.removeEventListener('load', this._onIframeLoad, {
          capture: true
        });
        this._iframeBridge.remove(node);
      }
    });
    _defineProperty(this, "_observe", node => {
      if (node.nodeType !== window.Node.DOCUMENT_NODE && node.nodeType !== window.Node.DOCUMENT_FRAGMENT_NODE) {
        throw new Error("CobrowseIO: observed a non-document or fragment node (type=".concat(node.nodeType, ")"));
      } else {
        if (this._documents.has(node)) return;
        debug('starting observation of', node);
        this._documents.add(node);
        debug('doing initial node tracking on observe for', node);
        _nodes.NodeTree.depthFirst(node, this._track);
        this._eventObserver.observe(node);
        try {
          this._mutationObserver.observe(node, {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
          });
        } catch (e) {
          console.error('CobrowseIO failed to start mutation observer for', node);
        }
      }
    });
    _defineProperty(this, "_onAttachShadow", shadowRoot => {
      var _RedactionIndexProvid;
      const host = shadowRoot.host;

      // if the host isn't tracked yet we let the
      // mutation observer handle the node & corresponding
      // shadowRoot once it is added into the DOM
      if (!_nodes.NodeTracker.get(host)) return;
      if ((_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid !== void 0 && _RedactionIndexProvid.isRedacted(host)) return;
      this._observe(shadowRoot);
      if (_nodes.NodeTree.isIgnored(host)) return;

      // serialize the host of the shadowRoot and the shadowRoot itself
      this.emit('patch', {
        _t: 'attachshadow',
        modified: [_nodes.NodeSerializer.serialize(host), _nodes.NodeTree.depthFirst(shadowRoot, _nodes.NodeSerializer.serialize)]
      });
    });
    _defineProperty(this, "_onXDocIframeUpdate", (patch, _ref) => {
      var _RedactionIndexProvid2;
      let {
        iframe
      } = _ref;
      debug('xdoc iframe updated', iframe, patch);

      // if the message didn't come from an iframe in the page
      // then we should ignore it
      if (!iframe) return;
      if ((_RedactionIndexProvid2 = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid2 !== void 0 && _RedactionIndexProvid2.isRedacted(iframe)) return;
      if (_nodes.NodeTree.isIgnored(iframe)) return;

      // Embeded pages will send up patch events when their content changes
      // We will build these back into a VirtualDOM for eahc iframe that the
      // serialiser of this document can then access to read the (pre-
      // serialized) contents of the xdoc iframe.
      iframe.__document_id = patch.document_id;
      this.emit('patch', {
        _t: 'xdociframeupdate',
        modified: [
        // Make sure we always serialize the containing iframe. This catches cases
        // where the document id has changed and we'll need to recreate the whole
        // content from scratch.
        _nodes.NodeSerializer.serialize(iframe),
        // then just include the patches from inside the iframe verbatum
        ...patch.patch]
      });
    });
    _defineProperty(this, "_onIframeLoad", _ref2 => {
      var _RedactionIndexProvid3;
      let {
        target
      } = _ref2;
      debug('iframe loaded', target);
      if ((_RedactionIndexProvid3 = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid3 !== void 0 && _RedactionIndexProvid3.isRedacted(target)) return;

      // watch the iframe content for changes using our mutation observer
      if (!(0, _src.isxdoc)(target)) this._observe(target.contentWindow.document);

      // ensure the bridge is aware of this iframe
      this._iframeBridge.track(target);
      if (_nodes.NodeTree.isIgnored(target)) return;

      // and always send the content for compression and transmission
      this.emit('patch', {
        _t: 'iframeupdate',
        modified: [_nodes.NodeTree.depthFirst(target, _nodes.NodeSerializer.serialize)]
      });
    });
    _defineProperty(this, "_onEventMutation", function (target) {
      var _RedactionIndexProvid4;
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // this is called within a setTimeout, so we need to check if we're still running
      // the mutation observer before we do anything
      if (_this._mutationObserver) {
        // Force processing of any outstanding changes the mutation observer has queued up.
        // This should let us discover and track all new nodes that the event might have targeted
        _this._onDOMChange(_this._mutationObserver.takeRecords());
      }

      // IE 11 textareas don't trigger mutation events, so we might end up with new
      // text nodes that aren't tracked yet
      if (target.tagName === 'TEXTAREA') _nodes.NodeTree.depthFirst(target, _this._track);

      // Problem: we can get events for nodes that we might not know about yet through the
      //          mutation observer. This mean those nodes might not yet have a parent in our
      //          virtual dom, so sending state changes for them would lead to orphaned trees
      //          and cause things to blow up on the agent side
      //          To get around this we statefully track which nodes we currently know about
      //          and if we get events for nodes outside that set we can safely ignore the events
      //          Currently this state tracking is done globally via the NodeTracker class
      //    TODO: Find a better place to track the node discovery state
      if (!_nodes.NodeTracker.get(target)) return;
      if ((_RedactionIndexProvid4 = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid4 !== void 0 && _RedactionIndexProvid4.isRedacted(target)) return;
      if (_nodes.NodeTree.isIgnored(target)) return;
      const serializerOptions = {
        rasterizeCanvas: options.type === 'canvas'
      };
      const s = options.recursive ? _nodes.NodeTree.depthFirst(target, (root, overrideChildren) => _nodes.NodeSerializer.serialize(root, overrideChildren, serializerOptions)) : _nodes.NodeSerializer.serialize(target, undefined, serializerOptions);
      _this.emit('patch', {
        _t: "eventmutation:".concat(options.type),
        modified: [s]
      });
    });
    _defineProperty(this, "_getModifications", changes => {
      // build a summary across all changes of which nodes are added
      // and removed (note: a node might be removed then re-added in
      // the same group of changes, or it's parent might be removed)
      const removed = new Set();
      const modified = new Set();
      const added = new Set();

      // traverse the list of changes building a picture of the overall nodes that
      // have been modified
      changes.forEach(change => {
        // we re-use the mutation observer to watch for shadow dom changes too
        // it appears we can get shadow dom changes for trees not actually attached
        // to the main DOM, so we filter those out before applying the changes
        //
        // IE 11 text nodes seem to get randomly replaced and fail equality
        // checks, so we assume all character data changes are valid
        // if the nodes aren't actually in the DOM they'll get ignored
        const valid = change.type === 'characterData' || modified.has(change.target) || _nodes.NodeTracker.get(change.target);
        if (valid) (0, _discoverNodes.discoverNodes)(change, modified, added, removed);
      });

      // nodes that have been removed can be forgotten
      removed.forEach(node => this._untrack(node));

      // we need to make sure all the newly added nodes are being tracked (i.e. they have IDs)
      // IE 11 can change the node references in the DOM of modified nodes, so
      // we should count the modified nodes as if they were just added
      modified.forEach(node => {
        return this._track(node);
      });
      return {
        added,
        modified,
        removed
      };
    });
    _defineProperty(this, "_onDOMChange", changes => {
      var _RedactionIndexProvid5, _RedactionIndexProvid6;
      const {
        added,
        modified,
        removed
      } = this._getModifications(changes);

      // The redaction system is aware of changes that may need to take place in
      // nodes that expand beyond the direct nodes that were changed. Collect
      // those here
      const redactionChanges = (_RedactionIndexProvid5 = (_RedactionIndexProvid6 = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid6 === void 0 ? void 0 : _RedactionIndexProvid6.notifyChanges(changes, added, modified, removed)) !== null && _RedactionIndexProvid5 !== void 0 ? _RedactionIndexProvid5 : [];
      const allModified = new Set([...modified, ...redactionChanges]);
      debug('DOM changed', allModified);

      // serialise nodes that have been added or updated and
      // convert nodes that have been removed to a list of id only nodes
      const serialized = [...allModified].map(node => _nodes.NodeSerializer.serialize(node)).filter(Boolean);
      debug('DOM changes serialized', serialized);
      this.emit('patch', {
        _t: 'domchange',
        modified: serialized
      });
    });
    this._root = _root;
    this._mutationObserver = new _unpolyfill.MutationObserver(this._onDOMChange);
    this._eventObserver = new _MutatingEventObserver.default(this._onEventMutation);
    this._iframeBridge = _iframes.default;
  }
}
exports["default"] = PatchStream;

/***/ }),

/***/ 2847:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "PatchCompressor", ({
  enumerable: true,
  get: function () {
    return _PatchCompressor.default;
  }
}));
Object.defineProperty(exports, "PatchStream", ({
  enumerable: true,
  get: function () {
    return _PatchStream.default;
  }
}));
var _PatchStream = _interopRequireDefault(__webpack_require__(3221));
var _PatchCompressor = _interopRequireDefault(__webpack_require__(5596));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 3071:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _throttle = _interopRequireDefault(__webpack_require__(6770));
var _dompatches = __webpack_require__(2847);
var _nodes = __webpack_require__(6938);
var _activity = __webpack_require__(5264);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.DOMFrameSource');
class DOMFrameSource {
  constructor(onUpdate) {
    _defineProperty(this, "_throttleCompressAndEmitFrame", (0, _throttle.default)(() => this._compressAndEmitFrame(), 110));
    _defineProperty(this, "_compressAndEmitFrame", () => {
      // check if we've been destroyed before throttle ends
      // as throttles aren't cancelable
      if (!this._compression) return;

      // check the document we were attached to is still being tracked
      if (!document || !_nodes.NodeTracker.get(document)) return;

      // get a compressed version of the state so far (this won't alter the
      // state of the compression yet)
      const patch = this._compression.compress();
      if (!patch.length) return;

      // call the update callback. update callbacks may return falsy values
      // to indicate the update couldn't be handled for some reason, e.g. the
      // socket was disconencted or under too much backpressure
      if (this._onUpdate({
        document_id: _nodes.NodeTracker.get(document),
        patch
      })) {
        // mark this part of compressed state as used
        // so the next state will continue from here
        this._compression.mark();
      }
    });
    _defineProperty(this, "capturingWillStart", () => {
      debug('capturingWillStart for DOMFrameSource in', document);
      if (this._sendInterval) throw new Error('DOMFrameSource already running');
      if (!this._compression) this._compression = new _dompatches.PatchCompressor(_nodes.NodeTracker.track(document));
      if (!this._patchStream) this._patchStream = new _dompatches.PatchStream(document);
      _activity.WindowTracking.on('activate', this.reset);

      // sends are triggered both immediately on changes (with some rate
      // limiting) and on a regular tick to retry failed sends (e.g. if the
      // socket is temporarily disconnected)
      this._patchStream.on('patch', patch => {
        this._compression.push(patch);
        if (patch.flush) {
          this._compressAndEmitFrame();
        } else {
          this._throttleCompressAndEmitFrame();
        }
      });
      this._sendInterval = setInterval(() => this._compressAndEmitFrame(), 500);
      this._patchStream.start();
    });
    _defineProperty(this, "capturingWillStop", () => {
      debug('capturingWillStop for DOMFrameSource in', document);
      _activity.WindowTracking.removeListener('activate', this.reset);
      if (this._sendInterval) {
        clearInterval(this._sendInterval);
        this._sendInterval = null;
      }
      if (this._patchStream) {
        this._patchStream.destroy();
        this._patchStream = null;
      }
      if (this._compression) {
        this._compression.reset();
        this._compression = null;
      }
    });
    _defineProperty(this, "setCodecs", codecs => {
      // TODO: should we actually check this in any way
    });
    _defineProperty(this, "reset", () => {
      debug('resetting DOMFrameSource in', document);
      // we use a setTimeout to ensure that any DOM mutations are first
      // recorded in the async callback of the mutation observer
      setTimeout(() => {
        var _this$_compression, _this$_patchStream;
        (_this$_compression = this._compression) === null || _this$_compression === void 0 || _this$_compression.reset();
        (_this$_patchStream = this._patchStream) === null || _this$_patchStream === void 0 || _this$_patchStream.forceUpdate();
      }, 0);
    });
    _defineProperty(this, "destroy", () => {
      debug('destroying DOMFrameSource in', document);
      this.capturingWillStop();
      this._onUpdate = null;
    });
    _defineProperty(this, "partialSync", nodeId => {
      this._patchStream.partialSync(nodeId);
    });
    debug('DOMFrameSource constructed in', document);
    this._onUpdate = onUpdate;
  }
}
exports["default"] = DOMFrameSource;

/***/ }),

/***/ 287:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.FrameLoop');
class FrameLoop {
  constructor() {
    _defineProperty(this, "isRunning", () => {
      return this._running;
    });
    _defineProperty(this, "setSource", async source => {
      if (source.constructor === (this.source && this.source.constructor)) {
        debug('frame source type not changed');
        return;
      }
      if (this.isRunning()) {
        if (this.source) this.source.capturingWillStop();
        this.source = source;
        try {
          await this.source.capturingWillStart();
          // when switching between frame source while already
          // running we should force a new "keyframe" of the
          // underlying frame source in case the remote side doesn't
          // have the full state
          this.invalidateFrame();
        } catch (e) {
          console.error(e);
        }
      } else {
        this.source = source;
      }
    });
    _defineProperty(this, "getSource", () => {
      return this.source;
    });
    _defineProperty(this, "start", async () => {
      debug('starting frame loop in', document);
      if (!this.isRunning()) {
        this._running = true;
        this.source.capturingWillStart();
      }
    });
    _defineProperty(this, "stop", () => {
      if (this.isRunning()) {
        this.source.capturingWillStop();
        this._running = false;
      }
    });
    _defineProperty(this, "invalidateFrame", () => {
      if (!this.isRunning()) throw new Error('FrameLoop was destroyed');
      debug('invalidate frame in', document);
      if (this.source) this.source.reset();
    });
    _defineProperty(this, "destroy", () => {
      debug('destroying frame loop in', document);
      this.stop();
      if (this.source) {
        this.source.destroy();
        this.source = null;
      }
    });
    debug('FrameLoop constructed in', document);
    this._running = false;
  }
}
exports["default"] = FrameLoop;

/***/ }),

/***/ 6999:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _src = __webpack_require__(2343);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.H264Encoder');
var _delegate = /*#__PURE__*/new WeakMap();
var _media = /*#__PURE__*/new WeakMap();
var _demuxer = /*#__PURE__*/new WeakMap();
var _sinceLastKeyframe = /*#__PURE__*/new WeakMap();
class H264Encoder {
  constructor(media, delegate) {
    // delegate to handle fraems and provide some parameters (e.g. scale)
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    // media stream track
    _classPrivateFieldInitSpec(this, _media, void 0);
    // we demux web to extract the h264 stream
    _classPrivateFieldInitSpec(this, _demuxer, void 0);
    // we cache all the h264 data since the last keyframe, then when we get
    // a sync (reset) request we can immediately send keyframe data and any
    // subsequent updates
    _classPrivateFieldInitSpec(this, _sinceLastKeyframe, []);
    _defineProperty(this, "reset", () => {
      debug('resetting H264Encoder');
      // we need to force a new keyframe
      _classPrivateFieldGet(_sinceLastKeyframe, this).forEach(data => {
        _classPrivateFieldGet(_delegate, this).handleFrame(data, H264Encoder.MIME_TYPE, Infinity);
      });
    });
    _defineProperty(this, "destroy", () => {
      debug('destroy H264Encoder');
      if (_classPrivateFieldGet(_demuxer, this)) {
        _classPrivateFieldGet(_demuxer, this).stop();
        _classPrivateFieldSet(_demuxer, this, null);
      }
      _classPrivateFieldSet(_sinceLastKeyframe, this, null);
    });
    debug('H264Encoder constructed');
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_media, this, media);
    _classPrivateFieldSet(_demuxer, this, (0, _src.createMediaRecorderDemuxer)(media));
    if (!_classPrivateFieldGet(_demuxer, this)) throw new Error('Failed to create MediaRecorderDemuxer');
    _classPrivateFieldGet(_demuxer, this).on('media-packet', _ref => {
      let {
        data
      } = _ref;
      if (_classPrivateFieldGet(_demuxer, this) === null) return;

      // we need to remeber all the video data sent since the previous keyframe, so that
      // when a new client joins, we don't have to wait an unknown amount of time until
      // the browser decides to give us a new one
      let details;
      // look for H264 block delimeter, either 0 0 0 1 or 0 0 0 1
      if (data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 1) {
        details = data[4];
      } else if (data[0] === 0 && data[1] === 0 && data[2] === 1) {
        details = data[3];
      }
      // Look for keyframe NALs and reset the buffer each time we see one
      const nalType = details & 0x1f;
      if (nalType === 7) _classPrivateFieldSet(_sinceLastKeyframe, this, []);
      _classPrivateFieldGet(_sinceLastKeyframe, this).push(data);
      _classPrivateFieldGet(_delegate, this).handleFrame(data, H264Encoder.MIME_TYPE, Infinity);
    });
    return _classPrivateFieldGet(_demuxer, this).start();
  }
  static isSupported() {
    return _src.MediaRecorderDemuxer.isSupported('video/webm;codecs=h264');
  }
}
exports["default"] = H264Encoder;
_defineProperty(H264Encoder, "MIME_TYPE", 'video/avc');

/***/ }),

/***/ 7601:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
__webpack_require__(3697);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.JPEGEncoder');
var _video = /*#__PURE__*/new WeakMap();
var _canvas = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _emitUpdate = /*#__PURE__*/new WeakMap();
class JPEGEncoder {
  constructor(media, delegate) {
    // the video showing the media stream track, used for rendering to a canvas
    _classPrivateFieldInitSpec(this, _video, void 0);
    // the canvas we're drawing to, passed as an output to the delegate
    _classPrivateFieldInitSpec(this, _canvas, void 0);
    // delegate to handle fraems and provide some parameters (e.g. scale)
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    // frame rate interval
    _classPrivateFieldInitSpec(this, _interval, void 0);
    _classPrivateFieldInitSpec(this, _emitUpdate, () => {
      if (!_classPrivateFieldGet(_delegate, this)) return;
      const scale = _classPrivateFieldGet(_delegate, this).scale();
      // scale and video size can change dynamically, so make sure
      // the canvas reflects the latest parameters
      _classPrivateFieldGet(_canvas, this).width = _classPrivateFieldGet(_video, this).videoWidth * scale;
      _classPrivateFieldGet(_canvas, this).height = _classPrivateFieldGet(_video, this).videoHeight * scale;
      // draw the latest video frame to fill the current canvas size
      const ctx = _classPrivateFieldGet(_canvas, this).getContext('2d');
      ctx.drawImage(_classPrivateFieldGet(_video, this), 0, 0, _classPrivateFieldGet(_canvas, this).width, _classPrivateFieldGet(_canvas, this).height);

      // encode to JPEG and send to delegate
      _classPrivateFieldGet(_canvas, this).toBlob(async blob => {
        // check if encoder was destroyed while waiting for canvas
        if (!_classPrivateFieldGet(_delegate, this)) return;
        const data = new Uint8Array(await new Response(blob).arrayBuffer());
        _classPrivateFieldGet(_delegate, this).handleFrame(data, JPEGEncoder.MIME_TYPE, 1);
      }, JPEGEncoder.MIME_TYPE, 0.5);
    });
    _defineProperty(this, "reset", () => {
      // noop, just wait for next frame loop
    });
    _defineProperty(this, "destroy", () => {
      debug('destroy JPEGEncoder');
      if (_classPrivateFieldGet(_interval, this)) {
        clearInterval(_classPrivateFieldGet(_interval, this));
        _classPrivateFieldSet(_interval, this, null);
      }
      _classPrivateFieldSet(_delegate, this, null);
      _classPrivateFieldSet(_video, this, null);
      _classPrivateFieldSet(_canvas, this, null);
    });
    debug('JPEGEncoder constructed');
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_video, this, document.createElement('video'));
    _classPrivateFieldSet(_canvas, this, document.createElement('canvas'));

    // feed into a video element so we can render it to a canvas
    _classPrivateFieldGet(_video, this).srcObject = media;
    _classPrivateFieldGet(_video, this).play();

    // start frame loop
    _classPrivateFieldSet(_interval, this, setInterval(_classPrivateFieldGet(_emitUpdate, this), 100));
  }
}
exports["default"] = JPEGEncoder;
_defineProperty(JPEGEncoder, "MIME_TYPE", 'image/jpeg');

/***/ }),

/***/ 4911:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _H264Encoder = _interopRequireDefault(__webpack_require__(6999));
var _JPEGEncoder = _interopRequireDefault(__webpack_require__(7601));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _toSetter(t, e, n) { e || (e = []); var r = e.length++; return Object.defineProperty({}, "_", { set: function (o) { e[r] = o, t.apply(n, e); } }); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.MediaStreamFrameSource');
var _track = /*#__PURE__*/new WeakMap();
var _media = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _encoder = /*#__PURE__*/new WeakMap();
var _allowedCodecs = /*#__PURE__*/new WeakMap();
var _pickEncoderClass = /*#__PURE__*/new WeakMap();
var _setupEncoder = /*#__PURE__*/new WeakMap();
class MediaStreamFrameSource {
  constructor(delegate) {
    // media stream track
    _classPrivateFieldInitSpec(this, _track, void 0);
    // media object from the browser
    _classPrivateFieldInitSpec(this, _media, void 0);
    // delegate to handle fraems and provide some parameters (e.g. scale)
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _encoder, null);
    _classPrivateFieldInitSpec(this, _allowedCodecs, []);
    _classPrivateFieldInitSpec(this, _pickEncoderClass, () => {
      const h264allowed = !_classPrivateFieldGet(_allowedCodecs, this).length || _classPrivateFieldGet(_allowedCodecs, this).includes(_H264Encoder.default.MIME_TYPE);
      if (h264allowed && _H264Encoder.default.isSupported()) return _H264Encoder.default;else return _JPEGEncoder.default;
    });
    _classPrivateFieldInitSpec(this, _setupEncoder, async media => {
      const Encoder = _classPrivateFieldGet(_pickEncoderClass, this).call(this);
      if (!(_classPrivateFieldGet(_encoder, this) instanceof Encoder)) {
        var _classPrivateFieldGet2;
        debug('Changing encoder to', Encoder);
        (_classPrivateFieldGet2 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.destroy();
        _classPrivateFieldSet(_encoder, this, new Encoder(media, _classPrivateFieldGet(_delegate, this)));
      }
      return _classPrivateFieldGet(_encoder, this);
    });
    _defineProperty(this, "setCodecs", codecs => {
      _classPrivateFieldSet(_allowedCodecs, this, codecs || []);
      if (_classPrivateFieldGet(_media, this)) _classPrivateFieldGet(_setupEncoder, this).call(this, _classPrivateFieldGet(_media, this));
    });
    _defineProperty(this, "capturingWillStart", async () => {
      debug('capturingWillStart for MediaStreamFrameSource');

      // we need to show a prompt before requesting the display media as
      // some browsers need the display media to be triggered by a user action
      const result = await _classPrivateFieldGet(_delegate, this).requestPermission();
      if (!result) return;
      try {
        if (result instanceof MediaStream) {
          _classPrivateFieldSet(_media, this, result);
        } else {
          // start the media stream from the browser
          _classPrivateFieldSet(_media, this, await navigator.mediaDevices.getDisplayMedia({
            video: {
              cursor: 'always',
              width: {
                ideal: 1400
              },
              height: {
                ideal: 1000
              },
              frameRate: {
                max: 10
              }
            },
            audio: false,
            // encourage the browser to include the current tab in the list of tabs they can share
            selfBrowserSurface: 'include'
          }));
        }

        // handle track ending (e.g. user presses browser end stream button)
        [_toSetter(_classPrivateFieldSet, [_track, this])._] = _classPrivateFieldGet(_media, this).getVideoTracks();
        if (!_classPrivateFieldGet(_track, this)) throw new Error('failed to get display media track');
        _classPrivateFieldGet(_track, this).onended = () => {
          debug('track ended');
          _classPrivateFieldSet(_track, this, null);
          _classPrivateFieldGet(_delegate, this).captureEnded();
          this.destroy();
        };
        _classPrivateFieldGet(_setupEncoder, this).call(this, _classPrivateFieldGet(_media, this));
        _classPrivateFieldGet(_delegate, this).captureStarted(_classPrivateFieldGet(_media, this));
      } catch (e) {
        _classPrivateFieldGet(_delegate, this).captureEnded(e);
      }
    });
    _defineProperty(this, "capturingWillStop", () => {
      var _classPrivateFieldGet3;
      debug('capturingWillStop for MediaStreamFrameSource');
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.destroy();
      _classPrivateFieldSet(_encoder, this, null);
      _classPrivateFieldSet(_media, this, null);
      if (_classPrivateFieldGet(_track, this)) {
        _classPrivateFieldGet(_track, this).stop();
        _classPrivateFieldSet(_track, this, null);
        _classPrivateFieldGet(_delegate, this).captureEnded();
      }
    });
    _defineProperty(this, "reset", () => {
      var _classPrivateFieldGet4;
      debug('resetting MediaStreamFrameSource');
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.reset();
    });
    _defineProperty(this, "destroy", () => {
      var _classPrivateFieldGet5;
      debug('destroying MediaStreamFrameSource');
      this.capturingWillStop();
      _classPrivateFieldSet(_delegate, this, null);
      (_classPrivateFieldGet5 = _classPrivateFieldGet(_encoder, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.destroy();
      _classPrivateFieldSet(_encoder, this, null);
    });
    debug('MediaStreamFrameSource constructed');
    _classPrivateFieldSet(_delegate, this, delegate);
  }
}
exports["default"] = MediaStreamFrameSource;

/***/ }),

/***/ 8647:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "DOMFrameSource", ({
  enumerable: true,
  get: function () {
    return _DOMFrameSource.default;
  }
}));
Object.defineProperty(exports, "FrameLoop", ({
  enumerable: true,
  get: function () {
    return _FrameLoop.default;
  }
}));
Object.defineProperty(exports, "MediaStreamFrameSource", ({
  enumerable: true,
  get: function () {
    return _MediaStreamFrameSource.default;
  }
}));
var _FrameLoop = _interopRequireDefault(__webpack_require__(287));
var _DOMFrameSource = _interopRequireDefault(__webpack_require__(3071));
var _MediaStreamFrameSource = _interopRequireDefault(__webpack_require__(4911));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 1149:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IFrameContext = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _navigation2 = __webpack_require__(9715);
var _pdf = __webpack_require__(1065);
var _universal = __webpack_require__(1834);
var _XDocHandler = _interopRequireDefault(__webpack_require__(6900));
var _redaction = __webpack_require__(6566);
var _frames = __webpack_require__(8647);
var _protected = _interopRequireDefault(__webpack_require__(7609));
var _Navigation = __webpack_require__(4661);
var _UniversalHooks = _interopRequireDefault(__webpack_require__(1191));
var _documents = __webpack_require__(9689);
var _DocumentObserver = _interopRequireDefault(__webpack_require__(4033));
var _InteractionTracking = _interopRequireDefault(__webpack_require__(6913));
var _WindowTaps = _interopRequireDefault(__webpack_require__(4153));
var _NodeContent = __webpack_require__(9931);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _session = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _sendEventToParent = /*#__PURE__*/new WeakMap();
var _frameLoop = /*#__PURE__*/new WeakMap();
var _documentCollection = /*#__PURE__*/new WeakMap();
var _documentObserver = /*#__PURE__*/new WeakMap();
var _navigation = /*#__PURE__*/new WeakMap();
var _shouldNavigate = /*#__PURE__*/new WeakMap();
var _iframeNavigate = /*#__PURE__*/new WeakMap();
var _universalNavigate = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _startFrameLoop = /*#__PURE__*/new WeakMap();
var _stopFrameLoop = /*#__PURE__*/new WeakMap();
var _onNavigate = /*#__PURE__*/new WeakMap();
var _updateRedaction = /*#__PURE__*/new WeakMap();
var _onClick = /*#__PURE__*/new WeakMap();
var _onChange = /*#__PURE__*/new WeakMap();
class IFrameContext {
  constructor(_session2, delegate, sendEventToParent) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _sendEventToParent, void 0);
    _classPrivateFieldInitSpec(this, _frameLoop, void 0);
    _classPrivateFieldInitSpec(this, _documentCollection, void 0);
    _classPrivateFieldInitSpec(this, _documentObserver, void 0);
    _classPrivateFieldInitSpec(this, _navigation, void 0);
    _classPrivateFieldInitSpec(this, _shouldNavigate, type => {
      var _classPrivateFieldGet2;
      if (!((_classPrivateFieldGet2 = _classPrivateFieldGet(_session, this)) !== null && _classPrivateFieldGet2 !== void 0 && _classPrivateFieldGet2.isActive())) return false;
      // when an xdoc iframe is not trusted by its parent it only receives
      // a sanitised session which does not include a proxyToken
      if (!_classPrivateFieldGet(_session, this)[_protected.default].proxyToken()) return false;
      return true;
    });
    _defineProperty(this, "handleNavigation", (url, target, windowFeatures, options) => {
      const {
        name,
        go,
        e,
        type,
        block
      } = options;
      const {
        handle,
        document
      } = _classPrivateFieldGet(_documentCollection, this).resolveDocument(options.handle, name);
      const {
        windowProxy
      } = document;
      const currentWindow = e.view || window;
      const inNestedIFrame = currentWindow !== window;
      const isTargetSelf = !target || target === '_self';
      const nav = {
        block: () => {
          if (e.eventPhase === Event.CAPTURING_PHASE) return {
            windowProxy
          };
          block();
          if (!inNestedIFrame) _classPrivateFieldGet(_documentObserver, this).sendBlocked(url);
          return {
            windowProxy
          };
        },
        parent: overrideType => {
          document.load(url, target, windowFeatures, {
            type: overrideType || type
          });
          if (e.eventPhase === Event.CAPTURING_PHASE) return {
            windowProxy
          };
          _classPrivateFieldGet(_documentCollection, this).addDocument(handle, name, document);
          _classPrivateFieldGet(_delegate, this).open(url, target, windowFeatures, {
            type: overrideType || type,
            handle
          });
          return {
            windowProxy
          };
        },
        continue: () => {
          const handlerResult = _classPrivateFieldGet(_navigation, this).runHandler(url, target, windowFeatures, {
            type,
            document
          });
          if (handlerResult.rewrittenUrl) return {
            rewrittenUrl: handlerResult.rewrittenUrl
          };
          if (handlerResult.document) _classPrivateFieldGet(_documentCollection, this).addDocument(handle, name, handlerResult.document);
          return {
            windowProxy
          };
        },
        replay: () => go()
      };
      const dependencies = {
        url,
        target,
        windowFeatures,
        type,
        nav,
        getConsent: () => _classPrivateFieldGet(_delegate, this).confirmOpen(url, type),
        windowProxy,
        setLoading: () => !inNestedIFrame && isTargetSelf && _classPrivateFieldGet(_documentObserver, this).sendLoading(url)
      };
      const navigate = _UniversalHooks.default.inUniversalProxy ? _classPrivateFieldGet(_universalNavigate, this) : _classPrivateFieldGet(_iframeNavigate, this);
      return navigate(dependencies);
    });
    _classPrivateFieldInitSpec(this, _iframeNavigate, _ref => {
      let {
        target,
        type,
        nav,
        getConsent,
        windowProxy
      } = _ref;
      if (!type) return nav.continue();

      // XDoc navigations don't require consent
      if (type === _Navigation.NAVIGATION_TYPE.XDOC) return nav.continue();

      // prevent sending the confirmation if we can't navigate
      if (!_classPrivateFieldGet(_shouldNavigate, this).call(this, type)) return nav.continue();
      getConsent().then(_ref2 => {
        let {
          accepted
        } = _ref2;
        if (!accepted) return nav.replay();
        if (target === '_blank') return nav.parent();
        nav.continue();
      });
      return {
        windowProxy
      };
    });
    _classPrivateFieldInitSpec(this, _universalNavigate, _ref3 => {
      let {
        url,
        target,
        type,
        nav,
        getConsent,
        windowProxy,
        setLoading
      } = _ref3;
      const currentOrigin = new URL(_UniversalHooks.default.unproxify(window.location.href)).origin;
      const requiresConsent = currentOrigin !== new URL(url, currentOrigin).origin;
      if (!type) {
        // we rely on the Universal Handler in the parent to block
        if (target === '_blank') return nav.parent(_Navigation.NAVIGATION_TYPE.UNIVERSAL);
        return nav.block();
      }
      if (!requiresConsent) {
        if (target === '_blank') return nav.parent();
        if (type === _Navigation.NAVIGATION_TYPE.PDF) return nav.continue();
        setLoading();
        return {
          rewrittenUrl: url
        };
      }

      // prevent sending the confirmation if we can't navigate
      if (!_classPrivateFieldGet(_shouldNavigate, this).call(this, type)) return nav.continue();
      getConsent().then(_ref4 => {
        let {
          accepted
        } = _ref4;
        if (!accepted) return nav.block();
        if (target === '_blank') return nav.parent();
        if (type === _Navigation.NAVIGATION_TYPE.PDF) return nav.continue();
        setLoading();
        nav.replay();
      });
      return {
        windowProxy
      };
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, session => {
      _classPrivateFieldGet(_updateRedaction, this).call(this, session);
      if (session.isActive() && !_classPrivateFieldGet(_frameLoop, this)) _classPrivateFieldGet(_startFrameLoop, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, () => {
      _classPrivateFieldGet(_stopFrameLoop, this).call(this);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).closeAllDocuments();
    });
    _classPrivateFieldInitSpec(this, _startFrameLoop, () => {
      var _classPrivateFieldGet3;
      if ((_classPrivateFieldGet3 = _classPrivateFieldGet(_frameLoop, this)) !== null && _classPrivateFieldGet3 !== void 0 && _classPrivateFieldGet3.isRunning()) return;
      _classPrivateFieldSet(_frameLoop, this, new _frames.FrameLoop());
      _classPrivateFieldGet(_frameLoop, this).setSource(new _frames.DOMFrameSource(patch => {
        _classPrivateFieldGet(_sendEventToParent, this).call(this, 'patch', patch);
        return true;
      }));
      _classPrivateFieldGet(_frameLoop, this).start();
      _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _classPrivateFieldInitSpec(this, _stopFrameLoop, () => {
      if (_classPrivateFieldGet(_frameLoop, this)) _classPrivateFieldGet(_frameLoop, this).destroy();
      _classPrivateFieldSet(_frameLoop, this, null);
    });
    _classPrivateFieldInitSpec(this, _onNavigate, (_window, previousUrl) => {
      _classPrivateFieldGet(_updateRedaction, this).call(this, _classPrivateFieldGet(_session, this));

      // avoid an expensive operation if there are no changes in redaction selectors
      if (_redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_delegate, this).redactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_delegate, this).unredactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_session, this).redactionSelectors(), previousUrl) || _redaction.TargetedRedaction.hasChange(_classPrivateFieldGet(_session, this).unredactionSelectors(), previousUrl)) {
        // this is triggered from a synchronous event, we use a setTimeout to
        // ensure that any DOM mutations that occurred before the event are
        // first recorded in the async callback of the mutation observer
        setTimeout(() => {
          this.invalidateFrame();
        }, 0);
      }
    });
    _defineProperty(this, "invalidateFrame", () => {
      var _classPrivateFieldGet4;
      if ((_classPrivateFieldGet4 = _classPrivateFieldGet(_frameLoop, this)) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.isRunning()) _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _defineProperty(this, "partialSync", async nodeId => {
      var _classPrivateFieldGet5;
      if (!((_classPrivateFieldGet5 = _classPrivateFieldGet(_frameLoop, this)) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isRunning())) return;
      const current = _classPrivateFieldGet(_frameLoop, this).getSource();
      if (!(current instanceof _frames.DOMFrameSource)) return;
      await (0, _NodeContent.applyContentCache)(nodeId);
      current.partialSync(nodeId);
    });
    _classPrivateFieldInitSpec(this, _updateRedaction, session => {
      _redaction.RedactionIndexProvider.instance = new _redaction.RedactionIndex(_redaction.TargetedRedaction.filterSelectors(_classPrivateFieldGet(_delegate, this).redactedViews), _redaction.TargetedRedaction.filterSelectors(_classPrivateFieldGet(_delegate, this).unredactedViews), _redaction.TargetedRedaction.filterSelectors(session.redactionSelectors()), _redaction.TargetedRedaction.filterSelectors(session.unredactionSelectors()));
    });
    _classPrivateFieldInitSpec(this, _onClick, target => _classPrivateFieldGet(_sendEventToParent, this).call(this, 'click', target));
    _classPrivateFieldInitSpec(this, _onChange, target => _classPrivateFieldGet(_sendEventToParent, this).call(this, 'change', target));
    _defineProperty(this, "destroy", () => {
      if (_classPrivateFieldGet(_session, this)) {
        _classPrivateFieldGet(_session, this).removeListener('update', _classPrivateFieldGet(_onSessionUpdated, this));
        _classPrivateFieldGet(_session, this).removeListener('ended', _classPrivateFieldGet(_onSessionEnded, this));
      }
      _classPrivateFieldSet(_session, this, null);
      if (_classPrivateFieldGet(_navigation, this)) _classPrivateFieldGet(_navigation, this).destroy();
      _classPrivateFieldSet(_navigation, this, null);
      _WindowTaps.default.off('navigate', _classPrivateFieldGet(_onNavigate, this));
      _InteractionTracking.default.off('click', _classPrivateFieldGet(_onClick, this));
      _InteractionTracking.default.off('change', _classPrivateFieldGet(_onChange, this));
      if (_classPrivateFieldGet(_documentObserver, this)) _classPrivateFieldGet(_documentObserver, this).destroy();
      _classPrivateFieldSet(_documentObserver, this, null);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).destroy();
      _classPrivateFieldSet(_documentCollection, this, null);
    });
    _classPrivateFieldSet(_session, this, _session2);
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_sendEventToParent, this, sendEventToParent);
    _classPrivateFieldGet(_onSessionUpdated, this).call(this, _session2);
    _session2.on('updated', _classPrivateFieldGet(_onSessionUpdated, this));
    _session2.on('ended', _classPrivateFieldGet(_onSessionEnded, this));
    if (_UniversalHooks.default.inUniversalProxy) {
      _classPrivateFieldSet(_documentObserver, this, new _DocumentObserver.default(document => _classPrivateFieldGet(_sendEventToParent, this).call(this, 'document', {
        document
      })));
    }
    _classPrivateFieldSet(_documentCollection, this, new _documents.DocumentCollection({
      onDocumentAdded: document => {
        if (document.element) _classPrivateFieldGet(_delegate, this).showDocument(document);
      }
    }));
    const pdfHandler = new _pdf.PDFHandler(_session2, delegate);
    const universalHandler = new _universal.UniversalHandler(_session2, delegate);
    const xdocHandler = new _XDocHandler.default(_session2, delegate);
    _classPrivateFieldSet(_navigation, this, new _navigation2.Navigation({
      shouldNavigate: _classPrivateFieldGet(_shouldNavigate, this),
      handlers: [pdfHandler, universalHandler, xdocHandler],
      handleNavigation: this.handleNavigation
    }));
    _WindowTaps.default.on('navigate', _classPrivateFieldGet(_onNavigate, this));
    _InteractionTracking.default.on('click', _classPrivateFieldGet(_onClick, this));
    _InteractionTracking.default.on('change', _classPrivateFieldGet(_onChange, this));
  }
  navigate(url, target, _ref5) {
    let {
      type
    } = _ref5;
    const result = _classPrivateFieldGet(_navigation, this).navigate(url, target, {
      type
    });
    if (typeof result === 'string') return window.open(result, target);
  }
}
exports.IFrameContext = IFrameContext;

/***/ }),

/***/ 342:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
__webpack_require__(3697);
var _activity = __webpack_require__(5264);
var _remotecontrol = __webpack_require__(3672);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.iframes.control');
function configure(bridge) {
  bridge.on('sync', (_, _ref) => {
    let {
      trusted
    } = _ref;
    if (!trusted) return debug('Ignoring untrusted sync event');
    _activity.MouseTracking.onChange = state => bridge.sendToParent('mouse', state);
    _activity.MouseTracking.track(window);
  });

  // Mouse events will also be sent up from cross document iframes as
  // the parent page is not allowed events obscured by xdoc iframes.
  bridge.on('mouse', (mouse, _ref2) => {
    let {
      iframe
    } = _ref2;
    debug('Received mouse event in', mouse, document, 'from', iframe);
    // if the message didn't come from an iframe in the page
    // then we should ignore it
    if (!iframe) return;
    _activity.MouseTracking.setPosition(mouse.x, mouse.y, iframe);
    _activity.MouseTracking.setDown(mouse.down);
  });

  // Control events will be sent down from the parent page and should
  // be applied by the iframe that contains the relevant DOM nodes
  bridge.on('control', (control, _ref3) => {
    let {
      trusted,
      trustedOnly
    } = _ref3;
    debug('Received control event in', document);
    if (!trusted) return debug('Ignoring untrusted control event');else _remotecontrol.ControlEvents.applyEvent(...control);

    // Forward control events down into child iframes
    bridge.broadcastToChildren('control', control, {
      trustedOnly
    });
  });
}

/***/ }),

/***/ 3350:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _protected = _interopRequireDefault(__webpack_require__(7609));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.iframes.sessions');
function configure(bridge, delegate) {
  function publish(session) {
    const serializedSanitizedSession = session[_protected.default].serializeSanitized();
    bridge.broadcastToChildren('session', serializedSanitizedSession, {
      trustedOnly: false
    });
    // if we have the full session we need to send it out to trusted
    // children only
    if (session.id()) {
      const serializedSession = session[_protected.default].serialize();
      bridge.broadcastToChildren('session', serializedSession, {
        trustedOnly: true
      });
    }
  }

  // When we know if we can trust an iframe or not, we can then share the
  // session state. Untrusted iframes get a sanitized version of the session.
  function onTrust(_, _ref) {
    let {
      iframe,
      trusted
    } = _ref;
    if (!iframe) return;
    const currentSession = delegate.currentSession;

    // xdoc iframes which haven't established a trusted relationship
    // will receive a sanitized variant of the session
    if (currentSession) {
      const serializedSession = trusted ? currentSession[_protected.default].serialize() : currentSession[_protected.default].serializeSanitized();
      bridge.send(iframe.contentWindow, 'session', serializedSession, {
        trustedOnly: trusted
      });
    }
  }
  bridge.on('trust', onTrust);

  // Session events are sent down from the parent page. Untrusted
  // xdoc iframes will receive a sanitized variant of the session
  function onSession(serializedSession, _ref2) {
    let {
      trusted,
      fromParent
    } = _ref2;
    if (!trusted) return debug('Ignoring untrusted session event');
    if (!fromParent) return;
    // we'll update the currentSession in place which will trigger a session
    // update event
    delegate.currentSession[_protected.default].deserialize(serializedSession);

    // we can then re-publish the event to our children so they're updated too
    publish(delegate.currentSession);
  }
  bridge.on('session', onSession);
  return {
    publish,
    unsubscribe: () => {
      bridge.off('trust', onTrust);
      bridge.off('session', onSession);
    }
  };
}

/***/ }),

/***/ 8232:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
__webpack_require__(3697);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _Deferred = __webpack_require__(3976);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.iframes.sync');
function configure(bridge, delegate) {
  let {
    waitForParentSync
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let syncDataReceived = waitForParentSync ? new _Deferred.Deferred() : true;
  let syncData;
  function config(data) {
    return {
      redactedViews: [...((data === null || data === void 0 ? void 0 : data.redactedViews) || []), ...(delegate.redactedViews || [])],
      unredactedViews: [...((data === null || data === void 0 ? void 0 : data.unredactedViews) || []), ...(delegate.unredactedViews || [])],
      universalLinks: (data === null || data === void 0 ? void 0 : data.universalLinks) || delegate.universalLinks || [],
      pdfLinks: (data === null || data === void 0 ? void 0 : data.pdfLinks) || delegate.pdfLinks || [],
      api: (data === null || data === void 0 ? void 0 : data.api) || delegate.api
    };
  }
  function configForSync(data) {
    const cfg = config(data);
    return _objectSpread(_objectSpread({}, cfg), {}, {
      // string selectors are only applied to the current domain
      redactedViews: cfg.redactedViews.filter(selector => typeof selector !== 'string'),
      unredactedViews: cfg.unredactedViews.filter(selector => typeof selector !== 'string')
    });
  }

  // Init events are sent up from the xdoc iframe
  // if we get an init message from an iframe we're tracking,
  // then we probably need to force a sync as the snippet was possibly
  // loaded in a delayed fashion in the iframe
  async function onInit(_, _ref) {
    let {
      iframe
    } = _ref;
    if (!iframe) return;

    // child iframes can publish init messages before the parent
    // iframe has recieved a sync form it's parent. We need to wait
    // until the sync event from the parent has completed before
    // we can send any sync events to our children
    await syncDataReceived.promise;

    // note: for top level frames the syncData will be undefined, config
    // will be read directly from the main delegate.
    bridge.send(iframe.contentWindow, 'sync', configForSync(syncData), {
      trustedOnly: false
    });
  }
  bridge.on('init', onInit);

  // Discovery events will be sent from the bridge when the track()
  // method is invoked, either from the observer or init event
  function onIframeDiscovered(iframe) {
    debug('iframe available', iframe, 'issuing sync');
    if (iframe) onInit(null, {
      iframe
    });
  }
  bridge.on('iframe_discovered', onIframeDiscovered);

  // Sync events will be sent from the parent page to setup config data
  function onSync(data, _ref2) {
    let {
      source,
      origin,
      trusted
    } = _ref2;
    if (!trusted) return debug('Ignoring untrusted sync event');

    // store the sync data for forwarding to child iframes on discovery
    syncData = data;
    syncDataReceived.resolve();

    // forward sync event to all children
    bridge.broadcastToChildren('sync', configForSync(data), {
      trustedOnly: false
    });
  }
  bridge.on('sync', onSync);
  return {
    getSyncedConfig: async () => {
      await syncDataReceived.promise;
      return config(syncData);
    },
    unsubscribe: () => {
      syncData = null;
      syncDataReceived = waitForParentSync ? new _Deferred.Deferred() : true;
      bridge.off('init', onInit);
      bridge.off('iframe_discovered', onIframeDiscovered);
      bridge.off('sync', onSync);
    },
    sendSync: async () => {
      await syncDataReceived.promise;
      bridge.broadcastToChildren('sync', configForSync(syncData), {
        trustedOnly: false
      });
    }
  };
}

/***/ }),

/***/ 8109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configure = configure;
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.iframes.trust');
function configure(bridge) {
  // Child iframes will response to sync events with a trust event, this allows
  // the parent to know the child frames origin and determine whether it is
  // trusted ro not.
  bridge.on('sync', (_, _ref) => {
    let {
      trusted
    } = _ref;
    if (!trusted) return debug('Ignoring untrusted sync event');
    // send trust state immediately
    bridge.sendToParent('trust', null, {
      trustedOnly: false
    });
    // but also send it again after the page is fully loaded
    // as the iframe load event in our parent that breaks the
    // trust only triggers on fully loaded pages
    if (document.readyState !== 'complete') {
      window.addEventListener('load', () => {
        bridge.sendToParent('trust', null, {
          trustedOnly: false
        });
      }, {
        once: true,
        capture: true
      });
    }
  });

  // if a child iframe navigates we need to stop trusting it
  // until it re-reports it's origin via a new trust event
  const breakTrustRelationship = _ref2 => {
    let {
      target
    } = _ref2;
    bridge.breakTrust(target.contentWindow);
  };

  // Trust events are sent up from the xdoc iframe after
  // it receives a sync event. Trust events are used to attempt to
  // associate a particular iframe to an origin which we trust
  bridge.on('trust', (_, _ref3) => {
    let {
      iframe,
      origin
    } = _ref3;
    if (!iframe) return;

    // each time an iframe loads we must remove the trusted
    // origin and wait for a new trust event from the iframe
    iframe.removeEventListener('load', breakTrustRelationship, {
      capture: true
    });
    iframe.addEventListener('load', breakTrustRelationship, {
      capture: true
    });

    // this marks an iframe as trusted, so when we need to broadcast
    // messages only to trusted iframes we can determine the list easily
    bridge.establishTrust(iframe.contentWindow, origin);
  });
}

/***/ }),

/***/ 7966:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.initIframeBridgeAsChild = initIframeBridgeAsChild;
exports.initIframeBridgeAsParent = initIframeBridgeAsParent;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _cocom = __webpack_require__(3439);
var _IFrameContext = __webpack_require__(1149);
var _Session = _interopRequireDefault(__webpack_require__(2404));
var trust = _interopRequireWildcard(__webpack_require__(8109));
var control = _interopRequireWildcard(__webpack_require__(342));
var sessions = _interopRequireWildcard(__webpack_require__(3350));
var sync = _interopRequireWildcard(__webpack_require__(8232));
var _protected = _interopRequireDefault(__webpack_require__(7609));
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _Highlight = _interopRequireDefault(__webpack_require__(6575));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.iframes');
const parent = (0, _cocom.closestXdocParent)();
const bridge = new _cocom.IFrameBridge(parent);

// common modules with no config differences for parent vs child usage
const rpc = new _cocom.IFrameRPC(bridge, parent);
trust.configure(bridge);
control.configure(bridge);
const trustProxy = api => session => {
  const sessionProxyUrl = session[_protected.default].proxyUrl();
  const proxyUrl = new URL(sessionProxyUrl, api);
  debug('trusting', proxyUrl.origin);
  bridge.automaticTrustedOrigins = [proxyUrl.origin];
};
function initIframeBridgeAsParent(delegate, _ref) {
  let {
    open
  } = _ref;
  // When the session in the top level parent changes we need
  // to pass this down to the child iframes.
  const sessionModule = sessions.configure(bridge, delegate);
  delegate.on('session.loaded', sessionModule.publish);
  delegate.on('session.updated', sessionModule.publish);

  // The page needs to trust the proxy origin automatically to
  // receive messages it needs to trust (e.g. rpc requests)
  const trustProxyForAPI = trustProxy(delegate.api);
  delegate.on('session.loaded', trustProxyForAPI);
  delegate.on('session.updated', trustProxyForAPI);

  // we need to pass config down to the iframes as they should
  // inherit settings from the top level page, e.g. universalLinks,
  // redaction settings etc...
  // We alos need to re-trigger a sync event if the agent side
  // re-requests the whole state of the page as we need the xdoc
  // iframes to re-serialise themselves
  const syncModule = sync.configure(bridge, delegate);
  delegate.on('session.sync', syncModule.sendSync);

  // The top level page is responsible for handling various RPC
  // calls like navigation confirmations and opening new tabs
  const onConfirmOpen = async _ref2 => {
    let {
      url,
      type
    } = _ref2;
    return {
      accepted: await delegate.confirmOpen(url, type)
    };
  };
  rpc.on('confirmOpen', onConfirmOpen);
  const onOpen = _ref3 => {
    let {
      url,
      target,
      windowFeatures,
      options
    } = _ref3;
    open(url, target, windowFeatures, options);
  };
  rpc.on('open', onOpen);
  bridge.start();
  return () => {
    sessionModule.unsubscribe();
    syncModule.unsubscribe();
    delegate.off('session.loaded', sessionModule.publish);
    delegate.off('session.updated', sessionModule.publish);
    delegate.off('session.loaded', trustProxyForAPI);
    delegate.off('session.updated', trustProxyForAPI);
    delegate.off('session.sync', syncModule.sendSync);
    rpc.off('confirmOpen', onConfirmOpen);
    rpc.off('open', onOpen);
  };
}
async function initIframeBridgeAsChild(delegate) {
  // create a placeholder session object for iframe contexts
  // as we wont have access to the "real" session object, that
  // lives in the root
  const currentSession = new _Session.default(delegate);
  const sessionModule = sessions.configure(bridge, {
    currentSession
  });

  // setup sync logic for passing config and content requests
  // down to child frames
  const syncModule = sync.configure(bridge, delegate, {
    waitForParentSync: true
  });
  bridge.start();

  // Get the config that is a merge of the iframes delegate config
  // and the ocnfig that is sent via postMessage. We might need to
  // wait for the sync event, hence getSyncedConfig() is async
  const config = await syncModule.getSyncedConfig();
  debug('synced config', config);
  let iframeContext;
  const updateContext = () => {
    // create a new context each time a new session starts
    if (currentSession.isActive() && !iframeContext) {
      debug('creating iframe context', iframeContext);
      trustProxy(config.api)(currentSession);
      iframeContext = new _IFrameContext.IFrameContext(currentSession, _objectSpread(_objectSpread({}, config), {}, {
        trustedOrigins: delegate.trustedOrigins,
        version: delegate.version,
        showDocument: delegate.showDocument,
        confirmOpen: (url, type) => rpc.send('confirmOpen', {
          url,
          type
        }),
        open: (url, target, windowFeatures, options) => rpc.send('open', {
          url,
          target,
          windowFeatures,
          options
        })
      }), bridge.sendToParent);

      // when the session ends we shoudl destroy the context so we're
      // in a clean state for the next session
      currentSession.once('ended', () => {
        debug('destroying iframe context', iframeContext);
        iframeContext.destroy();
        iframeContext = null;
      });
    }
  };
  bridge.on('session', updateContext);

  // we might be in an intermediate iframe so we need to
  // forward requests and responses up and down the tree
  // as only the SDK running as parent can respond
  const forwardReq = (req, _ref4) => {
    let {
      trustedOnly
    } = _ref4;
    return bridge.sendToParent('rpc:request', req, {
      trustedOnly
    });
  };
  bridge.on('rpc:request', forwardReq);
  // responses broadcast downwards to children
  const forwardRes = (res, _ref5) => {
    let {
      trustedOnly
    } = _ref5;
    return bridge.broadcastToChildren('rpc:response', res, {
      trustedOnly
    });
  };
  bridge.on('rpc:response', forwardRes);

  // force a re-send of frame data on agent sync messages
  const invalidateFrame = () => {
    var _iframeContext;
    return (_iframeContext = iframeContext) === null || _iframeContext === void 0 ? void 0 : _iframeContext.invalidateFrame();
  };
  bridge.on('sync', invalidateFrame);

  // force a re-send of node data on load-error messages
  const onRemoteError = (data, _ref6) => {
    var _iframeContext2;
    let {
      trustedOnly
    } = _ref6;
    const {
      target,
      error: {
        cause
      }
    } = data;
    // TODO: remove backwards compatibility when frontend sends target as an object
    const nodeId = typeof target === 'string' ? target : target.id;
    if (cause === 'load-error') (_iframeContext2 = iframeContext) === null || _iframeContext2 === void 0 || _iframeContext2.partialSync(nodeId);
    bridge.broadcastToChildren('remote-error', data, {
      trustedOnly
    });
  };
  bridge.on('remote-error', onRemoteError);
  const onHighlight = async event => _Highlight.default.highlight(delegate, event);
  bridge.on('highlight', onHighlight);
  return () => {
    syncModule.unsubscribe();
    sessionModule.unsubscribe();
    bridge.off('highlight', onHighlight);
    bridge.off('remote-error', onRemoteError);
    bridge.off('sync', invalidateFrame);
    bridge.off('session', updateContext);
    bridge.off('rpc:request', forwardReq);
    bridge.off('rpc:response', forwardRes);
  };
}
var _default = exports["default"] = bridge;

/***/ }),

/***/ 7988:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(3697);
// Import all locale JSON files in the current directory
const context = __webpack_require__(6277);
const Translations = context.keys().reduce((translations, file) => {
  const lang = file.replace('./', '').replace('.json', '');
  translations[lang] = context(file);
  return translations;
}, {});
const rightToLeftLocales = ['ar', 'he', 'fa', 'ur'];
class Locale {
  static getLocale() {
    for (const l of navigator.languages) {
      if (Translations[l]) return new Locale(l);
      if (l.includes('-')) {
        const major = l.split('-')[0].toLowerCase();
        if (Translations[major]) return new Locale(major);
      }
    }
    return new Locale('en');
  }
  static tr(key) {
    return this.getLocale().translate(key);
  }
  static direction() {
    return this.getLocale().direction;
  }
  constructor(language) {
    this.language = language;
    this.direction = rightToLeftLocales.includes(language) ? 'rtl' : 'ltr';
  }
  translate(key) {
    return Translations[this.language][key] || Translations.en[key] || key;
  }
}
exports["default"] = Locale;

/***/ }),

/***/ 4661:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.NAVIGATION_TYPE = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _NavigationTracking = _interopRequireDefault(__webpack_require__(6356));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const NAVIGATION_TYPE = exports.NAVIGATION_TYPE = {
  PDF: 'pdf',
  XDOC: 'xdoc',
  UNIVERSAL: 'universal'
};
var _shouldNavigate = /*#__PURE__*/new WeakMap();
var _handlers = /*#__PURE__*/new WeakMap();
var _handleNavigation = /*#__PURE__*/new WeakMap();
var _beforeNavigate = /*#__PURE__*/new WeakMap();
var _navigateToBlockedScreen = /*#__PURE__*/new WeakMap();
class Navigation {
  constructor(delegate) {
    _classPrivateFieldInitSpec(this, _shouldNavigate, void 0);
    _classPrivateFieldInitSpec(this, _handlers, void 0);
    _classPrivateFieldInitSpec(this, _handleNavigation, void 0);
    _defineProperty(this, "findHandlerByUrl", u => {
      if (!u) return null;
      try {
        const url = new URL(u, window.location.origin);
        return _classPrivateFieldGet(_handlers, this).find(h => h.shouldHandle(url));
      } catch (err) {
        console.warn('CobrowseIO: Failed to infer navigation type', err);
        return null;
      }
    });
    _defineProperty(this, "findHandlerByType", type => _classPrivateFieldGet(_handlers, this).find(h => h.type === type));
    _classPrivateFieldInitSpec(this, _beforeNavigate, (url, target, windowFeatures, _ref) => {
      let {
        name,
        go,
        e
      } = _ref;
      const handler = this.findHandlerByUrl(url);
      if (handler && !handler.shouldHandleEvent(e)) {
        if (e.eventPhase === Event.BUBBLING_PHASE) console.warn('CobrowseIO: Inferred navigation type but event is already handled');
        return {
          rewrittenUrl: url
        };
      }
      const currentWindow = e.view || window;
      const block = () => _classPrivateFieldGet(_navigateToBlockedScreen, this).call(this, currentWindow, e);
      return _classPrivateFieldGet(_handleNavigation, this).call(this, url, target, windowFeatures, {
        name,
        go,
        e,
        type: handler === null || handler === void 0 ? void 0 : handler.type,
        block
      });
    });
    _classPrivateFieldInitSpec(this, _navigateToBlockedScreen, (currentWindow, e) => {
      if (e.eventPhase === Event.CAPTURING_PHASE) return;
      const root = currentWindow.document;
      const overlayElement = root.createElement('div');
      overlayElement.style.position = 'fixed';
      overlayElement.style.top = 0;
      overlayElement.style.left = 0;
      overlayElement.style.width = '100vw';
      overlayElement.style.height = '100vh';
      overlayElement.style.backgroundColor = 'black';
      overlayElement.style.zIndex = '2147483647';
      overlayElement.style.margin = 0;
      overlayElement.style.padding = 0;
      overlayElement.style.border = 0;
      overlayElement.style.borderRadius = 0;
      const originalOverflow = root.body.style.overflow;
      root.body.style.overflow = 'hidden';
      root.body.appendChild(overlayElement);
      const restore = () => {
        if (root.body.contains(overlayElement)) root.body.removeChild(overlayElement);
        root.body.style.overflow = originalOverflow;
        currentWindow.removeEventListener('popstate', restore);
      };
      currentWindow.addEventListener('popstate', restore);
      currentWindow.history.pushState({}, '');
    });
    _defineProperty(this, "destroy", () => {
      _NavigationTracking.default.beforeNavigate = null;
    });
    _classPrivateFieldSet(_shouldNavigate, this, delegate.shouldNavigate);
    _classPrivateFieldSet(_handlers, this, delegate.handlers);
    _classPrivateFieldSet(_handleNavigation, this, delegate.handleNavigation);
    _NavigationTracking.default.beforeNavigate = _classPrivateFieldGet(_beforeNavigate, this);
  }
  runHandler(url, target, windowFeatures, options) {
    if (!url) return {
      rewrittenUrl: url
    };
    const handler = options.type != null ? this.findHandlerByType(options.type) : this.findHandlerByUrl(url);
    if (!handler) return {
      rewrittenUrl: url
    };
    if (!_classPrivateFieldGet(_shouldNavigate, this).call(this, handler.type)) return {
      rewrittenUrl: url
    };
    return handler.handle(url, target, windowFeatures, options);
  }
}
exports["default"] = Navigation;

/***/ }),

/***/ 9301:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class NavigationHandler {
  get type() {
    throw new Error("Getter 'type' must be implemented.");
  }
  shouldHandleEvent(e) {
    throw new Error("Method 'shouldHandleEvent()' must be implemented.");
  }
  shouldHandle(url) {
    throw new Error("Method 'shouldHandle()' must be implemented.");
  }
  handle(url, target, windowFeatures, options) {
    throw new Error("Method 'handle()' must be implemented.");
  }
}
exports["default"] = NavigationHandler;

/***/ }),

/***/ 6356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _splitNameFromTarget = __webpack_require__(2117);
var _formAttributes = __webpack_require__(0);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
class CustomViewEvent extends Event {
  constructor(type, options) {
    super(type, options);
    this._view = options.view;
  }
  get view() {
    return this._view;
  }
}
var _windows = /*#__PURE__*/new WeakMap();
var _handleClickEvent = /*#__PURE__*/new WeakMap();
var _handleSubmitEvent = /*#__PURE__*/new WeakMap();
var _handleWindowOpenTap = /*#__PURE__*/new WeakMap();
var _handleFormSubmitTap = /*#__PURE__*/new WeakMap();
class NavigationTracking {
  constructor() {
    var _this = this;
    _defineProperty(this, "beforeNavigate", void 0);
    _classPrivateFieldInitSpec(this, _windows, new Set());
    _defineProperty(this, "track", root => {
      root.addEventListener('click', _classPrivateFieldGet(_handleClickEvent, this), {
        capture: true
      });
      root.addEventListener('click', _classPrivateFieldGet(_handleClickEvent, this));
      root.addEventListener('submit', _classPrivateFieldGet(_handleSubmitEvent, this));
    });
    _defineProperty(this, "untrack", root => {
      root.removeEventListener('click', _classPrivateFieldGet(_handleClickEvent, this), {
        capture: true
      });
      root.removeEventListener('click', _classPrivateFieldGet(_handleClickEvent, this));
      root.removeEventListener('submit', _classPrivateFieldGet(_handleSubmitEvent, this));
    });
    _defineProperty(this, "tap", window => {
      if (_classPrivateFieldGet(_windows, this).has(window)) return;
      const self = this;
      const {
        open
      } = window;
      window.open = function () {
        for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
          rest[_key] = arguments[_key];
        }
        return _classPrivateFieldGet(_handleWindowOpenTap, self).call(self, this, open, ...rest);
      };
      const {
        submit
      } = window.HTMLFormElement.prototype;
      window.HTMLFormElement.prototype.submit = function () {
        for (var _len2 = arguments.length, rest = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          rest[_key2] = arguments[_key2];
        }
        return _classPrivateFieldGet(_handleFormSubmitTap, self).call(self, this, submit, ...rest);
      };
      _classPrivateFieldGet(_windows, this).add(window);
    });
    _defineProperty(this, "untap", _window => {
      // we can't safely remove the patches applied
      // to the window so we leave these in place
    });
    _classPrivateFieldInitSpec(this, _handleClickEvent, e => {
      var _e$target;
      if (!this.beforeNavigate) return;
      const anchor = e === null || e === void 0 || (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest('a');
      if (!anchor) return;
      if (!anchor.href) return;
      if (anchor.__cbio_forceDefaultNavigation) return;
      const go = () => {
        anchor.__cbio_forceDefaultNavigation = true;
        anchor.click();
        delete anchor.__cbio_forceDefaultNavigation;
      };
      const {
        target,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)(anchor.target, '_self');
      const {
        rewrittenUrl,
        windowProxy
      } = this.beforeNavigate(anchor.href, target, '', {
        name,
        go,
        e
      });

      // preserve relative or absolute URLs if they aren't rewritten
      const isRewrittenUrl = rewrittenUrl && rewrittenUrl !== anchor.href;
      if (isRewrittenUrl) anchor.href = rewrittenUrl;
      if (windowProxy) e.preventDefault();
    });
    _classPrivateFieldInitSpec(this, _handleSubmitEvent, e => {
      var _e$target2;
      if (!this.beforeNavigate) return;
      const form = e === null || e === void 0 || (_e$target2 = e.target) === null || _e$target2 === void 0 ? void 0 : _e$target2.closest('form');
      if (!form) return;
      if (!(0, _formAttributes.getFormAttribute)(form, 'action')) return;
      if (form.__cbio_forceDefaultNavigation) return;
      const go = () => {
        form.__cbio_forceDefaultNavigation = true;
        form.submit();
        delete form.__cbio_forceDefaultNavigation;
      };
      const {
        target,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)((0, _formAttributes.getFormAttribute)(form, 'target'), '_self');
      const {
        rewrittenUrl,
        windowProxy
      } = this.beforeNavigate((0, _formAttributes.getFormAttribute)(form, 'action'), target, '', {
        name,
        go,
        e
      });
      if (rewrittenUrl) (0, _formAttributes.setFormAttribute)(form, 'action', rewrittenUrl);
      if (windowProxy) e.preventDefault();
    });
    _classPrivateFieldInitSpec(this, _handleWindowOpenTap, (ctx, windowOpen, url, target, windowFeatures) => {
      if (!this.beforeNavigate) return windowOpen.call(ctx, url, target, windowFeatures);
      const go = () => windowOpen.call(ctx, url, target, windowFeatures);
      const e = new CustomViewEvent('WindowOpen', {
        view: ctx
      });
      const {
        target: newTarget,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)(target, '_blank');
      const {
        rewrittenUrl,
        windowProxy
      } = this.beforeNavigate(url, newTarget, windowFeatures, {
        name,
        go,
        e
      });
      if (rewrittenUrl) return windowOpen.call(ctx, rewrittenUrl, target, windowFeatures);
      if (windowProxy) return windowProxy;
    });
    _classPrivateFieldInitSpec(this, _handleFormSubmitTap, function (ctx, formSubmit) {
      for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        rest[_key3 - 2] = arguments[_key3];
      }
      if (!_this.beforeNavigate) return formSubmit.call(ctx, ...rest);
      const parent = ctx.parentElement;
      const go = () => {
        // form submission can be asynchronous when using the go() method, we need
        // to ensure the form is still attached when we come back to submit it
        const requiresReattachment = document.contains(parent) && !document.contains(ctx);
        if (requiresReattachment) parent.appendChild(ctx);
        const result = formSubmit.call(ctx, ...rest);

        // make sure the form is removed after submission as that is the intended state
        if (requiresReattachment) ctx.remove();
        return result;
      };
      const e = new CustomViewEvent('FormSubmit', {
        view: ctx.ownerDocument.defaultView
      });
      const {
        target,
        name
      } = (0, _splitNameFromTarget.splitNameFromTarget)((0, _formAttributes.getFormAttribute)(ctx, 'target'), '_self');
      const {
        rewrittenUrl,
        windowProxy
      } = _this.beforeNavigate((0, _formAttributes.getFormAttribute)(ctx, 'action'), target, '', {
        name,
        go,
        e
      });
      if (rewrittenUrl) (0, _formAttributes.setFormAttribute)(ctx, 'action', rewrittenUrl);
      if (windowProxy) return null;
      return formSubmit.call(ctx, ...rest);
    });
  }
}
var _default = exports["default"] = new NavigationTracking();

/***/ }),

/***/ 9715:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3697);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "NAVIGATION_TYPE", ({
  enumerable: true,
  get: function () {
    return _Navigation.NAVIGATION_TYPE;
  }
}));
Object.defineProperty(exports, "Navigation", ({
  enumerable: true,
  get: function () {
    return _Navigation.default;
  }
}));
Object.defineProperty(exports, "NavigationHandler", ({
  enumerable: true,
  get: function () {
    return _NavigationHandler.default;
  }
}));
Object.defineProperty(exports, "NavigationTracking", ({
  enumerable: true,
  get: function () {
    return _NavigationTracking.default;
  }
}));
var _Navigation = _interopRequireWildcard(__webpack_require__(4661));
var _NavigationTracking = _interopRequireDefault(__webpack_require__(6356));
var _NavigationHandler = _interopRequireDefault(__webpack_require__(9301));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

/***/ }),

/***/ 9931:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getCacheContent = exports.applyContentCache = void 0;
var _NodeTracker = _interopRequireDefault(__webpack_require__(4822));
var _getCssText = __webpack_require__(9768);
var _DataUrl = _interopRequireDefault(__webpack_require__(1762));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const fetchCrossOriginImage = url => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = url;
    img.onload = () => {
      try {
        const dataUrl = _DataUrl.default.fromImage(img);
        resolve(dataUrl);
      } catch (error) {
        reject(error);
      }
    };
    img.onerror = reject;
  });
};
const fetchCrossOriginLink = url => {
  return new Promise((resolve, reject) => {
    const link = document.createElement('link');
    link.crossOrigin = 'anonymous';
    link.rel = 'stylesheet';
    link.href = url;
    link.setAttribute('class', '__cbio_ignored');
    link.onload = () => {
      try {
        const cssText = (0, _getCssText.getCssText)(link.sheet);
        resolve(cssText);
      } catch (error) {
        reject(error);
      } finally {
        link.remove();
      }
    };
    link.onerror = err => {
      link.remove();
      reject(err);
    };
    document.head.appendChild(link);
  });
};
const getUrlForNode = node => {
  if (node.tagName === 'IMG') return node.src;
  if (node.tagName === 'LINK') return node.href;
  return null;
};
const updateCacheContent = (node, content) => {
  const url = getUrlForNode(node);
  node.__cbio_content_cache = node.__cbio_content_cache || {};
  node.__cbio_content_cache[url] = content;
};
const cacheImgContent = async node => {
  if (getCacheContent(node)) return;
  const url = getUrlForNode(node);
  const getDataUrl = async () => {
    try {
      return _DataUrl.default.fromImage(node);
    } catch (_error) {}
    try {
      return await fetchCrossOriginImage(url);
    } catch (_error) {}
  };
  const dataUrl = await getDataUrl();
  if (dataUrl) updateCacheContent(node, dataUrl);
};
const cacheLinkContent = async node => {
  if (getCacheContent(node)) return;
  const url = getUrlForNode(node);
  const getCss = async () => {
    try {
      if (node.sheet) return (0, _getCssText.getCssText)(node.sheet);
    } catch (_error) {}
    try {
      return await fetchCrossOriginLink(url);
    } catch (_error) {}
  };
  const css = await getCss();
  if (css) updateCacheContent(node, css);
};
const getCacheContent = node => {
  var _node$__cbio_content_;
  const url = getUrlForNode(node);
  return (_node$__cbio_content_ = node.__cbio_content_cache) === null || _node$__cbio_content_ === void 0 ? void 0 : _node$__cbio_content_[url];
};
exports.getCacheContent = getCacheContent;
const applyContentCache = async nodeId => {
  const node = _NodeTracker.default.getById(nodeId);
  if (!node) return;
  if (node.tagName === 'IMG') return cacheImgContent(node);
  if (node.tagName === 'LINK' && node.rel === 'stylesheet') return cacheLinkContent(node);
};
exports.applyContentCache = applyContentCache;

/***/ }),

/***/ 8708:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(9199);
__webpack_require__(3697);
var _src = __webpack_require__(9501);
var _redaction = __webpack_require__(6566);
var _NodeTracker = _interopRequireDefault(__webpack_require__(4822));
var _NodeUtils = _interopRequireDefault(__webpack_require__(8571));
var _NodeTree = _interopRequireDefault(__webpack_require__(2588));
var _DataUrl = _interopRequireDefault(__webpack_require__(1762));
var _getScrollBarSize = __webpack_require__(7384);
var _getCssText = __webpack_require__(9768);
var _NodeContent = __webpack_require__(9931);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class NodeSerializer {
  constructor() {
    var _this = this;
    _defineProperty(this, "isLocalResource", url => {
      if (/^https?:\/\/localhost/.test(url)) return true;
      if (/^https?:\/\/127.0.0.1/.test(url)) return true;
      if (/^file:\/\//.test(url)) return true;
      if (/^blob:/.test(url)) return true;
      if (/^ionic:/.test(url)) return true;
      return false;
    });
    _defineProperty(this, "serializeAdoptedStyleSheets", node => {
      try {
        // the try here is because some shadow DOM polyfills (looking at you salesforce)
        // are broken and throw errors when calling adoptedStyleSheets
        let rules = [];
        [...(node.adoptedStyleSheets || [])].forEach(sheet => {
          rules = rules.concat([].slice.call(sheet.cssRules));
        });
        return (0, _getCssText.getCssText)({
          cssRules: rules
        });
      } catch (e) {
        console.warn('CobrowseIO: AdoptedStyleSheets serialize failed:', e.message, 'for', node);
        return '';
      }
    });
    _defineProperty(this, "_serializeAttributes", (node, serialized) => {
      if (node.nodeType === window.Node.ELEMENT_NODE && node.attributes) {
        const valueMap = {};
        Array.from(node.attributes || []).forEach(attr => {
          if (attr.nodeName === 'href' || attr.nodeName === 'src') {
            valueMap[attr.nodeName] = typeof node[attr.nodeName] === 'string'
            // use the node property for an absolute path if it's a string type
            ? node[attr.nodeName]
            // otherwise use the value as is (some nodes like <image> in <svg> act
            // differently and return objects)
            // TODO: these could be relative URLs which will then not get proxied, so
            //       we liekly need some way to convert them to absolute URLs before
            //       we send them
            : attr.nodeValue;
          } else {
            valueMap[attr.nodeName] = attr.nodeValue;
          }
        });
        serialized.attributes = valueMap;
      }
    });
    _defineProperty(this, "_serializeSelection", (node, serialized) => {
      var _node$activeElement;
      let serializedSelection = null;
      const selection = node.getSelection();
      if (selection && selection.type === 'Range' && !selection.isCollapsed && selection.rangeCount > 0) {
        try {
          // gecko browsers support multiple selections.
          // see: https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount
          serializedSelection = [...Array(selection.rangeCount)].reduce((acc, _, idx) => {
            var _RedactionIndexProvid, _RedactionIndexProvid2;
            const range = selection.getRangeAt(idx);
            const {
              startOffset,
              endOffset
            } = range;

            // if an element is redacted by another than the element being selected won't
            // be available on the agent view. As such we find the element which causes the
            // redaction and use that instead
            const startRedactedBy = (_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid === void 0 ? void 0 : _RedactionIndexProvid.getRedactedBy(range.startContainer);
            const endRedactedBy = (_RedactionIndexProvid2 = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid2 === void 0 ? void 0 : _RedactionIndexProvid2.getRedactedBy(range.endContainer);
            const start = _NodeTracker.default.get(startRedactedBy !== null && startRedactedBy !== void 0 ? startRedactedBy : range.startContainer);
            const end = _NodeTracker.default.get(endRedactedBy !== null && endRedactedBy !== void 0 ? endRedactedBy : range.endContainer);
            acc.push({
              start,
              end,
              // if the element is redacted by a parent than we need to use offset 0 instead
              // of the actually selected offset
              startOffset: startRedactedBy ? 0 : startOffset,
              endOffset: endRedactedBy ? 0 : endOffset
            });
            return acc;
          }, []);
        } catch (err) {
          console.warn('CobrowseIO: Could not serialize text selection', err);
        }
      } else if (['INPUT', 'TEXTAREA'].includes((_node$activeElement = node.activeElement) === null || _node$activeElement === void 0 ? void 0 : _node$activeElement.tagName) && node.activeElement.selectionStart !== node.activeElement.selectionEnd) {
        // when an input has a selection we set it to false to tell the frontend application to not reset the selection as
        // it's being handled on the input level
        serializedSelection = false;
      }
      serialized.selection = serializedSelection;
    });
    _defineProperty(this, "_serializeDocument", (node, serialized) => {
      if (node.nodeType === window.Node.DOCUMENT_NODE) {
        var _node$defaultView$vis, _node$defaultView, _node$defaultView2, _node$documentElement, _node$defaultView3, _node$documentElement2;
        serialized.url = node.location && node.location.href;

        // viewport scaling is not supported yet so we default
        // to client dimensions if the viewport is scaled
        const isViewportUnscaled = ((_node$defaultView$vis = (_node$defaultView = node.defaultView) === null || _node$defaultView === void 0 || (_node$defaultView = _node$defaultView.visualViewport) === null || _node$defaultView === void 0 ? void 0 : _node$defaultView.scale) !== null && _node$defaultView$vis !== void 0 ? _node$defaultView$vis : 1) === 1;
        const useInnerDimensions = (0, _getScrollBarSize.getScrollBarSize)() === 0 && isViewportUnscaled;
        const width = useInnerDimensions ? (_node$defaultView2 = node.defaultView) === null || _node$defaultView2 === void 0 ? void 0 : _node$defaultView2.innerWidth : (_node$documentElement = node.documentElement) === null || _node$documentElement === void 0 ? void 0 : _node$documentElement.clientWidth;
        const height = useInnerDimensions ? (_node$defaultView3 = node.defaultView) === null || _node$defaultView3 === void 0 ? void 0 : _node$defaultView3.innerHeight : (_node$documentElement2 = node.documentElement) === null || _node$documentElement2 === void 0 ? void 0 : _node$documentElement2.clientHeight;
        serialized.size = {
          width,
          height
        };
        serialized.focus = _NodeTracker.default.get(node.activeElement);
        const serializeDoctype = doctype => ({
          name: doctype.name,
          publicId: doctype.publicId,
          systemId: doctype.systemId
        });
        serialized.doctype = node.doctype != null ? serializeDoctype(node.doctype) : null;
        serialized.css = this.serializeAdoptedStyleSheets(node);
        this._serializeSelection(node, serialized);
      }
    });
    _defineProperty(this, "_serializeInput", (node, serialized) => {
      if (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA' || node.tagName === 'OPTION') {
        serialized.value = node.value;
        if ((node.type === 'radio' || node.type === 'checkbox') && typeof node.checked !== 'undefined') {
          serialized.checked = node.checked;
        }
        serialized.selection = null;
        try {
          const {
            selectionStart,
            selectionEnd,
            selectionDirection
          } = node;

          // this should be on a try catch and only appled to the correct input.type as
          // defined under https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
          if (selectionStart !== selectionEnd && node === node.ownerDocument.activeElement) {
            serialized.selection = {
              start: selectionStart,
              end: selectionEnd,
              direction: selectionDirection
            };
          }
        } catch (err) {
          console.warn('Failed to serialise text selection for the input', node);
        }
      }
    });
    _defineProperty(this, "_serializeSelect", (node, serialized) => {
      if (node.tagName === 'SELECT' && (!node.size || node.size === 1) && !node.multiple) {
        // selects are handled by our NativeSelect component
        serialized.preventDefault = true;
      }
    });
    _defineProperty(this, "_serializeOption", (node, serialized) => {
      if (node.tagName === 'OPTION') {
        serialized.selected = node.selected;
      }
    });
    _defineProperty(this, "_serializeShadowRoot", (node, serialized) => {
      if (node.nodeType === window.Node.DOCUMENT_FRAGMENT_NODE) {
        serialized.css = this.serializeAdoptedStyleSheets(node);
      }
    });
    _defineProperty(this, "_serializeStyle", (node, serialized) => {
      var _node$tagName;
      // note: SVG style tags can have lowercase names
      if (((_node$tagName = node.tagName) === null || _node$tagName === void 0 ? void 0 : _node$tagName.toUpperCase()) === 'STYLE') {
        try {
          if (node.sheet) serialized.css = (0, _getCssText.getCssText)(node.sheet);
        } catch (e) {
          console.warn('CobrowseIO: CSS serialize failed:', e.message, 'for', node);
        }
      }
    });
    _defineProperty(this, "_serializeLinkStyleSheet", (node, serialized) => {
      if (node.tagName === 'LINK' && node.rel === 'stylesheet') {
        const cachedContent = (0, _NodeContent.getCacheContent)(node);
        if (cachedContent) {
          serialized.css = cachedContent;
          return;
        }
        if (this.isLocalResource(node.href)) {
          try {
            if (node.sheet) serialized.css = (0, _getCssText.getCssText)(node.sheet);
          } catch (e) {
            console.warn('CobrowseIO: CSS serialize failed:', e.message, 'for', node);
          }
        }
      }
    });
    _defineProperty(this, "_serializeCanvas", (node, serialized, options) => {
      if (node.tagName === 'CANVAS' && !options.isRedacted && options.rasterizeCanvas) {
        try {
          var _node$attributes;
          const quality = parseFloat((_node$attributes = node.attributes) === null || _node$attributes === void 0 || (_node$attributes = _node$attributes['data-cbio-quality']) === null || _node$attributes === void 0 ? void 0 : _node$attributes.value) || 0.8;
          serialized.data = _DataUrl.default.fromCanvas(node, quality);
        } catch (e) {
          if (!node._cb_serialize_warned) {
            console.warn('Cobrowse failed to serialize canvas', node, 'due to error', e);
            node._cb_serialize_warned = true;
          }
        }
      }
    });
    _defineProperty(this, "_serializeImage", (node, serialized, options) => {
      if (node.tagName === 'IMG' && !options.isRedacted) {
        const cachedContent = (0, _NodeContent.getCacheContent)(node);
        if (cachedContent) {
          serialized.attributes.src = cachedContent;
          delete serialized.attributes.srcset;
          return;
        }
        if (this.isLocalResource(node.src)) {
          try {
            serialized.attributes.src = _DataUrl.default.fromImage(node);
            delete serialized.attributes.srcset;
          } catch (e) {
            console.warn('CobrowseIO: Failed to serialize image', node);
          }
        }
      }
    });
    _defineProperty(this, "_serializeScroll", (node, serialized) => {
      if ((0, _src.isxdoc)(node)) return;

      // IE11 is completely borked so we need to test document nodes
      // differently from everything else that scrolls
      if (node.nodeType === window.Node.DOCUMENT_NODE) {
        var _node$defaultView4, _node$defaultView5;
        serialized.scroll = {
          x: ((_node$defaultView4 = node.defaultView) === null || _node$defaultView4 === void 0 ? void 0 : _node$defaultView4.pageXOffset) || 0,
          y: ((_node$defaultView5 = node.defaultView) === null || _node$defaultView5 === void 0 ? void 0 : _node$defaultView5.pageYOffset) || 0
        };
      } else if (
      // we don't want to serialize the scroll on the HTML element as it's already
      // serialized on the document element
      node.tagName !== 'HTML' && (node.scrollWidth > node.clientWidth || node.scrollHeight > node.clientHeight)) {
        serialized.scroll = {
          x: node.scrollLeft || 0,
          y: node.scrollTop || 0
        };
      }
    });
    _defineProperty(this, "_serializeRedaction", (node, serialized, options) => {
      if (options.isRedacted) {
        delete serialized.value;

        // Get the visual size of the node
        const size = this._getSize(node);
        if (node.nodeType === 1) {
          // A regular element should have its display set to inline-block if it
          // were inline. This ensures that width/height from redaction will be
          // respected
          const style = window.getComputedStyle(node);

          // If this element has size and is inline, we cast it to inline-block so
          // it can accept size styling on the agent
          const display = style.display === 'inline' && size.height > 0 ? 'inline-block' : style.display;
          serialized.attributes = serialized.attributes && _objectSpread({
            id: serialized.attributes.id,
            class: serialized.attributes.class,
            // flex-basis: 0 will colapse the elements that do have any content which is the
            // case fo the redacted elements. We unset it to prevent this behaviour.
            // see: https://github.com/cobrowseio/cobrowse-sdk-js/pull/23
            // Regarding flex-shrink, it ensures that the calculated size is actually respected
            // and the size doesn't automatically colapse when flex is laying out the content
            style: "".concat(serialized.attributes.style || '', "; display: ").concat(display, " !important;flex-basis: unset !important;flex-shrink: 0;z-index:").concat(style.zIndex, ";")
          }, node.nodeName === 'EMBED' ? {
            src: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
          } : {});
        } else if (node.nodeType === 3) {
          // A redacted text node needs to be able to be given width and height on
          // the server side. So we convert it to a span
          serialized.nodeType = 1;
          serialized.tagName = 'SPAN';

          // Make it display: inline-block if we have to give it size, since
          // if it remains inline then it can't take styled size
          serialized.attributes = {
            style: size.height > 0 ? 'display: inline-block !important' : undefined
          };
        }
        serialized.redaction = {
          height: "".concat(size.height, "px"),
          width: "".concat(size.width, "px")
        };
      } else {
        serialized.redaction = undefined;
      }
    });
    _defineProperty(this, "_serializePseudoSelectors", (node, serialized) => {
      var _serialized$attribute, _serialized$attribute2, _serialized$attribute3;
      if (typeof node.matches !== 'function') return;
      (_serialized$attribute = serialized.attributes) === null || _serialized$attribute === void 0 || delete _serialized$attribute.__cbio_pseudo_hover;
      (_serialized$attribute2 = serialized.attributes) === null || _serialized$attribute2 === void 0 || delete _serialized$attribute2.__cbio_pseudo_active;
      (_serialized$attribute3 = serialized.attributes) === null || _serialized$attribute3 === void 0 || delete _serialized$attribute3.__cbio_pseudo_focus;
      serialized.attributes = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, serialized.attributes), node.matches(':hover') ? {
        __cbio_pseudo_hover: ''
      } : {}), node.matches(':active') ? {
        __cbio_pseudo_active: ''
      } : {}), node.matches(':focus') ? {
        __cbio_pseudo_focus: ''
      } : {});
    });
    _defineProperty(this, "_serializeVisibility", (node, serialized) => {
      delete serialized.hidden;
      if (!node.tagName) return;
      if (node.hidden || node.getAttribute('aria-hidden') === 'true' || !node.checkVisibility({
        visibilityProperty: true
      })) {
        serialized.hidden = true;
      }
    });
    _defineProperty(this, "_getSize", node => {
      const nodeType = node === null || node === void 0 ? void 0 : node.nodeType;
      if (nodeType == null) {
        return {
          height: 0,
          width: 0
        };
      } else if (nodeType === Node.ELEMENT_NODE) {
        return node.getBoundingClientRect();
      } else {
        const range = document.createRange();
        range.selectNodeContents(node);
        return range.getBoundingClientRect();
      }
    });
    _defineProperty(this, "_serialize", (node, options) => {
      if (!_NodeTracker.default.get(node)) {
        console.error('node missing id', node, node.parentNode);
        throw new Error('node missing id', node);
      }

      // check if this node looks like it's already been serialized
      // in which case we can skip it
      if (!_NodeUtils.default.isDOMNode(node)) return node;
      if (!node.nodeType) throw new Error('node missing type', node);
      const serialized = {
        id: _NodeTracker.default.get(node),
        nodeType: node.nodeType
      };
      this._serializeShadowRoot(node, serialized);
      this._serializeAttributes(node, serialized);
      this._serializeImage(node, serialized, options);
      this._serializeDocument(node, serialized);
      this._serializeScroll(node, serialized);
      this._serializeInput(node, serialized);
      this._serializeSelect(node, serialized);
      this._serializeOption(node, serialized);
      this._serializeStyle(node, serialized);
      this._serializeLinkStyleSheet(node, serialized);
      this._serializeCanvas(node, serialized, options);
      this._serializeRedaction(node, serialized, options);
      this._serializePseudoSelectors(node, serialized);
      this._serializeVisibility(node, serialized);
      if (node.tagName) serialized.tagName = node.tagName;
      if (node.nodeValue) serialized.content = node.nodeValue;
      return serialized;
    });
    _defineProperty(this, "serialize", function (root) {
      var _RedactionIndexProvid3;
      let overrideChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => undefined;
      let serializerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const redactedBy = (_RedactionIndexProvid3 = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid3 === void 0 ? void 0 : _RedactionIndexProvid3.getRedactedBy(root);

      // we ignore any nodes that are a child of a redacted node, so we should
      // not allow the serilizer to return anything for those nodes
      const ignored = redactedBy && redactedBy !== root || [root, ...(0, _src.parents)(root)].find(n => _NodeTree.default.isIgnored(n));
      if (ignored) return null;

      // We're ready to serialize the target node now, we'll do that first then work out
      // what to do aout serilizing its children.
      const serialized = _this._serialize(root, _objectSpread({
        isRedacted: Boolean(redactedBy)
      }, serializerOptions));
      if (serializerOptions.skipChildren) return serialized;

      // If this ndoe is the root of a redacted area, then we should not be serializing
      // any of it's children,so we'll short-circuit the tree traversal here. We'll also
      // make sure to return an emtpy list for the child nodes to wipe any children from
      // the serilized state.
      if (redactedBy) {
        overrideChildren([]);
        return _objectSpread(_objectSpread({}, serialized), {}, {
          childNodes: []
        });
      }

      // Fetch the child nodes based on the node type etc...
      const children = _NodeTree.default.children(root);
      // Some special cases (xdoc iframes) may not return any children information. This doesn't mean
      // that the nodes do not have children, but rather we can't determine the state of the children
      // right now.  In these cases we should not assume that there are no children, instead we should
      // also not return any children information (i.e. we must be careful not to send an empty childNodes
      // array by mistake asthis would imply that there are no children.
      if (children) {
        // convert DOM nodes to IDs, or use already serialized elements (from xdoc iframes)
        const childNodes = children.map(child => {
          if (!_NodeUtils.default.isDOMNode(child)) return _objectSpread({}, child);
          const nodeId = _NodeTracker.default.get(child);
          if (!nodeId) console.warn('child node missing id', child);
          return {
            id: nodeId
          };
        });
        return _objectSpread(_objectSpread({}, serialized), {}, {
          childNodes
        });
      }

      // Otherwise, just return the serilized state.
      return serialized;
    });
  }
}
var _default = exports["default"] = new NodeSerializer();

/***/ }),

/***/ 4822:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _randomString = _interopRequireDefault(__webpack_require__(8981));
var _NodeUtils = _interopRequireDefault(__webpack_require__(8571));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class NodeTracker {
  constructor() {
    _defineProperty(this, "_idMap", new Map());
    _defineProperty(this, "_nodeMap", new Map());
    _defineProperty(this, "_currentId", 0);
    _defineProperty(this, "_nextId", () => {
      this._currentId += 1;
      return this._currentId;
    });
    _defineProperty(this, "track", node => {
      if (!node) return null;
      if (!_NodeUtils.default.isDOMNode(node)) return node.id;
      if (!this.get(node)) {
        const isDocument = node.nodeType === window.Node.DOCUMENT_NODE;
        const id = isDocument ? (0, _randomString.default)(5) : "".concat(this.track(document), "-").concat(this._nextId());
        this._idMap.set(id, node);
        this._nodeMap.set(node, id);
      }
      return this._nodeMap.get(node);
    });
    _defineProperty(this, "get", node => {
      if (!node) return null;
      if (!_NodeUtils.default.isDOMNode(node)) return node.id;
      return this._nodeMap.get(node) || null;
    });
    _defineProperty(this, "getById", id => {
      if (!id) return null;
      return this._idMap.get(id) || null;
    });
    _defineProperty(this, "forget", node => {
      this._idMap.delete(this.get(node));
      this._nodeMap.delete(node);
    });
  }
}
var _default = exports["default"] = new NodeTracker();

/***/ }),

/***/ 2588:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _src = __webpack_require__(9501);
var _NodeUtils = _interopRequireDefault(__webpack_require__(8571));
var _unpolyfill = __webpack_require__(9883);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.NodeTree');
var _ignoredViews = /*#__PURE__*/new WeakMap();
class NodeTree {
  constructor() {
    _classPrivateFieldInitSpec(this, _ignoredViews, '.__cbio_ignored');
    _defineProperty(this, "isIgnored", target => {
      var _parent$tagName;
      // ignore any elements specifically marked with a class to be ignored
      if (target && target.matches && target.matches(_classPrivateFieldGet(_ignoredViews, this))) {
        debug('ignoring', target, 'because child of classes');
        return true;
      }

      // ignore a whole bunch of specific node types that don't
      // actually add visible content to the DOM, or aren't supported
      if ([window.Node.COMMENT_NODE, window.Node.CDATA_SECTION_NODE, window.Node.ENTITY_REFERENCE_NODE, window.Node.ENTITY_NODE, window.Node.PROCESSING_INSTRUCTION_NODE, window.Node.NOTATION_NODE, window.Node.DOCUMENT_TYPE_NODE].includes(target.nodeType)) {
        debug('ignoring', target, 'because of nodeType');
        return true;
      }

      // ignore script tags
      if (target.tagName === 'SCRIPT') {
        debug('ignoring', target, 'because of SCRIPT');
        return true;
      }
      const parent = target.parentNode || target.defaultView && target.defaultView.frameElement;

      // ignore content of style nodes, we use JS APIs to serialise their
      // content separaetly. SVG style nodes can have lowercase tag names
      if (parent && ((_parent$tagName = parent.tagName) === null || _parent$tagName === void 0 ? void 0 : _parent$tagName.toUpperCase()) === 'STYLE') {
        debug('ignoring', target, 'because child of STYLE');
        return true;
      }
      return false;
    });
    _defineProperty(this, "children", node => {
      // Salesforce lightning components screw with browser APIs significantly
      // so we need to use the unpolyfil'd versions to access some properties
      const {
        get: childNodes
      } = Object.getOwnPropertyDescriptor(_unpolyfill.Node.prototype, 'childNodes');
      const {
        get: shadowRoot
      } = Object.getOwnPropertyDescriptor(_unpolyfill.Element.prototype, 'shadowRoot');
      if (!_NodeUtils.default.isDOMNode(node)) return node.childNodes;
      if (node.tagName === 'IFRAME' && (0, _src.isxdoc)(node)) {
        // For cross doc iframes we create a fake document node once we know the id
        // of the document inside the iframe (sent over the bridge). Patches can then be
        // applied on top of this id.
        if (node.__document_id) return [{
          id: node.__document_id,
          nodeType: 9
        }];else return [];
      } else if (node.tagName === 'IFRAME' && !(0, _src.isxdoc)(node)) {
        // include IFRAME content we can access
        // if the iframe is still loading, then we don't serilise it's content. We'll reserialise again
        // once the load event triggers indicating the full content is available
        if (node.contentWindow.document.readyState !== 'complete') return [];
        return [node.contentWindow.document].filter(n => !this.isIgnored(n));
      } else if (node.nodeType === window.Node.ELEMENT_NODE && shadowRoot.apply(node)) {
        // Also traverse shadow roots
        return [shadowRoot.apply(node), ...Array.from(childNodes.apply(node))].filter(n => !this.isIgnored(n));
      } else {
        // and just regular nodes with children
        return Array.from(childNodes.apply(node)).filter(n => !this.isIgnored(n));
      }
    });
    _defineProperty(this, "depthFirst", (root, visitor) => {
      return (0, _src.depthFirst)(root, (node, overrideChildren) => {
        // override children to make sure iframe content and shadow DOM content is included
        overrideChildren(this.children(node));
        // also allow visitor to override children again if it wishes as this is useful
        // for skipping entire subtrees
        return visitor(node, overrideChildren);
      });
    });
  }
  setIgnoredViews(ignored) {
    if (Array.isArray(ignored)) {
      _classPrivateFieldSet(_ignoredViews, this, ['.__cbio_ignored', ...ignored].filter(Boolean).join(','));
      debug('set ignored view selectors', _classPrivateFieldGet(_ignoredViews, this));
      return;
    }
    debug('not updating #ignoredViews due to arg to being an array', ignored);
  }
}
var _default = exports["default"] = new NodeTree();

/***/ }),

/***/ 8571:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class NodeUtils {
  constructor() {
    _defineProperty(this, "isDOMNode", node => {
      if (!node) return false;
      // quack quack
      return !!(node.childNodes && typeof node.appendChild === 'function' && typeof node.nodeType !== 'undefined');
    });
  }
}
var _default = exports["default"] = new NodeUtils();

/***/ }),

/***/ 6938:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "NodeSerializer", ({
  enumerable: true,
  get: function () {
    return _NodeSerializer.default;
  }
}));
Object.defineProperty(exports, "NodeTracker", ({
  enumerable: true,
  get: function () {
    return _NodeTracker.default;
  }
}));
Object.defineProperty(exports, "NodeTree", ({
  enumerable: true,
  get: function () {
    return _NodeTree.default;
  }
}));
Object.defineProperty(exports, "NodeUtils", ({
  enumerable: true,
  get: function () {
    return _NodeUtils.default;
  }
}));
var _NodeTracker = _interopRequireDefault(__webpack_require__(4822));
var _NodeUtils = _interopRequireDefault(__webpack_require__(8571));
var _NodeTree = _interopRequireDefault(__webpack_require__(2588));
var _NodeSerializer = _interopRequireDefault(__webpack_require__(8708));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 1099:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(9199);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _convertLinkToRegExp = __webpack_require__(48);
var _navigation = __webpack_require__(9715);
var _Navigation = __webpack_require__(4661);
var _PDFViewer = _interopRequireDefault(__webpack_require__(7005));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _pdfLinkRegExps = /*#__PURE__*/new WeakMap();
var _pdfViewer = /*#__PURE__*/new WeakMap();
var _getPdfName = /*#__PURE__*/new WeakMap();
var _loadPdfDocument = /*#__PURE__*/new WeakMap();
class PDFHandler extends _navigation.NavigationHandler {
  constructor(session, delegate) {
    var _delegate$pdfLinks;
    super();
    _classPrivateFieldInitSpec(this, _pdfLinkRegExps, void 0);
    _classPrivateFieldInitSpec(this, _pdfViewer, void 0);
    _classPrivateFieldInitSpec(this, _getPdfName, rawUrl => {
      const url = new URL(rawUrl, window.location.href);
      return url.pathname.split('/').pop();
    });
    _classPrivateFieldInitSpec(this, _loadPdfDocument, (url, target, windowFeatures, options) => {
      const {
        document: pdfDocument
      } = options;
      const container = document.createElement('div');
      container.style.width = '100%';
      container.style.height = '100%';
      pdfDocument.load(url, target, windowFeatures, {
        element: container,
        type: this.type
      });
      _classPrivateFieldGet(_pdfViewer, this).openPdfViewer(url, container, () => {
        const pdfName = _classPrivateFieldGet(_getPdfName, this).call(this, url);
        pdfDocument.icon = '';
        pdfDocument.title = pdfName;
        pdfDocument.isLoading = false;
      });
    });
    _classPrivateFieldSet(_pdfLinkRegExps, this, ((_delegate$pdfLinks = delegate.pdfLinks) === null || _delegate$pdfLinks === void 0 ? void 0 : _delegate$pdfLinks.map(_convertLinkToRegExp.convertLinkToRegExp)) || []);
    _classPrivateFieldSet(_pdfViewer, this, new _PDFViewer.default(session, delegate.api));
  }
  get type() {
    return _Navigation.NAVIGATION_TYPE.PDF;
  }
  shouldHandleEvent(e) {
    // only watch for events that have started bubbling
    if (e.eventPhase === Event.CAPTURING_PHASE) return false;
    // we need to honor the defaultPrevented flag for PDF
    // navigations as this can cause a double navigation to occur
    return !e.defaultPrevented;
  }
  shouldHandle(u) {
    const urlWithoutQueryParams = new URL(u, window.location.origin);
    urlWithoutQueryParams.search = '';
    return _classPrivateFieldGet(_pdfLinkRegExps, this).some(regExp => regExp.test(urlWithoutQueryParams));
  }
  handle(url, target, windowFeatures, options) {
    _classPrivateFieldGet(_loadPdfDocument, this).call(this, url, target, windowFeatures, options);
    return {
      document: options.document
    };
  }
}
exports["default"] = PDFHandler;

/***/ }),

/***/ 7005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.GLOBAL_OPEN_PDF_KEY = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _protected = _interopRequireDefault(__webpack_require__(7609));
var _proxy = __webpack_require__(9147);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const GLOBAL_OPEN_PDF_KEY = exports.GLOBAL_OPEN_PDF_KEY = '__cobrowse_io_openPdf';
var _session = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _createUrlRewriter = /*#__PURE__*/new WeakMap();
class PDFViewer {
  constructor(_session2, api) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _api, void 0);
    _classPrivateFieldInitSpec(this, _createUrlRewriter, session => {
      const proxyToken = session[_protected.default].proxyToken();
      const sessionProxyUrl = session[_protected.default].proxyUrl();
      const proxyUrl = new URL(sessionProxyUrl, _classPrivateFieldGet(_api, this));
      return new _proxy.URLRewriter(proxyUrl, _proxy.PROXY_PREFIX.UNIVERSAL, proxyToken, window.location);
    });
    _defineProperty(this, "openPdfViewer", (url, container, onLoadComplete) => {
      const globalOpenPdf = window[GLOBAL_OPEN_PDF_KEY];
      const open = openPdf => {
        const {
          setPdfUrl
        } = openPdf(url, {
          container,
          onLoadError: failedUrl => {
            const urlRewriter = _classPrivateFieldGet(_createUrlRewriter, this).call(this, _classPrivateFieldGet(_session, this));
            const proxiedUrl = urlRewriter.proxify(url);
            if (failedUrl === proxiedUrl) {
              onLoadComplete();
              return;
            }
            console.warn('CobrowseIO: Failed to fetch PDF document, attempting to proxy it');
            setPdfUrl(proxiedUrl);
          },
          onLoadSuccess: onLoadComplete,
          preventClose: true
        });
      };

      // check if we have a global viewer defined, this would exist
      // when a consumer has an unnamed import for the pdf-viewer
      if (typeof globalOpenPdf === 'function') {
        open(globalOpenPdf);
        return;
      }

      // we only bundle and chunk the PDF viewer for script builds
      // eslint-disable-next-line
      if (false) {}
      console.warn('CobrowseIO: No PDF Viewer included');
    });
    _classPrivateFieldSet(_session, this, _session2);
    _classPrivateFieldSet(_api, this, api);
  }
}
exports["default"] = PDFViewer;

/***/ }),

/***/ 1065:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3697);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "GLOBAL_OPEN_PDF_KEY", ({
  enumerable: true,
  get: function () {
    return _PDFViewer.GLOBAL_OPEN_PDF_KEY;
  }
}));
Object.defineProperty(exports, "PDFHandler", ({
  enumerable: true,
  get: function () {
    return _PDFHandler.default;
  }
}));
Object.defineProperty(exports, "PDFViewer", ({
  enumerable: true,
  get: function () {
    return _PDFViewer.default;
  }
}));
var _PDFViewer = _interopRequireWildcard(__webpack_require__(7005));
var _PDFHandler = _interopRequireDefault(__webpack_require__(1099));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

/***/ }),

/***/ 168:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URLRewriter = void 0;
__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _unproxifyPath = __webpack_require__(9444);
var _proxifyUrl = __webpack_require__(6925);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _shouldIgnore = /*#__PURE__*/new WeakMap();
var _isProxyUrl = /*#__PURE__*/new WeakMap();
var _getPathWithoutPrefix = /*#__PURE__*/new WeakMap();
class URLRewriter {
  constructor(proxyApiUrl, proxyPrefix, proxyToken, baseUrl, _queryParams, getOrigin) {
    var _this = this;
    _defineProperty(this, "ALLOWED_PROTOCOLS", ['http:', 'https:']);
    _classPrivateFieldInitSpec(this, _shouldIgnore, urlString => {
      return urlString.startsWith('#');
    });
    _classPrivateFieldInitSpec(this, _isProxyUrl, url => {
      return url.hostname === this.proxyApiUrl.hostname;
    });
    _classPrivateFieldInitSpec(this, _getPathWithoutPrefix, url => {
      const path = "".concat(url.pathname).concat(url.search).concat(url.hash);
      return path.replace(/^.*?\/proxy\/1\/[^/]+/i, '');
    });
    _defineProperty(this, "proxify", function (rawUrl) {
      let additionalQueryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!rawUrl) return rawUrl;
      if (_classPrivateFieldGet(_shouldIgnore, _this).call(_this, rawUrl.toString())) return rawUrl;
      const queryParams = _objectSpread(_objectSpread(_objectSpread({}, _this.queryParams), _this.getOrigin ? {
        origin: _this.getOrigin()
      } : {}), additionalQueryParams);
      try {
        const url = new URL(rawUrl, _this.baseUrl);
        if (!_this.ALLOWED_PROTOCOLS.includes(url.protocol)) return rawUrl;
        const urlString = _classPrivateFieldGet(_isProxyUrl, _this).call(_this, url) ? _this.unproxify(url.toString()) : url.toString();
        const targetPath = (0, _proxifyUrl.proxifyUrl)(urlString, queryParams);
        const targetUrl = new URL(".".concat(targetPath), _this.proxyApiUrl);
        return targetUrl.toString();
      } catch (err) {
        return rawUrl;
      }
    });
    _defineProperty(this, "unproxify", rawUrl => {
      if (!rawUrl) return rawUrl;
      if (_classPrivateFieldGet(_shouldIgnore, this).call(this, rawUrl.toString())) return rawUrl;
      try {
        const url = new URL(rawUrl, this.baseUrl);
        if (!this.ALLOWED_PROTOCOLS.includes(url.protocol)) return rawUrl;
        if (!_classPrivateFieldGet(_isProxyUrl, this).call(this, url)) return rawUrl;
        const pathWithoutPrefix = _classPrivateFieldGet(_getPathWithoutPrefix, this).call(this, url);
        const targetUrl = (0, _unproxifyPath.unproxifyPath)(pathWithoutPrefix);
        return targetUrl.toString();
      } catch (err) {
        return rawUrl;
      }
    });
    this.proxyApiUrl = new URL(proxyPrefix, proxyApiUrl);
    this.queryParams = _queryParams ? _objectSpread({}, _queryParams) : {};
    if (proxyToken) this.queryParams.access_token = proxyToken;
    this.baseUrl = baseUrl;
    this.getOrigin = getOrigin;
  }
}
exports.URLRewriter = URLRewriter;

/***/ }),

/***/ 9147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "PROXY_PREFIX", ({
  enumerable: true,
  get: function () {
    return _proxyPrefix.PROXY_PREFIX;
  }
}));
Object.defineProperty(exports, "URLRewriter", ({
  enumerable: true,
  get: function () {
    return _URLRewriter.URLRewriter;
  }
}));
var _URLRewriter = __webpack_require__(168);
var _proxyPrefix = __webpack_require__(2859);

/***/ }),

/***/ 6925:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.reverseHost = exports.proxifyUrl = void 0;
__webpack_require__(8340);
__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
const reverseHost = host => host.split('.').reverse().map(encodeURIComponent).join('/');
exports.reverseHost = reverseHost;
const proxifyUrl = (url, queryParams) => {
  const {
    hostname,
    protocol,
    pathname,
    search,
    port,
    username,
    password,
    hash
  } = new URL(url);
  const targetHost = reverseHost(hostname);
  const targetPath = "".concat(targetHost, "/").concat(protocol).concat(pathname).concat(hash);
  const targetUrl = new URL(targetPath, 'http://placeholder.base');
  if (search) targetUrl.searchParams.set('search', search.replace('?', ''));
  if (port) targetUrl.searchParams.set('port', port);
  if (username) targetUrl.searchParams.set('username', username);
  if (password) targetUrl.searchParams.set('password', password);
  for (const [key, value] of Object.entries(queryParams || {})) {
    targetUrl.searchParams.set(key, value);
  }
  return "".concat(targetUrl.pathname).concat(targetUrl.search).concat(targetUrl.hash);
};
exports.proxifyUrl = proxifyUrl;

/***/ }),

/***/ 2859:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PROXY_PREFIX = void 0;
const PROXY_PREFIX = exports.PROXY_PREFIX = {
  UNIVERSAL: './proxy/1/universal/'
};

/***/ }),

/***/ 9444:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.unproxifyPath = void 0;
__webpack_require__(8340);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
const unproxifyPath = path => {
  const {
    pathname,
    hash,
    searchParams
  } = new URL(path, 'http://placeholder.base');
  const parts = pathname.split('/');
  const protocolIndex = parts.findIndex(part => part === 'http:' || part === 'https:');
  const protocol = parts[protocolIndex];
  const hostParts = parts.slice(1, protocolIndex).reverse().map(decodeURIComponent);
  const pathParts = parts.slice(protocolIndex + 1, parts.length);
  const search = searchParams.get('search');
  const port = searchParams.get('port');
  const username = searchParams.get('username');
  const password = searchParams.get('password');
  const targetHost = hostParts.join('.');
  const targetPath = pathParts.join('/');
  const searchWithPrefix = search ? "?".concat(search) : '';
  const portWithPrefix = port ? ":".concat(port) : '';
  const credentials = username && password ? "".concat(username, ":").concat(password, "@") : '';
  return new URL("".concat(protocol, "//").concat(credentials).concat(targetHost).concat(portWithPrefix, "/").concat(targetPath).concat(searchWithPrefix).concat(hash));
};
exports.unproxifyPath = unproxifyPath;

/***/ }),

/***/ 2615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RedactionIndex = void 0;
__webpack_require__(1952);
__webpack_require__(4045);
__webpack_require__(3697);
var _NodeTree = _interopRequireDefault(__webpack_require__(2588));
var _src = __webpack_require__(9501);
var _unpolyfill = __webpack_require__(9883);
var _nodes = __webpack_require__(6938);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * An index cache that tracks element redaction state and can be efficiently
 * queried for node redaction state.
 *
 * The logistics behind what is able to be redacted takes on a complex
 * consideration that even though an element is supposed to be redacted, it may
 * not be able to be redacted because it has a descendant that is explicitly
 * unredacted. To accomodate this requirement, there is a concept of
 * "projection" worked into the algorithm:
 *
 *  * A redacted element "projects" redaction down to its descendants. This
 *    projection ends as soon as it hits another node that has direct redaction/
 *    unredaction set; and
 *  * An unredacted element "projects" unredaction up to its ancestors. This
 *    projection does not end when an ancestor has a direct redaction state.
 *
 * Given this distinction, every element in the DOM can have the following
 * direct and projected characteristics:
 *
 *  1. Direct unredaction. A node is indexed with `setRedacted(node, false)`
 *  2. Projected unredaction. All nodes that are ancestors of a direct
 *     unredaction node are projected unredaction.
 *  3. Direct redaction. A node is indexed with `setRedacted(node, true)`
 *  4. Projected redaction. All nodes that are descendants of a direct
 *     redaction node are projected redaction.
 *
 * With the concept of projection in mind, determining if a node is redacted
 * boils down to the following logic:
 *
 *  1. A direct or projected unredacted node must not be redacted
 *  2. A direct redacted node is redacted only if it is not projected unredacted
 *  3. A projected redacted node is redacted only if its direct parent is
 *     projected unredacted
 *  4. Any node that has no other redaction state is not redacted
 */
var _redactedSelector = /*#__PURE__*/new WeakMap();
var _unredactedSelector = /*#__PURE__*/new WeakMap();
var _redactedTagNames = /*#__PURE__*/new WeakMap();
var _unredactedCache = /*#__PURE__*/new WeakMap();
var _redactedCache = /*#__PURE__*/new WeakMap();
var _RedactionIndex_brand = /*#__PURE__*/new WeakSet();
class RedactionIndex {
  constructor() {
    let redactedSelectors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let unredactedSelectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let sessionRedactionSelectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let sessionUnredactionSelectors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    let {
      document = window.document
    } = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    _classPrivateMethodInitSpec(this, _RedactionIndex_brand);
    _classPrivateFieldInitSpec(this, _redactedSelector, void 0);
    _classPrivateFieldInitSpec(this, _unredactedSelector, void 0);
    _classPrivateFieldInitSpec(this, _redactedTagNames, ['OBJECT', 'EMBED']);
    _classPrivateFieldInitSpec(this, _unredactedCache, new Set());
    _classPrivateFieldInitSpec(this, _redactedCache, new Set());
    _classPrivateFieldSet(_redactedSelector, this, _assertClassBrand(_RedactionIndex_brand, this, _combineSelectors).call(this, ..._classPrivateFieldGet(_redactedTagNames, this), ...redactedSelectors, ...sessionRedactionSelectors));
    _classPrivateFieldSet(_unredactedSelector, this, _assertClassBrand(_RedactionIndex_brand, this, _combineSelectors).call(this, ...unredactedSelectors, ...sessionUnredactionSelectors));
    for (const n of _assertClassBrand(_RedactionIndex_brand, this, _findDescendants).call(this, document, _classPrivateFieldGet(_redactedSelector, this))) {
      _classPrivateFieldGet(_redactedCache, this).add(n);
    }
    for (const n of _assertClassBrand(_RedactionIndex_brand, this, _findDescendants).call(this, document, _classPrivateFieldGet(_unredactedSelector, this))) {
      _classPrivateFieldGet(_unredactedCache, this).add(n);
    }
  }

  /**
   * Determine which node, if any, the specified node is redacted by.
   *
   * If this node is not redacted (e.g., it is not redacted directly or
   * indirectly by a selector, or it has been unredacted by a selector), then
   * `null` is returned.
   *
   * Otherwise, if any ancestor of the specified node is determined to be
   * directly redacted (i.e., the specified node is "indirectly" redacted), then
   * that ancestor node will be returned.
   *
   * Otherwise, if the specified node is directly redacted, then the node itself
   * will be returned.
   *
   * Redacted nodes that match a selector set in the admin interface will take
   * precende over any other redaction/unredaction.
   */
  getRedactedBy(node) {
    // if redacted by session selector or parent is redacted by session selector
    const redactedByPriority = _assertClassBrand(_RedactionIndex_brand, this, _getRedactedByPriority).call(this, node);
    if (redactedByPriority) {
      return redactedByPriority;
    }
    if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, node) || _assertClassBrand(_RedactionIndex_brand, this, _isProjectedUnredaction).call(this, node)) {
      // A direct or projected unredacted node must not be redacted
      return null;
    }

    // First determine if this node is projected redaction from an ancestor
    const projectedRedactionBy = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedRedactionBy).call(this, node);
    if (projectedRedactionBy) {
      // A projected redaction node is directly redacted only if its direct parent
      // is projected unredacted. Otherwise, it is indirectly redacted
      return _assertClassBrand(_RedactionIndex_brand, this, _isProjectedUnredaction).call(this, node.parentNode) ? node : projectedRedactionBy;
    }
    if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectRedaction).call(this, node)) {
      // A direct redacted node that is not projected unredacted is redacted
      return node;
    }
    return null;
  }
  notifyChanges(records, addedNodes, modifiedNodes, removedNodes) {
    const modified = new Set();
    const expandUnredaction = new Set();

    // performance optimisation so we can update the cache as we go and in the end compare the
    // elements removed from the cache so those can be added to the changeset
    const previousRedactedCache = new Set([..._classPrivateFieldGet(_redactedCache, this)]);
    for (const record of records) {
      if (_NodeTree.default.isIgnored(record.target) || removedNodes.has(record.target)) {
        continue;
      }
      const redactedBy = this.getRedactedBy(record.target);

      // If an element is modified that is a descendent of a direct redacted node,
      // we want to propagate a change for the redacted node to pick up potential
      // changes in size
      if (redactedBy && redactedBy !== record.target) {
        modified.add(redactedBy);
      }
      if (record.type === 'attributes') {
        const projectedUnredaction = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedUnredaction).call(this, record.target);
        // If this node is projected unredaction, we have to account for the
        // possibility that this change resulted in projected redaction to
        // change, on the ancestors of all those elements, which would change
        // which state children of projected unredaction nodes have.
        //
        // If this node became redacted, then children of all projected
        // unredaction nodes are now direct redaction.
        //
        // If this node became non-redacted, then children of projected
        // unredaction nodes are now no longer redacted
        for (const node of projectedUnredaction) {
          expandUnredaction.add(node);
        }
        const isDirectUnredaction = _assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, record.target);
        if (_classPrivateFieldGet(_unredactedCache, this).has(record.target) !== !!isDirectUnredaction) {
          // If this nodes unredaction state changed, we need to propagate
          // modifications through its unredaction chain
          expandUnredaction.add(record.target.parentNode);
        }
      } else if (record.type === 'childList') {
        const hasRemovedUnredacted = _assertClassBrand(_RedactionIndex_brand, this, _hasUnredacted).call(this, record.removedNodes);
        const hasAddedUnredacted = _assertClassBrand(_RedactionIndex_brand, this, _hasUnredacted).call(this, record.addedNodes);
        if (!expandUnredaction.has(record.target)) {
          const projectedUnredaction = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedUnredaction).call(this, record.target);
          const isProjectedUnredaction = projectedUnredaction.length > 0;
          const potentiallyBecameProjectedUnredaction = isProjectedUnredaction && hasAddedUnredacted;

          // We possibly became non-"projected unredaction" if we are now not
          // projected unredaction AND one of our descendants are unredacted
          const potentiallyBecameNotProjectedUnredaction = !isProjectedUnredaction && hasRemovedUnredacted;
          if (potentiallyBecameProjectedUnredaction || potentiallyBecameNotProjectedUnredaction) {
            expandUnredaction.add(record.target);
          }
        }
      }
    }

    // Expand out the nodes that are potentially modified from a potential
    // unredaction modification
    const potentiallyAffectedUnredactionNodes = _assertClassBrand(_RedactionIndex_brand, this, _expandAffectedUnredaction).call(this, expandUnredaction);
    for (const node of potentiallyAffectedUnredactionNodes) {
      if (!_NodeTree.default.isIgnored(node)) {
        modified.add(node);
      }
    }
    _assertClassBrand(_RedactionIndex_brand, this, _updateCaches).call(this, addedNodes, new Set([...modified, ...modifiedNodes]), removedNodes);

    // If the modified element contains redacted children, we need to propagate a change
    // for each of the redacted children as the parent size can affect the children size
    for (const node of modifiedNodes) {
      for (const redactedNode of _classPrivateFieldGet(_redactedCache, this)) {
        if (node.contains(redactedNode)) {
          modified.add(redactedNode);
        }
      }
    }

    // if the element was modified in a way that it is no longer redacted, we
    // appended to the list of added nodes
    for (const node of previousRedactedCache) {
      if (!_classPrivateFieldGet(_redactedCache, this).has(node) && !removedNodes.has(node)) {
        _NodeTree.default.depthFirst(node, n => {
          modified.add(n);
        });
      }
    }
    return modified;
  }
  isRedacted(node) {
    return Boolean(this.getRedactedBy(node));
  }
}
exports.RedactionIndex = RedactionIndex;
function _hasUnredacted(list) {
  const nodes = [...list];
  return nodes.find(n => !_NodeTree.default.isIgnored(n) && _assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, n)) || nodes.find(n => _assertClassBrand(_RedactionIndex_brand, this, _getProjectedUnredaction).call(this, n).length > 0);
}
function _updateCaches(addedNodes, modifiedNodes, removedNodes) {
  _assertClassBrand(_RedactionIndex_brand, this, _updateUnredactedCache).call(this, addedNodes, modifiedNodes, removedNodes);
  _assertClassBrand(_RedactionIndex_brand, this, _updateRedactedCache).call(this, modifiedNodes, removedNodes);
}
function _updateUnredactedCache(addedNodes, modifiedNodes, removedNodes) {
  for (const removed of _assertClassBrand(_RedactionIndex_brand, this, _processUnredactionCache).call(this, removedNodes)) {
    _classPrivateFieldGet(_unredactedCache, this).delete(removed);
  }
  for (const added of _assertClassBrand(_RedactionIndex_brand, this, _processUnredactionCache).call(this, addedNodes)) {
    _classPrivateFieldGet(_unredactedCache, this).add(added);
  }
  for (const modified of modifiedNodes) {
    // added nodes are included in modified nodes, but there's more expensive calculations
    // for those. As a result we can skip them here.
    if (!addedNodes.has(modified)) {
      if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, modified)) {
        _classPrivateFieldGet(_unredactedCache, this).add(modified);
      } else {
        _classPrivateFieldGet(_unredactedCache, this).delete(modified);
      }
    }
  }
}
function _updateRedactedCache(modifiedNodes, removedNodes) {
  for (const removed of removedNodes) {
    _classPrivateFieldGet(_redactedCache, this).delete(removed);
  }

  // the modified nodes are the ones that were added or modified
  // this is a result of the handling of mutations within the PatchStream._domChange
  for (const modified of modifiedNodes) {
    _assertClassBrand(_RedactionIndex_brand, this, _updateRedactionCache).call(this, modified);
  }
}
function* _processUnredactionCache(nodes) {
  for (const node of nodes) {
    if (_assertClassBrand(_RedactionIndex_brand, this, _isDirectUnredaction).call(this, node)) {
      yield node;
    }
  }
}
/**
 * Returns the element that redacts the passed node through an admin selector
 * or an always redacted HTML tag. Both this selectors are always redacted.
 * It returns the node itself if directly redacted or a parent node that is
 * directly redacted
 */
function _getRedactedByPriority(node) {
  const selectors = [..._classPrivateFieldGet(_redactedTagNames, this)];
  if (_assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, node, selectors)) {
    return node;
  }
  return [...(0, _src.parents)(node)].find(n => _assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, n, selectors));
}
/**
 * Given a list of modified elements updates the redaction cache accordingly
 * if any of the nodes modified has stopped or became redacted
 */
function _updateRedactionCache(node) {
  const hasRedacted = _classPrivateFieldGet(_redactedCache, this).has(node);
  if (hasRedacted && this.getRedactedBy(node) !== node) {
    _classPrivateFieldGet(_redactedCache, this).delete(node);
  } else if (!hasRedacted && this.getRedactedBy(node) === node) {
    _classPrivateFieldGet(_redactedCache, this).add(node);
  }
}
function _expandAffectedUnredaction(nodes) {
  const ancestors = new Set([...nodes].flatMap(n => [n, ...(0, _src.parents)(n)]));
  return [...ancestors].flatMap(a => [...(a.childNodes || [])]);
}
function _isDirectRedaction(node) {
  return _assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, node, _classPrivateFieldGet(_redactedSelector, this));
}
function _isDirectUnredaction(node) {
  return _assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, node, _classPrivateFieldGet(_unredactedSelector, this));
}
/**
 * Find the closest ancestor that is directly redacted, if any.
 *
 * This takes into consideration:
 *
 *  - Nodes that are directly redacted by a redaction selector; and
 *  - Nodes that are directly redacted because they are projected redaction
 *    AND their parent is projected unredaction
 */
function _getProjectedRedactionBy(node) {
  const projectedRedactionBy = _assertClassBrand(_RedactionIndex_brand, this, _getProjectedRedactionBySelector).call(this, node);
  if (projectedRedactionBy) {
    return (0, _src.parents)(node, projectedRedactionBy).find(a => _assertClassBrand(_RedactionIndex_brand, this, _isProjectedUnredaction).call(this, a.parentNode)) || projectedRedactionBy;
  } else {
    return null;
  }
}
/**
 * Find the closest ancestor that matches either a redaction or unredaction
 * selector, and return it only if it matches the redaction selector.
 *
 * If no ancestor matches a selector, or the closest ancestor that does is
 * marked unredacted, then this returns `null`.
 *
 * The reason for using a combination of the redacted and unredacted selectors
 * to find the closest ancestor is because when a redacted node projects
 * redaction to its descendants, that projection ends at a node that is
 * unredacted. For example:
 *
 * ```
 * <div id="a" redacted>
 *   <div id="b" unredacted>
 *     <div id="c"></div>
 *   </div>
 *   <div id="d"></div>
 * </div>
 * ```
 *
 * In this example, `#c` is not projected redaction by selector, because there
 * is an `[unredacted]` as its closest ancestor that matches either
 * redacted/unredacted. `#d` is projected redaction by selector.
 *
 * Note: This will accurately tell you if a node is projected redaction, but
 * it won't accurately tell you the closest ancestor that is directly
 * redacted (as opposed to indirectly redacted). Use #getProjectedRedactionBy
 * for that.
 */
function _getProjectedRedactionBySelector(node) {
  // this might be called with a serialized object from the NodeSerializer when parsing xdoc iframe messages
  if (!_nodes.NodeUtils.isDOMNode(node)) return null;
  const {
    get: parentNode
  } = Object.getOwnPropertyDescriptor(_unpolyfill.Node.prototype, 'parentNode');
  const combinedSelectors = _assertClassBrand(_RedactionIndex_brand, this, _combineSelectors).call(this, _classPrivateFieldGet(_redactedSelector, this), _classPrivateFieldGet(_unredactedSelector, this));
  // Salesforce lightning components mess with the parent node API so we use the unpolyfil'd version
  // to ensure we can get the correct parentNode
  const parentElem = node && node.nodeType === _unpolyfill.Node.ELEMENT_NODE && parentNode.call(node);
  const closestElem = parentElem && parentElem.nodeType === _unpolyfill.Node.ELEMENT_NODE && combinedSelectors && parentElem.closest(combinedSelectors);
  if (_assertClassBrand(_RedactionIndex_brand, this, _matches).call(this, closestElem, _classPrivateFieldGet(_redactedSelector, this))) {
    // Before we return the node that is projecting redaction, we have to
    // first consider that there is an intermediary ancestor that is redacted
    // as a result of having a parent that is projected unredaction
    return closestElem;
  } else {
    return null;
  }
}
/** Determine if the node has any descendent that matches an unredaction selector. */
function _isProjectedUnredaction(node) {
  // TODO: This does not project across iframe boundaries, which is a known issue but outscoped
  return _classPrivateFieldGet(_unredactedSelector, this) && node && node.tagName !== 'HTML' && node.querySelector && node.querySelector(_classPrivateFieldGet(_unredactedSelector, this));
}
function _getProjectedUnredaction(node) {
  return _assertClassBrand(_RedactionIndex_brand, this, _findDescendants).call(this, node, _classPrivateFieldGet(_unredactedSelector, this));
}
/** Find all descendents that match the provided selector. */
function _findDescendants(node, selectors) {
  if (selectors && node.querySelectorAll) {
    // TODO: This does not project across iframe boundaries, which is a known issue but outscoped
    // Get all unredacted nodes projecting unredaction to the specified node
    return node.querySelectorAll(selectors);
  } else {
    return [];
  }
}
/** Determine if the specified node matches a CSS selector. */
function _matches(node, selector) {
  return node && selector && node.matches && node.matches(selector);
}
function _combineSelectors() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }
  return selectors.filter(Boolean).join(',');
}

/***/ }),

/***/ 9702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.RedactionIndexProvider');
var _index = /*#__PURE__*/new WeakMap();
class RedactionIndexProvider {
  constructor() {
    _classPrivateFieldInitSpec(this, _index, void 0);
  }
  set instance(redactionIndex) {
    _classPrivateFieldSet(_index, this, redactionIndex);
    debug('set new redaction index');
  }
  get instance() {
    return _classPrivateFieldGet(_index, this);
  }
}
var _default = exports["default"] = new RedactionIndexProvider();

/***/ }),

/***/ 8111:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(8425);
__webpack_require__(2832);
__webpack_require__(9492);
__webpack_require__(9199);
__webpack_require__(3697);
var _globToRegexp = _interopRequireDefault(__webpack_require__(3034));
var _UniversalHooks = _interopRequireDefault(__webpack_require__(1191));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _getRedactionUrl = /*#__PURE__*/new WeakMap();
var _getSelectorsByUrl = /*#__PURE__*/new WeakMap();
class TargetedRedaction {
  constructor() {
    _classPrivateFieldInitSpec(this, _getRedactionUrl, () => _UniversalHooks.default.unproxify(window.location.href));
    _classPrivateFieldInitSpec(this, _getSelectorsByUrl, (selectors, url) => {
      if (!selectors) return selectors;
      const filteredSelectors = selectors.map(selector => {
        if (typeof selector === 'string') return selector;
        if (typeof selector === 'object') {
          return Object.entries(selector).filter(_ref => {
            let [key] = _ref;
            const urlRegExp = (0, _globToRegexp.default)(key, {
              flags: 'i'
            });
            return urlRegExp.test(url);
          }).map(_ref2 => {
            let [_, value] = _ref2;
            return value;
          });
        }
        return null;
      }).filter(Boolean).flat(2);
      return [...new Set(filteredSelectors)];
    });
    _defineProperty(this, "filterSelectors", selectors => {
      const redactionUrl = _classPrivateFieldGet(_getRedactionUrl, this).call(this);
      return _classPrivateFieldGet(_getSelectorsByUrl, this).call(this, selectors, redactionUrl);
    });
    _defineProperty(this, "hasChange", (selectors, previousRedactionUrl) => {
      if (!selectors) return false;
      if (!previousRedactionUrl) return true;
      const previousSelectors = _classPrivateFieldGet(_getSelectorsByUrl, this).call(this, selectors, previousRedactionUrl);
      const currentSelectors = _classPrivateFieldGet(_getSelectorsByUrl, this).call(this, selectors, _classPrivateFieldGet(_getRedactionUrl, this).call(this));
      if (previousSelectors.length !== currentSelectors.length) return true;
      const sortedPreviousSelectors = [...previousSelectors].sort();
      const sortedCurrentSelectors = [...currentSelectors].sort();
      return !sortedPreviousSelectors.every((value, index) => value === sortedCurrentSelectors[index]);
    });
  }
}
var _default = exports["default"] = new TargetedRedaction();

/***/ }),

/***/ 6566:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "RedactionIndex", ({
  enumerable: true,
  get: function () {
    return _RedactionIndex.RedactionIndex;
  }
}));
Object.defineProperty(exports, "RedactionIndexProvider", ({
  enumerable: true,
  get: function () {
    return _RedactionIndexProvider.default;
  }
}));
Object.defineProperty(exports, "TargetedRedaction", ({
  enumerable: true,
  get: function () {
    return _TargetedRedaction.default;
  }
}));
var _RedactionIndex = __webpack_require__(2615);
var _RedactionIndexProvider = _interopRequireDefault(__webpack_require__(9702));
var _TargetedRedaction = _interopRequireDefault(__webpack_require__(8111));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 2976:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _dompurify = _interopRequireDefault(__webpack_require__(7447));
var _nodes = __webpack_require__(6938);
var _redaction = __webpack_require__(6566);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.ControlEvents');
class ControlEvents {
  constructor() {
    _defineProperty(this, "_applyScroll", (target, event) => {
      const tgt = target.defaultView || target;
      if (tgt.scrollTo) tgt.scrollTo(event.x, event.y);else {
        tgt.scrollTop = event.y;
        tgt.scrollLeft = event.x;
      }
    });
    _defineProperty(this, "_updateCheckbox", (target, _ref) => {
      let {
        checked
      } = _ref;
      if (typeof checked !== 'undefined' && target.tagName === 'INPUT' && typeof target.checked !== 'undefined') {
        const descriptor = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'checked');
        if (descriptor) descriptor.set.call(target, checked);
      }
    });
    _defineProperty(this, "_updateInnerHTML", (target, _ref2) => {
      let {
        innerHTML
      } = _ref2;
      if (typeof innerHTML !== 'undefined') {
        const parser = new DOMParser();
        const html = parser.parseFromString(_dompurify.default.sanitize(innerHTML), 'text/html');
        target.replaceChildren(...html.body.children);
      }
    });
    _defineProperty(this, "_updateValue", (target, _ref3) => {
      let {
        value,
        selectedOptions
      } = _ref3;
      // some frameworks (e.g. react) wrap the value setter, so we need
      // to make sure we're calling the browsers version without those wrappers
      // https://github.com/assaf/zombie/issues/1123
      if (typeof value !== 'undefined') {
        const descriptor = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
        if (descriptor) descriptor.set.call(target, value);
      }
      // IE 11 hack: textarea text node gets replaced when it's udpated, but the mutation
      // observer doesn't get an event, so we need to manually force the tracking of the
      // new node
      if (target.tagName === 'TEXTAREA') {
        _nodes.NodeTracker.track(target.childNodes[0]);
      }
      if (target.tagName === 'SELECT' && selectedOptions != null) {
        [...target.options].forEach(opt => {
          opt.selected = selectedOptions.includes(opt.value);
        });
      }
    });
    _defineProperty(this, "_updateTarget", (target, event) => {
      this._updateValue(target, event.target);
      this._updateCheckbox(target, event.target);
      this._updateInnerHTML(target, event.target);
    });
    _defineProperty(this, "_generateMouse", (target, event) => {
      return new MouseEvent(event.state, {
        clientX: event.x * window.innerWidth,
        clientY: event.y * window.innerHeight,
        bubbles: true,
        cancelable: true,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generatePointer", (target, event) => {
      return new PointerEvent(event.state, {
        clientX: event.x * window.innerWidth,
        clientY: event.y * window.innerHeight,
        pointerId: event.pointerId,
        width: event.width,
        height: event.height,
        pressure: event.pressure,
        tangentialPressure: event.tangentialPressure,
        tiltX: event.tiltX,
        tiltY: event.tiltY,
        twist: event.twist,
        pointerType: event.pointerType,
        isPrimary: event.isPrimary,
        bubbles: true,
        cancelable: true,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateKeypress", (target, event) => {
      return new KeyboardEvent(event.state, {
        key: event.key,
        code: event.code,
        ctrlKey: event.ctrlKey,
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        metaKey: event.metaKey,
        charCode: event.charCode,
        keyCode: event.keyCode,
        which: event.which,
        bubbles: true,
        cancelable: true,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateFocus", (target, event) => {
      return new FocusEvent(event.state, {
        bubbles: ['focusin', 'focusout'].includes(event.state),
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateChange", (target, event) => {
      return new CustomEvent(event.state, {
        bubbles: true,
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window
      });
    });
    _defineProperty(this, "_generateInput", (target, event) => {
      return new CustomEvent(event.state, {
        bubbles: true,
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window,
        inputType: event.inputType,
        data: event.data
      });
    });
    _defineProperty(this, "_generateSelection", (target, event) => {
      return new CustomEvent('selection', {
        bubbles: true,
        cancelable: false,
        composed: true,
        view: target.ownerDocument && target.ownerDocument.defaultView || window,
        selection: event.selection
      });
    });
    _defineProperty(this, "_generateEvent", (type, target, event) => {
      if (event.state.includes('move')) debug('generate', event, 'on', target);
      switch (type) {
        case 'keypress':
          return this._generateKeypress(target, event);
        case 'mouse':
          return this._generateMouse(target, event);
        case 'pointer':
          return this._generatePointer(target, event);
        case 'change':
          return this._generateChange(target, event);
        case 'input':
          return this._generateInput(target, event);
        case 'focus':
          return this._generateFocus(target, event);
        case 'select':
          return this._generateSelection(target, event);
        default:
          {
            console.warn('CobrowseIO: unknown event type', type, event);
            return null;
          }
      }
    });
    _defineProperty(this, "_setSelection", (target, _ref4) => {
      let {
        selection
      } = _ref4;
      if (target.__cobrowse_user_selection_timestamp > Date.now() - 100) {
        return;
      }

      // input elements can emit Select events with a state of selectionchange but
      // they don't support getSelection, so we ignore the set selection in this case
      if (!target.getSelection) {
        return;
      }

      // Firefox can return null while calling getSelection https://bugzilla.mozilla.org/show_bug.cgi?id=827585
      if (!target.getSelection()) {
        return;
      }
      try {
        // if the selection didn't change, skip
        if (selection) {
          // clear any existing selection
          target.__last_agent_selection_ts = Date.now();
          target.getSelection().removeAllRanges();

          // firefox supports multiple selections
          // see: https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount
          selection.forEach(serializedRange => {
            const {
              start,
              startOffset,
              end,
              endOffset
            } = serializedRange;
            const range = document.createRange();
            const startNode = _nodes.NodeTracker.getById(start);
            const endNode = _nodes.NodeTracker.getById(end);
            range.setStart(startNode, startOffset);
            range.setEnd(endNode, endOffset);
            target.getSelection().addRange(range);
          });
        } else {
          target.getSelection().removeAllRanges();
        }
      } catch (err) {
        console.warn('Failed to apply selection', selection, err);
      }
    });
    _defineProperty(this, "_setInputSelection", (target, _ref5) => {
      let {
        selection
      } = _ref5;
      if (target.ownerDocument.__cobrowse_user_selection_timestamp > Date.now() - 100) {
        return;
      }
      const hasTextSelectionSupport = ['text', 'textarea', 'search', 'url'].includes(target.type);
      if (!hasTextSelectionSupport) {
        return;
      }
      try {
        target.ownerDocument.__last_agent_selection_ts = Date.now();
        if (selection) {
          const {
            start,
            end,
            direction
          } = selection;
          target.focus();
          target.setSelectionRange(start, end, direction);
        } else if (target.getRootNode({
          composed: true
        }).activeElement === target) {
          target.setSelectionRange(null, null);
        }
      } catch (err) {
        console.warn('Failed to select text', err);
      }
    });
    _defineProperty(this, "applyEvent", (type, event) => {
      var _RedactionIndexProvid;
      if (!event.target) return null;
      const target = _nodes.NodeTracker.getById(event.target.id);
      if (!target) return null;
      if ((_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) !== null && _RedactionIndexProvid !== void 0 && _RedactionIndexProvid.isRedacted(target)) return null;
      try {
        var _target$_cobrowse_sup;
        if (type === 'scroll') return this._applyScroll(target, event);

        // Allow for supressing some events when preceeding events are cancelled.
        // See comment below for more detail.
        if ((_target$_cobrowse_sup = target._cobrowse_suppress_events) !== null && _target$_cobrowse_sup !== void 0 && _target$_cobrowse_sup.has(event.state)) {
          target._cobrowse_suppress_events.delete(event.state);
          if (target._cobrowse_suppress_events.size === 0) delete target._cobrowse_suppress_events.size;
          return null;
        }
        const evt = this._generateEvent(type, target, event);
        if (evt) {
          if (target.dispatchEvent(evt)) {
            if (['keydown', 'keypress', 'input'].includes(event.state)) this._updateTarget(target, event);
            if (['selectionchange'].includes(event.state)) this._setSelection(target, event);
            if (['select'].includes(event.state)) this._setInputSelection(target, event);
          } else {
            // If the event is cancelled (i.e. a user side JS handler called preventDefault())
            // we should try to respect that. On the agent side, we have no knowledge
            // of what JS event handlers might do, so the agent side will send ALL
            // events in a sequence that the browser generated.
            // For example, pressing a key in an <input> might generate
            //    keydown -> keypress -> input -> change -> keyup
            // However if the keydown is cancelled, many of those events would not actually
            // be triggered by the browser as there will be no change in input value.
            // This means we need some way to track when events have been cancelled and
            // ignore them here so they're not injected by cobrowse.
            // We do this by setting a flag on the target that will allow later event
            // generators to check if a previous event in the chain was cancelled.
            // This is a long way from perfect, but it's good enough for now.
            if (event.state === 'keydown') {
              target._cobrowse_suppress_events = new Set(['keypress', 'input']);
            } else if (event.state === 'keypress') {
              target._cobrowse_suppress_events = new Set(['input']);
            }
          }
        }
        return evt;
      } catch (e) {
        console.warn('Error while injecting event', type, e);
        return null;
      }
    });
  }
  isTypingInput(event) {
    if (event.target) {
      const target = _nodes.NodeTracker.getById(event.target.id);
      if (['text', 'email', 'number', 'password', 'search', 'tel', 'url', 'datetime', 'textarea'].includes(target === null || target === void 0 ? void 0 : target.type)) {
        return true;
      }
    }
    return false;
  }
}
var _default = exports["default"] = new ControlEvents();

/***/ }),

/***/ 3672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ControlEvents", ({
  enumerable: true,
  get: function () {
    return _ControlEvents.default;
  }
}));
var _ControlEvents = _interopRequireDefault(__webpack_require__(2976));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 2109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _HTTPError = _interopRequireDefault(__webpack_require__(2701));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class APIError extends _HTTPError.default {
  constructor(id, status, message) {
    super(status, message);
    this.id = id;
    this.name = 'APIError';
  }
}
exports["default"] = APIError;

/***/ }),

/***/ 2701:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class HTTPError extends Error {
  constructor(status, message) {
    super(message);
    this.status = status;
    this.name = 'HTTPError';
  }
}
exports["default"] = HTTPError;

/***/ }),

/***/ 3469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(4428);
__webpack_require__(3697);
var _events = __webpack_require__(6261);
var _isMatchWith = _interopRequireDefault(__webpack_require__(6971));
var _omit = _interopRequireDefault(__webpack_require__(9947));
var _isEqual = _interopRequireDefault(__webpack_require__(8894));
var _APIError = _interopRequireDefault(__webpack_require__(2109));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _headers = /*#__PURE__*/new WeakMap();
var _resource = /*#__PURE__*/new WeakMap();
var _createPromise = /*#__PURE__*/new WeakMap();
var _updatePromise = /*#__PURE__*/new WeakMap();
var _destroyPromise = /*#__PURE__*/new WeakMap();
var _parseResponse = /*#__PURE__*/new WeakMap();
class RESTResource extends _events.EventEmitter {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec(this, _headers, {});
    _classPrivateFieldInitSpec(this, _resource, {});
    _classPrivateFieldInitSpec(this, _createPromise, null);
    _classPrivateFieldInitSpec(this, _updatePromise, null);
    _classPrivateFieldInitSpec(this, _destroyPromise, null);
    _classPrivateFieldInitSpec(this, _parseResponse, async res => {
      if (res.status >= 400) {
        const err = await res.json();
        throw new _APIError.default(err.id, res.status, err.message);
      }
      if (!res.ok) {
        throw new Error('Failed to parse response, response not ok');
      }
      if (res.status === 204) return null;
      return await res.json();
    });
  }
  get _resource() {
    console.warn('The _resource property is private and should not be accessed directly. It will soon be removed entirely. Please update your implementation to use only the public APIs.');
    return _classPrivateFieldGet(_resource, this);
  }
  get resource() {
    return _classPrivateFieldGet(_resource, this);
  }
  url() {
    throw new Error('url() must be implemented');
  }
  id() {
    return this.field('id');
  }
  field(field) {
    return (_classPrivateFieldGet(_resource, this) || {})[field];
  }
  cache(fields) {
    _classPrivateFieldSet(_resource, this, _objectSpread(_objectSpread({}, _classPrivateFieldGet(_resource, this)), fields));
  }
  async fetch() {
    // if there's a request in progress wait for it, ignoring
    // any error as they are handled by the original caller
    await Promise.allSettled([_classPrivateFieldGet(_createPromise, this), _classPrivateFieldGet(_updatePromise, this), _classPrivateFieldGet(_destroyPromise, this)]);
    const res = await fetch(this.url(), {
      headers: (0, _omit.default)(this.headers(), ['Content-Type'])
    });
    return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
  }
  async create() {
    const performCreate = async () => {
      const res = await fetch(this.url(), {
        method: 'POST',
        headers: this.headers()
      });
      return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
    };
    _classPrivateFieldSet(_createPromise, this, performCreate());
    try {
      return await _classPrivateFieldGet(_createPromise, this);
    } finally {
      _classPrivateFieldSet(_createPromise, this, null);
    }
  }
  async update(newState) {
    const performUpdate = async newState => {
      if (newState && Object.keys(newState).length > 0 && (0, _isMatchWith.default)(_classPrivateFieldGet(_resource, this), newState, _isEqual.default)) return this;
      const res = await fetch(this.url(), {
        method: this.id() ? 'PUT' : 'POST',
        headers: this.headers(),
        body: JSON.stringify(newState)
      });
      return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
    };

    // if there's an in-flight update request wait to complete
    await Promise.allSettled([_classPrivateFieldGet(_updatePromise, this)]);
    _classPrivateFieldSet(_updatePromise, this, performUpdate(newState));
    try {
      return await _classPrivateFieldGet(_updatePromise, this);
    } finally {
      _classPrivateFieldSet(_updatePromise, this, null);
    }
  }
  async destroy() {
    const performDestroy = async () => {
      const res = await fetch(this.url(), {
        method: 'DELETE',
        headers: this.headers()
      });
      return this.updateResource(await _classPrivateFieldGet(_parseResponse, this).call(this, res));
    };
    _classPrivateFieldSet(_destroyPromise, this, performDestroy());
    try {
      return await _classPrivateFieldGet(_destroyPromise, this);
    } finally {
      _classPrivateFieldSet(_destroyPromise, this, null);
    }
  }
  updateResource(resource) {
    const copy = this.clone();
    _classPrivateFieldSet(_resource, this, resource || {});
    this.emit('updated', this, copy);
    return this;
  }
  clone(copy) {
    // ensure we have a copy in case there
    // is no clone method on the subclass
    if (copy) _classPrivateFieldSet(_resource, copy, _objectSpread({}, _classPrivateFieldGet(_resource, this)));
  }
  headers() {
    return _objectSpread(_objectSpread({}, RESTResource.headers()), _classPrivateFieldGet(_headers, this));
  }
  setHeader(header, value) {
    _classPrivateFieldGet(_headers, this)[header] = value;
  }
  getHeader(header) {
    return this.headers()[header];
  }
  static headers() {
    return _assertClassBrand(RESTResource, this, _globalHeaders)._;
  }
  static setHeader(header, value) {
    _globalHeaders._[header] = value;
  }
  static getHeader(header) {
    return _globalHeaders._[header];
  }
  static set api(api) {
    _api._ = api;
  }
  static get api() {
    return _api._;
  }
}
exports["default"] = RESTResource;
var _globalHeaders = {
  _: {}
};
var _api = {
  _: void 0
};

/***/ }),

/***/ 492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "RESTResource", ({
  enumerable: true,
  get: function () {
    return _RESTResource.default;
  }
}));
var _RESTResource = _interopRequireDefault(__webpack_require__(3469));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 2404:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _uuid = __webpack_require__(5392);
var _protected = __webpack_require__(7609);
var _SessionCapabilities = _interopRequireDefault(__webpack_require__(86));
var _rest = __webpack_require__(492);
var _device = __webpack_require__(1667);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.Session');
var _delegate = /*#__PURE__*/new WeakMap();
var _capabilities = /*#__PURE__*/new WeakMap();
var _metrics = /*#__PURE__*/new WeakMap();
var _setAuthToken = /*#__PURE__*/new WeakMap();
var _authToken = /*#__PURE__*/new WeakMap();
var _setMetrics = /*#__PURE__*/new WeakMap();
var _serialize = /*#__PURE__*/new WeakMap();
var _serializeSanitized = /*#__PURE__*/new WeakMap();
var _deserialize = /*#__PURE__*/new WeakMap();
var _compress = /*#__PURE__*/new WeakMap();
var _decompress = /*#__PURE__*/new WeakMap();
var _proxyToken = /*#__PURE__*/new WeakMap();
var _proxyUrl = /*#__PURE__*/new WeakMap();
class Session extends _rest.RESTResource {
  constructor(delegate) {
    var _this;
    super();
    _this = this;
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _capabilities, void 0);
    _classPrivateFieldInitSpec(this, _metrics, {});
    _classPrivateFieldInitSpec(this, _setAuthToken, token => {
      this.setHeader('X-CobrowseDeviceToken', token);
    });
    _classPrivateFieldInitSpec(this, _authToken, () => {
      return this.getHeader('X-CobrowseDeviceToken');
    });
    _defineProperty(this, "activate", () => {
      debug('activate session');
      return this.update({
        state: 'active',
        device: _device.Device.info,
        custom_data: _classPrivateFieldGet(_delegate, this).customData
      });
    });
    _defineProperty(this, "end", () => {
      debug('end session');
      return this.update({
        state: 'ended'
      });
    });
    _defineProperty(this, "code", () => {
      return this.field('code');
    });
    _defineProperty(this, "state", () => {
      return this.field('state');
    });
    _defineProperty(this, "isActive", () => {
      return this.state() === 'active';
    });
    _defineProperty(this, "isAuthorizing", () => {
      return this.state() === 'authorizing';
    });
    _defineProperty(this, "isPending", () => {
      return this.state() === 'pending';
    });
    _defineProperty(this, "isEnded", () => {
      return this.state() === 'ended';
    });
    _defineProperty(this, "redactionSelectors", () => {
      const selectors = this.field('redaction_selectors');
      if (Array.isArray(selectors)) return selectors;
      return [];
    });
    _defineProperty(this, "unredactionSelectors", () => {
      const selectors = this.field('unredaction_selectors');
      if (Array.isArray(selectors)) return selectors;
      return [];
    });
    _defineProperty(this, "agent", () => {
      return this.field('agent') || false;
    });
    _defineProperty(this, "requireConsent", () => {
      return this.field('require_consent');
    });
    _defineProperty(this, "endedReason", () => {
      return this.field('ended_reason');
    });
    _defineProperty(this, "fullDevice", () => {
      return this.field('full_device') === true || this.field('full_device') === 'on' || this.field('full_device') === 'requested';
    });
    _defineProperty(this, "setFullDevice", state => {
      const capabilitiesToToggle = ['laser', 'drawing', 'disappearing_ink', 'arrows', 'rectangles', 'pointer', 'scroll', 'select', 'keypress', 'cursor'];
      _classPrivateFieldGet(_capabilities, this).toggle(capabilitiesToToggle, state !== 'on');
      return this.update({
        full_device: state
      });
    });
    _defineProperty(this, "update", properties => {
      return super.update(_objectSpread({
        capabilities: _classPrivateFieldGet(_capabilities, this).toArray()
      }, properties));
    });
    _defineProperty(this, "scale", () => {
      return this.field('scale') || 0.5;
    });
    _defineProperty(this, "remoteControl", () => {
      // must default to "on" for remote control as older
      // server versions (<= 1.2) did not set this property
      // TODO: default to "off" when its feasilble to drop
      //       support for old servers
      return this.field('remote_control') || 'on';
    });
    _defineProperty(this, "setRemoteControl", state => {
      return this.update({
        remote_control: state
      });
    });
    _defineProperty(this, "allowRemoteControl", () => {
      return this.remoteControl() === 'on';
    });
    _defineProperty(this, "calling", () => {
      return this.field('calling');
    });
    _defineProperty(this, "setCalling", state => {
      return this.update({
        calling: state
      });
    });
    _defineProperty(this, "updateResource", resource => {
      const wasEnded = this.isEnded();
      super.updateResource(resource);
      if (this.isEnded() && !wasEnded) {
        this.emit('ended', this);
        this.removeAllListeners();
      }
      return this;
    });
    _defineProperty(this, "clone", () => {
      const copy = new Session(_classPrivateFieldGet(_delegate, this));
      super.clone(copy);
      return copy;
    });
    _classPrivateFieldInitSpec(this, _setMetrics, (0, _protected.protect)(this, 'setMetrics', function () {
      let metrics = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classPrivateFieldSet(_metrics, _this, _objectSpread(_objectSpread({}, _classPrivateFieldGet(_metrics, _this)), metrics));
      _this.emit('metrics.updated', _this);
    }));
    _classPrivateFieldInitSpec(this, _serialize, (0, _protected.protect)(this, 'serialize', () => {
      return _objectSpread(_objectSpread({}, this.resource), {}, {
        _locals: {
          token: _classPrivateFieldGet(_authToken, this).call(this)
        }
      });
    }));
    _classPrivateFieldInitSpec(this, _serializeSanitized, (0, _protected.protect)(this, 'serializeSanitized', () => {
      return {
        state: this.resource.state,
        redaction_selectors: this.resource.redaction_selectors
      };
    }));
    _classPrivateFieldInitSpec(this, _deserialize, (0, _protected.protect)(this, 'deserialize', serialized => {
      const meta = serialized._locals || {};
      delete serialized._locals;
      _classPrivateFieldGet(_setAuthToken, this).call(this, meta.token);
      this.updateResource(serialized);
      return this;
    }));
    _classPrivateFieldInitSpec(this, _compress, (0, _protected.protect)(this, 'compress', () => {
      return "".concat(this.resource.id, ":").concat(_classPrivateFieldGet(_authToken, this).call(this));
    }));
    _classPrivateFieldInitSpec(this, _decompress, (0, _protected.protect)(this, 'decompress', compressed => {
      const parsed = compressed.split(':');
      _classPrivateFieldGet(_deserialize, this).call(this, {
        _locals: {
          token: parsed[parsed.length - 1]
        },
        id: parsed.slice(0, -1).join(':')
      });
      return this;
    }));
    _classPrivateFieldInitSpec(this, _proxyToken, (0, _protected.protect)(this, 'proxyToken', () => {
      return this.field('proxy_token');
    }));
    _classPrivateFieldInitSpec(this, _proxyUrl, (0, _protected.protect)(this, 'proxyUrl', () => {
      return this.field('proxy_url');
    }));
    if (!delegate) throw new Error('Session delegate is required');
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_capabilities, this, new _SessionCapabilities.default(delegate.capabilities));
    // Make sure we've assigned a token for this session
    // The session auth tokens may be exposed in URLs, but we
    // don't want to expose the device token directly, so we
    // derive a token from the device token for this purpose
    const salt = Math.ceil(Date.now() / (60 * 60 * 1000));
    _classPrivateFieldGet(_setAuthToken, this).call(this, (0, _uuid.v5)(salt + '', _device.Device.deviceToken()));
  }
  get capabilities() {
    const capabilities = this.field('capabilities');
    if (capabilities == null) return _classPrivateFieldGet(_capabilities, this).toArray();
    return _classPrivateFieldGet(_capabilities, this).toArray().filter(capability => capabilities === null || capabilities === void 0 ? void 0 : capabilities.includes(capability));
  }
  url() {
    const id = this.id() || this.code();
    return new URL("api/1/sessions".concat(id ? "/".concat(id) : ''), Session.api).toString();
  }
  get created() {
    return new Date(this.field('created'));
  }
  get expires() {
    return new Date(this.field('expires'));
  }
  get activated() {
    return this.field('activated') ? new Date(this.field('activated')) : null;
  }
  get updated() {
    return this.field('updated') ? new Date(this.field('updated')) : null;
  }
  get ended() {
    return this.field('ended') ? new Date(this.field('ended')) : null;
  }
  get metrics() {
    return _classPrivateFieldGet(_metrics, this);
  }
}
exports["default"] = Session;

/***/ }),

/***/ 86:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _capabilities = /*#__PURE__*/new WeakMap();
class SessionCapabilities {
  constructor(capabilities) {
    _classPrivateFieldInitSpec(this, _capabilities, {});
    this.fill(capabilities);
  }
  fill(capabilities) {
    _classPrivateFieldSet(_capabilities, this, capabilities.reduce((accumulator, capability) => {
      accumulator[capability] = true;
      return accumulator;
    }, {}));
    return this;
  }
  all() {
    return _classPrivateFieldGet(_capabilities, this);
  }
  toArray() {
    return Object.keys(_classPrivateFieldGet(_capabilities, this)).filter(key => _classPrivateFieldGet(_capabilities, this)[key]);
  }
  toggle(capabilities, state) {
    if (!Array.isArray(capabilities)) {
      capabilities = [capabilities];
    }
    capabilities.filter(capability => capability in _classPrivateFieldGet(_capabilities, this)).forEach(capability => {
      _classPrivateFieldGet(_capabilities, this)[capability] = state;
    });
    return this;
  }
}
exports["default"] = SessionCapabilities;

/***/ }),

/***/ 7089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.SESSION_CAPABILITY_TYPE_UNIVERSAL = exports.SESSION_CAPABILITY_TYPE_SELECT = exports.SESSION_CAPABILITY_TYPE_SCROLL = exports.SESSION_CAPABILITY_TYPE_RECTANGLES = exports.SESSION_CAPABILITY_TYPE_POINTER = exports.SESSION_CAPABILITY_TYPE_LASER = exports.SESSION_CAPABILITY_TYPE_KEYPRESS = exports.SESSION_CAPABILITY_TYPE_HIGHLIGHT = exports.SESSION_CAPABILITY_TYPE_FULL_DEVICE = exports.SESSION_CAPABILITY_TYPE_DRAWING = exports.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK = exports.SESSION_CAPABILITY_TYPE_CURSOR = exports.SESSION_CAPABILITY_TYPE_CALLING = exports.SESSION_CAPABILITY_TYPE_ARROWS = void 0;
const SESSION_CAPABILITY_TYPE_POINTER = exports.SESSION_CAPABILITY_TYPE_POINTER = 'pointer';
const SESSION_CAPABILITY_TYPE_SCROLL = exports.SESSION_CAPABILITY_TYPE_SCROLL = 'scroll';
const SESSION_CAPABILITY_TYPE_SELECT = exports.SESSION_CAPABILITY_TYPE_SELECT = 'select';
const SESSION_CAPABILITY_TYPE_KEYPRESS = exports.SESSION_CAPABILITY_TYPE_KEYPRESS = 'keypress';
const SESSION_CAPABILITY_TYPE_DRAWING = exports.SESSION_CAPABILITY_TYPE_DRAWING = 'drawing';
const SESSION_CAPABILITY_TYPE_ARROWS = exports.SESSION_CAPABILITY_TYPE_ARROWS = 'arrows';
const SESSION_CAPABILITY_TYPE_RECTANGLES = exports.SESSION_CAPABILITY_TYPE_RECTANGLES = 'rectangles';
const SESSION_CAPABILITY_TYPE_LASER = exports.SESSION_CAPABILITY_TYPE_LASER = 'laser';
const SESSION_CAPABILITY_TYPE_DISAPPEARING_INK = exports.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK = 'disappearing_ink';
const SESSION_CAPABILITY_TYPE_FULL_DEVICE = exports.SESSION_CAPABILITY_TYPE_FULL_DEVICE = 'full_device';
const SESSION_CAPABILITY_TYPE_CURSOR = exports.SESSION_CAPABILITY_TYPE_CURSOR = 'cursor';
const SESSION_CAPABILITY_TYPE_UNIVERSAL = exports.SESSION_CAPABILITY_TYPE_UNIVERSAL = 'universal';
const SESSION_CAPABILITY_TYPE_HIGHLIGHT = exports.SESSION_CAPABILITY_TYPE_HIGHLIGHT = 'highlight';
const SESSION_CAPABILITY_TYPE_CALLING = exports.SESSION_CAPABILITY_TYPE_CALLING = 'calling';
var _default = exports["default"] = [SESSION_CAPABILITY_TYPE_POINTER, SESSION_CAPABILITY_TYPE_SCROLL, SESSION_CAPABILITY_TYPE_SELECT, SESSION_CAPABILITY_TYPE_KEYPRESS, SESSION_CAPABILITY_TYPE_DRAWING, SESSION_CAPABILITY_TYPE_ARROWS, SESSION_CAPABILITY_TYPE_RECTANGLES, SESSION_CAPABILITY_TYPE_DISAPPEARING_INK, SESSION_CAPABILITY_TYPE_LASER, SESSION_CAPABILITY_TYPE_FULL_DEVICE, SESSION_CAPABILITY_TYPE_CURSOR, SESSION_CAPABILITY_TYPE_UNIVERSAL, SESSION_CAPABILITY_TYPE_HIGHLIGHT, SESSION_CAPABILITY_TYPE_CALLING];

/***/ }),

/***/ 729:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _isEqual = _interopRequireDefault(__webpack_require__(8894));
var _uuid = __webpack_require__(5392);
var _SessionSockets = _interopRequireDefault(__webpack_require__(324));
var _frames = __webpack_require__(8647);
var _activity = __webpack_require__(5264);
var _ui = __webpack_require__(3035);
var _remotecontrol = __webpack_require__(3672);
var _redaction = __webpack_require__(6566);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _SessionCapabilityTypes = __webpack_require__(7089);
var _SessionEventTypes = __webpack_require__(8325);
var _navigation2 = __webpack_require__(9715);
var _pdf = __webpack_require__(1065);
var _universal = __webpack_require__(1834);
var _XDocHandler = _interopRequireDefault(__webpack_require__(6900));
var _Navigation = __webpack_require__(4661);
var _documents = __webpack_require__(9689);
var _WindowTaps = _interopRequireDefault(__webpack_require__(4153));
var _NodeContent = __webpack_require__(9931);
var _SessionStateOverlay = _interopRequireDefault(__webpack_require__(4340));
var _ClientTracker = __webpack_require__(4162);
var _getPersistentId = __webpack_require__(7195);
var _calling = __webpack_require__(4719);
var _iframes = _interopRequireDefault(__webpack_require__(7966));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.SessionContext');
const debugEvents = (0, _debug.default)('cbio.SessionContext.events');
var _sockets = /*#__PURE__*/new WeakMap();
var _frameId = /*#__PURE__*/new WeakMap();
var _frameLoop = /*#__PURE__*/new WeakMap();
var _lastSyncId = /*#__PURE__*/new WeakMap();
var _confirmingSession = /*#__PURE__*/new WeakMap();
var _documentCollection = /*#__PURE__*/new WeakMap();
var _navigation = /*#__PURE__*/new WeakMap();
var _clientTracker = /*#__PURE__*/new WeakMap();
var _callHandler = /*#__PURE__*/new WeakMap();
var _onStreamOpen = /*#__PURE__*/new WeakMap();
var _onSessionStateOverlayClick = /*#__PURE__*/new WeakMap();
var _shouldNavigate = /*#__PURE__*/new WeakMap();
var _SessionContext_brand = /*#__PURE__*/new WeakSet();
var _onNavigate = /*#__PURE__*/new WeakMap();
var _onRemoteErrorEvent = /*#__PURE__*/new WeakMap();
var _onSyncEvent = /*#__PURE__*/new WeakMap();
var _onLaserEvent = /*#__PURE__*/new WeakMap();
var _onHighlightEvent = /*#__PURE__*/new WeakMap();
var _onDrawingEvent = /*#__PURE__*/new WeakMap();
var _onControlEvent = /*#__PURE__*/new WeakMap();
var _onClientEvent = /*#__PURE__*/new WeakMap();
var _updateSessionControls = /*#__PURE__*/new WeakMap();
var _updateRedaction = /*#__PURE__*/new WeakMap();
var _hasRedactionChanges = /*#__PURE__*/new WeakMap();
var _runConfirmSession = /*#__PURE__*/new WeakMap();
var _requestRemoteControl = /*#__PURE__*/new WeakMap();
var _requestFullDevice = /*#__PURE__*/new WeakMap();
var _pickFrameSource = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onSessionEnded = /*#__PURE__*/new WeakMap();
var _sendEvent = /*#__PURE__*/new WeakMap();
var _sendFocusEvent = /*#__PURE__*/new WeakMap();
var _sendScreenEvent = /*#__PURE__*/new WeakMap();
var _sendDOMFrame = /*#__PURE__*/new WeakMap();
var _sendFrame = /*#__PURE__*/new WeakMap();
var _sendClickEvent = /*#__PURE__*/new WeakMap();
var _sendChangeEvent = /*#__PURE__*/new WeakMap();
var _sendMouseEvent = /*#__PURE__*/new WeakMap();
var _startFrames = /*#__PURE__*/new WeakMap();
class SessionContext {
  constructor(_session, delegate) {
    _classPrivateMethodInitSpec(this, _SessionContext_brand);
    _classPrivateFieldInitSpec(this, _sockets, void 0);
    _classPrivateFieldInitSpec(this, _frameId, void 0);
    _classPrivateFieldInitSpec(this, _frameLoop, new _frames.FrameLoop());
    _classPrivateFieldInitSpec(this, _lastSyncId, void 0);
    _classPrivateFieldInitSpec(this, _confirmingSession, void 0);
    _classPrivateFieldInitSpec(this, _documentCollection, void 0);
    _classPrivateFieldInitSpec(this, _navigation, void 0);
    _classPrivateFieldInitSpec(this, _clientTracker, void 0);
    _classPrivateFieldInitSpec(this, _callHandler, void 0);
    _classPrivateFieldInitSpec(this, _onStreamOpen, () => {
      _classPrivateFieldGet(_sendFocusEvent, this).call(this);
      if (!_classPrivateFieldGet(_clientTracker, this)) {
        _classPrivateFieldSet(_clientTracker, this, new _ClientTracker.ClientTracker((0, _getPersistentId.getPersistentId)('_cobrowse_client_id'), (0, _uuid.v4)()));
        _classPrivateFieldGet(_clientTracker, this).on('ping', data => _classPrivateFieldGet(_sockets, this).stream.send('client', data));
        this.session.on('client', _classPrivateFieldGet(_onClientEvent, this));
      }
      if (!_classPrivateFieldGet(_callHandler, this)) _classPrivateFieldSet(_callHandler, this, new _calling.CallHandler(this.session, _classPrivateFieldGet(_clientTracker, this), _classPrivateFieldGet(_sockets, this).stream));
      _classPrivateFieldGet(_clientTracker, this).ping();
    });
    _classPrivateFieldInitSpec(this, _onSessionStateOverlayClick, target => {
      var _this$session;
      if (target === 'session-end' && (_this$session = this.session) !== null && _this$session !== void 0 && _this$session.isActive()) this.session.end();
      if (target === 'call-end') this.session.update({
        calling: 'off'
      });
    });
    _classPrivateFieldInitSpec(this, _shouldNavigate, type => {
      var _this$session2;
      if (!((_this$session2 = this.session) !== null && _this$session2 !== void 0 && _this$session2.isActive())) return false;
      if (type === _Navigation.NAVIGATION_TYPE.UNIVERSAL && !this.session.capabilities.includes(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_UNIVERSAL)) return false;
      return true;
    });
    _defineProperty(this, "handleNavigation", (url, target, windowFeatures, options) => {
      var _consentResult$then;
      const {
        name,
        go,
        type
      } = options;
      const {
        handle,
        document
      } = _classPrivateFieldGet(_documentCollection, this).resolveDocument(options.handle, name);
      const {
        windowProxy
      } = document;
      const nav = {
        continue: overrideTarget => {
          const handlerResult = _classPrivateFieldGet(_navigation, this).runHandler(url, overrideTarget || target, windowFeatures, _objectSpread(_objectSpread({}, options), {}, {
            document
          }));
          if (handlerResult.rewrittenUrl) return {
            rewrittenUrl: handlerResult.rewrittenUrl
          };
          if (handlerResult.document) _classPrivateFieldGet(_documentCollection, this).addDocument(handle, name, handlerResult.document);
          return {
            windowProxy
          };
        },
        replay: () => {
          go();
          return {
            windowProxy
          };
        }
      };
      if (!type) return nav.continue();

      // XDoc navigations don't require consent
      if (type === _Navigation.NAVIGATION_TYPE.XDOC) return nav.continue();
      const consentResult = this.delegate.confirmOpen(url, type);

      // handle sync consent result, no need to replay
      if (!consentResult) return {
        rewrittenUrl: url
      };
      if (consentResult === true) return nav.continue('_blank');

      // handle async consent result
      (_consentResult$then = consentResult.then) === null || _consentResult$then === void 0 || _consentResult$then.call(consentResult, accepted => {
        if (!accepted) return nav.replay();
        nav.continue('_blank');
      });
      return {
        windowProxy
      };
    });
    _defineProperty(this, "invalidateFrames", () => {
      if (_classPrivateFieldGet(_frameLoop, this).isRunning()) _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _defineProperty(this, "destroy", () => {
      debug('destroy session context');
      _classPrivateFieldGet(_onSessionEnded, this).call(this);
      _SessionStateOverlay.default.off('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
      if (_classPrivateFieldGet(_navigation, this)) _classPrivateFieldGet(_navigation, this).destroy();
      _classPrivateFieldSet(_navigation, this, null);
      _WindowTaps.default.off('navigate', _classPrivateFieldGet(_onNavigate, this));
      if (_classPrivateFieldGet(_sockets, this)) _classPrivateFieldGet(_sockets, this).close();
      _classPrivateFieldSet(_sockets, this, null);
      if (_classPrivateFieldGet(_frameLoop, this)) _classPrivateFieldGet(_frameLoop, this).destroy();
      _classPrivateFieldSet(_frameLoop, this, null);
      if (_classPrivateFieldGet(_callHandler, this)) _classPrivateFieldGet(_callHandler, this).destroy();
      _classPrivateFieldSet(_callHandler, this, null);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).destroy();
      _classPrivateFieldSet(_documentCollection, this, null);
      if (_classPrivateFieldGet(_clientTracker, this)) _classPrivateFieldGet(_clientTracker, this).destroy();
      _classPrivateFieldSet(_clientTracker, this, null);
      _activity.WindowTracking.off('activate', _classPrivateFieldGet(_sendFocusEvent, this));
      window.removeEventListener('focus', _classPrivateFieldGet(_sendFocusEvent, this), {
        capture: true,
        passive: true
      });
      window.removeEventListener('hashchange', _classPrivateFieldGet(_sendScreenEvent, this), {
        capture: true,
        passive: true
      });
      if (_activity.MouseTracking.onChange === _classPrivateFieldGet(_sendMouseEvent, this)) _activity.MouseTracking.onChange = null;
      _activity.InteractionTracking.off('click', _classPrivateFieldGet(_sendClickEvent, this));
      _activity.InteractionTracking.off('change', _classPrivateFieldGet(_sendChangeEvent, this));
      _iframes.default.off('click', _classPrivateFieldGet(_sendClickEvent, this));
      _iframes.default.off('change', _classPrivateFieldGet(_sendChangeEvent, this));
      if (this.session) {
        this.session.removeListener('update', _classPrivateFieldGet(_onSessionUpdated, this));
        this.session.removeListener('ended', _classPrivateFieldGet(_onSessionEnded, this));
        this.session.removeListener('sync', _classPrivateFieldGet(_onSyncEvent, this));
        this.session.removeListener('drawing', _classPrivateFieldGet(_onDrawingEvent, this));
        this.session.removeListener('laser', _classPrivateFieldGet(_onLaserEvent, this));
        this.session.removeListener('control', _classPrivateFieldGet(_onControlEvent, this));
        this.session.removeListener('remote-error', _classPrivateFieldGet(_onRemoteErrorEvent, this));
        this.session.removeListener('client', _classPrivateFieldGet(_onClientEvent, this));
      }
      document.removeEventListener('DOMContentLoaded', _classPrivateFieldGet(_updateSessionControls, this), {
        once: true
      });
      this.session = null;
    });
    _classPrivateFieldInitSpec(this, _onNavigate, (_window, previousUrl) => {
      _classPrivateFieldGet(_updateRedaction, this).call(this, this.session);
      _ui.Highlight.hide();

      // avoid an expensive operation if there are no changes in redaction selectors
      if (_redaction.TargetedRedaction.hasChange(this.delegate.redactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(this.delegate.unredactedViews, previousUrl) || _redaction.TargetedRedaction.hasChange(this.session.redactionSelectors(), previousUrl) || _redaction.TargetedRedaction.hasChange(this.session.unredactionSelectors(), previousUrl)) {
        this.invalidateFrames();
      }
    });
    _classPrivateFieldInitSpec(this, _onRemoteErrorEvent, async event => {
      const current = _classPrivateFieldGet(_frameLoop, this).getSource();
      if (!(current instanceof _frames.DOMFrameSource)) return;
      const {
        target,
        error: {
          cause
        }
      } = event;
      if (cause !== 'load-error') return;
      // TODO: remove backwards compatibility when frontend sends target as an object
      const nodeId = typeof target === 'string' ? target : target.id;
      await (0, _NodeContent.applyContentCache)(nodeId);
      current.partialSync(nodeId);
    });
    _classPrivateFieldInitSpec(this, _onSyncEvent, _ref => {
      let {
        id
      } = _ref;
      if (id && _classPrivateFieldGet(_lastSyncId, this) === id) return;
      _classPrivateFieldSet(_lastSyncId, this, id);
      _classPrivateFieldGet(_frameLoop, this).invalidateFrame();
    });
    _classPrivateFieldInitSpec(this, _onLaserEvent, event => {
      if (!_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) {
        return;
      }
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      _ui.LaserOverlay.update(event);
    });
    _classPrivateFieldInitSpec(this, _onHighlightEvent, async event => {
      debugEvents('on(highlight)', event);
      if (!_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) return;
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      await _ui.Highlight.highlight(this.delegate, event);
    });
    _classPrivateFieldInitSpec(this, _onDrawingEvent, event => {
      if (!_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) {
        return;
      }
      if (!event.image) _ui.AnnotationOverlay.hide(event.agent);
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      _ui.AnnotationOverlay.update(event);
    });
    _classPrivateFieldInitSpec(this, _onControlEvent, (type, event) => {
      if (type === 'focus' && !event.agent) {
        _activity.WindowTracking.resignActive();
      }
      if (!event.agent) return;
      if (!_activity.WindowTracking.isActive()) return;
      if (this.session.fullDevice()) return;
      if (this.session.allowRemoteControl()) {
        if (this.session.capabilities.includes(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_CURSOR)) {
          _ui.RemoteCursor.update(type, event);
        }
        if (_assertClassBrand(_SessionContext_brand, this, _allowsEvent).call(this, event)) {
          _remotecontrol.ControlEvents.applyEvent(type, event);
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onClientEvent, data => {
      _classPrivateFieldGet(_clientTracker, this).track(data);
    });
    _classPrivateFieldInitSpec(this, _updateSessionControls, session => {
      // check if context was destroyed while waiting for DOM
      if (!this.session) return;

      // then evaluate control state
      if (session.isActive()) {
        // if the body is available, show the controls right away
        if (document.body) this.delegate.showSessionControls(session);
        // otherwise wait for the dom content and then try
        else document.addEventListener('DOMContentLoaded', _classPrivateFieldGet(_updateSessionControls, this), {
          once: true
        });
      } else this.delegate.hideSessionControls(session);
    });
    _classPrivateFieldInitSpec(this, _updateRedaction, session => {
      _redaction.RedactionIndexProvider.instance = new _redaction.RedactionIndex(_redaction.TargetedRedaction.filterSelectors(this.delegate.redactedViews), _redaction.TargetedRedaction.filterSelectors(this.delegate.unredactedViews), _redaction.TargetedRedaction.filterSelectors(session.redactionSelectors()), _redaction.TargetedRedaction.filterSelectors(session.unredactionSelectors()));
    });
    _classPrivateFieldInitSpec(this, _hasRedactionChanges, (session, prevSession) => {
      const hasRedactionSelectorChanges = !(0, _isEqual.default)(session.redactionSelectors(), (prevSession === null || prevSession === void 0 ? void 0 : prevSession.redactionSelectors()) || []);
      const hasUnredactionSelectorChanges = !(0, _isEqual.default)(session.unredactionSelectors(), (prevSession === null || prevSession === void 0 ? void 0 : prevSession.unredactionSelectors()) || []);
      return hasRedactionSelectorChanges || hasUnredactionSelectorChanges;
    });
    _classPrivateFieldInitSpec(this, _runConfirmSession, async session => {
      // wait until an agent has actually joined the session and the
      // user has passed through the confirmSession flow before actually
      // activiating the session (starts stream sockets & frame loop)
      if (!session.agent() || session.isActive() || session.isEnded()) return null;

      // only try to confirm session acceptance once per context
      if (_classPrivateFieldGet(_confirmingSession, this)) return null;
      _classPrivateFieldSet(_confirmingSession, this, true);

      // skip auth prompt if the sessions allows
      if (!session.requireConsent()) return session.activate();
      try {
        // move state to authorizing
        debug('authorizing session');
        await session.update({
          state: 'authorizing'
        });

        // open confirmation dialog if context was not destroyed during async update
        if (!this.session || !session.isAuthorizing()) return null;

        // returning false from session confirmations will prevent session activiation
        // we accept null or udnefined or anything truthy as acceptance
        const accepted = await this.delegate.confirmSession(session);

        // check if context was destroyed while waiting for user confirmation
        if (!this.session) return null;
        if (accepted === false) {
          debug('user rejected session request');
          return session.end();
        } else {
          debug('session accepted');
          return session.activate();
        }
      } catch (e) {
        if (e) console.warn('CobrowseIO: error caught during confirmation', e);
        if (this.session) return session.end();
        return null;
      }
    });
    _classPrivateFieldInitSpec(this, _requestRemoteControl, async session => {
      if (session.remoteControl() !== 'requested') return null;
      try {
        // anything except false will allow remote control
        if ((await this.delegate.confirmRemoteControl()) === false) {
          debug('user rejeted remote control');
          return session.update({
            remote_control: 'rejected'
          });
        } else {
          debug('user accepted remote control');
          return session.update({
            remote_control: 'on'
          });
        }
      } catch (e) {
        if (e) console.warn('CobrowseIO: error caught during confirmation', e);
        return session.update({
          remote_control: 'rejected'
        });
      }
    });
    _classPrivateFieldInitSpec(this, _requestFullDevice, async () => {
      // prevent full device consent from being reprompted
      // legacy full_device is a boolean value
      const fullDevice = this.session.resource.full_device;
      if (fullDevice !== true && fullDevice !== 'requested') return false;
      if (!_activity.WindowTracking.isActive()) return false;
      if (!this.session.capabilities.includes(_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_FULL_DEVICE)) {
        return;
      }
      try {
        const accepted = await this.delegate.confirmFullDevice();
        debug('full device request', accepted);
        if (!accepted) await this.session.setFullDevice('rejected');
        return accepted;
      } catch (_unused) {
        await this.session.setFullDevice('off');
        return false;
      }
    });
    _classPrivateFieldInitSpec(this, _pickFrameSource, async session => {
      if (session.isEnded() || !_classPrivateFieldGet(_frameLoop, this)) return null;
      const current = _classPrivateFieldGet(_frameLoop, this).getSource();
      if (session.fullDevice()) {
        if (!(current instanceof _frames.MediaStreamFrameSource)) {
          await _classPrivateFieldGet(_frameLoop, this).setSource(new _frames.MediaStreamFrameSource({
            handleFrame: _classPrivateFieldGet(_sendFrame, this),
            scale: session.scale,
            captureStarted: media => {
              session.setFullDevice('on');
              session.emit('media', media);
            },
            captureEnded: e => {
              if (e) console.warn('Full device mode failed: ', e);
              session.setFullDevice(e ? 'rejected' : 'off');
            },
            requestPermission: _classPrivateFieldGet(_requestFullDevice, this)
          }));
        }
      } else {
        if (!(current instanceof _frames.DOMFrameSource)) {
          _classPrivateFieldGet(_frameLoop, this).setSource(new _frames.DOMFrameSource(_classPrivateFieldGet(_sendDOMFrame, this)));
        }
      }
      _classPrivateFieldGet(_frameLoop, this).getSource().setCodecs(session.resource.video_codecs);
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, (session, prevSession) => {
      // check if context has been destroyed
      if (!this.session) {
        debug('onSessionUpdated called after destroy()');
        return;
      }
      _classPrivateFieldGet(_runConfirmSession, this).call(this, session);
      _classPrivateFieldGet(_updateSessionControls, this).call(this, session);
      _classPrivateFieldGet(_updateRedaction, this).call(this, session);
      if (_classPrivateFieldGet(_hasRedactionChanges, this).call(this, session, prevSession)) this.invalidateFrames();
      _classPrivateFieldGet(_requestRemoteControl, this).call(this, session);
      _classPrivateFieldGet(_pickFrameSource, this).call(this, session);
      if (session.isActive()) _classPrivateFieldGet(_startFrames, this).call(this);
    });
    _classPrivateFieldInitSpec(this, _onSessionEnded, () => {
      _ui.AnnotationOverlay.hide();
      _ui.RemoteCursor.hide();
      _ui.LaserOverlay.hide();
      _ui.Highlight.hide();
      this.delegate.hideSessionControls(this.session);
      if (_classPrivateFieldGet(_documentCollection, this)) _classPrivateFieldGet(_documentCollection, this).closeAllDocuments();
    });
    _classPrivateFieldInitSpec(this, _sendEvent, (event, data) => {
      if (!this.session || !this.session.isActive()) return false;
      if (!this.session.fullDevice() && !_activity.WindowTracking.isActive()) return false;
      if (!_classPrivateFieldGet(_sockets, this)) return false;
      if (!_classPrivateFieldGet(_sockets, this).stream) return false;
      if (!_classPrivateFieldGet(_sockets, this).stream.connected) return false;
      if (!_classPrivateFieldGet(_sockets, this).stream.bufferedAmount > 100) return false;
      _classPrivateFieldGet(_sockets, this).stream.send(event, data);
      return true;
    });
    _classPrivateFieldInitSpec(this, _sendFocusEvent, () => {
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'focus', {
        type: 'Focus',
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _sendScreenEvent, () => {
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'screen', {
        type: 'Screen',
        timestamp: new Date(),
        url: window.location.href,
        title: document.title
      });
    });
    _classPrivateFieldInitSpec(this, _sendDOMFrame, dom => {
      _classPrivateFieldSet(_frameId, this, (_classPrivateFieldGet(_frameId, this) || 0) + 1);
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'frame', {
        type: 'Frame',
        id: _classPrivateFieldGet(_frameId, this),
        data: dom,
        timestamp: new Date(),
        mime_type: 'application/x-cbio-vdom-patch'
      });
    });
    _classPrivateFieldInitSpec(this, _sendFrame, (data, mimeType, maxInFlight) => {
      if (_classPrivateFieldGet(_sockets, this).stream.messageLag() >= maxInFlight) {
        debug('dropped frame due to message lag', _classPrivateFieldGet(_sockets, this).stream.messageLag());
        return;
      }
      _classPrivateFieldSet(_frameId, this, (_classPrivateFieldGet(_frameId, this) || 0) + 1);
      _classPrivateFieldGet(_sendEvent, this).call(this, 'frame', {
        type: 'Frame',
        id: _classPrivateFieldGet(_frameId, this),
        data,
        timestamp: new Date(),
        mime_type: mimeType
      });
    });
    _classPrivateFieldInitSpec(this, _sendClickEvent, serializedTarget => {
      const position = _activity.MouseTracking.position();
      _classPrivateFieldGet(_sendEvent, this).call(this, 'mouse', {
        type: _SessionEventTypes.SESSION_EVENT_TYPE_MOUSE,
        x: position.x / window.innerWidth,
        y: position.y / window.innerHeight,
        target: serializedTarget,
        state: 'click',
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _sendChangeEvent, serializedTarget => {
      _classPrivateFieldGet(_sendEvent, this).call(this, 'change', {
        type: _SessionEventTypes.SESSION_EVENT_TYPE_CHANGE,
        target: serializedTarget,
        state: 'change',
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _sendMouseEvent, mouse => {
      let state = 'mouseout';
      if (mouse.in) state = mouse.down ? 'mousedown' : 'mouseup';
      return _classPrivateFieldGet(_sendEvent, this).call(this, 'mouse', {
        type: _SessionEventTypes.SESSION_EVENT_TYPE_MOUSE,
        x: mouse.x / window.innerWidth,
        y: mouse.y / window.innerHeight,
        state,
        timestamp: new Date()
      });
    });
    _classPrivateFieldInitSpec(this, _startFrames, () => {
      if (!_classPrivateFieldGet(_frameLoop, this).isRunning()) {
        debug('start frames');
        _classPrivateFieldGet(_frameLoop, this).start();
      }
      return this;
    });
    debug('session context constructed');
    this.session = _session;
    this.delegate = delegate;
    _classPrivateFieldSet(_sockets, this, new _SessionSockets.default(_session));
    _activity.WindowTracking.on('activate', _classPrivateFieldGet(_sendFocusEvent, this));
    window.addEventListener('focus', _classPrivateFieldGet(_sendFocusEvent, this), {
      capture: true,
      passive: true
    });
    window.addEventListener('hashchange', _classPrivateFieldGet(_sendScreenEvent, this), {
      capture: true,
      passive: true
    });
    _activity.MouseTracking.onChange = _classPrivateFieldGet(_sendMouseEvent, this);
    _activity.InteractionTracking.on('click', _classPrivateFieldGet(_sendClickEvent, this));
    _activity.InteractionTracking.on('change', _classPrivateFieldGet(_sendChangeEvent, this));
    _iframes.default.on('click', _classPrivateFieldGet(_sendClickEvent, this));
    _iframes.default.on('change', _classPrivateFieldGet(_sendChangeEvent, this));
    _classPrivateFieldGet(_onSessionUpdated, this).call(this, _session);
    _session.on('updated', _classPrivateFieldGet(_onSessionUpdated, this));
    _session.on('ended', _classPrivateFieldGet(_onSessionEnded, this));
    _session.on('sync', _classPrivateFieldGet(_onSyncEvent, this));
    _session.on('highlight', _classPrivateFieldGet(_onHighlightEvent, this));
    _session.on('drawing', _classPrivateFieldGet(_onDrawingEvent, this));
    _session.on('laser', _classPrivateFieldGet(_onLaserEvent, this));
    _session.on('control', _classPrivateFieldGet(_onControlEvent, this));
    _session.on('remote-error', _classPrivateFieldGet(_onRemoteErrorEvent, this));
    _session.once('stream-open', _classPrivateFieldGet(_onStreamOpen, this));
    _classPrivateFieldSet(_documentCollection, this, new _documents.DocumentCollection({
      onDocumentAdded: document => this.delegate.showDocument(document)
    }));
    const pdfHandler = new _pdf.PDFHandler(_session, delegate);
    const universalHandler = new _universal.UniversalHandler(_session, delegate);
    const xdocHandler = new _XDocHandler.default(_session, delegate);
    _classPrivateFieldSet(_navigation, this, new _navigation2.Navigation({
      shouldNavigate: _classPrivateFieldGet(_shouldNavigate, this),
      handlers: [pdfHandler, universalHandler, xdocHandler],
      handleNavigation: this.handleNavigation
    }));
    _WindowTaps.default.on('navigate', _classPrivateFieldGet(_onNavigate, this));
    _SessionStateOverlay.default.on('click', _classPrivateFieldGet(_onSessionStateOverlayClick, this));
  }
}
exports["default"] = SessionContext;
function _allowsEvent(event) {
  const events = {
    [_SessionEventTypes.SESSION_EVENT_TYPE_MOUSE]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_TOUCH]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_POINTER]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_FOCUS]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_KEYPRESS]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS],
    [_SessionEventTypes.SESSION_EVENT_TYPE_SCROLL]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SCROLL],
    [_SessionEventTypes.SESSION_EVENT_TYPE_CHANGE]: _remotecontrol.ControlEvents.isTypingInput(event) ? [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS] : [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_INPUT]: _remotecontrol.ControlEvents.isTypingInput(event) ? [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS] : [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_KEYPRESS, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_POINTER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_LASER]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_LASER],
    [_SessionEventTypes.SESSION_EVENT_TYPE_HIGHLIGHT]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_HIGHLIGHT],
    [_SessionEventTypes.SESSION_EVENT_TYPE_DRAWING]: event.disappears_in != null ? [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DISAPPEARING_INK] : [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_DRAWING, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_RECTANGLES, _SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_ARROWS],
    [_SessionEventTypes.SESSION_EVENT_TYPE_SELECT]: [_SessionCapabilityTypes.SESSION_CAPABILITY_TYPE_SELECT]
  };
  return events[event.type].some(capability => this.session.capabilities.includes(capability));
}

/***/ }),

/***/ 8325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SESSION_EVENT_TYPE_TOUCH = exports.SESSION_EVENT_TYPE_SELECT = exports.SESSION_EVENT_TYPE_SCROLL = exports.SESSION_EVENT_TYPE_POINTER = exports.SESSION_EVENT_TYPE_MOUSE = exports.SESSION_EVENT_TYPE_LASER = exports.SESSION_EVENT_TYPE_KEYPRESS = exports.SESSION_EVENT_TYPE_INPUT = exports.SESSION_EVENT_TYPE_HIGHLIGHT = exports.SESSION_EVENT_TYPE_FOCUS = exports.SESSION_EVENT_TYPE_DRAWING = exports.SESSION_EVENT_TYPE_CHANGE = void 0;
const SESSION_EVENT_TYPE_MOUSE = exports.SESSION_EVENT_TYPE_MOUSE = 'Mouse';
const SESSION_EVENT_TYPE_TOUCH = exports.SESSION_EVENT_TYPE_TOUCH = 'Touch';
const SESSION_EVENT_TYPE_POINTER = exports.SESSION_EVENT_TYPE_POINTER = 'Pointer';
const SESSION_EVENT_TYPE_FOCUS = exports.SESSION_EVENT_TYPE_FOCUS = 'Focus';
const SESSION_EVENT_TYPE_KEYPRESS = exports.SESSION_EVENT_TYPE_KEYPRESS = 'KeyPress';
const SESSION_EVENT_TYPE_SCROLL = exports.SESSION_EVENT_TYPE_SCROLL = 'Scroll';
const SESSION_EVENT_TYPE_CHANGE = exports.SESSION_EVENT_TYPE_CHANGE = 'Change';
const SESSION_EVENT_TYPE_INPUT = exports.SESSION_EVENT_TYPE_INPUT = 'Input';
const SESSION_EVENT_TYPE_LASER = exports.SESSION_EVENT_TYPE_LASER = 'Laser';
const SESSION_EVENT_TYPE_HIGHLIGHT = exports.SESSION_EVENT_TYPE_HIGHLIGHT = 'Highlight';
const SESSION_EVENT_TYPE_DRAWING = exports.SESSION_EVENT_TYPE_DRAWING = 'Drawing';
const SESSION_EVENT_TYPE_SELECT = exports.SESSION_EVENT_TYPE_SELECT = 'Select';

/***/ }),

/***/ 324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(9377);
__webpack_require__(3697);
var _cocom = __webpack_require__(3439);
var _makeSocketUrl = _interopRequireDefault(__webpack_require__(6851));
var _protected = _interopRequireDefault(__webpack_require__(7609));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const SESSION_METRICS_INTERVAL_MS = 1000;
var _session = /*#__PURE__*/new WeakMap();
var _control = /*#__PURE__*/new WeakMap();
var _stream = /*#__PURE__*/new WeakMap();
var _sessionMetricsIntervalId = /*#__PURE__*/new WeakMap();
var _createSocket = /*#__PURE__*/new WeakMap();
var _openControl = /*#__PURE__*/new WeakMap();
var _openStream = /*#__PURE__*/new WeakMap();
class SessionSockets {
  constructor(session) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _control, void 0);
    _classPrivateFieldInitSpec(this, _stream, void 0);
    _classPrivateFieldInitSpec(this, _sessionMetricsIntervalId, void 0);
    _defineProperty(this, "open", () => {
      if (!_classPrivateFieldGet(_session, this).isEnded()) {
        _classPrivateFieldGet(_openControl, this).call(this);
        _classPrivateFieldGet(_openStream, this).call(this);
      }
    });
    _defineProperty(this, "close", () => {
      window.removeEventListener('visibilitychange', this.onVisibilityChange);
      if (_classPrivateFieldGet(_sessionMetricsIntervalId, this)) {
        clearInterval(_classPrivateFieldGet(_sessionMetricsIntervalId, this));
        _classPrivateFieldSet(_sessionMetricsIntervalId, this, null);
      }
      if (_classPrivateFieldGet(_session, this)) {
        _classPrivateFieldGet(_session, this).removeListener('updated', this.open);
        _classPrivateFieldSet(_session, this, null);
      }
      if (_classPrivateFieldGet(_stream, this)) {
        _classPrivateFieldGet(_stream, this).close();
        _classPrivateFieldSet(_stream, this, null);
      }
      if (_classPrivateFieldGet(_control, this)) {
        _classPrivateFieldGet(_control, this).close();
        _classPrivateFieldSet(_control, this, null);
      }
    });
    _classPrivateFieldInitSpec(this, _createSocket, (url, tokenField) => {
      const socket = new _cocom.CBORSocket({
        getUrl: () => (0, _makeSocketUrl.default)(url),
        getProtocols: () => ["cbio.http.headers.authorization.bearer.".concat(window.btoa(_classPrivateFieldGet(_session, this).field(tokenField)).replaceAll('=', ''))]
      });
      socket.on('error', err => {
        console.warn('CobrowseIO session socket error:', err);
      });
      return socket;
    });
    _classPrivateFieldInitSpec(this, _openControl, () => {
      const url = _classPrivateFieldGet(_session, this).field('control_url');
      const token = _classPrivateFieldGet(_session, this).field('control_token');
      if (url && token && !_classPrivateFieldGet(_control, this)) {
        _classPrivateFieldSet(_control, this, _classPrivateFieldGet(_createSocket, this).call(this, url, 'control_token'));
        _classPrivateFieldGet(_control, this).on('open', () => {
          _classPrivateFieldGet(_control, this).send('filter', {
            events: ['session']
          });
          _classPrivateFieldGet(_session, this).fetch().catch(err => {
            console.warn('CobrowseIO failed fetching session state', err);
          });
        });
        _classPrivateFieldGet(_control, this).on('event', (event, data) => {
          if (event === 'session') _classPrivateFieldGet(_session, this).updateResource(data);
        });
      }
    });
    _classPrivateFieldInitSpec(this, _openStream, () => {
      const url = _classPrivateFieldGet(_session, this).field('stream_url');
      const token = _classPrivateFieldGet(_session, this).field('stream_token');
      if (url && token && !_classPrivateFieldGet(_stream, this)) {
        _classPrivateFieldSet(_stream, this, _classPrivateFieldGet(_createSocket, this).call(this, url, 'stream_token'));
        _classPrivateFieldSet(_sessionMetricsIntervalId, this, setInterval(() => {
          const latency = Math.round(_classPrivateFieldGet(_stream, this).metrics.latency());
          _classPrivateFieldGet(_session, this)[_protected.default].setMetrics({
            latency
          });
        }, SESSION_METRICS_INTERVAL_MS));
        const annotation = ['highlight', 'drawing', 'laser', 'url'];
        const control = ['touch', 'mouse', 'pointer', 'keypress', 'scroll', 'focus', 'input', 'change', 'select'];
        _classPrivateFieldGet(_stream, this).on('event', (event, data) => {
          if (event === 'sync') _classPrivateFieldGet(_session, this).emit('sync', data);
          if (event === 'remote-error') _classPrivateFieldGet(_session, this).emit('remote-error', data);
          if (event === 'client') _classPrivateFieldGet(_session, this).emit('client', data);else if (event === 'probe') _classPrivateFieldGet(_stream, this).send('alive', data);else if (annotation.includes(event)) {
            _classPrivateFieldGet(_session, this).emit(event, data);
          } else if (control.includes(event)) {
            _classPrivateFieldGet(_session, this).emit('control', event, data);
          }
          _classPrivateFieldGet(_session, this)[_protected.default].setMetrics({
            last_alive: new Date()
          });
        });
        _classPrivateFieldGet(_stream, this).on('open', () => {
          _classPrivateFieldGet(_stream, this).send('filter', {
            events: [...control, ...annotation, 'sync', 'probe', 'remote-error', 'client', 'sdp', 'icecandidate']
          });
          _classPrivateFieldGet(_session, this).emit('stream-open');
        });
      }
    });
    _classPrivateFieldSet(_session, this, session);
    session.on('updated', this.open);
    session[_protected.default].setMetrics({
      last_alive: null,
      latency: null
    });
    this.open();
  }
  get stream() {
    return _classPrivateFieldGet(_stream, this);
  }
}
exports["default"] = SessionSockets;

/***/ }),

/***/ 3531:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SessionStorage = void 0;
__webpack_require__(3697);
var _ForwardingSessionStorage = __webpack_require__(9070);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.sessionStorage');
var _load = /*#__PURE__*/new WeakMap();
var _store = /*#__PURE__*/new WeakMap();
var _retain = /*#__PURE__*/new WeakMap();
class SessionStorage {
  static create(trustedOrigins, api, _ref) {
    let {
      localStorage
    } = _ref;
    if (trustedOrigins.length > 1) {
      // We always attempt to load from forwarding storage first. There can be
      // weird cases, such as coming from a domain that didn't have cross-origin
      // local storage support to a domain where it does (e.g., site on deny-list).
      // It doesn't hurt to just check if something was there, and if it was then
      // we almost definitely want to restore it
      const forwardingStorage = new _ForwardingSessionStorage.ForwardingSessionStorage();
      return new SessionStorage({
        load: [forwardingStorage, localStorage],
        store: [localStorage, forwardingStorage],
        retain: [localStorage]
      });
    } else {
      // We only need a storage configuration for a single domain
      return new SessionStorage({
        load: [localStorage],
        store: [localStorage],
        retain: [localStorage]
      });
    }
  }
  constructor(_ref2) {
    let {
      load = [],
      store = [],
      retain = []
    } = _ref2;
    _classPrivateFieldInitSpec(this, _load, void 0);
    _classPrivateFieldInitSpec(this, _store, void 0);
    _classPrivateFieldInitSpec(this, _retain, void 0);
    _classPrivateFieldSet(_load, this, load);
    _classPrivateFieldSet(_store, this, store);
    _classPrivateFieldSet(_retain, this, retain);
  }
  async load(delegate) {
    debug('loading session');
    /*
    * Storage implementations that will be used to try and load sessions. The load()
    * function of these implementations are traversed in order and the first non-falsey
    * result we get is the storage that is returned.
    */
    for (const s of _classPrivateFieldGet(_load, this)) {
      const found = await s.load(delegate);
      const updated = await (found === null || found === void 0 ? void 0 : found.fetch());
      if (updated) {
        if (updated.isActive()) return updated;else await s.store(null);
      }
    }
    return null;
  }
  async store(session) {
    debug('storing session');
    /*
     * Storage implementations that will have sessions stored into them. All storage
     * implementations will have their .store() functions called here when a session
     * update is being stored.
     */
    for (const s of _classPrivateFieldGet(_store, this)) {
      try {
        await s.store(session);
      } catch (e) {
        console.error("Unexpected error storing session: ".concat(s.constructor.name), e);
      }
    }
  }
  destroy() {
    const toDestroy = new Set([..._classPrivateFieldGet(_load, this), ..._classPrivateFieldGet(_store, this)].filter(s => !_classPrivateFieldGet(_retain, this).includes(s)));
    for (const s of toDestroy) {
      s.destroy();
    }
    _classPrivateFieldSet(_load, this, null);
    _classPrivateFieldSet(_store, this, null);
    _classPrivateFieldSet(_retain, this, null);
  }
}
exports.SessionStorage = SessionStorage;

/***/ }),

/***/ 2176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Session", ({
  enumerable: true,
  get: function () {
    return _Session.default;
  }
}));
Object.defineProperty(exports, "SessionCapabilities", ({
  enumerable: true,
  get: function () {
    return _SessionCapabilities.default;
  }
}));
Object.defineProperty(exports, "SessionContext", ({
  enumerable: true,
  get: function () {
    return _SessionContext.default;
  }
}));
var _Session = _interopRequireDefault(__webpack_require__(2404));
var _SessionContext = _interopRequireDefault(__webpack_require__(729));
var _SessionCapabilities = _interopRequireDefault(__webpack_require__(86));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 3443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ActiveSessionPath = void 0;
const ActiveSessionPath = exports.ActiveSessionPath = '_cobrowse_active_session';

/***/ }),

/***/ 9070:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ForwardingSessionStorage = void 0;
exports.extractActiveSession = extractActiveSession;
exports.rewriteUrlIfNecessary = rewriteUrlIfNecessary;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _protected = _interopRequireDefault(__webpack_require__(7609));
var _Session = _interopRequireDefault(__webpack_require__(2404));
var _Constants = __webpack_require__(3443);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.sessionStorage.ForwardingSessionStorage');
const dataOnLoad = extractActiveSession();
function extractActiveSession() {
  let {
    window: thisWindow = window
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  try {
    // Load data from the qs and clear it immediately regardless of if the
    // forwarding session storage is activated
    const url = new URL(thisWindow.location.href);
    const dataOnLoad = url.searchParams.get(_Constants.ActiveSessionPath);
    if (dataOnLoad) {
      debug('found forwarded session that can be loaded', dataOnLoad);
      url.searchParams.delete(_Constants.ActiveSessionPath);
      thisWindow.history.replaceState({}, '', url);
    } else {
      debug('no forwarded session to load', url);
    }
    return dataOnLoad;
  } catch (e) {
    console.warn('Failed to attempt to extract forwarded session', e);
  }
}
function rewriteUrlIfNecessary(url, sessionId) {
  let {
    window: thisWindow = window
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  try {
    const result = new URL(url);
    if (result.origin === thisWindow.location.origin) {
      debug('not rewriting url because we are not changing origin', result.toString());
      return url;
    }
    result.searchParams.set(_Constants.ActiveSessionPath, sessionId);
    debug('rewriting trusted url for an active session', {
      from: url,
      to: result.toString()
    });
    return typeof url === 'string' ? result.toString() : result;
  } catch (e) {
    debug('failed rewriting url', e);
    return url;
  }
}
var _activeSessionData = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
class ForwardingSessionStorage {
  constructor() {
    let {
      /** Any (optional) forwarded session data that could be loaded. */
      activeSessionData = dataOnLoad
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    /** Configuration parameters. */
    _classPrivateFieldInitSpec(this, _activeSessionData, void 0);
    /** State parameters. */
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldSet(_activeSessionData, this, activeSessionData);
  }
  isSupported() {
    debug('isSupported?', true);
    return true;
  }
  load(delegate) {
    try {
      if (_classPrivateFieldGet(_activeSessionData, this)) {
        debug('loading session', _classPrivateFieldGet(_activeSessionData, this));
        return new _Session.default(delegate)[_protected.default].decompress(_classPrivateFieldGet(_activeSessionData, this));
      } else {
        debug('no session to load');
      }
    } catch (err) {
      debug('failed to load forwarded session', err);
    }
    return null;
  }
  store(session) {
    if (session !== null && session !== void 0 && session.isActive()) {
      debug('storing active session by binding forwarding hooks');
      _classPrivateFieldSet(_session, this, session);
    } else {
      debug('removing active session by unbinding forwarding hooks');
      this.destroy();
    }
  }
  destroy() {
    _classPrivateFieldSet(_session, this, undefined);
  }
}
exports.ForwardingSessionStorage = ForwardingSessionStorage;

/***/ }),

/***/ 1312:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalSessionStorage = void 0;
__webpack_require__(3697);
var _protected = _interopRequireDefault(__webpack_require__(7609));
var _storage2 = _interopRequireDefault(__webpack_require__(6542));
var _Session = _interopRequireDefault(__webpack_require__(2404));
var _Constants = __webpack_require__(3443);
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.sessionStorage.LocalSessionStorage');
var _storage = /*#__PURE__*/new WeakMap();
class LocalSessionStorage {
  constructor() {
    _classPrivateFieldInitSpec(this, _storage, (0, _storage2.default)());
  }
  isSupported() {
    debug('isSupported?', true);
    return true;
  }
  load(delegate) {
    const resource = _classPrivateFieldGet(_storage, this).getItem(_Constants.ActiveSessionPath);
    if (resource) {
      debug('loading session');
      return new _Session.default(delegate)[_protected.default].deserialize(resource);
    } else {
      debug('no session to load');
      return null;
    }
  }
  store(session) {
    if (session !== null && session !== void 0 && session.isActive()) {
      debug('storing active session');
      _classPrivateFieldGet(_storage, this).setItem(_Constants.ActiveSessionPath, session[_protected.default].serialize());
    } else {
      debug('removing inactive session');
      _classPrivateFieldGet(_storage, this).removeItem(_Constants.ActiveSessionPath);
    }
  }
  destroy() {
    _classPrivateFieldSet(_storage, this, undefined);
  }
}
exports.LocalSessionStorage = LocalSessionStorage;

/***/ }),

/***/ 6900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _Navigation = __webpack_require__(4661);
var _navigation = __webpack_require__(9715);
var _ForwardingSessionStorage = __webpack_require__(9070);
var _protected = _interopRequireDefault(__webpack_require__(7609));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _trustedOrigins = /*#__PURE__*/new WeakMap();
var _getSessionId = /*#__PURE__*/new WeakMap();
class XDocHandler extends _navigation.NavigationHandler {
  constructor(session, delegate) {
    super();
    _classPrivateFieldInitSpec(this, _trustedOrigins, void 0);
    _classPrivateFieldInitSpec(this, _getSessionId, void 0);
    _classPrivateFieldSet(_trustedOrigins, this, delegate.trustedOrigins);
    _classPrivateFieldSet(_getSessionId, this, () => session[_protected.default].compress());
  }
  get type() {
    return _Navigation.NAVIGATION_TYPE.XDOC;
  }
  shouldHandleEvent(_e) {
    return true;
  }
  shouldHandle(u) {
    const url = new URL(u, window.location.origin);
    return _classPrivateFieldGet(_trustedOrigins, this).includes(url.origin);
  }
  handle(url) {
    const sessionId = _classPrivateFieldGet(_getSessionId, this).call(this);
    const rewrittenUrl = (0, _ForwardingSessionStorage.rewriteUrlIfNecessary)(url, sessionId);
    return {
      rewrittenUrl
    };
  }
}
exports["default"] = XDocHandler;

/***/ }),

/***/ 6542:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _storage.default;
  }
}));
var _storage = _interopRequireDefault(__webpack_require__(6667));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 6667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _jsCookie = _interopRequireDefault(__webpack_require__(8440));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const store = {};
function localStorageAvailable() {
  try {
    const testKey = '_cobrowse_test_item';
    localStorage.setItem(testKey, testKey);
    localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
}
function showWarning() {
  if (!localStorageAvailable() && !showWarning.done) {
    showWarning.done = true;
    console.warn('Warning: localStorage is not supported. Cobrowse falling back to cookie or in-memory storage and may not function as expected.');
  }
}
function _default(groupId) {
  return {
    setItem(key, value) {
      showWarning();
      const encoded = JSON.stringify({
        value,
        group: groupId
      });
      if (localStorageAvailable()) window.localStorage.setItem(key, encoded);else _jsCookie.default.set(key, encoded);
      store[key] = encoded;
    },
    getItem(key) {
      try {
        let encoded;
        // trust localstoage first of all
        if (localStorageAvailable()) {
          encoded = window.localStorage && window.localStorage.getItem(key);
        } else encoded = _jsCookie.default.get(key);
        if (!encoded) encoded = store[key];
        const {
          value,
          group
        } = JSON.parse(encoded);
        if (groupId && groupId !== group) return null;
        return value;
      } catch (e) {
        return null;
      }
    },
    removeItem(key) {
      if (localStorageAvailable()) window.localStorage.removeItem(key);
      _jsCookie.default.remove(key);
      store[key] = undefined;
    }
  };
}

/***/ }),

/***/ 3024:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
var _activity = __webpack_require__(5264);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class AnnotationOverlay {
  constructor() {
    _defineProperty(this, "el", () => {
      if (!this._el) {
        this._el = document.createElement('img');
        this._el.className = 'cbio_session_overlay';
        this._el.style.pointerEvents = 'none';
        this._el.style.visibility = 'visible';
        this._el.style.width = '10vw';
        this._el.style.height = '100vh';
        this._el.style.position = 'fixed';
        this._el.style.zIndex = '2147483647';
        this._el.style.display = 'none';
        this._el.style.top = '0';
        this._el.style.left = '0';
      }
      return this._el;
    });
    _defineProperty(this, "_arrayBufferToBase64", buffer => {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i += 1) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    });
    _defineProperty(this, "remove", function (el) {
      let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      // Set up the transition using inline styles
      el.style.transition = "opacity ".concat(duration, "ms ease-in-out");
      el.style.opacity = 1; // Ensure opacity starts at 1

      // Listen for the transition end event
      el.addEventListener('transitionend', function () {
        // Remove the image from the DOM once the fade-out is complete
        el.remove();
      });

      // Trigger the fade-out by setting opacity to 0
      el.style.opacity = 0;
    });
    _defineProperty(this, "update", drawing => {
      if (!_activity.WindowTracking.isActive()) return;
      if (!drawing.image) this.hide(drawing.agent);else {
        // We create an identical image element so that we can work with it behind the scenes without affecting the
        // original one. This is necessary because updating the src attribute and the styles of the original element
        // will cause the browser to re-render the image, which is slow and causes flickering on Firefox.
        const image = this.el().cloneNode();
        const asDataUri = "data:".concat(drawing.mime_type, ";base64,").concat(this._arrayBufferToBase64(drawing.image));
        const {
          id = 'cb_io_drawing'
        } = drawing;
        image.style.left = "".concat(drawing.x * 100, "%");
        image.style.top = "".concat(drawing.y * 100, "%");
        image.style.height = "".concat(drawing.height * 100, "%");
        image.style.width = "".concat(drawing.width * 100, "%");
        image.style.display = 'block';
        image.src = asDataUri;
        image.id = id;
        image.dataset.agent = drawing.agent;

        // We need to force decoding the image before we can use it to avoid flickering on Firefox. Only when it's decoded
        // can we replace the old image with the new one.
        image.decode().then(() => {
          const elem = document.getElementById(id);
          if (elem) {
            elem.replaceWith(image);
          } else {
            document.body.appendChild(image);
          }
          if (drawing.disappears_in != null) {
            setTimeout(() => {
              this.remove(image, drawing.fade_duration);
            }, drawing.disappears_in);
          }
        }).catch(e => {
          console.error(e);
        });
      }
    });
    _defineProperty(this, "hide", agentId => {
      const elems = agentId != null ? document.querySelectorAll(".cbio_session_overlay[data-agent=\"".concat(agentId, "\"]")) : document.querySelectorAll('.cbio_session_overlay');
      elems.forEach(function (element) {
        element.remove();
      });
    });
  }
}
var _default = exports["default"] = new AnnotationOverlay();

/***/ }),

/***/ 3807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(2832);
__webpack_require__(3697);
var _hooks = __webpack_require__(16);
var _lite = __webpack_require__(8637);
var _Locale = _interopRequireDefault(__webpack_require__(7988));
var _Draggable = _interopRequireDefault(__webpack_require__(5029));
var _components = __webpack_require__(2996);
var _useSpeaking = __webpack_require__(4909);
var _storage = _interopRequireDefault(__webpack_require__(6542));
var _CallParticipantsModule = _interopRequireDefault(__webpack_require__(396));
var _jsxRuntime = __webpack_require__(6416);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const POSITION_STORAGE_KEY = '_cobrowse_participants_position';
const getParticipantsPosition = () => (0, _storage.default)().getItem(POSITION_STORAGE_KEY) || 'top-right';
const saveParticipantsPosition = position => (0, _storage.default)().setItem(POSITION_STORAGE_KEY, position);
const CallParticipants = _ref => {
  let {
    mediaSettings,
    callSession
  } = _ref;
  const [participants, setParticipants] = (0, _hooks.useState)(callSession.participants);
  const [audioOutputDeviceId, setAudioOutputDeviceId] = (0, _hooks.useState)(mediaSettings.settings.audioOutputDeviceId);
  (0, _hooks.useEffect)(() => {
    const onAudioOutputSettingsUpdated = _ref2 => {
      let {
        audioOutputDeviceId
      } = _ref2;
      return setAudioOutputDeviceId(audioOutputDeviceId);
    };
    mediaSettings.on('audioOutputSettings.updated', onAudioOutputSettingsUpdated);
    return () => {
      mediaSettings.off('audioOutputSettings.updated', onAudioOutputSettingsUpdated);
    };
  }, [mediaSettings]);
  (0, _hooks.useEffect)(() => {
    const onParticipantsChanged = participants => setParticipants(new Map(participants));
    callSession.on('participants.added', onParticipantsChanged);
    callSession.on('participants.removed', onParticipantsChanged);
    return () => {
      callSession.off('participants.removed', onParticipantsChanged);
      callSession.off('participants.added', onParticipantsChanged);
    };
  }, [callSession]);
  const sortedParticipants = (0, _hooks.useMemo)(() => {
    return [...participants.values()].sort((a, b) => Number(b.isLocal) - Number(a.isLocal));
  }, [participants]);
  return (0, _jsxRuntime.jsx)(_Draggable.default, {
    style: {
      zIndex: '2147483646'
    },
    corner: getParticipantsPosition(),
    onCornerChange: saveParticipantsPosition,
    children: (0, _jsxRuntime.jsx)("div", {
      className: _CallParticipantsModule.default.container,
      children: sortedParticipants.map(participant => (0, _jsxRuntime.jsx)(Participant, {
        participant: participant,
        audioOutputDeviceId: audioOutputDeviceId
      }, participant.id))
    })
  });
};
const Participant = _ref3 => {
  let {
    participant,
    audioOutputDeviceId
  } = _ref3;
  const videoRef = (0, _hooks.useRef)(null);
  const [hasVideo, setHasVideo] = (0, _hooks.useState)(participant.hasVideo);
  const [hasAudio, setHasAudio] = (0, _hooks.useState)(participant.hasAudio);
  const isSpeaking = (0, _useSpeaking.useSpeaking)(participant);
  (0, _hooks.useEffect)(() => {
    const onTracksChanged = () => {
      setHasVideo(participant.hasVideo);
      setHasAudio(participant.hasAudio);
    };
    participant.on('track.added', onTracksChanged);
    participant.on('track.removed', onTracksChanged);
    return () => {
      participant.off('track.removed', onTracksChanged);
      participant.off('track.added', onTracksChanged);
    };
  }, [participant]);
  (0, _hooks.useEffect)(() => {
    videoRef.current.srcObject = participant.stream;
  }, [participant]);
  (0, _hooks.useEffect)(() => {
    const setAudioOutput = async () => {
      await videoRef.current.setSinkId(audioOutputDeviceId);
    };
    if (hasAudio) setAudioOutput();
  }, [audioOutputDeviceId, hasAudio]);
  return (0, _jsxRuntime.jsxs)("div", {
    className: (0, _lite.clsx)(_CallParticipantsModule.default.participantContainer, isSpeaking && _CallParticipantsModule.default.participantSpeaking),
    children: [(0, _jsxRuntime.jsxs)("div", {
      className: _CallParticipantsModule.default.videoContainer,
      children: [(0, _jsxRuntime.jsx)("video", {
        className: _CallParticipantsModule.default.video,
        ref: videoRef,
        autoPlay: true,
        playsInline: true,
        muted: participant.isLocal
      }), !hasVideo ? (0, _jsxRuntime.jsxs)("div", {
        className: _CallParticipantsModule.default.videoOverlay,
        children: [(0, _jsxRuntime.jsx)("span", {
          className: "cbio-sr-only",
          children: _Locale.default.tr('CALLING_CAMERA_OFF')
        }), (0, _jsxRuntime.jsx)(_components.Icon, {
          name: "VideoOff",
          className: _CallParticipantsModule.default.videoOverlayIcon
        })]
      }) : null]
    }), (0, _jsxRuntime.jsxs)("div", {
      className: _CallParticipantsModule.default.statusContainer,
      children: [(0, _jsxRuntime.jsx)(_components.Icon, {
        className: _CallParticipantsModule.default.statusIcon,
        name: hasAudio ? 'Microphone' : 'MicrophoneOff'
      }), (0, _jsxRuntime.jsx)("span", {
        className: _CallParticipantsModule.default.statusTitle,
        children: participant.isLocal ? _Locale.default.tr('CALLING_LOCAL_PARTICIPANT_DESCRIPTION') : _Locale.default.tr('CALLING_REMOTE_PARTICIPANT_DESCRIPTION')
      })]
    })]
  });
};
var _default = exports["default"] = CallParticipants;

/***/ }),

/***/ 5573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(1631);
__webpack_require__(3697);
var _Locale = _interopRequireDefault(__webpack_require__(7988));
var _mountComponent = __webpack_require__(9103);
var _components = __webpack_require__(2996);
var _ConsentDialogModule = _interopRequireDefault(__webpack_require__(1398));
var _jsxRuntime = __webpack_require__(6416);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const ConsentDialogComponent = _ref => {
  let {
    title,
    description,
    onDeny,
    onAllow
  } = _ref;
  return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: (0, _jsxRuntime.jsxs)(_components.Modal, {
      className: _ConsentDialogModule.default.content,
      "aria-labelledby": "title",
      "aria-describedby": "description",
      children: [(0, _jsxRuntime.jsx)("header", {
        children: (0, _jsxRuntime.jsx)("h2", {
          id: "title",
          className: _ConsentDialogModule.default.title,
          children: title
        })
      }), (0, _jsxRuntime.jsx)("div", {
        className: _ConsentDialogModule.default.body,
        children: (0, _jsxRuntime.jsx)("p", {
          id: "description",
          className: _ConsentDialogModule.default.description,
          children: description
        })
      }), (0, _jsxRuntime.jsxs)("footer", {
        className: _ConsentDialogModule.default.buttons,
        children: [(0, _jsxRuntime.jsx)(_components.Button, {
          variant: "secondary",
          onClick: onDeny,
          children: _Locale.default.tr('DENY')
        }), (0, _jsxRuntime.jsx)(_components.Button, {
          variant: "primary",
          onClick: onAllow,
          children: _Locale.default.tr('ALLOW')
        })]
      })]
    })
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
class ConsentDialog {
  constructor() {
    _classPrivateFieldInitSpec(this, _mountHandle, void 0);
    _defineProperty(this, "show", async (title, description) => {
      var _classPrivateFieldGet2;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      return new Promise(resolve => {
        const props = {
          title,
          description,
          onDeny: e => {
            if (!e.isTrusted) return;
            resolve(false);
            this.hide();
          },
          onAllow: e => {
            if (!e.isTrusted) return;
            resolve(true);
            this.hide();
          }
        };
        _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(ConsentDialogComponent, props, true, true));
      });
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet3;
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.unmount();
      _classPrivateFieldSet(_mountHandle, this, null);
    });
  }
}
exports["default"] = ConsentDialog;

/***/ }),

/***/ 6575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _HighlightOverlay = _interopRequireDefault(__webpack_require__(6438));
var _Tooltip = _interopRequireDefault(__webpack_require__(7527));
var _NodeTracker = _interopRequireDefault(__webpack_require__(4822));
var _iframes = _interopRequireDefault(__webpack_require__(7966));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const debug = (0, _debug.default)('cbio.Highlight');
var _resolve = /*#__PURE__*/new WeakMap();
var _update = /*#__PURE__*/new WeakMap();
var _doUpdate = /*#__PURE__*/new WeakMap();
var _doHide = /*#__PURE__*/new WeakMap();
var _addClickListener = /*#__PURE__*/new WeakMap();
var _removeClickListener = /*#__PURE__*/new WeakMap();
var _handleClick = /*#__PURE__*/new WeakMap();
class Highlight {
  constructor() {
    _classPrivateFieldInitSpec(this, _resolve, void 0);
    _defineProperty(this, "highlight", async (delegate, event) => {
      var _delegate$highlightEl;
      const target = _NodeTracker.default.getById(event.target.id);
      if (!target) {
        // If it wasn't found here, it might be found in a child xdoc iframe. Forward it along to
        // highlight at another level
        _iframes.default.broadcastToChildren('highlight', event);
        return;
      }
      const highlightElement = (_delegate$highlightEl = delegate.highlightElement) !== null && _delegate$highlightEl !== void 0 ? _delegate$highlightEl : _classPrivateFieldGet(_update, this);
      const highlightElementP = highlightElement(target, event.title);
      delegate.emit('highlight.updated', {
        target,
        visible: true
      });
      await highlightElementP;
      delegate.emit('highlight.updated', {
        target,
        visible: false
      });
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet2;
      debug('hide', "resolve?=".concat(!!_classPrivateFieldGet(_resolve, this)));
      _classPrivateFieldGet(_removeClickListener, this).call(this);
      _classPrivateFieldGet(_doHide, this).call(this);
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_resolve, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this);
      _classPrivateFieldSet(_resolve, this, undefined);
    });
    _classPrivateFieldInitSpec(this, _update, (element, title) => new Promise(resolve => {
      debug('update', element, title);

      // It's theoretically possible that update can be run multiple times before being hidden. E.g.,
      // LLM decides to highlight multiple things when demoing a workflow. We don't want multiple
      // promise resolutions because those can be effectful
      _classPrivateFieldSet(_resolve, this, resolve);
      _classPrivateFieldGet(_doUpdate, this).call(this, element, title);
      _classPrivateFieldGet(_addClickListener, this).call(this);
    }));
    _classPrivateFieldInitSpec(this, _doUpdate, (element, title) => {
      _HighlightOverlay.default.update(element);
      _Tooltip.default.update(element, title);
    });
    _classPrivateFieldInitSpec(this, _doHide, () => {
      _Tooltip.default.hide();
      _HighlightOverlay.default.hide();
    });
    _classPrivateFieldInitSpec(this, _addClickListener, () => {
      _classPrivateFieldGet(_removeClickListener, this).call(this);
      document.addEventListener('click', _classPrivateFieldGet(_handleClick, this), {
        once: true,
        capture: true
      });
    });
    _classPrivateFieldInitSpec(this, _removeClickListener, () => {
      document.removeEventListener('click', _classPrivateFieldGet(_handleClick, this), true);
    });
    _classPrivateFieldInitSpec(this, _handleClick, () => {
      this.hide();
    });
  }
}
var _default = exports["default"] = new Highlight();

/***/ }),

/***/ 6162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _createRipple = __webpack_require__(2777);
var _activity = __webpack_require__(5264);
var _MultiAgentManager = __webpack_require__(2630);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const color = '#e94435';
class LaserOverlay {
  constructor() {
    _defineProperty(this, "el", () => {
      if (!this._el) {
        this._el = document.createElement('div');
        this._el.className = 'cbio_session_overlay';
        Object.assign(this._el.style, {
          position: 'fixed',
          zIndex: '2147483647',
          width: '8px',
          height: '8px',
          background: color,
          marginLeft: '-4px',
          marginTop: '-4px',
          borderRadius: '50%',
          border: 'border: 1px solid white',
          pointerEvents: 'none'
        });
      }
      return this._el;
    });
    _defineProperty(this, "hasChangedPosition", () => {
      if (this.previousPosition == null) return false;

      // we tolerade 1% movement before considerencing that the position has changed
      const tolerance = 1;
      return Math.abs(this.previousPosition.x - this.currentPosition.x) > tolerance || Math.abs(this.previousPosition.y - this.currentPosition.y) > tolerance;
    });
    _defineProperty(this, "startAnimation", color => {
      if (this._intervalId) return;
      this._intervalId = setInterval(() => this._createRipple(color), this.rippleInterval);

      // create a ripple immidiately to ensure the animation starts when the marker is visible
      this._createRipple(color);
    });
    _defineProperty(this, "stopAnimation", () => {
      if (this._intervalId) clearInterval(this._intervalId);
      if (this._el) this._el.replaceChildren();
      this.resetState();
    });
    _defineProperty(this, "update", laser => {
      if (!_activity.WindowTracking.isActive()) return;
      if (document.body && !this.el().parentNode) document.body.appendChild(this.el());
      if (laser.state === 'touchend') {
        this.hide();
      } else if (laser.x != null && laser.y != null) {
        this.currentPosition.x = laser.x * 100;
        this.currentPosition.y = laser.y * 100;
        this.el().style.background = laser.colour;
        this.el().style.left = "".concat(this.currentPosition.x, "%");
        this.el().style.top = "".concat(this.currentPosition.y, "%");
        this.startAnimation(laser.colour);
      }
    });
    _defineProperty(this, "hide", () => {
      var _this$_el;
      (_this$_el = this._el) === null || _this$_el === void 0 || (_this$_el = _this$_el.parentNode) === null || _this$_el === void 0 || _this$_el.removeChild(this._el);
      this.stopAnimation();
    });
    this.rippleDuration = 3000; // Total duration of each ripple in ms
    this.rippleInterval = 750; // Create a new ripple every 750ms
    this._el = null;
    this.resetState();
  }
  resetState() {
    this._intervalId = null;
    this.currentPosition = {
      x: 0,
      y: 0
    };
    this.previousPosition = null;
    this.resetRippleScale();
  }
  resetRippleScale() {
    this.rippleScale = 16;
  }
  _createRipple() {
    let selectedColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : color;
    if (!this.hasChangedPosition()) {
      this.rippleScale = Math.min(this.rippleScale + 5, 16);
    } else {
      this.rippleScale = 6;
    }
    this.previousPosition = _objectSpread({}, this.currentPosition);
    const ripple = (0, _createRipple.createRipple)(selectedColor, this.rippleDuration, this.rippleScale);
    this.el().appendChild(ripple);
  }
}
class LaserOverlayManager extends _MultiAgentManager.MultiAgentManager {
  constructor() {
    super(LaserOverlay);
  }
  update(laser) {
    const instance = this.getInstanceForAgent(laser.agent);
    instance.update(laser);
  }
}
var _default = exports["default"] = new LaserOverlayManager();

/***/ }),

/***/ 4037:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.MEDIA_PREVIEW_STATUS = void 0;
__webpack_require__(1631);
__webpack_require__(9908);
__webpack_require__(3697);
var _hooks = __webpack_require__(16);
var _lite = __webpack_require__(8637);
var _Locale = _interopRequireDefault(__webpack_require__(7988));
var _components = __webpack_require__(2996);
var _MediaSettings = __webpack_require__(3646);
var _useMediaDevices = __webpack_require__(4364);
var _microphone = _interopRequireDefault(__webpack_require__(9020));
var _volume = _interopRequireDefault(__webpack_require__(9978));
var _video = _interopRequireDefault(__webpack_require__(4053));
var _MediaPreviewModule = _interopRequireDefault(__webpack_require__(7294));
var _jsxRuntime = __webpack_require__(6416);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const MEDIA_PREVIEW_STATUS = exports.MEDIA_PREVIEW_STATUS = {
  REQUESTED: 'requested',
  REJOINING: 'rejoining',
  UPDATING: 'updating'
};
const DEFAULT_DEVICE = 'default';
const containsDeviceId = (devices, id) => devices.some(device => device.deviceId === id);
const STATUS_TO_TEXT = {
  [MEDIA_PREVIEW_STATUS.REQUESTED]: {
    title: _Locale.default.tr('CALLING_REQUEST'),
    description: _Locale.default.tr('CALLING_JOIN_PROMPT'),
    acceptTitle: _Locale.default.tr('CALLING_ACCEPT'),
    rejectTitle: _Locale.default.tr('CALLING_REJECT')
  },
  [MEDIA_PREVIEW_STATUS.REJOINING]: {
    title: _Locale.default.tr('CALLING_REQUEST'),
    description: _Locale.default.tr('CALLING_REJOIN_PROMPT'),
    acceptTitle: _Locale.default.tr('CALLING_JOIN'),
    rejectTitle: _Locale.default.tr('CALLING_END')
  },
  [MEDIA_PREVIEW_STATUS.UPDATING]: {
    title: null,
    description: null,
    acceptTitle: _Locale.default.tr('CALLING_SAVE'),
    rejectTitle: _Locale.default.tr('CALLING_CANCEL')
  }
};
const MediaPreview = _ref => {
  let {
    settings,
    status,
    accept,
    reject
  } = _ref;
  const videoRef = (0, _hooks.useRef)(null);
  const previewMediaStream = (0, _hooks.useRef)(new MediaStream());
  const {
    audioInputDevices,
    audioOutputDevices,
    videoInputDevices,
    audioPermission,
    videoPermission,
    updateDeviceLists,
    updatePermissions
  } = (0, _useMediaDevices.useMediaDevices)();
  const [isVideoStarting, setIsVideoStarting] = (0, _hooks.useState)(false);
  const [videoEnabled, setVideoEnabled] = (0, _hooks.useState)(settings.videoEnabled);
  const [videoInputDeviceId, setVideoInputDeviceId] = (0, _hooks.useState)(settings.videoInputDeviceId);
  const [audioEnabled, setAudioEnabled] = (0, _hooks.useState)(settings.audioEnabled);
  const [audioInputDeviceId, setAudioInputDeviceId] = (0, _hooks.useState)(settings.audioInputDeviceId);
  const [audioOutputDeviceId, setAudioOutputDeviceId] = (0, _hooks.useState)(settings.audioOutputDeviceId);
  const removeTracksWithKind = (0, _hooks.useCallback)(kind => {
    const tracksOfKind = previewMediaStream.current.getTracks().filter(track => track.kind === kind);
    tracksOfKind.forEach(track => {
      track.stop();
      previewMediaStream.current.removeTrack(track);
    });
  }, []);
  (0, _hooks.useEffect)(() => {
    if (videoRef.current) videoRef.current.srcObject = previewMediaStream.current;
  }, []);
  (0, _hooks.useEffect)(() => {
    if (containsDeviceId(audioInputDevices, audioInputDeviceId)) return;
    if (containsDeviceId(audioInputDevices, DEFAULT_DEVICE)) return setAudioInputDeviceId(DEFAULT_DEVICE);
    if (audioInputDevices.length) setAudioInputDeviceId(audioInputDevices[0].deviceId);
  }, [audioInputDevices, audioInputDeviceId]);
  (0, _hooks.useEffect)(() => {
    if (containsDeviceId(audioOutputDevices, audioOutputDeviceId)) return;
    if (containsDeviceId(audioOutputDevices, DEFAULT_DEVICE)) return setAudioOutputDeviceId(DEFAULT_DEVICE);
    if (audioOutputDevices.length) setAudioOutputDeviceId(audioOutputDevices[0].deviceId);
  }, [audioOutputDevices, audioOutputDeviceId]);
  (0, _hooks.useEffect)(() => {
    if (containsDeviceId(videoInputDevices, videoInputDeviceId)) return;
    if (containsDeviceId(videoInputDevices, DEFAULT_DEVICE)) return setVideoInputDeviceId(DEFAULT_DEVICE);
    if (videoInputDevices.length) setVideoInputDeviceId(videoInputDevices[0].deviceId);
  }, [videoInputDevices, videoInputDeviceId]);
  (0, _hooks.useEffect)(() => {
    if (!videoEnabled) return;
    if (!navigator.mediaDevices) {
      console.warn('CobrowseIO: Failed to start video, mediaDevices is not available');
      setVideoEnabled(false);
      return;
    }
    setIsVideoStarting(true);
    const constraints = (0, _MediaSettings.createVideoConstraints)({
      videoEnabled,
      videoInputDeviceId
    });
    navigator.mediaDevices.getUserMedia(constraints).then(stream => {
      stream.getTracks().forEach(track => previewMediaStream.current.addTrack(track));
      // Firefox requires an active stream to enumerate
      // the device list so we manually refresh
      updateDeviceLists();
    }).catch(err => {
      console.warn('CobrowseIO: Failed to get video', err);
      if (videoPermission.prompt) setVideoEnabled(false);
    }).finally(() => {
      // Safari doesn't support the permission change event
      // so we manually refresh permissions after getUserMedia
      updatePermissions();
      setIsVideoStarting(false);
    });
    return () => removeTracksWithKind('video');
  }, [videoPermission, videoEnabled, videoInputDeviceId, removeTracksWithKind]);
  (0, _hooks.useEffect)(() => {
    if (!audioEnabled) return;
    if (!navigator.mediaDevices) {
      console.warn('CobrowseIO: Failed to start audio, mediaDevices is not available');
      setAudioEnabled(false);
      return;
    }
    const constraints = (0, _MediaSettings.createAudioConstraints)({
      audioEnabled,
      audioInputDeviceId
    });
    navigator.mediaDevices.getUserMedia(constraints).then(stream => {
      stream.getTracks().forEach(track => previewMediaStream.current.addTrack(track));
      // Firefox requires an active stream to enumerate
      // the device list so we manually refresh
      updateDeviceLists();
    }).catch(err => {
      console.warn('CobrowseIO: Failed to get audio', err);
      if (audioPermission.prompt) setAudioEnabled(false);
    }).finally(() => {
      // Safari doesn't support the permission change event
      // so we manually refresh permissions after getUserMedia
      updatePermissions();
    });
    return () => removeTracksWithKind('audio');
  }, [audioPermission, audioEnabled, audioInputDeviceId, removeTracksWithKind]);
  const handleAccept = () => accept({
    videoEnabled,
    videoInputDeviceId,
    audioEnabled,
    audioInputDeviceId,
    audioOutputDeviceId
  });
  const handleReject = () => reject();
  const renderVideoOverlay = (message, isBackgroundTransparent) => (0, _jsxRuntime.jsx)("div", {
    className: (0, _lite.clsx)(_MediaPreviewModule.default.videoOverlay, isBackgroundTransparent ? _MediaPreviewModule.default.videoOverlayTransparent : _MediaPreviewModule.default.videoOverlaySolid),
    children: (0, _jsxRuntime.jsx)("p", {
      className: _MediaPreviewModule.default.videoOverlayText,
      children: message
    })
  });
  const renderVideoState = () => {
    const isBackgroundTransparent = videoEnabled && videoPermission.granted;
    if (audioEnabled) {
      if (audioPermission.denied) return renderVideoOverlay(_Locale.default.tr('CALLING_MICROPHONE_PERMISSION_DENIED'), isBackgroundTransparent);
      if (audioPermission.prompt) return renderVideoOverlay(_Locale.default.tr('CALLING_MICROPHONE_PERMISSION_PROMPT'), isBackgroundTransparent);
    }
    if (videoEnabled) {
      if (videoPermission.denied) return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_PERMISSION_DENIED'), isBackgroundTransparent);
      if (videoPermission.prompt) return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_PERMISSION_PROMPT'), isBackgroundTransparent);
      if (isVideoStarting) return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_STARTING'), isBackgroundTransparent);
    } else {
      return renderVideoOverlay(_Locale.default.tr('CALLING_CAMERA_OFF'), isBackgroundTransparent);
    }
    return null;
  };
  const renderPreview = () => (0, _jsxRuntime.jsxs)("div", {
    className: _MediaPreviewModule.default.previewContainer,
    children: [(0, _jsxRuntime.jsxs)("div", {
      className: _MediaPreviewModule.default.videoContainer,
      children: [(0, _jsxRuntime.jsx)("video", {
        ref: videoRef,
        className: _MediaPreviewModule.default.video,
        autoPlay: true,
        playsInline: true,
        muted: true
      }), renderVideoState()]
    }), (0, _jsxRuntime.jsx)(VoiceVideoControls, {
      audioEnabled: audioEnabled,
      toggleAudio: () => setAudioEnabled(prev => !prev),
      videoEnabled: videoEnabled,
      toggleVideo: () => setVideoEnabled(prev => !prev)
    })]
  });
  const renderMediaDeviceOptions = (hasPermission, devices) => {
    if (!hasPermission) return (0, _jsxRuntime.jsx)(_components.SelectOption, {
      value: "",
      disabled: true,
      selected: true,
      children: _Locale.default.tr('CALLING_PERMISSION_NEEDED')
    });
    if (!devices.length) return (0, _jsxRuntime.jsx)(_components.SelectOption, {
      value: "",
      disabled: true,
      selected: true,
      children: _Locale.default.tr('CALLING_NO_DEVICES')
    });
    return devices.map(device => (0, _jsxRuntime.jsx)(_components.SelectOption, {
      value: device.deviceId,
      children: device.label
    }, device.deviceId));
  };
  const renderMediaDevices = () => (0, _jsxRuntime.jsxs)("div", {
    className: _MediaPreviewModule.default.deviceContainer,
    children: [(0, _jsxRuntime.jsx)(_components.Select, {
      iconUrl: _microphone.default,
      ariaLabel: _Locale.default.tr('CALLING_SELECT_MICROPHONE'),
      value: audioPermission.granted && audioInputDevices.length ? audioInputDeviceId : '',
      onChange: e => setAudioInputDeviceId(e.target.value),
      disabled: !audioPermission.granted || !audioInputDevices.length,
      children: renderMediaDeviceOptions(audioPermission.granted, audioInputDevices)
    }), (0, _jsxRuntime.jsx)(_components.Select, {
      iconUrl: _volume.default,
      ariaLabel: _Locale.default.tr('CALLING_SELECT_SPEAKER'),
      value: audioPermission.granted && audioOutputDevices.length ? audioOutputDeviceId : '',
      onChange: e => setAudioOutputDeviceId(e.target.value),
      disabled: !audioPermission.granted || !audioOutputDevices.length,
      children: renderMediaDeviceOptions(audioPermission.granted, audioOutputDevices)
    }), (0, _jsxRuntime.jsx)(_components.Select, {
      iconUrl: _video.default,
      ariaLabel: _Locale.default.tr('CALLING_SELECT_CAMERA'),
      value: videoPermission.granted && videoInputDevices.length ? videoInputDeviceId : '',
      onChange: e => setVideoInputDeviceId(e.target.value),
      disabled: !videoPermission.granted || !videoInputDevices.length,
      children: renderMediaDeviceOptions(videoPermission.granted, videoInputDevices)
    })]
  });
  const {
    title,
    description,
    acceptTitle,
    rejectTitle
  } = STATUS_TO_TEXT[status];
  return (0, _jsxRuntime.jsxs)(_components.Modal, {
    className: _MediaPreviewModule.default.content,
    "aria-labelledby": "title",
    "aria-describedby": "description",
    children: [(0, _jsxRuntime.jsxs)("header", {
      className: _MediaPreviewModule.default.header,
      children: [(0, _jsxRuntime.jsxs)("section", {
        className: _MediaPreviewModule.default.media,
        children: [renderPreview(), renderMediaDevices()]
      }), title ? (0, _jsxRuntime.jsx)("h2", {
        id: "title",
        className: _MediaPreviewModule.default.title,
        children: title
      }) : null]
    }), description ? (0, _jsxRuntime.jsx)("div", {
      className: _MediaPreviewModule.default.body,
      children: (0, _jsxRuntime.jsx)("p", {
        id: "description",
        className: _MediaPreviewModule.default.description,
        children: description
      })
    }) : null, (0, _jsxRuntime.jsxs)("footer", {
      className: _MediaPreviewModule.default.buttonContainer,
      children: [(0, _jsxRuntime.jsx)(_components.Button, {
        variant: "secondary",
        onClick: handleReject,
        children: rejectTitle
      }), (0, _jsxRuntime.jsx)(_components.Button, {
        variant: "primary",
        onClick: handleAccept,
        children: acceptTitle
      })]
    })]
  });
};
const VoiceVideoControls = _ref2 => {
  let {
    audioEnabled,
    toggleAudio,
    videoEnabled,
    toggleVideo
  } = _ref2;
  return (0, _jsxRuntime.jsxs)("div", {
    className: _MediaPreviewModule.default.voiceVideoControls,
    children: [(0, _jsxRuntime.jsx)(_components.IconButton, {
      onClick: toggleAudio,
      ariaLabel: audioEnabled ? _Locale.default.tr('CALLING_DISABLE_AUDIO') : _Locale.default.tr('CALLING_ENABLE_AUDIO'),
      className: (0, _lite.clsx)(_MediaPreviewModule.default.voiceVideoControlsToggle, audioEnabled ? _MediaPreviewModule.default.voiceVideoControlsToggleOn : _MediaPreviewModule.default.voiceVideoControlsToggleOff),
      children: (0, _jsxRuntime.jsx)(_components.Icon, {
        className: _MediaPreviewModule.default.voiceVideoControlsIcon,
        name: audioEnabled ? 'Microphone' : 'MicrophoneOff'
      })
    }), (0, _jsxRuntime.jsx)(_components.IconButton, {
      onClick: toggleVideo,
      ariaLabel: videoEnabled ? _Locale.default.tr('CALLING_DISABLE_VIDEO') : _Locale.default.tr('CALLING_ENABLE_VIDEO'),
      className: (0, _lite.clsx)(_MediaPreviewModule.default.voiceVideoControlsToggle, videoEnabled ? _MediaPreviewModule.default.voiceVideoControlsToggleOn : _MediaPreviewModule.default.voiceVideoControlsToggleOff),
      style: {
        marginLeft: '-4px'
      },
      children: (0, _jsxRuntime.jsx)(_components.Icon, {
        className: _MediaPreviewModule.default.voiceVideoControlsIcon,
        name: videoEnabled ? 'Video' : 'VideoOff'
      })
    })]
  });
};
var _default = exports["default"] = MediaPreview;

/***/ }),

/***/ 2630:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MultiAgentManager = void 0;
__webpack_require__(3697);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _instances = /*#__PURE__*/new WeakMap();
var _classReference = /*#__PURE__*/new WeakMap();
class MultiAgentManager {
  constructor(ref) {
    _classPrivateFieldInitSpec(this, _instances, new Map());
    _classPrivateFieldInitSpec(this, _classReference, null);
    _classPrivateFieldSet(_classReference, this, ref);
  }
  getInstanceForAgent(agent) {
    if (_classPrivateFieldGet(_instances, this).has(agent)) {
      return _classPrivateFieldGet(_instances, this).get(agent);
    } else {
      _classPrivateFieldGet(_instances, this).set(agent, new (_classPrivateFieldGet(_classReference, this))());
      return _classPrivateFieldGet(_instances, this).get(agent);
    }
  }
  hide() {
    _classPrivateFieldGet(_instances, this).forEach((instance, key) => {
      instance.hide();
      _classPrivateFieldGet(_instances, this).delete(key);
    });
  }
}
exports.MultiAgentManager = MultiAgentManager;

/***/ }),

/***/ 1112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _dom = __webpack_require__(3532);
var _unpolyfill = __webpack_require__(9883);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const TICK_SVG = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5l10 -10" /></svg>';
const createCss = appendRule => {
  appendRule("\n    .cbioSelect {\n      z-index: 2147483647;\n      background-color: #6e6e6e;\n      box-sizing: border-box;\n      padding: 5px;\n      font-size: 13px;\n      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n      border-radius: 5px;\n      border: 1px solid #ccc;\n      max-height: 300px;\n      overflow-y: auto;\n      scrollbar-width: thin;\n      scrollbar-color: #c0c0c0 transparent;\n    }\n  ");
  appendRule("\n    .cbioOption {\n      color: white;\n      padding: 5px;\n      border-radius: 5px;\n      cursor: pointer;\n      display: flex;\n    }\n  ");
  appendRule("\n    .cbioOption:hover {\n      background-color: #649eec;\n    }\n  ");
  appendRule("\n    .cbioOptionIcon {\n      visibility: hidden;\n      margin-right: 5px;\n    }\n  ");
  appendRule("\n    .cbioOptionSelect .cbioOptionIcon {\n      visibility: visible;\n    }\n  ");
  appendRule("\n    .cbioOptionDisable {\n      color: #a9a9a9;\n      pointer-events: none;\n    }\n  ");
  appendRule("\n    .cbioOptionHighlight.cbioOption {\n      background-color: #649eec;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar {\n      width: 8px;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar-track {\n      background: transparent;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar-thumb {\n      background-color: #c0c0c0;\n      border-radius: 4px;\n    }\n  ");
  appendRule("\n    .cbioSelect::-webkit-scrollbar-thumb:hover {\n      background-color: #a0a0a0;\n    }\n  ");
};
const createStyle = doc => {
  const element = doc.createElement('style');
  doc.head.appendChild(element);
  const appendRule = rule => {
    try {
      element.sheet.insertRule(rule, element.sheet.cssRules.length);
    } catch (error) {
      // ignore broken / incompatible rules
    }
  };
  return {
    appendRule,
    cleanUp: () => element.remove()
  };
};
const createSelect = (doc, isRedacted, onKeyDown, onMouseEnter, onMouseMove) => {
  const element = doc.createElement('div');
  element.classList.add('cbioSelect');
  if (isRedacted) element.classList.add('__cbio_ignored');
  element.setAttribute('role', 'combobox');
  element.setAttribute('aria-expanded', 'true');
  element.tabIndex = 0;
  element.addEventListener('keydown', onKeyDown);
  element.addEventListener('mouseenter', onMouseEnter);
  element.addEventListener('mousemove', onMouseMove);
  return {
    element,
    addOption: option => element.appendChild(option.element),
    cleanUp: () => element.remove()
  };
};
const createOption = (doc, text, selected, disabled, onSelect, onMouseEnter) => {
  const element = doc.createElement('div');
  element.classList.add('cbioOption');
  if (disabled) element.classList.add('cbioOptionDisable');
  if (selected) element.classList.add('cbioOptionSelect');
  element.setAttribute('role', 'option');
  element.setAttribute('aria-disabled', disabled);
  element.setAttribute('aria-selected', selected);
  element.addEventListener('mouseup', () => onSelect());
  element.addEventListener('mouseenter', onMouseEnter);
  const iconImg = doc.createElement('img');
  iconImg.className = 'cbioOptionIcon';
  iconImg.src = TICK_SVG;
  const titleSpan = doc.createElement('span');
  titleSpan.innerText = text;
  element.appendChild(iconImg);
  element.appendChild(titleSpan);
  const addHighlight = () => {
    element.classList.add('cbioOptionHighlight');
    element.scrollIntoView({
      block: 'nearest',
      inline: 'nearest'
    });
  };
  const removeHighlight = () => element.classList.remove('cbioOptionHighlight');
  return {
    element,
    disabled,
    addHighlight,
    removeHighlight,
    select: () => onSelect()
  };
};
const createSelectPositioner = (target, selectElement) => {
  let isInitialised = false;
  let isSelectInitiallySmaller = false;
  return () => {
    (0, _dom.computePosition)(target, selectElement, {
      placement: 'bottom-start',
      strategy: 'fixed',
      middleware: [(0, _dom.flip)(), (0, _dom.size)({
        apply() {
          if (isSelectInitiallySmaller) {
            Object.assign(selectElement.style, {
              width: "".concat(target.offsetWidth, "px")
            });
          }
        }
      })]
    }).then(_ref => {
      let {
        x,
        y
      } = _ref;
      Object.assign(selectElement.style, {
        top: "".concat(y, "px"),
        left: "".concat(x, "px"),
        position: 'fixed'
      });
      if (!isInitialised) {
        isSelectInitiallySmaller = selectElement.offsetWidth < target.offsetWidth;
        selectElement.focus();
      }
      isInitialised = true;
    });
  };
};
var _delegate = /*#__PURE__*/new WeakMap();
var _trackedWindows = /*#__PURE__*/new WeakMap();
var _currentSelect = /*#__PURE__*/new WeakMap();
var _options = /*#__PURE__*/new WeakMap();
var _highlightedOptionIndex = /*#__PURE__*/new WeakMap();
var _usingMouse = /*#__PURE__*/new WeakMap();
var _isActive = /*#__PURE__*/new WeakMap();
var _cleanUpAutoUpdate = /*#__PURE__*/new WeakMap();
var _cleanUpSelect = /*#__PURE__*/new WeakMap();
var _cleanUpStyle = /*#__PURE__*/new WeakMap();
var _closeSelect = /*#__PURE__*/new WeakMap();
var _highlightByIndex = /*#__PURE__*/new WeakMap();
var _highlightPrevious = /*#__PURE__*/new WeakMap();
var _highlightNext = /*#__PURE__*/new WeakMap();
var _selectHighlighted = /*#__PURE__*/new WeakMap();
var _removeAllHighlights = /*#__PURE__*/new WeakMap();
var _onSelectKeyDown = /*#__PURE__*/new WeakMap();
var _onSelectMouseMove = /*#__PURE__*/new WeakMap();
var _createSelectFromTarget = /*#__PURE__*/new WeakMap();
var _openSelect = /*#__PURE__*/new WeakMap();
var _shouldShowSelect = /*#__PURE__*/new WeakMap();
var _handleMouseDown = /*#__PURE__*/new WeakMap();
var _handleKeyDown = /*#__PURE__*/new WeakMap();
var _handleClick = /*#__PURE__*/new WeakMap();
class NativeSelect {
  constructor(delegate) {
    _classPrivateFieldInitSpec(this, _delegate, void 0);
    _classPrivateFieldInitSpec(this, _trackedWindows, void 0);
    _classPrivateFieldInitSpec(this, _currentSelect, void 0);
    _classPrivateFieldInitSpec(this, _options, void 0);
    _classPrivateFieldInitSpec(this, _highlightedOptionIndex, void 0);
    _classPrivateFieldInitSpec(this, _usingMouse, void 0);
    _classPrivateFieldInitSpec(this, _isActive, void 0);
    _classPrivateFieldInitSpec(this, _cleanUpAutoUpdate, void 0);
    _classPrivateFieldInitSpec(this, _cleanUpSelect, void 0);
    _classPrivateFieldInitSpec(this, _cleanUpStyle, void 0);
    _defineProperty(this, "track", w => {
      if (_classPrivateFieldGet(_trackedWindows, this).has(w)) return;
      _classPrivateFieldGet(_trackedWindows, this).add(w);
      w.addEventListener('mousedown', _classPrivateFieldGet(_handleMouseDown, this));
      w.addEventListener('keydown', _classPrivateFieldGet(_handleKeyDown, this));
      w.addEventListener('click', _classPrivateFieldGet(_handleClick, this), {
        capture: true,
        passive: true
      });
    });
    _classPrivateFieldInitSpec(this, _closeSelect, () => {
      var _classPrivateFieldGet2, _classPrivateFieldGet3, _classPrivateFieldGet4;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_cleanUpAutoUpdate, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this);
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_cleanUpSelect, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.call(this);
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_cleanUpStyle, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.call(this);
      _classPrivateFieldSet(_currentSelect, this, null);
    });
    _classPrivateFieldInitSpec(this, _highlightByIndex, index => {
      if (_classPrivateFieldGet(_highlightedOptionIndex, this) >= 0) _classPrivateFieldGet(_options, this)[_classPrivateFieldGet(_highlightedOptionIndex, this)].removeHighlight();
      _classPrivateFieldGet(_options, this)[index].addHighlight();
      _classPrivateFieldSet(_highlightedOptionIndex, this, index);
    });
    _classPrivateFieldInitSpec(this, _highlightPrevious, () => {
      if (_classPrivateFieldGet(_highlightedOptionIndex, this) <= 0) return;
      let newOptionIndex = _classPrivateFieldGet(_highlightedOptionIndex, this) - 1;
      while (newOptionIndex >= 0) {
        if (!_classPrivateFieldGet(_options, this)[newOptionIndex].disabled) {
          return _classPrivateFieldGet(_highlightByIndex, this).call(this, newOptionIndex);
        }
        newOptionIndex--;
      }
    });
    _classPrivateFieldInitSpec(this, _highlightNext, () => {
      if (_classPrivateFieldGet(_highlightedOptionIndex, this) >= _classPrivateFieldGet(_options, this).length - 1) return;
      let newOptionIndex = _classPrivateFieldGet(_highlightedOptionIndex, this) + 1;
      while (newOptionIndex < _classPrivateFieldGet(_options, this).length) {
        if (!_classPrivateFieldGet(_options, this)[newOptionIndex].disabled) {
          return _classPrivateFieldGet(_highlightByIndex, this).call(this, newOptionIndex);
        }
        newOptionIndex++;
      }
    });
    _classPrivateFieldInitSpec(this, _selectHighlighted, () => {
      _classPrivateFieldGet(_options, this)[_classPrivateFieldGet(_highlightedOptionIndex, this)].select();
    });
    _classPrivateFieldInitSpec(this, _removeAllHighlights, () => {
      _classPrivateFieldGet(_options, this).forEach(option => option.removeHighlight());
    });
    _classPrivateFieldInitSpec(this, _onSelectKeyDown, e => {
      _classPrivateFieldSet(_usingMouse, this, false);
      switch (e.code) {
        case 'ArrowUp':
          e.preventDefault();
          _classPrivateFieldGet(_highlightPrevious, this).call(this);
          break;
        case 'ArrowDown':
          e.preventDefault();
          _classPrivateFieldGet(_highlightNext, this).call(this);
          break;
        case 'Space':
        case 'Enter':
          e.preventDefault();
          _classPrivateFieldGet(_selectHighlighted, this).call(this);
          break;
        case 'Escape':
          e.preventDefault();
          _classPrivateFieldGet(_closeSelect, this).call(this);
          break;
      }
    });
    _classPrivateFieldInitSpec(this, _onSelectMouseMove, () => {
      _classPrivateFieldSet(_usingMouse, this, true);
    });
    _classPrivateFieldInitSpec(this, _createSelectFromTarget, target => {
      const doc = target.ownerDocument || document;
      const style = createStyle(doc);
      _classPrivateFieldSet(_cleanUpStyle, this, style.cleanUp);
      createCss(style.appendRule);
      const isRedacted = _classPrivateFieldGet(_delegate, this).isRedacted(target);
      const select = createSelect(doc, isRedacted, _classPrivateFieldGet(_onSelectKeyDown, this), _classPrivateFieldGet(_removeAllHighlights, this), _classPrivateFieldGet(_onSelectMouseMove, this));
      _classPrivateFieldSet(_cleanUpSelect, this, select.cleanUp);
      const targetOptions = Array.from(target.options);
      _classPrivateFieldSet(_options, this, targetOptions.map((targetOption, index) => {
        const {
          text,
          value,
          disabled
        } = targetOption;
        const selected = !disabled && targetOption.selected;
        const onSelect = () => {
          if (!_classPrivateFieldGet(_isActive, this)) return;
          target.value = value;
          targetOption.selected = true;
          target.dispatchEvent(new _unpolyfill.Event('input', {
            bubbles: true
          }));
          target.dispatchEvent(new _unpolyfill.Event('change', {
            bubbles: true
          }));
          _classPrivateFieldGet(_closeSelect, this).call(this);
        };
        const onMouseEnter = () => {
          if (!_classPrivateFieldGet(_usingMouse, this)) return;
          _classPrivateFieldGet(_highlightByIndex, this).call(this, index);
        };
        const option = createOption(doc, text, selected, disabled, onSelect, onMouseEnter);
        if (selected) {
          _classPrivateFieldSet(_highlightedOptionIndex, this, index);
          option.addHighlight();
        }
        select.addOption(option);
        return option;
      }));
      const containsElement = el => {
        if (target === el) return true;
        if (select.element === el) return true;
        if (select.element.contains(el)) return true;
        return false;
      };
      target.after(select.element);
      _classPrivateFieldSet(_cleanUpAutoUpdate, this, (0, _dom.autoUpdate)(target, select.element, createSelectPositioner(target, select.element)));
      return {
        containsElement
      };
    });
    _classPrivateFieldInitSpec(this, _openSelect, target => {
      if (_classPrivateFieldGet(_currentSelect, this)) {
        _classPrivateFieldGet(_closeSelect, this).call(this);
        return;
      }

      // small debounce in case the select renders under the pointer
      // during a click event and makes an automatic selection
      _classPrivateFieldSet(_isActive, this, false);
      setTimeout(() => {
        _classPrivateFieldSet(_isActive, this, true);
      }, 200);
      _classPrivateFieldSet(_currentSelect, this, _classPrivateFieldGet(_createSelectFromTarget, this).call(this, target));
    });
    _classPrivateFieldInitSpec(this, _shouldShowSelect, e => {
      var _e$target;
      if (!_classPrivateFieldGet(_delegate, this).shouldShowSelect()) return false;
      if (((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.tagName) !== 'SELECT') return false;
      if (e.target.size > 1) return false;
      if (e.defaultPrevented) return false;
      const select = e.target;
      if (select.options.length === 0) return false;
      if (select.multiple) return false;
      return true;
    });
    _classPrivateFieldInitSpec(this, _handleMouseDown, e => {
      if (!_classPrivateFieldGet(_shouldShowSelect, this).call(this, e)) return;
      if (e.button !== 0) return;
      e.preventDefault();
      _classPrivateFieldGet(_openSelect, this).call(this, e.target);
    });
    _classPrivateFieldInitSpec(this, _handleKeyDown, e => {
      if (!_classPrivateFieldGet(_shouldShowSelect, this).call(this, e)) return;
      if (['Space', 'ArrowDown', 'ArrowUp'].includes(e.code)) {
        e.preventDefault();
        _classPrivateFieldGet(_openSelect, this).call(this, e.target);
      }
    });
    _classPrivateFieldInitSpec(this, _handleClick, e => {
      var _classPrivateFieldGet5;
      if (((_classPrivateFieldGet5 = _classPrivateFieldGet(_currentSelect, this)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.containsElement(e.target)) === false && _classPrivateFieldGet(_isActive, this)) {
        _classPrivateFieldGet(_closeSelect, this).call(this);
      }
    });
    _classPrivateFieldSet(_delegate, this, delegate);
    _classPrivateFieldSet(_trackedWindows, this, new Set());
  }
}
var _default = exports["default"] = NativeSelect;

/***/ }),

/***/ 3291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _createRipple = __webpack_require__(2777);
var _activity = __webpack_require__(5264);
var _nodes = __webpack_require__(6938);
var _MultiAgentManager = __webpack_require__(2630);
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class RemoteCursor {
  constructor() {
    var _this = this;
    _defineProperty(this, "el", () => {
      if (!this._el) {
        const svgNS = 'http://www.w3.org/2000/svg';
        this._el = document.createElementNS(svgNS, 'svg');
        this._el.setAttribute('class', '__cbio_ignored');
        this._el.setAttribute('viewBox', '0 0 35 35');
        this._el.setAttribute('fill', 'none');
        this._el.style.position = 'fixed';
        this._el.style.zIndex = '2147483647';
        this._el.style.height = '32px';
        this._el.style.width = '32px';
        this._el.style.marginLeft = '-16px';
        this._el.style.marginTop = '0px';
        this._el.style.color = 'red';
        this._el.style.transition = 'opacity 0.5s';
        this._el.style.opacity = 1;
        this._el.style.pointerEvents = 'none';
        const path1 = document.createElementNS(svgNS, 'path');
        path1.setAttribute('d', 'M26.5148 15.8441V17.0941C26.5148 17.7541 26.9798 17.2891 26.3198 17.2891C25.6598 17.2891 26.1248 17.7541 26.1248 17.0941V14.5108C26.1248 13.8361 24.5779 12.2891 23.9032 12.2891C23.2285 12.2891 21.6815 13.8361 21.6815 14.5108V17.0941C21.6815 17.7541 22.1465 17.2891 21.4865 17.2891C20.8265 17.2891 21.2915 17.7541 21.2915 17.0941V13.0108C21.2915 12.3361 19.7445 10.7891 19.0698 10.7891C18.3951 10.7891 16.8482 12.3361 16.8482 13.0108V17.0941C16.8482 17.7541 17.3131 17.2891 16.6532 17.2891C15.9932 17.2891 16.4582 17.7541 16.4582 17.0941V5.01073C16.4582 4.33602 14.9112 2.78906 14.2365 2.78906C13.5618 2.78906 12.0148 4.33602 12.0148 5.01073V18.5941C12.0148 19.0774 12.7237 18.5132 12.2771 18.6981C11.8306 18.8831 11.3166 18.7809 10.9748 18.4391L8.262 15.7263C7.85703 15.3213 6.23834 15.2209 5.72608 15.477C5.04602 15.8171 4.78867 17.6568 5.16142 18.3195L11.0678 28.0419C12.5818 30.7334 15.4298 32.3991 18.518 32.3991H21.3198C25.9066 32.3991 30.6248 27.6808 30.6248 23.0941V15.8441C30.6248 15.2614 29.1525 13.7891 28.5698 13.7891C27.9872 13.7891 26.5148 15.2614 26.5148 15.8441Z');
        path1.setAttribute('fill', 'currentColor');
        path1.setAttribute('fill-rule', 'evenodd');
        path1.setAttribute('clip-rule', 'evenodd');
        const path2 = document.createElementNS(svgNS, 'path');
        path2.setAttribute('d', 'M10.6247 5.01011C10.6247 3.01544 12.2417 1.39844 14.2364 1.39844C16.2311 1.39844 17.8481 3.01544 17.8481 5.01011V9.61029C18.2296 9.47316 18.641 9.39844 19.0697 9.39844C20.4448 9.39844 21.6404 10.1669 22.2505 11.2978C22.7457 11.0425 23.3076 10.8984 23.9031 10.8984C25.2578 10.8984 26.4383 11.6443 27.0563 12.7478C27.5131 12.524 28.0268 12.3984 28.5697 12.3984C30.4724 12.3984 32.0147 13.9408 32.0147 15.8434V23.0934C32.0147 29.0001 27.2264 33.7884 21.3197 33.7884H18.5179C14.5663 33.7884 10.9219 31.657 8.98462 28.2129L4.07828 19.4905C3.03598 17.6375 3.7556 15.2894 5.65716 14.3386C7.08954 13.6225 8.81951 13.9032 9.95191 15.0356L10.6247 15.7084V5.01011ZM27.5147 15.8434V17.0934C27.5147 17.7534 26.9797 18.2884 26.3197 18.2884C25.6597 18.2884 25.1247 17.7534 25.1247 17.0934V14.5101C25.1247 13.8354 24.5778 13.2884 23.9031 13.2884C23.2284 13.2884 22.6814 13.8354 22.6814 14.5101V17.0934C22.6814 17.7534 22.1464 18.2884 21.4864 18.2884C20.8264 18.2884 20.2914 17.7534 20.2914 17.0934V13.0101C20.2914 12.3354 19.7444 11.7884 19.0697 11.7884C18.395 11.7884 17.8481 12.3354 17.8481 13.0101V17.0934C17.8481 17.7534 17.313 18.2884 16.6531 18.2884C15.9931 18.2884 15.4581 17.7534 15.4581 17.0934V5.01011C15.4581 4.3354 14.9111 3.78844 14.2364 3.78844C13.5617 3.78844 13.0147 4.3354 13.0147 5.01011V18.5934C13.0147 19.0767 12.7236 19.5125 12.277 19.6974C11.8305 19.8824 11.3165 19.7802 10.9747 19.4384L8.26192 16.7256C7.85695 16.3206 7.23826 16.2202 6.726 16.4763C6.04594 16.8164 5.78859 17.6561 6.16134 18.3188L11.0677 27.0412C12.5817 29.7327 15.4297 31.3984 18.5179 31.3984H21.3197C25.9065 31.3984 29.6247 27.6801 29.6247 23.0934V15.8434C29.6247 15.2607 29.1524 14.7884 28.5697 14.7884C27.9871 14.7884 27.5147 15.2607 27.5147 15.8434Z');
        path2.setAttribute('fill', 'white');
        path2.setAttribute('fill-rule', 'evenodd');
        path2.setAttribute('clip-rule', 'evenodd');
        this._el.appendChild(path1);
        this._el.appendChild(path2);
      }
      return this._el;
    });
    _defineProperty(this, "calculateOffset", event => {
      var _target$ownerDocument;
      const target = _nodes.NodeTracker.getById(event.target.id);
      const iframe = target === null || target === void 0 || (_target$ownerDocument = target.ownerDocument) === null || _target$ownerDocument === void 0 || (_target$ownerDocument = _target$ownerDocument.defaultView) === null || _target$ownerDocument === void 0 ? void 0 : _target$ownerDocument.frameElement;
      if (!iframe) return {
        offsetX: 0,
        offsetY: 0
      };
      const rect = iframe.getBoundingClientRect();
      return {
        offsetX: Math.round(rect.left),
        offsetY: Math.round(rect.top)
      };
    });
    _defineProperty(this, "getOffset", event => {
      var _window$document, _window$document2;
      const {
        offsetX,
        offsetY
      } = event;
      const eventHasOffset = offsetX !== undefined && offsetY !== undefined;

      // for backwards compatibility when offset is not included in the event
      // we should still attempt to calculate it here. This calculation should
      // be removed once we can rely on the offset included within the event
      if (!eventHasOffset) return this.calculateOffset(event);
      return {
        offsetX: offsetX * ((_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.clientWidth),
        offsetY: offsetY * ((_window$document2 = window.document) === null || _window$document2 === void 0 || (_window$document2 = _window$document2.documentElement) === null || _window$document2 === void 0 ? void 0 : _window$document2.clientHeight)
      };
    });
    _defineProperty(this, "_updatePosition", event => {
      var _window$document3, _window$document4;
      let {
        x,
        y
      } = event;

      // prevent jumping cursor when crossing over iFrame borders due to condition
      // on the agent which can sometimes provide false for x and y coordinates
      if (x === false || y === false) return;
      x *= (_window$document3 = window.document) === null || _window$document3 === void 0 || (_window$document3 = _window$document3.documentElement) === null || _window$document3 === void 0 ? void 0 : _window$document3.clientWidth;
      y *= (_window$document4 = window.document) === null || _window$document4 === void 0 || (_window$document4 = _window$document4.documentElement) === null || _window$document4 === void 0 ? void 0 : _window$document4.clientHeight;
      const offset = this.getOffset(event);
      x += offset.offsetX;
      y += offset.offsetY;
      this.el().style.top = "".concat(y, "px");
      this.el().style.left = "".concat(x, "px");
      this._lastPosition = {
        x,
        y
      };
    });
    _defineProperty(this, "_getRippleStyle", () => ({
      position: 'fixed',
      left: "".concat(this._lastPosition.x - 4, "px"),
      top: "".concat(this._lastPosition.y + 4, "px")
    }));
    _defineProperty(this, "_createRipple", function () {
      let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#e94435';
      const ripple = (0, _createRipple.createRipple)(color, 1000, 12, _this._getRippleStyle());
      document.body.appendChild(ripple);
    });
    _defineProperty(this, "update", (type, event) => {
      if (type !== 'mouse') return;
      if (!_activity.WindowTracking.isActive()) return;
      if (document.body && !this.el().parentNode) document.body.appendChild(this.el());
      if (event.colour) this.el().style.color = event.colour;
      switch (event.state) {
        case 'mousedown':
          this._hideAfterTimeout();
          this._createRipple(event.colour);
          if (!this.interval) {
            this.interval = setInterval(() => {
              this._createRipple(event.colour);
            }, 500);
          }
          break;
        case 'mouseup':
          this._hideAfterTimeout();
          clearInterval(this.interval);
          this.interval = null;
          break;
        case 'mousemove':
          this._hideAfterTimeout();
          this._updatePosition(event);
          break;
        default:
          break;
      }
    });
    _defineProperty(this, "hide", () => {
      clearTimeout(this.fadeTimeOut);
      if (this.el().parentNode) {
        this.el().parentNode.removeChild(this.el());
      }
    });
  }
  _hideAfterTimeout() {
    clearTimeout(this.fadeTimeOut);
    this.el().style.opacity = 1;
    this.fadeTimeOut = setTimeout(() => {
      this.el().style.opacity = 0;
    }, 5000);
  }
}
class RemoteCursorManager extends _MultiAgentManager.MultiAgentManager {
  constructor() {
    super(RemoteCursor);
  }
  update(type, event) {
    const instance = this.getInstanceForAgent(event.agent);
    instance.update(type, event);
  }
}
var _default = exports["default"] = new RemoteCursorManager();

/***/ }),

/***/ 4340:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _events = _interopRequireDefault(__webpack_require__(6261));
var _lite = __webpack_require__(8637);
var _Locale = _interopRequireDefault(__webpack_require__(7988));
var _mountComponent = __webpack_require__(9103);
var _components = __webpack_require__(2996);
var _SessionStateOverlayModule = _interopRequireDefault(__webpack_require__(3983));
var _jsxRuntime = __webpack_require__(6416);
const _excluded = ["showSessionControls", "showCallingControls"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const EndSession = _ref => {
  let {
    onClick
  } = _ref;
  return (0, _jsxRuntime.jsxs)(_components.Button, {
    className: _SessionStateOverlayModule.default.endSessionButton,
    onClick: () => onClick('session-end'),
    children: [_Locale.default.tr('END_SESSION'), (0, _jsxRuntime.jsx)(_components.Icon, {
      className: _SessionStateOverlayModule.default.endSessionIcon,
      name: "EndSession"
    })]
  });
};
const CallingControls = _ref2 => {
  let {
    onClick,
    audioEnabled,
    videoEnabled
  } = _ref2;
  return (0, _jsxRuntime.jsxs)("div", {
    className: _SessionStateOverlayModule.default.callingControlsContainer,
    children: [(0, _jsxRuntime.jsxs)("div", {
      className: _SessionStateOverlayModule.default.callingControlsToggleContainer,
      children: [(0, _jsxRuntime.jsx)(_components.IconButton, {
        className: (0, _lite.clsx)(_SessionStateOverlayModule.default.callingControlsToggle, audioEnabled ? _SessionStateOverlayModule.default.callingControlsToggleOn : _SessionStateOverlayModule.default.callingControlsToggleOff),
        ariaLabel: audioEnabled ? _Locale.default.tr('CALLING_DISABLE_AUDIO') : _Locale.default.tr('CALLING_ENABLE_AUDIO'),
        onClick: () => onClick('audio'),
        children: (0, _jsxRuntime.jsx)(_components.Icon, {
          name: audioEnabled ? 'Microphone' : 'MicrophoneOff',
          className: _SessionStateOverlayModule.default.callingControlsIcon
        })
      }), (0, _jsxRuntime.jsx)(_components.IconButton, {
        className: (0, _lite.clsx)(_SessionStateOverlayModule.default.callingControlsToggle, videoEnabled ? _SessionStateOverlayModule.default.callingControlsToggleOn : _SessionStateOverlayModule.default.callingControlsToggleOff),
        ariaLabel: videoEnabled ? _Locale.default.tr('CALLING_DISABLE_VIDEO') : _Locale.default.tr('CALLING_ENABLE_VIDEO'),
        onClick: () => onClick('video'),
        children: (0, _jsxRuntime.jsx)(_components.Icon, {
          name: videoEnabled ? 'Video' : 'VideoOff',
          className: _SessionStateOverlayModule.default.callingControlsIcon
        })
      }), (0, _jsxRuntime.jsx)(_components.IconButton, {
        className: (0, _lite.clsx)(_SessionStateOverlayModule.default.callingControlsToggle, _SessionStateOverlayModule.default.callingControlsToggleOn),
        ariaLabel: _Locale.default.tr('CALLING_SHOW_CALL_SETTINGS'),
        onClick: () => onClick('settings'),
        children: (0, _jsxRuntime.jsx)(_components.Icon, {
          name: "DotsVertical",
          className: _SessionStateOverlayModule.default.callingControlsIcon
        })
      })]
    }), (0, _jsxRuntime.jsx)(_components.IconButton, {
      className: _SessionStateOverlayModule.default.callingControlsEnd,
      ariaLabel: _Locale.default.tr('CALLING_END'),
      onClick: () => onClick('call-end'),
      children: (0, _jsxRuntime.jsx)(_components.Icon, {
        name: "Phone",
        className: _SessionStateOverlayModule.default.callingControlsIcon
      })
    })]
  });
};
const SessionStateOverlayComponent = _ref3 => {
  let {
      showSessionControls,
      showCallingControls
    } = _ref3,
    props = _objectWithoutProperties(_ref3, _excluded);
  return (0, _jsxRuntime.jsxs)("div", {
    className: _SessionStateOverlayModule.default.sessionStateOverlay,
    children: [showSessionControls ? (0, _jsxRuntime.jsx)(EndSession, _objectSpread({}, props)) : null, showCallingControls ? (0, _jsxRuntime.jsx)(CallingControls, _objectSpread({}, props)) : null]
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
var _props = /*#__PURE__*/new WeakMap();
var _update = /*#__PURE__*/new WeakMap();
class SessionStateOverlay extends _events.default {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec(this, _mountHandle, null);
    _classPrivateFieldInitSpec(this, _props, {
      showSessionControls: false,
      showCallingControls: false,
      onClick: target => this.emit('click', target),
      audioEnabled: false,
      videoEnabled: false
    });
    _classPrivateFieldInitSpec(this, _update, () => {
      const shouldShow = _classPrivateFieldGet(_props, this).showSessionControls || _classPrivateFieldGet(_props, this).showCallingControls;
      if (!shouldShow) {
        var _classPrivateFieldGet2;
        (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
        _classPrivateFieldSet(_mountHandle, this, null);
        return;
      }
      if (_classPrivateFieldGet(_mountHandle, this)) return _classPrivateFieldGet(_mountHandle, this).rerender(_classPrivateFieldGet(_props, this));
      _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(SessionStateOverlayComponent, _classPrivateFieldGet(_props, this), true, true));
    });
    _defineProperty(this, "showSessionControls", () => {
      _classPrivateFieldGet(_props, this).showSessionControls = true;
      _classPrivateFieldGet(_update, this).call(this);
    });
    _defineProperty(this, "hideSessionControls", () => {
      _classPrivateFieldGet(_props, this).showSessionControls = false;
      _classPrivateFieldGet(_update, this).call(this);
    });
    _defineProperty(this, "showCallingControls", _ref4 => {
      let {
        audioEnabled,
        videoEnabled
      } = _ref4;
      _classPrivateFieldGet(_props, this).showCallingControls = true;
      _classPrivateFieldGet(_props, this).audioEnabled = audioEnabled;
      _classPrivateFieldGet(_props, this).videoEnabled = videoEnabled;
      _classPrivateFieldGet(_update, this).call(this);
    });
    _defineProperty(this, "hideCallingControls", () => {
      _classPrivateFieldGet(_props, this).showCallingControls = false;
      _classPrivateFieldGet(_update, this).call(this);
    });
  }
}
var _default = exports["default"] = new SessionStateOverlay();

/***/ }),

/***/ 198:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const LOADING_SVG = 'data:image/svg+xml,<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z"><animateTransform attributeName="transform" type="rotate" dur="0.75s" values="0 12 12;360 12 12" repeatCount="indefinite"/></path></svg>';
const GLOBE_SVG = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="gray"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 0 1 7.843 4.582M12 3a8.997 8.997 0 0 0-7.843 4.582m15.686 0A11.953 11.953 0 0 1 12 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0 1 21 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0 1 12 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 0 1 3 12c0-1.605.42-3.113 1.157-4.418" /></svg>';
var _openingHistoryLength = /*#__PURE__*/new WeakMap();
var _modal = /*#__PURE__*/new WeakMap();
var _tabs = /*#__PURE__*/new WeakMap();
var _mediaQuery = /*#__PURE__*/new WeakMap();
var _handlePopState = /*#__PURE__*/new WeakMap();
var _handleBeforeUnload = /*#__PURE__*/new WeakMap();
var _closeTab = /*#__PURE__*/new WeakMap();
var _activateTab = /*#__PURE__*/new WeakMap();
var _tabModal = /*#__PURE__*/new WeakMap();
var _tabToolbar = /*#__PURE__*/new WeakMap();
var _tabPanelContainer = /*#__PURE__*/new WeakMap();
var _tabButton = /*#__PURE__*/new WeakMap();
var _tabPanel = /*#__PURE__*/new WeakMap();
class TabOverlay {
  constructor() {
    _classPrivateFieldInitSpec(this, _openingHistoryLength, void 0);
    _classPrivateFieldInitSpec(this, _modal, void 0);
    _classPrivateFieldInitSpec(this, _tabs, []);
    _classPrivateFieldInitSpec(this, _mediaQuery, window.matchMedia('(min-width: 768px)'));
    _defineProperty(this, "singleTabFullScreen", false);
    _defineProperty(this, "enterFullScreen", () => _classPrivateFieldGet(_modal, this).enterFullScreen());
    _defineProperty(this, "exitFullScreen", () => _classPrivateFieldGet(_modal, this).exitFullScreen());
    _defineProperty(this, "getTabCount", () => _classPrivateFieldGet(_tabs, this).length);
    _defineProperty(this, "newTab", (el, icon, title, isLoading, onClose, confirmUnload) => {
      const tab = _classPrivateFieldGet(_modal, this).createTab({
        onTabClick: e => {
          _classPrivateFieldGet(_activateTab, this).call(this, tab);
        },
        onClose,
        confirmUnload
      });
      tab.setIcon(icon);
      tab.setTitle(title);
      tab.setIsLoading(isLoading);
      tab.setContent(el);
      _classPrivateFieldGet(_tabs, this).push(tab);
      _classPrivateFieldGet(_activateTab, this).call(this, tab);
      _classPrivateFieldGet(_modal, this).showModal();
      if (_classPrivateFieldGet(_tabs, this).length === 1) history.pushState({
        universalProxyOpen: true
      }, '');
      return _objectSpread(_objectSpread({}, tab), {}, {
        close: () => _classPrivateFieldGet(_closeTab, this).call(this, tab)
      });
    });
    _classPrivateFieldInitSpec(this, _handlePopState, () => {
      if (_classPrivateFieldGet(_tabs, this).length === 1) _classPrivateFieldGet(_closeTab, this).call(this, _classPrivateFieldGet(_tabs, this)[0]);
    });
    _classPrivateFieldInitSpec(this, _handleBeforeUnload, e => {
      const confirmUnload = _classPrivateFieldGet(_tabs, this).some(tab => tab.confirmUnload);
      if (confirmUnload) e.preventDefault();
    });
    _defineProperty(this, "closeAllTabs", () => {
      _classPrivateFieldGet(_tabs, this).forEach(_classPrivateFieldGet(_closeTab, this));
    });
    _classPrivateFieldInitSpec(this, _closeTab, tab => {
      const tabIndex = _classPrivateFieldGet(_tabs, this).indexOf(tab);
      if (tabIndex === -1) return;
      tab.removeTab();
      _classPrivateFieldGet(_tabs, this).splice(tabIndex, 1);
      if (!_classPrivateFieldGet(_tabs, this).length) return _classPrivateFieldGet(_modal, this).hideModal();
      const lastTabIndex = _classPrivateFieldGet(_tabs, this).length - 1;
      if (tab.isActive()) {
        if (tabIndex <= lastTabIndex) {
          _classPrivateFieldGet(_tabs, this)[tabIndex].show();
        } else {
          _classPrivateFieldGet(_tabs, this)[lastTabIndex].show();
        }
      }
    });
    _classPrivateFieldInitSpec(this, _activateTab, tab => {
      _classPrivateFieldGet(_tabs, this).forEach(t => t.hide());
      tab.show();
    });
    _classPrivateFieldInitSpec(this, _tabModal, () => {
      const host = document.createElement('div');
      const shadow = host.attachShadow({
        mode: 'open'
      });
      const element = document.createElement('div');
      element.style.background = 'rgba(50, 50, 50, 0.4)';
      element.style.position = 'fixed';
      element.style.zIndex = '2147483645';
      element.style.bottom = '0';
      element.style.top = '0';
      element.style.left = '0';
      element.style.right = '0';
      element.style.display = 'flex';
      element.style.flexDirection = 'column';
      element.style.padding = _classPrivateFieldGet(_mediaQuery, this).matches ? '25px' : '0';
      shadow.appendChild(element);
      const toolbar = _classPrivateFieldGet(_tabToolbar, this).call(this);
      element.appendChild(toolbar.element);
      const panelContainer = _classPrivateFieldGet(_tabPanelContainer, this).call(this);
      element.appendChild(panelContainer.element);
      const createTab = _ref => {
        let {
          onTabClick,
          onClose,
          confirmUnload
        } = _ref;
        const button = _classPrivateFieldGet(_tabButton, this).call(this, {
          onTabClick,
          onCloseClick: e => {
            e.stopPropagation();
            onClose();
          }
        });
        toolbar.addButton(button.element);
        const panel = _classPrivateFieldGet(_tabPanel, this).call(this);
        panelContainer.addPanel(panel.element);
        return {
          setIcon: button.setIcon,
          setTitle: button.setTitle,
          setIsLoading: button.setIsLoading,
          showBanner: panel.showBanner,
          hideBanner: panel.hideBanner,
          show: () => {
            button.setIsActive(true);
            panel.showPanel();
          },
          hide: () => {
            button.setIsActive(false);
            panel.hidePanel();
          },
          removeTab: () => {
            toolbar.removeButton(button.element);
            panelContainer.removePanel(panel.element);
          },
          isActive: () => button.isActive,
          onClose,
          confirmUnload,
          setContent: panel.setContent
        };
      };
      let overflow = null;
      const showModal = () => {
        if (this.isVisible) return;
        document.body.appendChild(host);
        overflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        this.isVisible = true;
        _classPrivateFieldSet(_openingHistoryLength, this, history.length);
      };
      const hideModal = () => {
        document.body.removeChild(host);
        document.body.style.overflow = overflow;
        this.isVisible = false;
        const requiredStepsBack = history.length - _classPrivateFieldGet(_openingHistoryLength, this);
        if (requiredStepsBack > 0) history.go(-requiredStepsBack);
      };
      const enterFullScreen = () => {
        toolbar.hide();
        element.style.padding = '0';
      };
      const exitFullScreen = () => {
        toolbar.show();
        element.style.padding = _classPrivateFieldGet(_mediaQuery, this).matches ? '25px' : '0';
      };
      return {
        element,
        showModal,
        hideModal,
        createTab,
        enterFullScreen,
        exitFullScreen
      };
    });
    _classPrivateFieldInitSpec(this, _tabToolbar, () => {
      const element = document.createElement('div');
      element.style.display = 'flex';
      element.style.backgroundColor = '#d6e2fb';
      element.style.borderBottom = '1px solid #d8d8d8';
      element.style.paddingTop = '6px';
      element.style.paddingLeft = '6px';
      element.style.paddingBottom = '5px';
      element.style.borderRadius = '10px 10px 0 0';
      if (this.fullScreen) element.style.display = 'none';
      return {
        element,
        addButton: tabButtonElement => element.appendChild(tabButtonElement),
        removeButton: tabButtonElement => element.removeChild(tabButtonElement),
        show: () => {
          element.style.display = 'flex';
        },
        hide: () => {
          element.style.display = 'none ';
        }
      };
    });
    _classPrivateFieldInitSpec(this, _tabPanelContainer, () => {
      const element = document.createElement('div');
      element.style.width = '100%';
      element.style.height = '100%';
      element.style.backgroundColor = 'white';
      element.style.borderRadius = '0 0 10px 10px';
      element.style.overflow = 'hidden';
      return {
        element,
        addPanel: tabPanelElement => element.appendChild(tabPanelElement),
        removePanel: tabPanelElement => element.removeChild(tabPanelElement)
      };
    });
    _classPrivateFieldInitSpec(this, _tabButton, _ref2 => {
      let {
        onTabClick,
        onCloseClick
      } = _ref2;
      const element = document.createElement('div');
      element.style.display = 'flex';
      element.style.alignItems = 'center';
      element.style.justifyContent = 'end';
      element.style.flex = '1 1 0';
      element.style.backgroundColor = '#ffffff66';
      element.style.padding = '4px';
      element.style.maxWidth = '200px';
      element.style.minWidth = '0';
      element.style.overflow = 'hidden';
      element.style.cursor = 'pointer';
      element.style.borderRadius = '9px';
      element.style.marginRight = '6px';
      const iconImg = document.createElement('img');
      iconImg.style.flex = '0 0 auto';
      iconImg.style.width = '16px';
      iconImg.style.height = '16px';
      iconImg.style.marginRight = '4px';
      const titleSpan = document.createElement('span');
      titleSpan.style.flex = '1 1 auto';
      titleSpan.style.display = 'block';
      titleSpan.style.fontFamily = 'sans-serif';
      titleSpan.style.fontSize = '13px';
      titleSpan.style.overflow = 'hidden';
      titleSpan.style.whiteSpace = 'nowrap';
      titleSpan.style.textOverflow = 'ellipsis';
      const closeButton = document.createElement('button');
      closeButton.style.flex = '0 0 auto';
      closeButton.style.width = '24px';
      closeButton.style.height = '24px';
      closeButton.style.border = 'none';
      closeButton.style.background = 'none';
      closeButton.style.padding = '4px';
      closeButton.style.cursor = 'pointer';
      const closeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      closeSvg.setAttribute('fill', 'none');
      closeSvg.setAttribute('viewBox', '0 0 24 24');
      closeSvg.setAttribute('stroke-width', '1.5');
      closeSvg.setAttribute('stroke', 'currentColor');
      closeSvg.style.width = '16px';
      closeSvg.style.height = '16px';
      const closeSvgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      closeSvgPath.setAttribute('stroke-linecap', 'round');
      closeSvgPath.setAttribute('stroke-linejoin', 'round');
      closeSvgPath.setAttribute('d', 'M6 18 18 6M6 6l12 12');
      closeSvg.appendChild(closeSvgPath);
      closeButton.appendChild(closeSvg);
      element.appendChild(iconImg);
      element.appendChild(titleSpan);
      element.appendChild(closeButton);
      element.addEventListener('click', onTabClick);
      closeButton.addEventListener('click', onCloseClick);
      iconImg.onerror = function () {
        this.src = GLOBE_SVG;
      };
      return {
        element,
        icon: '',
        title: '',
        isActive: false,
        isLoading: false,
        setIcon: function (src) {
          this.icon = src;
          iconImg.src = src;
        },
        setTitle: function (title) {
          this.title = title;
          titleSpan.textContent = title;
        },
        setIsActive: function (isActive) {
          this.isActive = isActive;
          if (this.isActive) {
            element.style.backgroundColor = 'white';
            element.style.borderColor = '#d8d8d8';
          } else {
            element.style.backgroundColor = '#ffffff66';
            element.style.borderColor = '#efefef';
          }
        },
        setIsLoading: function (isLoading) {
          this.isLoading = isLoading;
          iconImg.src = this.isLoading ? LOADING_SVG : this.icon;
        }
      };
    });
    _classPrivateFieldInitSpec(this, _tabPanel, () => {
      const element = document.createElement('div');
      element.style.width = '100%';
      element.style.height = '100%';
      element.style.backgroundColor = 'white';
      element.style.display = 'flex';
      element.style.flexDirection = 'column';
      const bannerElement = document.createElement('div');
      bannerElement.style.height = '30px';
      bannerElement.style.width = '100%';
      bannerElement.style.display = 'flex';
      bannerElement.style.alignItems = 'center';
      bannerElement.style.justifyContent = 'center';
      bannerElement.style.backgroundColor = 'white';
      bannerElement.style.color = 'black';
      bannerElement.style.fontFamily = 'sans-serif';
      bannerElement.style.fontSize = '13px';
      bannerElement.style.borderBottom = '1px solid #d8d8d8';
      const elementWrapper = document.createElement('div');
      elementWrapper.style.flex = '1';
      element.appendChild(elementWrapper);
      return {
        element,
        showPanel: () => {
          element.style.display = 'flex';
        },
        hidePanel: () => {
          element.style.display = 'none';
        },
        showBanner: text => {
          bannerElement.innerText = text;
          if (!element.contains(bannerElement)) element.prepend(bannerElement);
        },
        hideBanner: () => {
          if (element.contains(bannerElement)) element.removeChild(bannerElement);
        },
        setContent: el => {
          if (elementWrapper.contains(el)) return;
          elementWrapper.replaceChildren(el);
        }
      };
    });
    _classPrivateFieldSet(_modal, this, _classPrivateFieldGet(_tabModal, this).call(this));
    _classPrivateFieldGet(_mediaQuery, this).addEventListener('change', event => {
      _classPrivateFieldGet(_modal, this).element.style.padding = event.matches ? '25px' : '0';
    });
    window.addEventListener('popstate', _classPrivateFieldGet(_handlePopState, this));
    window.addEventListener('beforeunload', _classPrivateFieldGet(_handleBeforeUnload, this));
  }
}
var _default = exports["default"] = new TabOverlay();

/***/ }),

/***/ 7410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(8637);
var _ButtonModule = _interopRequireDefault(__webpack_require__(2989));
var _jsxRuntime = __webpack_require__(6416);
const _excluded = ["children", "className", "variant"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Button = _ref => {
  let {
      children,
      className,
      variant
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: (0, _jsxRuntime.jsx)("button", _objectSpread(_objectSpread({
      className: (0, _lite.clsx)(_ButtonModule.default.base, _ButtonModule.default[variant], className)
    }, props), {}, {
      children: children
    }))
  });
};
var _default = exports["default"] = Button;

/***/ }),

/***/ 5029:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _hooks = __webpack_require__(16);
var _jsxRuntime = __webpack_require__(6416);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const Draggable = _ref => {
  let {
    children,
    style,
    corner = 'top-left',
    onCornerChange
  } = _ref;
  const [position, setPosition] = (0, _hooks.useState)({
    x: 0,
    y: 0
  });
  const [isDragging, setIsDragging] = (0, _hooks.useState)(false);
  const [isSnapping, setIsSnapping] = (0, _hooks.useState)(false);
  const positionRef = (0, _hooks.useRef)(position);
  const elementRef = (0, _hooks.useRef)(null);
  const dragOffsetRef = (0, _hooks.useRef)({
    x: 0,
    y: 0
  });
  const snappedCornerOffsetRef = (0, _hooks.useRef)(null);
  const lastCornerRef = (0, _hooks.useRef)(corner);
  (0, _hooks.useEffect)(() => {
    positionRef.current = position;
  }, [position]);
  (0, _hooks.useEffect)(() => {
    var _window$visualViewpor, _window$visualViewpor2;
    if (!elementRef.current) return;
    const bounds = {
      width: ((_window$visualViewpor = window.visualViewport) === null || _window$visualViewpor === void 0 ? void 0 : _window$visualViewpor.width) || window.innerWidth,
      height: ((_window$visualViewpor2 = window.visualViewport) === null || _window$visualViewpor2 === void 0 ? void 0 : _window$visualViewpor2.height) || window.innerHeight
    };
    const {
      offsetWidth,
      offsetHeight
    } = elementRef.current;
    const corners = {
      'top-left': {
        x: 0,
        y: 0,
        dx: 0,
        dy: 0
      },
      'top-right': {
        x: bounds.width - offsetWidth,
        y: 0,
        dx: 1,
        dy: 0
      },
      'bottom-left': {
        x: 0,
        y: bounds.height - offsetHeight,
        dx: 0,
        dy: 1
      },
      'bottom-right': {
        x: bounds.width - offsetWidth,
        y: bounds.height - offsetHeight,
        dx: 1,
        dy: 1
      }
    };
    const {
      x,
      y,
      dx,
      dy
    } = corners[corner];
    setPosition({
      x,
      y
    });
    snappedCornerOffsetRef.current = {
      dx,
      dy
    };
    lastCornerRef.current = corner;
  }, [corner]);
  const handleStart = (clientX, clientY) => {
    setIsDragging(true);
    setIsSnapping(false);
    dragOffsetRef.current = {
      x: clientX - position.x,
      y: clientY - position.y
    };
  };
  const handleMouseDown = e => {
    e.preventDefault();
    handleStart(e.clientX, e.clientY);
  };
  const handleTouchStart = e => {
    const touch = e.touches[0];
    if (touch) {
      handleStart(touch.clientX, touch.clientY);
    }
  };
  (0, _hooks.useEffect)(() => {
    const handleMouseMove = e => {
      var _window$visualViewpor3, _window$visualViewpor4;
      if (!isDragging) return;
      const bounds = {
        width: ((_window$visualViewpor3 = window.visualViewport) === null || _window$visualViewpor3 === void 0 ? void 0 : _window$visualViewpor3.width) || window.innerWidth,
        height: ((_window$visualViewpor4 = window.visualViewport) === null || _window$visualViewpor4 === void 0 ? void 0 : _window$visualViewpor4.height) || window.innerHeight
      };
      let newX = e.clientX - dragOffsetRef.current.x;
      let newY = e.clientY - dragOffsetRef.current.y;
      if (elementRef.current) {
        const {
          offsetWidth,
          offsetHeight
        } = elementRef.current;
        newX = Math.max(0, Math.min(newX, bounds.width - offsetWidth));
        newY = Math.max(0, Math.min(newY, bounds.height - offsetHeight));
      }
      setPosition({
        x: newX,
        y: newY
      });
      positionRef.current = {
        x: newX,
        y: newY
      };
    };
    const handleTouchMove = e => {
      var _window$visualViewpor5, _window$visualViewpor6;
      if (!isDragging) return;
      e.preventDefault();
      const touch = e.touches[0];
      if (!touch) return;
      const bounds = {
        width: ((_window$visualViewpor5 = window.visualViewport) === null || _window$visualViewpor5 === void 0 ? void 0 : _window$visualViewpor5.width) || window.innerWidth,
        height: ((_window$visualViewpor6 = window.visualViewport) === null || _window$visualViewpor6 === void 0 ? void 0 : _window$visualViewpor6.height) || window.innerHeight
      };
      let newX = touch.clientX - dragOffsetRef.current.x;
      let newY = touch.clientY - dragOffsetRef.current.y;
      if (elementRef.current) {
        const {
          offsetWidth,
          offsetHeight
        } = elementRef.current;
        newX = Math.max(0, Math.min(newX, bounds.width - offsetWidth));
        newY = Math.max(0, Math.min(newY, bounds.height - offsetHeight));
      }
      setPosition({
        x: newX,
        y: newY
      });
      positionRef.current = {
        x: newX,
        y: newY
      };
    };
    const endDrag = () => {
      setIsDragging(false);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', endDrag);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', endDrag);
      setTimeout(snapToCorner, 0);
    };
    if (isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', endDrag);
      window.addEventListener('touchmove', handleTouchMove, {
        passive: false
      }); //  important
      window.addEventListener('touchend', endDrag);
    }
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', endDrag);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', endDrag);
    };
  }, [isDragging]);
  const handleResize = (0, _hooks.useCallback)(() => {
    var _window$visualViewpor7, _window$visualViewpor8;
    if (!elementRef.current || !snappedCornerOffsetRef.current) return;
    const bounds = {
      width: ((_window$visualViewpor7 = window.visualViewport) === null || _window$visualViewpor7 === void 0 ? void 0 : _window$visualViewpor7.width) || window.innerWidth,
      height: ((_window$visualViewpor8 = window.visualViewport) === null || _window$visualViewpor8 === void 0 ? void 0 : _window$visualViewpor8.height) || window.innerHeight
    };
    const {
      offsetWidth,
      offsetHeight
    } = elementRef.current;
    const {
      dx,
      dy
    } = snappedCornerOffsetRef.current;
    const newX = dx === 0 ? 0 : bounds.width - offsetWidth;
    const newY = dy === 0 ? 0 : bounds.height - offsetHeight;
    setPosition({
      x: newX,
      y: newY
    });
  }, []);
  (0, _hooks.useEffect)(() => {
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);
  (0, _hooks.useEffect)(() => {
    const observer = new ResizeObserver(() => {
      setIsSnapping(true);
      handleResize();
      setTimeout(() => setIsSnapping(false), 300);
    });
    if (elementRef.current) {
      observer.observe(elementRef.current);
    }
    return () => observer.disconnect();
  }, [handleResize]);
  const snapToCorner = () => {
    var _window$visualViewpor9, _window$visualViewpor0;
    if (!elementRef.current) return;
    const bounds = {
      width: ((_window$visualViewpor9 = window.visualViewport) === null || _window$visualViewpor9 === void 0 ? void 0 : _window$visualViewpor9.width) || window.innerWidth,
      height: ((_window$visualViewpor0 = window.visualViewport) === null || _window$visualViewpor0 === void 0 ? void 0 : _window$visualViewpor0.height) || window.innerHeight
    };
    const {
      offsetWidth,
      offsetHeight
    } = elementRef.current;
    const corners = [{
      name: 'top-left',
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    }, {
      name: 'top-right',
      x: bounds.width - offsetWidth,
      y: 0,
      dx: 1,
      dy: 0
    }, {
      name: 'bottom-left',
      x: 0,
      y: bounds.height - offsetHeight,
      dx: 0,
      dy: 1
    }, {
      name: 'bottom-right',
      x: bounds.width - offsetWidth,
      y: bounds.height - offsetHeight,
      dx: 1,
      dy: 1
    }];
    const current = positionRef.current;
    const distance = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    const nearest = corners.reduce((closest, corner) => distance(current, corner) < distance(current, closest) ? corner : closest);
    setIsSnapping(true);
    setPosition({
      x: nearest.x,
      y: nearest.y
    });
    snappedCornerOffsetRef.current = {
      dx: nearest.dx,
      dy: nearest.dy
    };
    if (lastCornerRef.current !== nearest.name) {
      onCornerChange === null || onCornerChange === void 0 || onCornerChange(nearest.name);
      lastCornerRef.current = nearest.name;
    }
    setTimeout(() => setIsSnapping(false), 300);
  };
  return (0, _jsxRuntime.jsx)("div", {
    ref: elementRef,
    style: _objectSpread(_objectSpread({}, style), {}, {
      position: 'fixed',
      left: position.x,
      top: position.y,
      cursor: isDragging ? 'grabbing' : 'grab',
      transition: isSnapping ? 'left 0.3s ease, top 0.3s ease, transform 0.2s ease' : 'transform 0.2s ease',
      transform: isDragging ? 'scale(1.02)' : 'scale(1)'
    }),
    onMouseDown: handleMouseDown,
    onTouchStart: handleTouchStart,
    children: children
  });
};
var _default = exports["default"] = Draggable;

/***/ }),

/***/ 6497:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3697);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var icons = _interopRequireWildcard(__webpack_require__(6746));
var _jsxRuntime = __webpack_require__(6416);
const _excluded = ["name"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Icon = _ref => {
  let {
      name
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread({
    "aria-hidden": "true",
    style: {
      display: 'inline-block'
    }
  }, props), {}, {
    children: icons[name]
  }));
};
var _default = exports["default"] = Icon;

/***/ }),

/***/ 341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(8637);
var _IconButtonModule = _interopRequireDefault(__webpack_require__(4556));
var _jsxRuntime = __webpack_require__(6416);
const _excluded = ["children", "className", "ariaLabel", "title"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const IconButton = _ref => {
  let {
      children,
      className,
      ariaLabel,
      title
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("button", _objectSpread(_objectSpread({
    className: (0, _lite.clsx)(_IconButtonModule.default.base, className),
    "aria-label": ariaLabel,
    title: ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : title
  }, props), {}, {
    children: children
  }));
};
var _default = exports["default"] = IconButton;

/***/ }),

/***/ 4287:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(8637);
var _Locale = _interopRequireDefault(__webpack_require__(7988));
var _ModalModule = _interopRequireDefault(__webpack_require__(2704));
var _jsxRuntime = __webpack_require__(6416);
const _excluded = ["children", "className"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Modal = _ref => {
  let {
      children,
      className
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread({
    className: _ModalModule.default.container,
    role: "dialog",
    "aria-modal": "true"
  }, props), {}, {
    children: (0, _jsxRuntime.jsx)("section", {
      className: (0, _lite.clsx)(_ModalModule.default.content, className),
      dir: _Locale.default.direction(),
      children: children
    })
  }));
};
var _default = exports["default"] = Modal;

/***/ }),

/***/ 8670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lite = __webpack_require__(8637);
var _chevronDown = _interopRequireDefault(__webpack_require__(2098));
var _SelectModule = _interopRequireDefault(__webpack_require__(9417));
var _jsxRuntime = __webpack_require__(6416);
const _excluded = ["children", "iconUrl", "className", "ariaLabel", "style"];
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const Select = _ref => {
  let {
      children,
      iconUrl,
      className,
      ariaLabel,
      style
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  const iconStyle = iconUrl ? {
    backgroundImage: "url(\"".concat(iconUrl, "\"),url(\"").concat(_chevronDown.default, "\")"),
    backgroundPosition: 'left 4px center,right 4px center',
    padding: '8px 24px 8px 24px'
  } : {
    backgroundImage: "url(\"".concat(_chevronDown.default, "\")")
  };
  const mergedStyle = _objectSpread(_objectSpread({}, iconStyle), style);
  return (0, _jsxRuntime.jsx)("select", _objectSpread(_objectSpread({
    className: (0, _lite.clsx)(_SelectModule.default.base, !iconUrl && _SelectModule.default.noIcon, className),
    "aria-label": ariaLabel,
    style: mergedStyle
  }, props), {}, {
    children: children
  }));
};
var _default = exports["default"] = Select;

/***/ }),

/***/ 2973:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
const _excluded = ["children"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
const SelectOption = _ref => {
  let {
      children
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  return (0, _jsxRuntime.jsx)("option", _objectSpread(_objectSpread({}, props), {}, {
    children: children
  }));
};
var _default = exports["default"] = SelectOption;

/***/ }),

/***/ 2996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Button", ({
  enumerable: true,
  get: function () {
    return _Button.default;
  }
}));
Object.defineProperty(exports, "Draggable", ({
  enumerable: true,
  get: function () {
    return _Draggable.default;
  }
}));
Object.defineProperty(exports, "Icon", ({
  enumerable: true,
  get: function () {
    return _Icon.default;
  }
}));
Object.defineProperty(exports, "IconButton", ({
  enumerable: true,
  get: function () {
    return _IconButton.default;
  }
}));
Object.defineProperty(exports, "Modal", ({
  enumerable: true,
  get: function () {
    return _Modal.default;
  }
}));
Object.defineProperty(exports, "Select", ({
  enumerable: true,
  get: function () {
    return _Select.default;
  }
}));
Object.defineProperty(exports, "SelectOption", ({
  enumerable: true,
  get: function () {
    return _SelectOption.default;
  }
}));
var _Button = _interopRequireDefault(__webpack_require__(7410));
var _Draggable = _interopRequireDefault(__webpack_require__(5029));
var _Icon = _interopRequireDefault(__webpack_require__(6497));
var _IconButton = _interopRequireDefault(__webpack_require__(341));
var _Modal = _interopRequireDefault(__webpack_require__(4287));
var _Select = _interopRequireDefault(__webpack_require__(8670));
var _SelectOption = _interopRequireDefault(__webpack_require__(2973));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 6438:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _hooks = __webpack_require__(16);
var _mountComponent = __webpack_require__(9103);
var _HighlightOverlayModule = _interopRequireDefault(__webpack_require__(9887));
var _jsxRuntime = __webpack_require__(6416);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const DEFAULT_BORDER_RADIUS = '4px';
const getOverlayPosition = element => {
  // Calculate the element's position and size
  const rect = element.getBoundingClientRect();
  const scrollTop = document.documentElement.scrollTop;
  const scrollLeft = document.documentElement.scrollLeft;
  const top = rect.top + scrollTop;
  const left = rect.left + scrollLeft;
  const width = rect.width;
  const height = rect.height;
  if (!width || !height) return null;

  // Get the element's border radius so that we can apply the same radius
  // to the highlight area. For elements without a border radius, we use a
  // default value to avoid showing sharp corners.
  const computedStyles = window.getComputedStyle(element);
  let borderRadius = computedStyles.borderRadius || computedStyles.borderTopLeftRadius;
  if (borderRadius === '0px') {
    borderRadius = DEFAULT_BORDER_RADIUS;
  }

  // Calculate padding to achieve 6px spacing on all sides
  const paddedX = (width + 6) / width;
  const paddedY = (height + 6) / height;
  return {
    top,
    left,
    width,
    height,
    borderRadius,
    paddedX,
    paddedY
  };
};
const HighlightOverlayComponent = _ref => {
  let {
    targetElement
  } = _ref;
  const overlayRef = (0, _hooks.useRef)();
  const scrollEventDisabledRef = (0, _hooks.useRef)(false);
  const updatePosition = (0, _hooks.useCallback)(() => {
    if (!targetElement) return;
    const position = getOverlayPosition(targetElement);
    if (!position || !overlayRef.current) return;
    const {
      top,
      left,
      width,
      height,
      borderRadius,
      paddedX,
      paddedY
    } = position;

    // Update the overlay position and size and show it
    requestAnimationFrame(() => {
      overlayRef.current.style.width = "".concat(width, "px");
      overlayRef.current.style.height = "".concat(height, "px");
      overlayRef.current.style.top = "".concat(top, "px");
      overlayRef.current.style.left = "".concat(left, "px");
      overlayRef.current.style.borderRadius = borderRadius;
      overlayRef.current.style.setProperty('--cbio-padded-x', paddedX);
      overlayRef.current.style.setProperty('--cbio-padded-y', paddedY);
    });
  }, [targetElement]);
  const scrollElementIntoView = (0, _hooks.useCallback)(() => {
    if (!targetElement) return;
    scrollEventDisabledRef.current = true;
    targetElement.scrollIntoView({
      behavior: 'smooth',
      block: 'center',
      inline: 'center'
    });
    setTimeout(() => {
      scrollEventDisabledRef.current = false;
      updatePosition();
    }, 100);
  }, [targetElement, updatePosition]);
  (0, _hooks.useEffect)(() => {
    scrollElementIntoView();
  }, [scrollElementIntoView]);

  // Set the initial position
  (0, _hooks.useEffect)(() => {
    updatePosition();
  }, [updatePosition]);
  (0, _hooks.useEffect)(() => {
    let animationTimeout;
    const reposition = () => {
      if (scrollEventDisabledRef.current) return;
      if (overlayRef.current) {
        // Temporarily disable animations during resize or scroll so that
        // the highlight stays in position and doesn't jump around
        requestAnimationFrame(() => {
          overlayRef.current.classList.add(_HighlightOverlayModule.default.disableAnimations);
        });
        updatePosition();

        // Restore animations
        requestAnimationFrame(() => {
          overlayRef.current.classList.remove(_HighlightOverlayModule.default.disableAnimations);
        });
      }
    };
    window.addEventListener('resize', reposition);
    window.addEventListener('scroll', reposition, {
      passive: true,
      capture: true
    });
    return () => {
      window.removeEventListener('resize', reposition);
      window.removeEventListener('scroll', reposition, {
        passive: true,
        capture: true
      });
      clearTimeout(animationTimeout);
    };
  }, [updatePosition, targetElement]);
  (0, _hooks.useEffect)(() => {
    let mutationObserver;
    if (targetElement) {
      mutationObserver = new MutationObserver(() => {
        const isInDOM = targetElement.isConnected;
        const isVisible = targetElement.checkVisibility ? targetElement.checkVisibility() : true;
        overlayRef.current.style.display = isInDOM && isVisible ? 'block' : 'none';
      });

      // Detect when the element styles change
      mutationObserver.observe(targetElement, {
        attributes: true,
        attributeFilter: ['style', 'class']
      });
      // Detect when the element is removed from the DOM
      mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
    return () => {
      var _mutationObserver;
      (_mutationObserver = mutationObserver) === null || _mutationObserver === void 0 || _mutationObserver.disconnect();
    };
  }, [targetElement]);
  return (0, _jsxRuntime.jsx)("div", {
    className: _HighlightOverlayModule.default.overlay,
    ref: overlayRef
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
class HighlightOverlay {
  constructor() {
    _classPrivateFieldInitSpec(this, _mountHandle, null);
    _defineProperty(this, "update", element => {
      if (!_classPrivateFieldGet(_mountHandle, this)) {
        _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(HighlightOverlayComponent, {
          targetElement: element
        }, false, true));
      } else {
        _classPrivateFieldGet(_mountHandle, this).rerender({
          targetElement: element
        });
      }
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet2;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      _classPrivateFieldSet(_mountHandle, this, null);
    });
  }
}
var _default = exports["default"] = new HighlightOverlay();

/***/ }),

/***/ 7527:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
var _dom = __webpack_require__(3532);
var _hooks = __webpack_require__(16);
var _mountComponent = __webpack_require__(9103);
var _TooltipModule = _interopRequireDefault(__webpack_require__(6000));
var _jsxRuntime = __webpack_require__(6416);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const getUpdatedPositions = async (targetElement, tooltipElement, arrowElement) => {
  if (!targetElement || !tooltipElement || !arrowElement) return null;
  const {
    x,
    y,
    placement,
    middlewareData
  } = await (0, _dom.computePosition)(targetElement, tooltipElement, {
    placement: 'top',
    middleware: [(0, _dom.offset)(12), (0, _dom.flip)(), (0, _dom.shift)({
      padding: 8
    }), (0, _dom.arrow)({
      element: arrowElement
    }), (0, _dom.hide)()]
  });
  const {
    x: arrowX,
    y: arrowY
  } = middlewareData.arrow;
  const isVisible = !middlewareData.hide.referenceHidden;
  const staticSide = {
    top: 'bottom',
    right: 'left',
    bottom: 'top',
    left: 'right'
  }[placement.split('-')[0]];
  return {
    tooltip: {
      x,
      y
    },
    arrow: {
      x: arrowX,
      y: arrowY,
      staticSide
    },
    isVisible
  };
};
const TooltipTitle = _ref => {
  let {
    title
  } = _ref;
  return (0, _jsxRuntime.jsx)("div", {
    className: _TooltipModule.default.tooltipTitle,
    children: title
  });
};
const TooltipArrow = _ref2 => {
  let {
    arrowRef
  } = _ref2;
  return (0, _jsxRuntime.jsx)("div", {
    className: _TooltipModule.default.tooltipArrow,
    ref: arrowRef
  });
};
const TooltipComponent = _ref3 => {
  let {
    targetElement,
    title
  } = _ref3;
  const tooltipRef = (0, _hooks.useRef)();
  const arrowRef = (0, _hooks.useRef)();
  (0, _hooks.useEffect)(() => {
    var _tooltipRef$current;
    const updatePosition = async () => {
      const positions = await getUpdatedPositions(targetElement, tooltipRef.current, arrowRef.current);
      if (!positions) return;
      tooltipRef.current.style.left = "".concat(positions.tooltip.x, "px");
      tooltipRef.current.style.top = "".concat(positions.tooltip.y, "px");
      tooltipRef.current.style.display = positions.isVisible ? 'block' : 'none';
      arrowRef.current.style.left = positions.arrow.x ? "".concat(positions.arrow.x, "px") : '';
      arrowRef.current.style.top = positions.arrow.y ? "".concat(positions.arrow.y, "px") : '';
      arrowRef.current.style[positions.arrow.staticSide] = '-4px';
    };
    let cleanup;
    if (targetElement) {
      cleanup = (0, _dom.autoUpdate)(targetElement, tooltipRef.current, updatePosition);
    }
    (_tooltipRef$current = tooltipRef.current) === null || _tooltipRef$current === void 0 || _tooltipRef$current.classList.add(_TooltipModule.default.tooltipVisible);
    return () => {
      var _cleanup;
      (_cleanup = cleanup) === null || _cleanup === void 0 || _cleanup();
    };
  }, [targetElement]);
  return (0, _jsxRuntime.jsxs)("div", {
    className: _TooltipModule.default.tooltip,
    role: "tooltip",
    "aria-live": "polite",
    ref: tooltipRef,
    children: [(0, _jsxRuntime.jsx)(TooltipTitle, {
      title: title
    }), (0, _jsxRuntime.jsx)(TooltipArrow, {
      arrowRef: arrowRef
    })]
  });
};
var _mountHandle = /*#__PURE__*/new WeakMap();
class Tooltip {
  constructor() {
    _classPrivateFieldInitSpec(this, _mountHandle, null);
    _defineProperty(this, "update", (element, title) => {
      if (!_classPrivateFieldGet(_mountHandle, this)) {
        _classPrivateFieldSet(_mountHandle, this, (0, _mountComponent.mountComponent)(TooltipComponent, {
          targetElement: element,
          title
        }, true, true));
      } else {
        _classPrivateFieldGet(_mountHandle, this).rerender({
          targetElement: element,
          title
        });
      }
    });
    _defineProperty(this, "hide", () => {
      var _classPrivateFieldGet2;
      (_classPrivateFieldGet2 = _classPrivateFieldGet(_mountHandle, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.unmount();
      _classPrivateFieldSet(_mountHandle, this, null);
    });
  }
}
var _default = exports["default"] = new Tooltip();

/***/ }),

/***/ 4364:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useMediaDevices = void 0;
__webpack_require__(3697);
var _hooks = __webpack_require__(16);
const PERMISSION = {
  GRANTED: 'granted',
  DENIED: 'denied',
  PROMPT: 'prompt'
};
const isPermission = permission => ({
  granted: permission === PERMISSION.GRANTED,
  denied: permission === PERMISSION.DENIED,
  prompt: permission === PERMISSION.PROMPT
});
const useMediaDevices = () => {
  const [audioInputDevices, setAudioInputDevices] = (0, _hooks.useState)([]);
  const [audioOutputDevices, setAudioOutputDevices] = (0, _hooks.useState)([]);
  const [videoInputDevices, setVideoInputDevices] = (0, _hooks.useState)([]);
  const [audioPermissionState, setAudioPermissionState] = (0, _hooks.useState)(PERMISSION.PROMPT);
  const [videoPermissionState, setVideoPermissionState] = (0, _hooks.useState)(PERMISSION.PROMPT);
  const audioPermission = (0, _hooks.useMemo)(() => isPermission(audioPermissionState), [audioPermissionState]);
  const videoPermission = (0, _hooks.useMemo)(() => isPermission(videoPermissionState), [videoPermissionState]);
  const audioPermissionRef = (0, _hooks.useRef)(null);
  const videoPermissionRef = (0, _hooks.useRef)(null);
  const updateDeviceLists = (0, _hooks.useCallback)(async () => {
    if (!navigator.mediaDevices) return;
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = [];
    const audioOutputs = [];
    const videoInputs = [];
    devices.forEach(device => {
      if (!device.deviceId) return;
      if (device.kind === 'audioinput') audioInputs.push(device);
      if (device.kind === 'audiooutput') audioOutputs.push(device);
      if (device.kind === 'videoinput') videoInputs.push(device);
    });
    setAudioInputDevices(audioInputs);
    setAudioOutputDevices(audioOutputs);
    setVideoInputDevices(videoInputs);
  }, []);
  const onAudioPermissionChange = () => setAudioPermissionState(audioPermissionRef.current.state);
  const onVideoPermissionChange = () => setVideoPermissionState(videoPermissionRef.current.state);
  const updatePermissions = (0, _hooks.useCallback)(async () => {
    try {
      var _audioPermissionRef$c, _videoPermissionRef$c;
      (_audioPermissionRef$c = audioPermissionRef.current) === null || _audioPermissionRef$c === void 0 || _audioPermissionRef$c.removeEventListener('change', onAudioPermissionChange);
      audioPermissionRef.current = await navigator.permissions.query({
        name: 'microphone'
      });
      audioPermissionRef.current.addEventListener('change', onAudioPermissionChange);
      (_videoPermissionRef$c = videoPermissionRef.current) === null || _videoPermissionRef$c === void 0 || _videoPermissionRef$c.removeEventListener('change', onVideoPermissionChange);
      videoPermissionRef.current = await navigator.permissions.query({
        name: 'camera'
      });
      videoPermissionRef.current.addEventListener('change', onVideoPermissionChange);
      setAudioPermissionState(audioPermissionRef.current.state);
      setVideoPermissionState(videoPermissionRef.current.state);
    } catch (err) {
      console.warn('CobrowseIO: Failed to get permissions', err);
      setAudioPermissionState(PERMISSION.PROMPT);
      setVideoPermissionState(PERMISSION.PROMPT);
    }
  }, []);
  (0, _hooks.useEffect)(() => {
    updatePermissions();
  }, [updatePermissions]);
  (0, _hooks.useEffect)(() => {
    var _navigator$mediaDevic;
    (_navigator$mediaDevic = navigator.mediaDevices) === null || _navigator$mediaDevic === void 0 || _navigator$mediaDevic.addEventListener('devicechange', updateDeviceLists);
    updateDeviceLists();
    return () => {
      var _navigator$mediaDevic2;
      (_navigator$mediaDevic2 = navigator.mediaDevices) === null || _navigator$mediaDevic2 === void 0 || _navigator$mediaDevic2.removeEventListener('devicechange', updateDeviceLists);
    };
  }, [updateDeviceLists]);
  (0, _hooks.useEffect)(() => {
    updateDeviceLists();
  }, [audioPermissionState, videoPermissionState, updateDeviceLists]);
  return {
    audioInputDevices,
    audioOutputDevices,
    videoInputDevices,
    audioPermission,
    videoPermission,
    updateDeviceLists,
    updatePermissions
  };
};
exports.useMediaDevices = useMediaDevices;

/***/ }),

/***/ 4909:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useSpeaking = void 0;
__webpack_require__(3697);
var _hooks = __webpack_require__(16);
var _NoiseAnalyser = _interopRequireDefault(__webpack_require__(7688));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const SPEAKING_VOLUME_THRESHOLD = 15;
const useSpeaking = participant => {
  const [isSpeaking, setIsSpeaking] = (0, _hooks.useState)(false);
  const noiseAnalyser = (0, _hooks.useRef)(null);
  (0, _hooks.useEffect)(() => {
    const onNoiseUpdated = hasNoise => setIsSpeaking(hasNoise);
    const handleTrackChange = () => {
      if (participant.hasAudio && !noiseAnalyser.current) {
        noiseAnalyser.current = new _NoiseAnalyser.default(participant.stream, SPEAKING_VOLUME_THRESHOLD);
        noiseAnalyser.current.on('noise.updated', onNoiseUpdated);
      }
      if (!participant.hasAudio && noiseAnalyser.current) {
        noiseAnalyser.current.off('noise.updated', onNoiseUpdated);
        noiseAnalyser.current.destroy();
        noiseAnalyser.current = null;
        setIsSpeaking(false);
      }
    };
    participant.on('track.added', handleTrackChange);
    participant.on('track.removed', handleTrackChange);
    handleTrackChange();
    return () => {
      participant.off('track.removed', handleTrackChange);
      participant.off('track.added', handleTrackChange);
      if (noiseAnalyser.current) {
        noiseAnalyser.current.off('noise.updated', onNoiseUpdated);
        noiseAnalyser.current.destroy();
        noiseAnalyser.current = null;
      }
    };
  }, [participant]);
  return isSpeaking;
};
exports.useSpeaking = useSpeaking;

/***/ }),

/***/ 8898:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"
  })]
});

/***/ }),

/***/ 9515:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsx)("svg", {
  height: "100%",
  viewBox: "0 0 25 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: (0, _jsxRuntime.jsx)("path", {
    d: "M21.5 12V15C21.5 15.2652 21.3946 15.5196 21.2071 15.7071C21.0196 15.8946 20.7652 16 20.5 16H4.5C4.23478 16 3.98043 15.8946 3.79289 15.7071C3.60536 15.5196 3.5 15.2652 3.5 15L3.5 5C3.5 4.73478 3.60536 4.48043 3.79289 4.29289C3.98043 4.10536 4.23478 4 4.5 4L13.5 4M7.5 20H17.5M9.5 16V20M15.5 16V20M17.5 8L21.5 4M17.5 4L21.5 8",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  })
});

/***/ }),

/***/ 7008:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M5 10a7 7 0 0 0 14 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M8 21l8 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 17l0 4"
  })]
});

/***/ }),

/***/ 5239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M3 3l18 18"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M8 21l8 0"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M12 17l0 4"
  })]
});

/***/ }),

/***/ 8930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsx)("svg", {
  height: "100%",
  viewBox: "0 0 25 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: (0, _jsxRuntime.jsx)("path", {
    d: "M23.1068 13.9142L20.2784 16.7426L15.3286 14.6213L16.0357 11.7929C13.7429 11.0147 11.2574 11.0147 8.96465 11.7929L9.67175 14.6213L4.72201 16.7426L1.89358 13.9142C1.51851 13.5391 1.30779 13.0304 1.30779 12.5C1.30779 11.9696 1.51851 11.4609 1.89358 11.0858C4.81944 8.49517 8.59225 7.06493 12.5002 7.06493C16.4081 7.06493 20.1809 8.49517 23.1068 11.0858C23.4819 11.4609 23.6926 11.9696 23.6926 12.5C23.6926 13.0304 23.4819 13.5391 23.1068 13.9142Z",
    stroke: "#F5F6FB",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  })
});

/***/ }),

/***/ 505:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M15 10l4.553 -2.276a1 1 0 0 1 1.447 .894v6.764a1 1 0 0 1 -1.447 .894l-4.553 -2.276v-4z"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M3 6m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"
  })]
});

/***/ }),

/***/ 4032:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M3 3l18 18"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M15 11v-1l4.553 -2.276a1 1 0 0 1 1.447 .894v6.764a1 1 0 0 1 -.675 .946"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M10 6h3a2 2 0 0 1 2 2v3m0 4v1a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-8a2 2 0 0 1 2 -2h1"
  })]
});

/***/ }),

/***/ 3894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _jsxRuntime = __webpack_require__(6416);
var _default = exports["default"] = (0, _jsxRuntime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "100%",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  children: [(0, _jsxRuntime.jsx)("path", {
    stroke: "none",
    d: "M0 0h24v24H0z",
    fill: "none"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M15 8a5 5 0 0 1 0 8"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M17.7 5a9 9 0 0 1 0 14"
  }), (0, _jsxRuntime.jsx)("path", {
    d: "M6 15h-2a1 1 0 0 1 -1 -1v-4a1 1 0 0 1 1 -1h2l3.5 -4.5a.8 .8 0 0 1 1.5 .5v14a.8 .8 0 0 1 -1.5 .5l-3.5 -4.5"
  })]
});

/***/ }),

/***/ 6746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "DotsVertical", ({
  enumerable: true,
  get: function () {
    return _DotsVertical.default;
  }
}));
Object.defineProperty(exports, "EndSession", ({
  enumerable: true,
  get: function () {
    return _EndSession.default;
  }
}));
Object.defineProperty(exports, "Microphone", ({
  enumerable: true,
  get: function () {
    return _Microphone.default;
  }
}));
Object.defineProperty(exports, "MicrophoneOff", ({
  enumerable: true,
  get: function () {
    return _MicrophoneOff.default;
  }
}));
Object.defineProperty(exports, "Phone", ({
  enumerable: true,
  get: function () {
    return _Phone.default;
  }
}));
Object.defineProperty(exports, "Video", ({
  enumerable: true,
  get: function () {
    return _Video.default;
  }
}));
Object.defineProperty(exports, "VideoOff", ({
  enumerable: true,
  get: function () {
    return _VideoOff.default;
  }
}));
Object.defineProperty(exports, "Volume", ({
  enumerable: true,
  get: function () {
    return _Volume.default;
  }
}));
var _DotsVertical = _interopRequireDefault(__webpack_require__(8898));
var _EndSession = _interopRequireDefault(__webpack_require__(9515));
var _Microphone = _interopRequireDefault(__webpack_require__(7008));
var _MicrophoneOff = _interopRequireDefault(__webpack_require__(5239));
var _Phone = _interopRequireDefault(__webpack_require__(8930));
var _Video = _interopRequireDefault(__webpack_require__(505));
var _VideoOff = _interopRequireDefault(__webpack_require__(4032));
var _Volume = _interopRequireDefault(__webpack_require__(3894));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 3035:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AnnotationOverlay", ({
  enumerable: true,
  get: function () {
    return _AnnotationOverlay.default;
  }
}));
Object.defineProperty(exports, "CallParticipants", ({
  enumerable: true,
  get: function () {
    return _CallParticipants.default;
  }
}));
Object.defineProperty(exports, "ConsentDialog", ({
  enumerable: true,
  get: function () {
    return _ConsentDialog.default;
  }
}));
Object.defineProperty(exports, "Highlight", ({
  enumerable: true,
  get: function () {
    return _Highlight.default;
  }
}));
Object.defineProperty(exports, "LaserOverlay", ({
  enumerable: true,
  get: function () {
    return _LaserOverlay.default;
  }
}));
Object.defineProperty(exports, "MediaPreview", ({
  enumerable: true,
  get: function () {
    return _MediaPreview.default;
  }
}));
Object.defineProperty(exports, "RemoteCursor", ({
  enumerable: true,
  get: function () {
    return _RemoteCursor.default;
  }
}));
Object.defineProperty(exports, "SessionStateOverlay", ({
  enumerable: true,
  get: function () {
    return _SessionStateOverlay.default;
  }
}));
__webpack_require__(2143);
var _AnnotationOverlay = _interopRequireDefault(__webpack_require__(3024));
var _LaserOverlay = _interopRequireDefault(__webpack_require__(6162));
var _RemoteCursor = _interopRequireDefault(__webpack_require__(3291));
var _SessionStateOverlay = _interopRequireDefault(__webpack_require__(4340));
var _ConsentDialog = _interopRequireDefault(__webpack_require__(5573));
var _Highlight = _interopRequireDefault(__webpack_require__(6575));
var _CallParticipants = _interopRequireDefault(__webpack_require__(3807));
var _MediaPreview = _interopRequireDefault(__webpack_require__(4037));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 7487:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(9199);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _convertLinkToRegExp = __webpack_require__(48);
var _navigation = __webpack_require__(9715);
var _Navigation = __webpack_require__(4661);
var _UniversalProxy = _interopRequireDefault(__webpack_require__(8619));
var _iframes = _interopRequireDefault(__webpack_require__(7966));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _universalLinkRegExps = /*#__PURE__*/new WeakMap();
var _universalProxy = /*#__PURE__*/new WeakMap();
var _loadUniversalDocument = /*#__PURE__*/new WeakMap();
var _loadForbiddenDocument = /*#__PURE__*/new WeakMap();
class UniversalHandler extends _navigation.NavigationHandler {
  constructor(session, delegate) {
    var _delegate$universalLi;
    super();
    _classPrivateFieldInitSpec(this, _universalLinkRegExps, void 0);
    _classPrivateFieldInitSpec(this, _universalProxy, void 0);
    _classPrivateFieldInitSpec(this, _loadUniversalDocument, (url, target, windowFeatures, options) => {
      const {
        document: universalDocument
      } = options;
      const universalProxyFrameName = _classPrivateFieldGet(_universalProxy, this).createUniversalProxyFrameName();
      const universalProxyUrl = _classPrivateFieldGet(_universalProxy, this).createUniversalProxyUrl(url, universalProxyFrameName);
      const universalProxyIFrame = _classPrivateFieldGet(_universalProxy, this).createUniversalProxyIFrame(universalProxyUrl, universalProxyFrameName);
      universalDocument.load(universalProxyUrl, target, windowFeatures, {
        element: universalProxyIFrame,
        type: this.type
      });
      const onDocument = (_ref, _ref2) => {
        let {
          handle,
          document: {
            url,
            icon,
            title,
            isLoading,
            isBlocked
          }
        } = _ref;
        let {
          trusted,
          iframe
        } = _ref2;
        if (handle) return;
        if (!trusted) return;
        if (iframe !== universalProxyIFrame) return;
        universalDocument.url = url;
        universalDocument.icon = icon;
        universalDocument.title = title;
        universalDocument.isLoading = isLoading;
        universalDocument.isBlocked = isBlocked;
      };
      _iframes.default.on('document', onDocument);
      universalDocument.once('closed', () => {
        _iframes.default.off('document', onDocument);
      });
    });
    _classPrivateFieldInitSpec(this, _loadForbiddenDocument, (url, target, windowFeatures, options) => {
      const {
        document: fobiddenDocument
      } = options;
      const element = document.createElement('div');
      element.style.width = '100%';
      element.style.height = '100%';
      element.style.backgroundColor = 'black';
      fobiddenDocument.load(url, target, windowFeatures, {
        element,
        type: this.type
      });
      fobiddenDocument.isLoading = false;
      fobiddenDocument.isBlocked = true;
    });
    _classPrivateFieldSet(_universalLinkRegExps, this, ((_delegate$universalLi = delegate.universalLinks) === null || _delegate$universalLi === void 0 ? void 0 : _delegate$universalLi.map(_convertLinkToRegExp.convertLinkToRegExp)) || []);
    _classPrivateFieldSet(_universalProxy, this, new _UniversalProxy.default(session, delegate.api, delegate.version));
  }
  get type() {
    return _Navigation.NAVIGATION_TYPE.UNIVERSAL;
  }
  shouldHandleEvent(e) {
    // only watch for events that have started bubbling
    if (e.eventPhase === Event.CAPTURING_PHASE) return false;
    // we need to honor the defaultPrevented flag for Universal
    // navigations as this can cause a double navigation to occur
    return !e.defaultPrevented;
  }
  shouldHandle(u) {
    const urlWithoutQueryParams = new URL(u, window.location.origin);
    urlWithoutQueryParams.search = '';
    return _classPrivateFieldGet(_universalLinkRegExps, this).some(regExp => regExp.test(urlWithoutQueryParams));
  }
  handle(url, target, windowFeatures, options) {
    const loadDocument = this.shouldHandle(url) ? _classPrivateFieldGet(_loadUniversalDocument, this) : _classPrivateFieldGet(_loadForbiddenDocument, this);
    loadDocument(url, target, windowFeatures, options);
    return {
      document: options.document
    };
  }
}
exports["default"] = UniversalHandler;

/***/ }),

/***/ 1191:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class UniversalHooks {
  constructor() {
    _defineProperty(this, "proxify", url => url);
    _defineProperty(this, "unproxify", url => url);
    _defineProperty(this, "inUniversalProxy", false);
  }
}
var _default = exports["default"] = new UniversalHooks();

/***/ }),

/***/ 8619:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _protected = _interopRequireDefault(__webpack_require__(7609));
var _proxy = __webpack_require__(9147);
var _randomString = _interopRequireDefault(__webpack_require__(8981));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _session = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _sdkVersion = /*#__PURE__*/new WeakMap();
class UniversalProxy {
  constructor(session, api, sdkVersion) {
    _classPrivateFieldInitSpec(this, _session, void 0);
    _classPrivateFieldInitSpec(this, _api, void 0);
    _classPrivateFieldInitSpec(this, _sdkVersion, void 0);
    _defineProperty(this, "createUniversalProxyFrameName", () => "cbioUniversalFrame-".concat((0, _randomString.default)(5)));
    _defineProperty(this, "createUniversalProxyUrl", (url, frameName) => {
      const proxyToken = _classPrivateFieldGet(_session, this)[_protected.default].proxyToken();
      const sessionProxyUrl = _classPrivateFieldGet(_session, this)[_protected.default].proxyUrl();
      const proxyUrl = new URL(sessionProxyUrl, _classPrivateFieldGet(_api, this));
      const queryParams = {
        parent_origin: window.location.origin,
        proxy_path: proxyUrl.pathname,
        sdk_version: _classPrivateFieldGet(_sdkVersion, this),
        frame_name: frameName
      };
      const urlRewriter = new _proxy.URLRewriter(proxyUrl, _proxy.PROXY_PREFIX.UNIVERSAL, proxyToken, window.location, queryParams);
      const targetUrl = urlRewriter.proxify(url);
      return targetUrl;
    });
    _defineProperty(this, "createUniversalProxyIFrame", (src, name) => {
      const iframe = document.createElement('iframe');

      // allow WebAuthn within the iframe
      iframe.allow = 'publickey-credentials-get *';
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.backgroundColor = 'white';
      iframe.style.border = 'none';
      iframe.src = src;
      iframe.name = name;
      return iframe;
    });
    _classPrivateFieldSet(_session, this, session);
    _classPrivateFieldSet(_api, this, api);
    _classPrivateFieldSet(_sdkVersion, this, sdkVersion);
  }
}
exports["default"] = UniversalProxy;

/***/ }),

/***/ 1834:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "UniversalHandler", ({
  enumerable: true,
  get: function () {
    return _UniversalHandler.default;
  }
}));
Object.defineProperty(exports, "UniversalProxy", ({
  enumerable: true,
  get: function () {
    return _UniversalProxy.default;
  }
}));
var _UniversalProxy = _interopRequireDefault(__webpack_require__(8619));
var _UniversalHandler = _interopRequireDefault(__webpack_require__(7487));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }

/***/ }),

/***/ 9516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _debug = _interopRequireDefault(__webpack_require__(1227));
var _storage = _interopRequireDefault(__webpack_require__(6542));
var _rest = __webpack_require__(492);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const debug = (0, _debug.default)('cbio.VirtualAgent.VirtualAgentEmbed');
const storageKeyPrefix = '_cobrowse_va_conversation_';

/**
 * How long the embed data can be cached in local storage.
 * This depends on how long the signed urls are valid.
 * e.g. ElevenLabs is only valid for 15 minutes
 */
const conversationTtlMillis = 13 * 60 * 1000;

/** The maximum number of seconds to wait when retrying a failed embed request */
const expBackoffLimitSeconds = 15 * 60;
class VirtualAgentEmbed extends _rest.RESTResource {
  constructor() {
    super();
    _defineProperty(this, "url", () => {
      return new URL("api/1/virtualagents/".concat(encodeURIComponent(this.slug()), "/embed"), VirtualAgentEmbed.api).toString();
    });
    _defineProperty(this, "slug", () => {
      return this.field('slug');
    });
    _defineProperty(this, "type", () => {
      return this.field('type');
    });
    /**
     * Get the provider-specific data that is needed to embed the agent widget for this specific
     * provider. This data-structure is not known by the interface at this level, however its model
     * is known between the provider impl in the API and the provider impl in the JS SDK.
     *
     * @returns {Record<string, unknown>}
     */
    _defineProperty(this, "data", () => {
      return this.field('data');
    });
    debug('constructed');
  }
  static async load(delegate, slug) {
    var _store$getItem;
    const agent = new VirtualAgentEmbed();
    const store = (0, _storage.default)(delegate.license);
    const storageKey = "".concat(storageKeyPrefix).concat(slug);
    const {
      iat,
      resource,
      attempts = 0
    } = (_store$getItem = store.getItem(storageKey)) !== null && _store$getItem !== void 0 ? _store$getItem : {};
    if (resource && iat && iat > Date.now() - conversationTtlMillis) {
      debug('loaded agent embed data from storage');
      agent.updateResource(resource);
      return agent;
    }
    if (!resource && attempts) {
      const nextRetry = getNextRetryTime(iat, attempts);
      if (nextRetry > Date.now()) {
        console.warn("Not loading virtual agent embed data, next retry at: ".concat(new Date(nextRetry)));
        return;
      }
    }
    try {
      debug('loading agent embed data from the API');
      agent.updateResource({
        slug
      });
      await agent.fetch();
    } catch (err) {
      const nextRetry = getNextRetryTime(Date.now(), attempts);
      console.error("Unable to resolve virtual agent embed data. Next retry at ".concat(new Date(nextRetry)), err);
      store.setItem(storageKey, {
        iat: Date.now(),
        attempts: attempts + 1
      });
      return;
    }
    store.setItem(storageKey, {
      resource: agent.resource,
      iat: Date.now()
    });
    return agent;
  }
}
exports["default"] = VirtualAgentEmbed;
function getNextRetryTime(iat, attempts) {
  const backoffSeconds = Math.min(Math.pow(2, attempts), expBackoffLimitSeconds);
  const backoffMs = backoffSeconds * 1000;
  return iat + backoffMs;
}

/***/ }),

/***/ 3177:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.initializeVirtualAgent = initializeVirtualAgent;
__webpack_require__(3697);
var _VirtualAgentEmbed = _interopRequireDefault(__webpack_require__(9516));
var _debug = _interopRequireDefault(__webpack_require__(1227));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('cbio.VirtualAgent');
async function initializeVirtualAgent(agentSlug, delegate) {
  debug('Loading virtual agent %s', agentSlug);
  const embed = await _VirtualAgentEmbed.default.load(delegate, agentSlug);
  if ((embed === null || embed === void 0 ? void 0 : embed.type()) === 'elevenlabs') {
    // Dynamically import the widget logic so it doesn't get bundled into the main SDK
    const {
      loadElevenLabsWidget
    } = await __webpack_require__.e(/* import() | elevenlabs */ 660).then(__webpack_require__.bind(__webpack_require__, 1475));
    await loadElevenLabsWidget(embed, delegate);
  }
}

/***/ }),

/***/ 4162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ClientTracker = void 0;
__webpack_require__(3697);
var _events = _interopRequireDefault(__webpack_require__(6261));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _id = /*#__PURE__*/new WeakMap();
var _instanceId = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _pingInterval = /*#__PURE__*/new WeakMap();
var _clients = /*#__PURE__*/new WeakMap();
var _expired = /*#__PURE__*/new WeakMap();
class ClientTracker extends _events.default {
  constructor(_id2, _instanceId2) {
    let {
      interval
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      interval: 3000
    };
    super();
    _classPrivateFieldInitSpec(this, _id, void 0);
    _classPrivateFieldInitSpec(this, _instanceId, void 0);
    _classPrivateFieldInitSpec(this, _interval, void 0);
    _classPrivateFieldInitSpec(this, _pingInterval, void 0);
    _classPrivateFieldInitSpec(this, _clients, new Map());
    _defineProperty(this, "ping", () => {
      this.emit('ping', {
        id: _classPrivateFieldGet(_id, this),
        instanceId: _classPrivateFieldGet(_instanceId, this),
        timeout: _classPrivateFieldGet(_interval, this) * 2
      });
    });
    _defineProperty(this, "track", _ref => {
      let {
        id,
        instanceId,
        timeout,
        agent
      } = _ref;
      if (this.id === id) return;
      const hasClient = _classPrivateFieldGet(_clients, this).has(id);
      if (!hasClient) _classPrivateFieldGet(_clients, this).set(id, {
        instances: new Map(),
        agent
      });
      const client = _classPrivateFieldGet(_clients, this).get(id);
      const instance = client.instances.get(instanceId);
      const timer = setTimeout(() => _classPrivateFieldGet(_expired, this).call(this, id, instanceId), timeout || _classPrivateFieldGet(_interval, this) * 2);
      if (instance) clearTimeout(instance.timeout);
      client.instances.set(instanceId, {
        timestamp: new Date(),
        timeout: timer
      });
      if (!hasClient) this.emit('join', {
        id,
        agent
      });

      // when a new client instance is detected we resend our client state
      if (!instance) this.ping();
    });
    _classPrivateFieldInitSpec(this, _expired, (id, instanceId) => {
      const client = _classPrivateFieldGet(_clients, this).get(id);
      client.instances.delete(instanceId);
      if (client.instances.size === 0) {
        _classPrivateFieldGet(_clients, this).delete(id);
        this.emit('leave', id);
      }
    });
    _defineProperty(this, "all", () => {
      return Array.from(_classPrivateFieldGet(_clients, this)).map(_ref2 => {
        let [id, {
          agent
        }] = _ref2;
        return {
          id,
          agent
        };
      });
    });
    _defineProperty(this, "destroy", () => {
      for (const client of _classPrivateFieldGet(_clients, this).values()) {
        for (const instance of client.instances.values()) {
          clearTimeout(instance.timeout);
        }
        client.instances.clear();
      }
      _classPrivateFieldGet(_clients, this).clear();
      clearInterval(_classPrivateFieldGet(_pingInterval, this));
      this.removeAllListeners();
    });
    _classPrivateFieldSet(_id, this, _id2);
    _classPrivateFieldSet(_instanceId, this, _instanceId2);
    _classPrivateFieldSet(_interval, this, interval);
    _classPrivateFieldSet(_pingInterval, this, setInterval(this.ping, interval));
  }
  get id() {
    return _classPrivateFieldGet(_id, this);
  }
}
exports.ClientTracker = ClientTracker;

/***/ }),

/***/ 1762:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class DataUrl {
  static fromImage(img) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    return this.fromCanvas(canvas);
  }
  static fromCanvas(canvas) {
    let scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let quality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.3;
    if (scale === 1) return canvas.toDataURL ? canvas.toDataURL('image/webp', quality) : null;
    const scaledCanvas = document.createElement('canvas');
    const scaledContext = scaledCanvas.getContext('2d');
    scaledCanvas.width = canvas.width * scale;
    scaledCanvas.height = canvas.height * scale;
    scaledContext.drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
    return scaledCanvas.toDataURL('image/webp', quality);
  }
}
exports["default"] = DataUrl;

/***/ }),

/***/ 3976:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Deferred = void 0;
class Deferred {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
}
exports.Deferred = Deferred;

/***/ }),

/***/ 8781:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class RateLimiter {
  constructor(rate, period) {
    // allow rate passes over period milliseconds
    this.rate = rate;
    this.period = period;

    // tracks timestamps of the limit calls
    this._tracked = [];
  }
  limit() {
    // clear out expired entries from the tracking array
    const expiry = Date.now() - this.period;
    this._tracked = this._tracked.filter(t => t > expiry);

    // work out if there's space for the new entry
    if (this._tracked.length < this.rate) {
      this._tracked.push(Date.now());
      return false;
    } else {
      return true;
    }
  }
}
exports["default"] = RateLimiter;

/***/ }),

/***/ 4153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(3697);
var _events = __webpack_require__(6261);
var _throttle = _interopRequireDefault(__webpack_require__(6770));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class WindowTaps extends _events.EventEmitter {
  constructor() {
    super();
    _defineProperty(this, "windows", new Set());
    _defineProperty(this, "tap", window => {
      if (this.windows.has(window)) return;
      this.windows.add(window);
      const self = this;
      const pushState = window.history.pushState.bind(window.history);
      window.history.pushState = function () {
        const previousUrl = window.location.href;
        pushState(...arguments);
        self.emit('navigate', window, previousUrl);
      };
      const replaceState = window.history.replaceState.bind(window.history);
      window.history.replaceState = function () {
        const previousUrl = window.location.href;
        replaceState(...arguments);
        self.emit('navigate', window, previousUrl);
      };
      const {
        insertRule
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.insertRule = function () {
        const ret = insertRule.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        deleteRule
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.deleteRule = function () {
        const ret = deleteRule.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        replace
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.replace = function () {
        const ret = replace.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        replaceSync
      } = window.CSSStyleSheet.prototype;
      window.CSSStyleSheet.prototype.replaceSync = function () {
        const ret = replaceSync.bind(this)(...arguments);
        self.emit('stylechange', this);
        return ret;
      };
      const {
        attachShadow
      } = window.Element.prototype;
      window.Element.prototype.attachShadow = function (options) {
        const shadowRoot = attachShadow.bind(this)(options);
        self.emit('attachshadow', shadowRoot);
        return shadowRoot;
      };
      const watchCanvasContext = canvasContext => {
        Object.getOwnPropertyNames(canvasContext.prototype).forEach(prop => {
          try {
            if (typeof canvasContext.prototype[prop] !== 'function') return;
          } catch (_err) {
            // accessing some properties will throw an exception we can't test for
            return;
          }
          const originalFn = canvasContext.prototype[prop];
          canvasContext.prototype[prop] = function () {
            if (!this.canvas.__cbio_emit_change) {
              this.canvas.__cbio_emit_change = (0, _throttle.default)(c => self.emit('canvaschange', c), 500, {
                leading: false,
                trailing: true
              });
            }
            this.canvas.__cbio_emit_change(this.canvas);
            return originalFn.apply(this, arguments);
          };
        });
      };
      watchCanvasContext(window.CanvasRenderingContext2D);
      watchCanvasContext(window.WebGLRenderingContext);
      if (window.WebGL2RenderingContext) watchCanvasContext(window.WebGL2RenderingContext);
    });
    _defineProperty(this, "untap", (/* window */
    ) => {
      // todo: work out how to remove only our taps...
    });
    this.setMaxListeners(200);
  }
}
var _default = exports["default"] = new WindowTaps();

/***/ }),

/***/ 923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _nodes = __webpack_require__(6938);
async function _default() {
  if (_nodes.NodeSerializer.isLocalResource(window.location.href)) {
    console.warn('CobrowseIO: This page was loaded from a local address, Cobrowse may not work as expected due to inaccessible resources. We recommend using ngrok for testing development versions.');
  }
}

/***/ }),

/***/ 48:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertLinkToRegExp = void 0;
__webpack_require__(2298);
__webpack_require__(9199);
var _globToRegexp = _interopRequireDefault(__webpack_require__(3034));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const convertLinkToRegExp = link => link instanceof RegExp ? link : (0, _globToRegexp.default)(link, {
  flags: 'i'
});
exports.convertLinkToRegExp = convertLinkToRegExp;

/***/ }),

/***/ 2777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createRipple = createRipple;
__webpack_require__(3697);
var _hexToRgb = __webpack_require__(8276);
// track the styles already added to the page
const rippleStyleSet = new Set();
function injectRippleStyles(rippleDuration, rippleScale) {
  const key = "".concat(rippleDuration, "-").concat(rippleScale);
  if (rippleStyleSet.has(key)) {
    return;
  }
  const styleElement = document.createElement('style');
  styleElement.id = "cbio_session_ripple_stylesheet_".concat(key);
  styleElement.textContent = "\n        @keyframes cbio_session_ripple_effect-".concat(key, " {\n            0% {\n                transform: translate(-50%, -50%) scale(2);\n                opacity: 1;\n            }\n            100% {\n                transform: translate(-50%, -50%) scale(").concat(rippleScale, ");\n                opacity: 0;\n            }\n        }\n        .cbio_session_ripple-").concat(key, " {\n            width: 8px;\n            height: 8px;\n            border-radius: 50%;\n            position: absolute;\n            z-index: 2147483647;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%) scale(").concat(rippleScale, ");\n            pointer-events: none;\n            animation: cbio_session_ripple_effect-").concat(key, " ").concat(rippleDuration, "ms ease-out forwards;\n        }\n    ");
  document.head.appendChild(styleElement);

  // Add the key to the Set to mark this combination as injected
  rippleStyleSet.add(key);
}
function createRipple(selectedColor, rippleDuration, rippleScale) {
  let customStyles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  injectRippleStyles(rippleDuration, rippleScale);
  const selectedColorRgba = (0, _hexToRgb.hexToRGB)(selectedColor, 0.25);
  const ripple = document.createElement('div');
  ripple.classList.add("cbio_session_ripple-".concat(rippleDuration, "-").concat(rippleScale));
  Object.assign(ripple.style, {
    backgroundColor: selectedColorRgba
  }, customStyles);
  setTimeout(() => {
    ripple.remove();
  }, rippleDuration);
  return ripple;
}

/***/ }),

/***/ 8091:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.discoverNodes = discoverNodes;
__webpack_require__(3697);
var _nodes = __webpack_require__(6938);
/**
 * Builds a list of elements which have been added, removed or modified by mutating
 * the passed objects. Added and removed nodes are expanded to include their children.
 *
 * @param {MutationRecord} change - The mutation record to process
 * @param {Set} modified - The set of modified nodes
 * @param {Set} added - The map of added nodes
 * @param {Set} removed - The map of removed nodes
 */
function discoverNodes(change, modified, added, removed) {
  const addedNodes = new Set(change.addedNodes
  // slices because of IE 11 wierdness
  ? [].slice.call(change.addedNodes) : []);
  if (!removed.has(change.target)) {
    modified.add(change.target);
  }
  for (const node of addedNodes) {
    _nodes.NodeTree.depthFirst(node, n => {
      modified.add(n);
      removed.delete(n);
      added.add(n);
    });
  }

  // when a node is removed we also need to make sure we track all its its children
  // as removed, even those in the modified collection
  if (change.removedNodes) {
    [].slice.call(change.removedNodes).forEach(node => {
      _nodes.NodeTree.depthFirst(node, n => {
        modified.delete(n);
        added.delete(n);
        removed.add(n);
      });
    });
  }
}

/***/ }),

/***/ 0:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setFormAttribute = exports.getFormAttribute = void 0;
const getFormAttribute = (form, attribute) => {
  return Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, attribute).get.call(form);
};
exports.getFormAttribute = getFormAttribute;
const setFormAttribute = (form, attribute, value) => {
  return Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, attribute).set.call(form, value);
};
exports.setFormAttribute = setFormAttribute;

/***/ }),

/***/ 9768:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getCssText = void 0;
const getCssText = sheet => {
  try {
    if (sheet.media && sheet.media.length && !window.matchMedia(sheet.media).matches) return '';
  } catch (e) {
    console.warn('CobrowseIO: Media detection for sheet failed:', e, 'sheet', sheet);
  }
  return [].slice.call(sheet.cssRules).reduce((prev, cssRule) => {
    // IE11 throws an error on serializing some css animation rules
    // so we simply ignore them for now.
    try {
      return prev + cssRule.cssText;
    } catch (e) {
      return prev;
    }
  }, '');
};
exports.getCssText = getCssText;

/***/ }),

/***/ 7195:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getPersistentId = void 0;
var _uuid = __webpack_require__(5392);
var _storage = _interopRequireDefault(__webpack_require__(6542));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const getPersistentId = key => {
  const id = (0, _storage.default)().getItem(key);
  if (id) return id;
  const newId = (0, _uuid.v4)();
  (0, _storage.default)().setItem(key, newId);
  return newId;
};
exports.getPersistentId = getPersistentId;

/***/ }),

/***/ 7384:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getScrollBarSize = getScrollBarSize;
let scrollbarSize = null;
function getScrollBarSize() {
  if (scrollbarSize == null) {
    var _document$body, _document$body2;
    const elem = document.createElement('div');
    elem.style.cssText = 'width: 100px; height: 100px; overflow: scroll; position: absolute; top: -500px; left: -500px; margin: 0px; padding: 0px; border: none;';
    (_document$body = document.body) === null || _document$body === void 0 || _document$body.appendChild(elem);
    scrollbarSize = elem.offsetWidth - elem.clientWidth;
    (_document$body2 = document.body) === null || _document$body2 === void 0 || _document$body2.removeChild(elem);
  }
  return scrollbarSize;
}

/***/ }),

/***/ 8276:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hexToRGB = hexToRGB;
function hexToRGB(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  if (alpha) {
    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
  } else {
    return 'rgb(' + r + ', ' + g + ', ' + b + ')';
  }
}

/***/ }),

/***/ 6851:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
__webpack_require__(9199);
__webpack_require__(1722);
__webpack_require__(3697);
__webpack_require__(3914);
__webpack_require__(2114);
__webpack_require__(8034);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _default(url, token) {
  let delegate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _CobrowseIO.default;
  // websockets dont support cusotmer headers, so use query
  // string instead
  const query = [token ? "access_token=".concat(token) : null, "X-CobrowseSDKVersion=".concat(delegate.version), 'X-CobrowsePlatform=web', "X-CobrowseDevice=".concat(delegate.deviceId()), "X-CobrowseLicense=".concat(delegate.license)].filter(Boolean).join('&');

  // The server may not always specify the FQDN of the socket server
  // and may return a path relative to the API URL.
  // We resolve the value sent by the server against the currently configured
  // API to create an URL with a full domain name included.
  // Note: this will likely result in an URL that ends in a slash
  const resolved = new URL(url, delegate.api).toString();

  // The browser APIs require a wss:// protocol for connecting websockets
  // so we'll do a simple replacement of http(s) -> ws(s)
  const wsUrl = resolved.replace('https://', 'wss://').replace('http://', 'ws://');

  // Resolve the sockets path against the URL we've generated for the socket
  // server so far.
  // Note: we unofficially support socket paths that include a base path,
  //       e.g. https://example.com/cobrowse/ so this means we should leave
  //       off the leading / so it resolves relative to the current path
  return new URL("sockets/1/ws?".concat(query), wsUrl).toString();
}

/***/ }),

/***/ 9103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.mountComponent = void 0;
var _preact = __webpack_require__(5403);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const mountComponent = (component, initialProps, hideFromAgent, useShadowRoot) => {
  const container = document.createElement('div');
  if (hideFromAgent) container.className = '__cbio_ignored';
  const mountTarget = useShadowRoot ? container.attachShadow({
    mode: 'open'
  }) : container;
  const unmount = () => {
    (0, _preact.render)(null, mountTarget);
    if (document.body.contains(container)) document.body.removeChild(container);
  };
  const renderWithProps = props => {
    (0, _preact.render)((0, _preact.h)(component, _objectSpread(_objectSpread({}, props), {}, {
      unmount
    })), mountTarget);
  };
  renderWithProps(initialProps);
  document.body.appendChild(container);
  const styleTag = document.createElement('style');
  styleTag.textContent = window.__cbio_sdk_styles;
  mountTarget.prepend(styleTag);
  return {
    unmount,
    rerender: renderWithProps
  };
};
exports.mountComponent = mountComponent;

/***/ }),

/***/ 8567:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseWindowFeatures = void 0;
__webpack_require__(3697);
const TRUE_VALUES = ['true', 'yes', undefined];
const FALSE_VALUES = ['false', 'no'];
const parseWindowFeatures = windowFeatures => {
  if (typeof windowFeatures !== 'string') return {};
  const lowerCaseWindowFeatures = windowFeatures.toLowerCase();
  return lowerCaseWindowFeatures.split(',').reduce((acc, feature) => {
    const [key, value] = feature.split('=');
    acc[key] = TRUE_VALUES.indexOf(value) >= 0 ? true : FALSE_VALUES.indexOf(value) >= 0 ? false : value;
    return acc;
  }, {});
};
exports.parseWindowFeatures = parseWindowFeatures;

/***/ }),

/***/ 7609:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.protect = protect;
__webpack_require__(1631);
const symbol = Symbol('protected');
var _default = exports["default"] = symbol;
function protect(obj, method, fn) {
  if (!obj[symbol]) {
    Object.defineProperty(obj, symbol, {
      enumerable: false,
      value: {}
    });
  }
  const existing = obj[symbol][method];
  Object.getPrototypeOf(Object.getPrototypeOf(obj))[method] = existing;
  Object.defineProperty(obj[symbol], method, {
    enumerable: false,
    value: fn,
    configurable: true
  });
  return fn;
}

/***/ }),

/***/ 8981:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = randomString;
const nums = '0123456789';
const alphas = 'abcdefghijklmnopqrstuvwxyz';
const alphanums = "".concat(nums).concat(alphas.toLowerCase()).concat(alphas.toUpperCase());
function randomString(len) {
  let chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : alphanums;
  let random = '';
  for (let i = len; i > 0; i -= 1) {
    random += chars[Math.floor(Math.random() * chars.length)];
  }
  return random;
}

/***/ }),

/***/ 2117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.splitNameFromTarget = void 0;
const SPECIAL_TARGET_NAMES = ['_blank', '_self', '_parent', '_top', '_unfencedTop'];
const splitNameFromTarget = (target, defaultTarget) => {
  if (!target) return {
    name: '',
    target: defaultTarget
  };
  if (SPECIAL_TARGET_NAMES.includes(target)) return {
    name: '',
    target
  };
  return {
    name: target,
    target: defaultTarget
  };
};
exports.splitNameFromTarget = splitNameFromTarget;

/***/ }),

/***/ 706:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.delta = delta;
exports.mark = mark;
const timestamps = {
  load: Date.now()
};
function mark(tag) {
  timestamps[tag] = Date.now();
}
function delta(tag1, tag2) {
  if (!timestamps[tag1]) return NaN;
  if (tag1 && tag2) {
    return timestamps[tag2] - timestamps[tag1];
  } else {
    return Date.now() - timestamps[tag1];
  }
}

/***/ }),

/***/ 1354:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
class UserAgents {
  static isHeadless() {
    return navigator.userAgent.toLowerCase().includes('headless');
  }
}
exports["default"] = UserAgents;

/***/ }),

/***/ 9883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Node = exports.MutationObserver = exports.EventTarget = exports.Event = exports.Element = void 0;
var _iframe$contentWindow, _iframe;
let iframe;
try {
  iframe = document.createElement('iframe');
  document.documentElement.appendChild(iframe);
  iframe.style.display = 'none';
  iframe.className = '__cbio_ignored';
  iframe.width = 0;
  iframe.height = 0;
} catch (e) {
  console.warn('Failed to create unpolyfill iframe', e);
}
const {
  Node,
  Element,
  MutationObserver,
  Event,
  EventTarget
} = (_iframe$contentWindow = (_iframe = iframe) === null || _iframe === void 0 ? void 0 : _iframe.contentWindow) !== null && _iframe$contentWindow !== void 0 ? _iframe$contentWindow : window;
exports.EventTarget = EventTarget;
exports.Event = Event;
exports.MutationObserver = MutationObserver;
exports.Element = Element;
exports.Node = Node;

/***/ }),

/***/ 2143:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"container":"CallParticipants-module__container___JHyh3","participantContainer":"CallParticipants-module__participantContainer___WEeET","participantSpeaking":"CallParticipants-module__participantSpeaking___aovg8","videoContainer":"CallParticipants-module__videoContainer___cuUmK","video":"CallParticipants-module__video___osVRK","videoOverlay":"CallParticipants-module__videoOverlay___x1yb0","statusContainer":"CallParticipants-module__statusContainer___Vrvvr","statusTitle":"CallParticipants-module__statusTitle___puKch","statusIcon":"CallParticipants-module__statusIcon____w42b","videoOverlayIcon":"CallParticipants-module__videoOverlayIcon___Fph1m"});

/***/ }),

/***/ 1398:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"content":"ConsentDialog-module__content___fUfL3","title":"ConsentDialog-module__title___MTrAq","body":"ConsentDialog-module__body___FtS5W","confirmation":"ConsentDialog-module__confirmation___v7fj3","description":"ConsentDialog-module__description___eSwUl","buttons":"ConsentDialog-module__buttons___nToO7"});

/***/ }),

/***/ 7294:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"content":"MediaPreview-module__content___4fxuk","header":"MediaPreview-module__header___E2CcH","media":"MediaPreview-module__media___kmkmo","body":"MediaPreview-module__body___VPagd","title":"MediaPreview-module__title___uSKCr","description":"MediaPreview-module__description___IPolu","previewContainer":"MediaPreview-module__previewContainer___hZF98","videoContainer":"MediaPreview-module__videoContainer____O8KD","video":"MediaPreview-module__video___DnVpX","videoOverlay":"MediaPreview-module__videoOverlay___Wy27K","videoOverlaySolid":"MediaPreview-module__videoOverlaySolid___Ifi1O","videoOverlayTransparent":"MediaPreview-module__videoOverlayTransparent___vPzQr","videoOverlayText":"MediaPreview-module__videoOverlayText___kzAHr","deviceContainer":"MediaPreview-module__deviceContainer___MEdwh","buttonContainer":"MediaPreview-module__buttonContainer___aXcOQ","voiceVideoControls":"MediaPreview-module__voiceVideoControls___qTsRx","voiceVideoControlsToggle":"MediaPreview-module__voiceVideoControlsToggle___prGk3","voiceVideoControlsToggleOff":"MediaPreview-module__voiceVideoControlsToggleOff___ql_2k","voiceVideoControlsToggleOn":"MediaPreview-module__voiceVideoControlsToggleOn___URkye","voiceVideoControlsIcon":"MediaPreview-module__voiceVideoControlsIcon___yrQoV"});

/***/ }),

/***/ 3983:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"sessionStateOverlay":"SessionStateOverlay-module__sessionStateOverlay___pCowu","endSessionButton":"SessionStateOverlay-module__endSessionButton___pUtd7","endSessionIcon":"SessionStateOverlay-module__endSessionIcon___vLhgE","callingControlsContainer":"SessionStateOverlay-module__callingControlsContainer___UYdU1","callingControlsToggleContainer":"SessionStateOverlay-module__callingControlsToggleContainer___jmNM6","callingControlsToggle":"SessionStateOverlay-module__callingControlsToggle___ry4m0","callingControlsToggleOff":"SessionStateOverlay-module__callingControlsToggleOff___jxwB4","callingControlsToggleOn":"SessionStateOverlay-module__callingControlsToggleOn___FUuRG","callingControlsIcon":"SessionStateOverlay-module__callingControlsIcon___OWYpc","callingControlsEnd":"SessionStateOverlay-module__callingControlsEnd___t4Xky"});

/***/ }),

/***/ 2989:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"base":"Button-module__base___PvaYv","primary":"Button-module__primary___jyGbF","secondary":"Button-module__secondary___V1ksJ"});

/***/ }),

/***/ 4556:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"base":"IconButton-module__base___wAyLz"});

/***/ }),

/***/ 2704:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"container":"Modal-module__container___G4Twz","content":"Modal-module__content___tkuQp"});

/***/ }),

/***/ 9417:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"base":"Select-module__base___YM7TJ","noIcon":"Select-module__noIcon___nzh9A"});

/***/ }),

/***/ 9887:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"overlay":"HighlightOverlay-module__overlay___IwXTu","highlightOverlayFadeIn":"HighlightOverlay-module__highlightOverlayFadeIn___gxAX9","highlightOverlayPulse":"HighlightOverlay-module__highlightOverlayPulse___fW7eg","disableAnimations":"HighlightOverlay-module__disableAnimations___vQPvb"});

/***/ }),

/***/ 6000:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// extracted by mini-css-extract-plugin
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"tooltip":"Tooltip-module__tooltip___IL4dx","tooltipVisible":"Tooltip-module__tooltipVisible___a7Zvs","tooltipTitle":"Tooltip-module__tooltipTitle___gG75M","tooltipArrow":"Tooltip-module__tooltipArrow___kPSXv"});

/***/ }),

/***/ 6277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./ar.json": 5120,
	"./cs.json": 7337,
	"./da.json": 1088,
	"./de.json": 428,
	"./en.json": 5448,
	"./es-MX.json": 9467,
	"./es.json": 831,
	"./et.json": 3202,
	"./fi.json": 4818,
	"./fr.json": 9867,
	"./hi.json": 7876,
	"./it.json": 8038,
	"./ja.json": 6582,
	"./kk.json": 1753,
	"./ko.json": 5613,
	"./lt.json": 2391,
	"./mr.json": 9396,
	"./ms.json": 8439,
	"./nl.json": 9121,
	"./pl.json": 5443,
	"./pt-BR.json": 4389,
	"./pt.json": 3851,
	"./ro.json": 7304,
	"./ru.json": 6146,
	"./sk.json": 5537,
	"./sl.json": 1224,
	"./sv.json": 8978,
	"./th-TH.json": 9250,
	"./th.json": 747,
	"./uk.json": 1559,
	"./vi.json": 7762,
	"./zh-Hant.json": 4181,
	"./zh.json": 9225
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 6277;

/***/ }),

/***/ 2098:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDI0IDI0JyBmaWxsPSdub25lJyBzdHJva2U9J2N1cnJlbnRDb2xvcicgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogIDxwYXRoIHN0cm9rZT0nbm9uZScgZD0nTTAgMGgyNHYyNEgweicgZmlsbD0nbm9uZScvPjxwYXRoIGQ9J002IDlsNiA2bDYgLTYnIC8+Cjwvc3ZnPg==";

/***/ }),

/***/ 9020:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDI0IDI0JyBmaWxsPSdub25lJyBzdHJva2U9J2N1cnJlbnRDb2xvcicgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogIDxwYXRoIHN0cm9rZT0nbm9uZScgZD0nTTAgMGgyNHYyNEgweicgZmlsbD0nbm9uZScgLz48cGF0aCBkPSdNOSAybTAgM2EzIDMgMCAwIDEgMyAtM2gwYTMgMyAwIDAgMSAzIDN2NWEzIDMgMCAwIDEgLTMgM2gwYTMgMyAwIDAgMSAtMyAtM3onIC8+PHBhdGggZD0nTTUgMTBhNyA3IDAgMCAwIDE0IDAnIC8+PHBhdGggZD0nTTggMjFsOCAwJyAvPjxwYXRoIGQ9J00xMiAxN2wwIDQnIC8+Cjwvc3ZnPg==";

/***/ }),

/***/ 4053:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDI0IDI0JyBmaWxsPSdub25lJyBzdHJva2U9J2N1cnJlbnRDb2xvcicgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogIDxwYXRoIHN0cm9rZT0nbm9uZScgZD0nTTAgMGgyNHYyNEgweicgZmlsbD0nbm9uZScgLz48cGF0aCBkPSdNMTUgMTBsNC41NTMgLTIuMjc2YTEgMSAwIDAgMSAxLjQ0NyAuODk0djYuNzY0YTEgMSAwIDAgMSAtMS40NDcgLjg5NGwtNC41NTMgLTIuMjc2di00eicgLz48cGF0aCBkPSdNMyA2bTAgMmEyIDIgMCAwIDEgMiAtMmg4YTIgMiAwIDAgMSAyIDJ2OGEyIDIgMCAwIDEgLTIgMmgtOGEyIDIgMCAwIDEgLTIgLTJ6JyAvPgo8L3N2Zz4=";

/***/ }),

/***/ 9978:
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,ICA8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JzI0JyBoZWlnaHQ9JzI0JyB2aWV3Qm94PScwIDAgMjQgMjQnIGZpbGw9J25vbmUnIHN0cm9rZT0nY3VycmVudENvbG9yJyBzdHJva2Utd2lkdGg9JzInIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+PHBhdGggc3Ryb2tlPSdub25lJyBkPSdNMCAwaDI0djI0SDB6JyBmaWxsPSdub25lJyAvPgogICAgPHBhdGggZD0nTTE1IDhhNSA1IDAgMCAxIDAgOCcgLz48cGF0aCBkPSdNMTcuNyA1YTkgOSAwIDAgMSAwIDE0JyAvPjxwYXRoIGQ9J002IDE1aC0yYTEgMSAwIDAgMSAtMSAtMXYtNGExIDEgMCAwIDEgMSAtMWgybDMuNSAtNC41YS44IC44IDAgMCAxIDEuNSAuNXYxNGEuOCAuOCAwIDAgMSAtMS41IC41bC0zLjUgLTQuNScgLz4KICA8L3N2Zz4=";

/***/ }),

/***/ 6233:
/***/ ((module) => {

"use strict";
module.exports = require("@elevenlabs/client");

/***/ }),

/***/ 3532:
/***/ ((module) => {

"use strict";
module.exports = require("@floating-ui/dom");

/***/ }),

/***/ 2853:
/***/ ((module) => {

"use strict";
module.exports = require("@preact/signals");

/***/ }),

/***/ 4956:
/***/ ((module) => {

"use strict";
module.exports = require("clsx");

/***/ }),

/***/ 8637:
/***/ ((module) => {

"use strict";
module.exports = require("clsx/lite");

/***/ }),

/***/ 132:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/es/promise/all-settled");

/***/ }),

/***/ 8799:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array-buffer.constructor.js");

/***/ }),

/***/ 5833:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array-buffer.slice.js");

/***/ }),

/***/ 7436:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.concat.js");

/***/ }),

/***/ 8434:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.filter.js");

/***/ }),

/***/ 1945:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.find.js");

/***/ }),

/***/ 1952:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.flat-map.js");

/***/ }),

/***/ 8425:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.flat.js");

/***/ }),

/***/ 2765:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.for-each.js");

/***/ }),

/***/ 6612:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.from.js");

/***/ }),

/***/ 687:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.includes.js");

/***/ }),

/***/ 2868:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.is-array.js");

/***/ }),

/***/ 4602:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.iterator.js");

/***/ }),

/***/ 8340:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.reverse.js");

/***/ }),

/***/ 6592:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.slice.js");

/***/ }),

/***/ 2832:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.sort.js");

/***/ }),

/***/ 4045:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.unscopables.flat-map.js");

/***/ }),

/***/ 9492:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.array.unscopables.flat.js");

/***/ }),

/***/ 8549:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.data-view.js");

/***/ }),

/***/ 7081:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.date.now.js");

/***/ }),

/***/ 8742:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.date.to-primitive.js");

/***/ }),

/***/ 7234:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.date.to-string.js");

/***/ }),

/***/ 660:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.function.bind.js");

/***/ }),

/***/ 5780:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.function.name.js");

/***/ }),

/***/ 6235:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.json.to-string-tag.js");

/***/ }),

/***/ 3769:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.map.js");

/***/ }),

/***/ 8151:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.math.to-string-tag.js");

/***/ }),

/***/ 1774:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.number.constructor.js");

/***/ }),

/***/ 8922:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.object.create.js");

/***/ }),

/***/ 2065:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.object.define-property.js");

/***/ }),

/***/ 6761:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.object.from-entries.js");

/***/ }),

/***/ 5435:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.object.get-prototype-of.js");

/***/ }),

/***/ 8263:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.object.set-prototype-of.js");

/***/ }),

/***/ 7043:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.object.to-string.js");

/***/ }),

/***/ 9908:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.promise.finally.js");

/***/ }),

/***/ 7057:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.reflect.construct.js");

/***/ }),

/***/ 2298:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.regexp.constructor.js");

/***/ }),

/***/ 9199:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.regexp.exec.js");

/***/ }),

/***/ 1871:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.regexp.flags.js");

/***/ }),

/***/ 2589:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.regexp.to-string.js");

/***/ }),

/***/ 7007:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.set.js");

/***/ }),

/***/ 1779:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.string.includes.js");

/***/ }),

/***/ 9062:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.string.iterator.js");

/***/ }),

/***/ 1722:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.string.replace.js");

/***/ }),

/***/ 9316:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.string.trim.js");

/***/ }),

/***/ 6126:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.symbol.async-iterator.js");

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.symbol.description.js");

/***/ }),

/***/ 2864:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.symbol.iterator.js");

/***/ }),

/***/ 483:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.symbol.js");

/***/ }),

/***/ 5366:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.symbol.to-primitive.js");

/***/ }),

/***/ 1309:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.symbol.to-string-tag.js");

/***/ }),

/***/ 6736:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.copy-within.js");

/***/ }),

/***/ 5284:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.every.js");

/***/ }),

/***/ 9670:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.fill.js");

/***/ }),

/***/ 4211:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.filter.js");

/***/ }),

/***/ 7939:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.find-index.js");

/***/ }),

/***/ 2880:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.find.js");

/***/ }),

/***/ 4380:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.float32-array.js");

/***/ }),

/***/ 1249:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.float64-array.js");

/***/ }),

/***/ 5640:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.for-each.js");

/***/ }),

/***/ 6330:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.includes.js");

/***/ }),

/***/ 7387:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.index-of.js");

/***/ }),

/***/ 4315:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.int16-array.js");

/***/ }),

/***/ 6405:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.int32-array.js");

/***/ }),

/***/ 2668:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.int8-array.js");

/***/ }),

/***/ 2591:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.iterator.js");

/***/ }),

/***/ 769:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.join.js");

/***/ }),

/***/ 7342:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.last-index-of.js");

/***/ }),

/***/ 8435:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.map.js");

/***/ }),

/***/ 98:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.of.js");

/***/ }),

/***/ 6066:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.reduce-right.js");

/***/ }),

/***/ 5599:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.reduce.js");

/***/ }),

/***/ 2411:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.reverse.js");

/***/ }),

/***/ 973:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.set.js");

/***/ }),

/***/ 9367:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.slice.js");

/***/ }),

/***/ 3973:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.some.js");

/***/ }),

/***/ 8213:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.sort.js");

/***/ }),

/***/ 6904:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.subarray.js");

/***/ }),

/***/ 8973:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.to-locale-string.js");

/***/ }),

/***/ 2422:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.to-string.js");

/***/ }),

/***/ 8884:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.uint16-array.js");

/***/ }),

/***/ 8366:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.uint32-array.js");

/***/ }),

/***/ 1417:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.uint8-array.js");

/***/ }),

/***/ 3720:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.typed-array.uint8-clamped-array.js");

/***/ }),

/***/ 2718:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/es.weak-map.js");

/***/ }),

/***/ 8282:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/esnext.global-this.js");

/***/ }),

/***/ 4428:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/esnext.promise.all-settled.js");

/***/ }),

/***/ 9377:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/esnext.string.replace-all.js");

/***/ }),

/***/ 9198:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/web.dom-collections.for-each.js");

/***/ }),

/***/ 3697:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/web.dom-collections.iterator.js");

/***/ }),

/***/ 8615:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/web.timers.js");

/***/ }),

/***/ 8034:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/web.url-search-params.js");

/***/ }),

/***/ 3914:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/web.url.js");

/***/ }),

/***/ 2114:
/***/ ((module) => {

"use strict";
module.exports = require("core-js/modules/web.url.to-json.js");

/***/ }),

/***/ 7447:
/***/ ((module) => {

"use strict";
module.exports = require("dompurify");

/***/ }),

/***/ 6261:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7078:
/***/ ((module) => {

"use strict";
module.exports = require("fast-deep-equal");

/***/ }),

/***/ 3034:
/***/ ((module) => {

"use strict";
module.exports = require("glob-to-regexp");

/***/ }),

/***/ 8440:
/***/ ((module) => {

"use strict";
module.exports = require("js-cookie");

/***/ }),

/***/ 8894:
/***/ ((module) => {

"use strict";
module.exports = require("lodash/isEqual");

/***/ }),

/***/ 6971:
/***/ ((module) => {

"use strict";
module.exports = require("lodash/isMatchWith");

/***/ }),

/***/ 9947:
/***/ ((module) => {

"use strict";
module.exports = require("lodash/omit");

/***/ }),

/***/ 751:
/***/ ((module) => {

"use strict";
module.exports = require("lodash/pick");

/***/ }),

/***/ 6770:
/***/ ((module) => {

"use strict";
module.exports = require("lodash/throttle");

/***/ }),

/***/ 2736:
/***/ ((module) => {

"use strict";
module.exports = require("ms");

/***/ }),

/***/ 5403:
/***/ ((module) => {

"use strict";
module.exports = require("preact");

/***/ }),

/***/ 1999:
/***/ ((module) => {

"use strict";
module.exports = require("preact-custom-element");

/***/ }),

/***/ 150:
/***/ ((module) => {

"use strict";
module.exports = require("preact/compat");

/***/ }),

/***/ 3150:
/***/ ((module) => {

"use strict";
module.exports = require("preact/compat/jsx-runtime");

/***/ }),

/***/ 16:
/***/ ((module) => {

"use strict";
module.exports = require("preact/hooks");

/***/ }),

/***/ 6416:
/***/ ((module) => {

"use strict";
module.exports = require("preact/jsx-runtime");

/***/ }),

/***/ 9284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(1631);
__webpack_require__(6126);
__webpack_require__(8340);
__webpack_require__(2832);
__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(2298);
__webpack_require__(9199);
__webpack_require__(1871);
__webpack_require__(4380);
__webpack_require__(1249);
__webpack_require__(2668);
__webpack_require__(4315);
__webpack_require__(6405);
__webpack_require__(1417);
__webpack_require__(3720);
__webpack_require__(8884);
__webpack_require__(8366);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
__webpack_require__(8282);
__webpack_require__(3697);
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _asyncGeneratorDelegate(t) { var e = {}, n = !1; function pump(e, r) { return n = !0, r = new Promise(function (n) { n(t[e](r)); }), { done: !1, value: new _OverloadYield(r, 1) }; } return e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () { return this; }, e.next = function (t) { return n ? (n = !1, t) : pump("next", t); }, "function" == typeof t.throw && (e.throw = function (t) { if (n) throw n = !1, t; return pump("throw", t); }), "function" == typeof t.return && (e.return = function (t) { return n ? (n = !1, t) : pump("return", t); }), e; }
function _OverloadYield(e, d) { this.v = e, this.k = d; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }
(function (global, factory) {
   true ? factory(exports) : 0;
})(void 0, function (exports) {
  'use strict';

  let decoder;
  try {
    decoder = new TextDecoder();
  } catch (error) {}
  let src;
  let srcEnd;
  let position$1 = 0;
  const LEGACY_RECORD_INLINE_ID = 105;
  const RECORD_DEFINITIONS_ID = 0xdffe;
  const RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'
  const BUNDLED_STRINGS_ID = 0xdff9;
  const PACKED_REFERENCE_TAG_ID = 6;
  const STOP_CODE = {};
  let maxArraySize = 112810000; // This is the maximum array size in V8. We would potentially detect and set it higher
  // for JSC, but this is pretty large and should be sufficient for most use cases
  let maxMapSize = 16810000; // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,
  let currentDecoder = {};
  let currentStructures;
  let srcString;
  let srcStringStart = 0;
  let srcStringEnd = 0;
  let bundledStrings$1;
  let referenceMap;
  let currentExtensions = [];
  let currentExtensionRanges = [];
  let packedValues;
  let dataView;
  let restoreMapsAsObject;
  let defaultOptions = {
    useRecords: false,
    mapsAsObjects: true
  };
  let sequentialMode = false;
  let inlineObjectReadThreshold = 2;
  var BlockedFunction; // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for
  // no-eval build
  try {
    new BlockedFunction('');
  } catch (error) {
    // if eval variants are not supported, do not create inline object readers ever
    inlineObjectReadThreshold = Infinity;
  }
  class Decoder {
    constructor(options) {
      if (options) {
        if ((options.keyMap || options._keyMap) && !options.useRecords) {
          options.useRecords = false;
          options.mapsAsObjects = true;
        }
        if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;
        if (options.getStructures) options.getShared = options.getStructures;
        if (options.getShared && !options.structures) (options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures
        if (options.keyMap) {
          this.mapKey = new Map();
          for (let [k, v] of Object.entries(options.keyMap)) this.mapKey.set(v, k);
        }
      }
      Object.assign(this, options);
    }
    /*
    decodeKey(key) {
    	return this.keyMap
    		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
    		: key
    }
    */
    decodeKey(key) {
      return this.keyMap ? this.mapKey.get(key) || key : key;
    }
    encodeKey(key) {
      return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
    }
    encodeKeys(rec) {
      if (!this._keyMap) return rec;
      let map = new Map();
      for (let [k, v] of Object.entries(rec)) map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
      return map;
    }
    decodeKeys(map) {
      if (!this._keyMap || map.constructor.name != 'Map') return map;
      if (!this._mapKey) {
        this._mapKey = new Map();
        for (let [k, v] of Object.entries(this._keyMap)) this._mapKey.set(v, k);
      }
      let res = {};
      //map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)
      map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
      return res;
    }
    mapDecode(source, end) {
      let res = this.decode(source);
      if (this._keyMap) {
        //Experiemntal support for Optimised KeyMap  decoding 
        switch (res.constructor.name) {
          case 'Array':
            return res.map(r => this.decodeKeys(r));
          //case 'Map': return this.decodeKeys(res)
        }
      }
      return res;
    }
    decode(source, end) {
      if (src) {
        // re-entrant execution, save the state and restore it after we do this decode
        return saveState(() => {
          clearSource();
          return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);
        });
      }
      srcEnd = end > -1 ? end : source.length;
      position$1 = 0;
      srcStringEnd = 0;
      srcString = null;
      bundledStrings$1 = null;
      src = source;
      // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
      // technique for getting data from a database where it can be copied into an existing buffer instead of creating
      // new ones
      try {
        dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
      } catch (error) {
        // if it doesn't have a buffer, maybe it is the wrong type of object
        src = null;
        if (source instanceof Uint8Array) throw error;
        throw new Error('Source must be a Uint8Array or Buffer but was a ' + (source && typeof source == 'object' ? source.constructor.name : typeof source));
      }
      if (this instanceof Decoder) {
        currentDecoder = this;
        packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
        if (this.structures) {
          currentStructures = this.structures;
          return checkedRead();
        } else if (!currentStructures || currentStructures.length > 0) {
          currentStructures = [];
        }
      } else {
        currentDecoder = defaultOptions;
        if (!currentStructures || currentStructures.length > 0) currentStructures = [];
        packedValues = null;
      }
      return checkedRead();
    }
    decodeMultiple(source, forEach) {
      let values,
        lastPosition = 0;
      try {
        let size = source.length;
        sequentialMode = true;
        let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
        if (forEach) {
          if (forEach(value) === false) {
            return;
          }
          while (position$1 < size) {
            lastPosition = position$1;
            if (forEach(checkedRead()) === false) {
              return;
            }
          }
        } else {
          values = [value];
          while (position$1 < size) {
            lastPosition = position$1;
            values.push(checkedRead());
          }
          return values;
        }
      } catch (error) {
        error.lastPosition = lastPosition;
        error.values = values;
        throw error;
      } finally {
        sequentialMode = false;
        clearSource();
      }
    }
  }
  function checkedRead() {
    try {
      let result = read();
      if (bundledStrings$1) {
        if (position$1 >= bundledStrings$1.postBundlePosition) {
          let error = new Error('Unexpected bundle position');
          error.incomplete = true;
          throw error;
        }
        // bundled strings to skip past
        position$1 = bundledStrings$1.postBundlePosition;
        bundledStrings$1 = null;
      }
      if (position$1 == srcEnd) {
        // finished reading this source, cleanup references
        currentStructures = null;
        src = null;
        if (referenceMap) referenceMap = null;
      } else if (position$1 > srcEnd) {
        // over read
        let error = new Error('Unexpected end of CBOR data');
        error.incomplete = true;
        throw error;
      } else if (!sequentialMode) {
        throw new Error('Data read, but end of buffer not reached');
      }
      // else more to read, but we are reading sequentially, so don't clear source yet
      return result;
    } catch (error) {
      clearSource();
      if (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {
        error.incomplete = true;
      }
      throw error;
    }
  }
  function read() {
    let token = src[position$1++];
    let majorType = token >> 5;
    token = token & 0x1f;
    if (token > 0x17) {
      switch (token) {
        case 0x18:
          token = src[position$1++];
          break;
        case 0x19:
          if (majorType == 7) {
            return getFloat16();
          }
          token = dataView.getUint16(position$1);
          position$1 += 2;
          break;
        case 0x1a:
          if (majorType == 7) {
            let value = dataView.getFloat32(position$1);
            if (currentDecoder.useFloat32 > 2) {
              // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
              let multiplier = mult10[(src[position$1] & 0x7f) << 1 | src[position$1 + 1] >> 7];
              position$1 += 4;
              return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
            }
            position$1 += 4;
            return value;
          }
          token = dataView.getUint32(position$1);
          position$1 += 4;
          break;
        case 0x1b:
          if (majorType == 7) {
            let value = dataView.getFloat64(position$1);
            position$1 += 8;
            return value;
          }
          if (majorType > 1) {
            if (dataView.getUint32(position$1) > 0) throw new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295');
            token = dataView.getUint32(position$1 + 4);
          } else if (currentDecoder.int64AsNumber) {
            token = dataView.getUint32(position$1) * 0x100000000;
            token += dataView.getUint32(position$1 + 4);
          } else token = dataView.getBigUint64(position$1);
          position$1 += 8;
          break;
        case 0x1f:
          // indefinite length
          switch (majorType) {
            case 2: // byte string
            case 3:
              // text string
              throw new Error('Indefinite length not supported for byte or text strings');
            case 4:
              // array
              let array = [];
              let value,
                i = 0;
              while ((value = read()) != STOP_CODE) {
                if (i >= maxArraySize) throw new Error("Array length exceeds ".concat(maxArraySize));
                array[i++] = value;
              }
              return majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array);
            case 5:
              // map
              let key;
              if (currentDecoder.mapsAsObjects) {
                let object = {};
                let i = 0;
                if (currentDecoder.keyMap) {
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) throw new Error("Property count exceeds ".concat(maxMapSize));
                    object[safeKey(currentDecoder.decodeKey(key))] = read();
                  }
                } else {
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) throw new Error("Property count exceeds ".concat(maxMapSize));
                    object[safeKey(key)] = read();
                  }
                }
                return object;
              } else {
                if (restoreMapsAsObject) {
                  currentDecoder.mapsAsObjects = true;
                  restoreMapsAsObject = false;
                }
                let map = new Map();
                if (currentDecoder.keyMap) {
                  let i = 0;
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) {
                      throw new Error("Map size exceeds ".concat(maxMapSize));
                    }
                    map.set(currentDecoder.decodeKey(key), read());
                  }
                } else {
                  let i = 0;
                  while ((key = read()) != STOP_CODE) {
                    if (i++ >= maxMapSize) {
                      throw new Error("Map size exceeds ".concat(maxMapSize));
                    }
                    map.set(key, read());
                  }
                }
                return map;
              }
            case 7:
              return STOP_CODE;
            default:
              throw new Error('Invalid major type for indefinite length ' + majorType);
          }
        default:
          throw new Error('Unknown token ' + token);
      }
    }
    switch (majorType) {
      case 0:
        // positive int
        return token;
      case 1:
        // negative int
        return ~token;
      case 2:
        // buffer
        return readBin(token);
      case 3:
        // string
        if (srcStringEnd >= position$1) {
          return srcString.slice(position$1 - srcStringStart, (position$1 += token) - srcStringStart);
        }
        if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
          // for small blocks, avoiding the overhead of the extract call is helpful
          let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
          if (string != null) return string;
        }
        return readFixedString(token);
      case 4:
        // array
        if (token >= maxArraySize) throw new Error("Array length exceeds ".concat(maxArraySize));
        let array = new Array(token);
        //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())	
        //else 
        for (let i = 0; i < token; i++) array[i] = read();
        return array;
      case 5:
        // map
        if (token >= maxMapSize) throw new Error("Map size exceeds ".concat(maxArraySize));
        if (currentDecoder.mapsAsObjects) {
          let object = {};
          if (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read();else for (let i = 0; i < token; i++) object[safeKey(read())] = read();
          return object;
        } else {
          if (restoreMapsAsObject) {
            currentDecoder.mapsAsObjects = true;
            restoreMapsAsObject = false;
          }
          let map = new Map();
          if (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()), read());else for (let i = 0; i < token; i++) map.set(read(), read());
          return map;
        }
      case 6:
        // extension
        if (token >= BUNDLED_STRINGS_ID) {
          let structure = currentStructures[token & 0x1fff]; // check record structures first
          // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
          if (structure) {
            if (!structure.read) structure.read = createStructureReader(structure);
            return structure.read();
          }
          if (token < 0x10000) {
            if (token == RECORD_INLINE_ID) {
              // we do a special check for this so that we can keep the
              // currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
              let length = readJustLength();
              let id = read();
              let structure = read();
              recordDefinition(id, structure);
              let object = {};
              if (currentDecoder.keyMap) for (let i = 2; i < length; i++) {
                let key = currentDecoder.decodeKey(structure[i - 2]);
                object[safeKey(key)] = read();
              } else for (let i = 2; i < length; i++) {
                let key = structure[i - 2];
                object[safeKey(key)] = read();
              }
              return object;
            } else if (token == RECORD_DEFINITIONS_ID) {
              let length = readJustLength();
              let id = read();
              for (let i = 2; i < length; i++) {
                recordDefinition(id++, read());
              }
              return read();
            } else if (token == BUNDLED_STRINGS_ID) {
              return readBundleExt();
            }
            if (currentDecoder.getShared) {
              loadShared();
              structure = currentStructures[token & 0x1fff];
              if (structure) {
                if (!structure.read) structure.read = createStructureReader(structure);
                return structure.read();
              }
            }
          }
        }
        let extension = currentExtensions[token];
        if (extension) {
          if (extension.handlesRead) return extension(read);else return extension(read());
        } else {
          let input = read();
          for (let i = 0; i < currentExtensionRanges.length; i++) {
            let value = currentExtensionRanges[i](token, input);
            if (value !== undefined) return value;
          }
          return new Tag(input, token);
        }
      case 7:
        // fixed value
        switch (token) {
          case 0x14:
            return false;
          case 0x15:
            return true;
          case 0x16:
            return null;
          case 0x17:
            return;
          // undefined
          case 0x1f:
          default:
            let packedValue = (packedValues || getPackedValues())[token];
            if (packedValue !== undefined) return packedValue;
            throw new Error('Unknown token ' + token);
        }
      default:
        // negative int
        if (isNaN(token)) {
          let error = new Error('Unexpected end of CBOR data');
          error.incomplete = true;
          throw error;
        }
        throw new Error('Unknown CBOR token ' + token);
    }
  }
  const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
  function createStructureReader(structure) {
    if (!structure) throw new Error('Structure is required in record definition');
    function readObject() {
      // get the array size from the header
      let length = src[position$1++];
      //let majorType = token >> 5
      length = length & 0x1f;
      if (length > 0x17) {
        switch (length) {
          case 0x18:
            length = src[position$1++];
            break;
          case 0x19:
            length = dataView.getUint16(position$1);
            position$1 += 2;
            break;
          case 0x1a:
            length = dataView.getUint32(position$1);
            position$1 += 4;
            break;
          default:
            throw new Error('Expected array header, but got ' + src[position$1 - 1]);
        }
      }
      // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
      let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function
      while (compiledReader) {
        // we have a fast compiled object literal reader
        if (compiledReader.propertyCount === length) return compiledReader(read); // with the right length, so we use it
        compiledReader = compiledReader.next; // see if there is another reader with the right length
      }
      if (this.slowReads++ >= inlineObjectReadThreshold) {
        // create a fast compiled reader
        let array = this.length == length ? this : this.slice(0, length);
        compiledReader = currentDecoder.keyMap ? new BlockedFunction('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : '[' + JSON.stringify(k) + ']:r()').join(',') + '}') : new BlockedFunction('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : '[' + JSON.stringify(key) + ']:r()').join(',') + '}');
        if (this.compiledReader) compiledReader.next = this.compiledReader; // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure
        compiledReader.propertyCount = length;
        this.compiledReader = compiledReader;
        return compiledReader(read);
      }
      let object = {};
      if (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read();else for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
      return object;
    }
    structure.slowReads = 0;
    return readObject;
  }
  function safeKey(key) {
    // protect against prototype pollution
    if (typeof key === 'string') return key === '__proto__' ? '__proto_' : key;
    if (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();
    if (key == null) return key + '';
    // protect against expensive (DoS) string conversions
    throw new Error('Invalid property name type ' + typeof key);
  }
  let readFixedString = readStringJS;
  let isNativeAccelerationEnabled = false;
  function readStringJS(length) {
    let result;
    if (length < 16) {
      if (result = shortStringInJS(length)) return result;
    }
    if (length > 64 && decoder) return decoder.decode(src.subarray(position$1, position$1 += length));
    const end = position$1 + length;
    const units = [];
    result = '';
    while (position$1 < end) {
      const byte1 = src[position$1++];
      if ((byte1 & 0x80) === 0) {
        // 1 byte
        units.push(byte1);
      } else if ((byte1 & 0xe0) === 0xc0) {
        // 2 bytes
        const byte2 = src[position$1++] & 0x3f;
        units.push((byte1 & 0x1f) << 6 | byte2);
      } else if ((byte1 & 0xf0) === 0xe0) {
        // 3 bytes
        const byte2 = src[position$1++] & 0x3f;
        const byte3 = src[position$1++] & 0x3f;
        units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
      } else if ((byte1 & 0xf8) === 0xf0) {
        // 4 bytes
        const byte2 = src[position$1++] & 0x3f;
        const byte3 = src[position$1++] & 0x3f;
        const byte4 = src[position$1++] & 0x3f;
        let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;
        if (unit > 0xffff) {
          unit -= 0x10000;
          units.push(unit >>> 10 & 0x3ff | 0xd800);
          unit = 0xdc00 | unit & 0x3ff;
        }
        units.push(unit);
      } else {
        units.push(byte1);
      }
      if (units.length >= 0x1000) {
        result += fromCharCode.apply(String, units);
        units.length = 0;
      }
    }
    if (units.length > 0) {
      result += fromCharCode.apply(String, units);
    }
    return result;
  }
  let fromCharCode = String.fromCharCode;
  function longStringInJS(length) {
    let start = position$1;
    let bytes = new Array(length);
    for (let i = 0; i < length; i++) {
      const byte = src[position$1++];
      if ((byte & 0x80) > 0) {
        position$1 = start;
        return;
      }
      bytes[i] = byte;
    }
    return fromCharCode.apply(String, bytes);
  }
  function shortStringInJS(length) {
    if (length < 4) {
      if (length < 2) {
        if (length === 0) return '';else {
          let a = src[position$1++];
          if ((a & 0x80) > 1) {
            position$1 -= 1;
            return;
          }
          return fromCharCode(a);
        }
      } else {
        let a = src[position$1++];
        let b = src[position$1++];
        if ((a & 0x80) > 0 || (b & 0x80) > 0) {
          position$1 -= 2;
          return;
        }
        if (length < 3) return fromCharCode(a, b);
        let c = src[position$1++];
        if ((c & 0x80) > 0) {
          position$1 -= 3;
          return;
        }
        return fromCharCode(a, b, c);
      }
    } else {
      let a = src[position$1++];
      let b = src[position$1++];
      let c = src[position$1++];
      let d = src[position$1++];
      if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
        position$1 -= 4;
        return;
      }
      if (length < 6) {
        if (length === 4) return fromCharCode(a, b, c, d);else {
          let e = src[position$1++];
          if ((e & 0x80) > 0) {
            position$1 -= 5;
            return;
          }
          return fromCharCode(a, b, c, d, e);
        }
      } else if (length < 8) {
        let e = src[position$1++];
        let f = src[position$1++];
        if ((e & 0x80) > 0 || (f & 0x80) > 0) {
          position$1 -= 6;
          return;
        }
        if (length < 7) return fromCharCode(a, b, c, d, e, f);
        let g = src[position$1++];
        if ((g & 0x80) > 0) {
          position$1 -= 7;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g);
      } else {
        let e = src[position$1++];
        let f = src[position$1++];
        let g = src[position$1++];
        let h = src[position$1++];
        if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
          position$1 -= 8;
          return;
        }
        if (length < 10) {
          if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h);else {
            let i = src[position$1++];
            if ((i & 0x80) > 0) {
              position$1 -= 9;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i);
          }
        } else if (length < 12) {
          let i = src[position$1++];
          let j = src[position$1++];
          if ((i & 0x80) > 0 || (j & 0x80) > 0) {
            position$1 -= 10;
            return;
          }
          if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i, j);
          let k = src[position$1++];
          if ((k & 0x80) > 0) {
            position$1 -= 11;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
        } else {
          let i = src[position$1++];
          let j = src[position$1++];
          let k = src[position$1++];
          let l = src[position$1++];
          if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
            position$1 -= 12;
            return;
          }
          if (length < 14) {
            if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);else {
              let m = src[position$1++];
              if ((m & 0x80) > 0) {
                position$1 -= 13;
                return;
              }
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
            }
          } else {
            let m = src[position$1++];
            let n = src[position$1++];
            if ((m & 0x80) > 0 || (n & 0x80) > 0) {
              position$1 -= 14;
              return;
            }
            if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
            let o = src[position$1++];
            if ((o & 0x80) > 0) {
              position$1 -= 15;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
          }
        }
      }
    }
  }
  function readBin(length) {
    return currentDecoder.copyBuffers ?
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position$1, position$1 += length) : src.subarray(position$1, position$1 += length);
  }
  let f32Array = new Float32Array(1);
  let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
  function getFloat16() {
    let byte0 = src[position$1++];
    let byte1 = src[position$1++];
    let exponent = (byte0 & 0x7f) >> 2;
    if (exponent === 0x1f) {
      // specials
      if (byte1 || byte0 & 3) return NaN;
      return byte0 & 0x80 ? -Infinity : Infinity;
    }
    if (exponent === 0) {
      // sub-normals
      // significand with 10 fractional bits and divided by 2^14
      let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
      return byte0 & 0x80 ? -abs : abs;
    }
    u8Array[3] = byte0 & 0x80 |
    // sign bit
    (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed
    u8Array[2] = (byte0 & 7) << 5 |
    // last exponent bit and first two mantissa bits
    byte1 >> 3; // next 5 bits of mantissa
    u8Array[1] = byte1 << 5; // last three bits of mantissa
    u8Array[0] = 0;
    return f32Array[0];
  }
  new Array(4096);
  class Tag {
    constructor(value, tag) {
      this.value = value;
      this.tag = tag;
    }
  }
  currentExtensions[0] = dateString => {
    // string date extension
    return new Date(dateString);
  };
  currentExtensions[1] = epochSec => {
    // numeric date extension
    return new Date(Math.round(epochSec * 1000));
  };
  currentExtensions[2] = buffer => {
    // bigint extension
    let value = BigInt(0);
    for (let i = 0, l = buffer.byteLength; i < l; i++) {
      value = BigInt(buffer[i]) + (value << BigInt(8));
    }
    return value;
  };
  currentExtensions[3] = buffer => {
    // negative bigint extension
    return BigInt(-1) - currentExtensions[2](buffer);
  };
  currentExtensions[4] = fraction => {
    // best to reparse to maintain accuracy
    return +(fraction[1] + 'e' + fraction[0]);
  };
  currentExtensions[5] = fraction => {
    // probably not sufficiently accurate
    return fraction[1] * Math.exp(fraction[0] * Math.log(2));
  };

  // the registration of the record definition extension
  const recordDefinition = (id, structure) => {
    id = id - 0xe000;
    let existingStructure = currentStructures[id];
    if (existingStructure && existingStructure.isShared) {
      (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
    }
    currentStructures[id] = structure;
    structure.read = createStructureReader(structure);
  };
  currentExtensions[LEGACY_RECORD_INLINE_ID] = data => {
    let length = data.length;
    let structure = data[1];
    recordDefinition(data[0], structure);
    let object = {};
    for (let i = 2; i < length; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = data[i];
    }
    return object;
  };
  currentExtensions[14] = value => {
    if (bundledStrings$1) return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 += value);
    return new Tag(value, 14);
  };
  currentExtensions[15] = value => {
    if (bundledStrings$1) return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value);
    return new Tag(value, 15);
  };
  let glbl = {
    Error,
    RegExp
  };
  currentExtensions[27] = data => {
    // http://cbor.schmorp.de/generic-object
    return (glbl[data[0]] || Error)(data[1], data[2]);
  };
  const packedTable = read => {
    if (src[position$1++] != 0x84) {
      let error = new Error('Packed values structure must be followed by a 4 element array');
      if (src.length < position$1) error.incomplete = true;
      throw error;
    }
    let newPackedValues = read(); // packed values
    if (!newPackedValues || !newPackedValues.length) {
      let error = new Error('Packed values structure must be followed by a 4 element array');
      error.incomplete = true;
      throw error;
    }
    packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
    packedValues.prefixes = read();
    packedValues.suffixes = read();
    return read(); // read the rump
  };
  packedTable.handlesRead = true;
  currentExtensions[51] = packedTable;
  currentExtensions[PACKED_REFERENCE_TAG_ID] = data => {
    // packed reference
    if (!packedValues) {
      if (currentDecoder.getShared) loadShared();else return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
    if (typeof data == 'number') return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
    let error = new Error('No support for non-integer packed references yet');
    if (data === undefined) error.incomplete = true;
    throw error;
  };

  // The following code is an incomplete implementation of http://cbor.schmorp.de/stringref
  // the real thing would need to implemennt more logic to populate the stringRefs table and
  // maintain a stack of stringRef "namespaces".
  //
  // currentExtensions[25] = (id) => {
  // 	return stringRefs[id]
  // }
  // currentExtensions[256] = (read) => {
  // 	stringRefs = []
  // 	try {
  // 		return read()
  // 	} finally {
  // 		stringRefs = null
  // 	}
  // }
  // currentExtensions[256].handlesRead = true

  currentExtensions[28] = read => {
    // shareable http://cbor.schmorp.de/value-sharing (for structured clones)
    if (!referenceMap) {
      referenceMap = new Map();
      referenceMap.id = 0;
    }
    let id = referenceMap.id++;
    let startingPosition = position$1;
    let token = src[position$1];
    let target;
    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
    // ahead past references to record structure definitions
    if (token >> 5 == 4) target = [];else target = {};
    let refEntry = {
      target
    }; // a placeholder object
    referenceMap.set(id, refEntry);
    let targetProperties = read(); // read the next value as the target object to id
    if (refEntry.used) {
      // there is a cycle, so we have to assign properties to original target
      if (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {
        // this means that the returned target does not match the targetProperties, so we need rerun the read to
        // have the correctly create instance be assigned as a reference, then we do the copy the properties back to the
        // target
        // reset the position so that the read can be repeated
        position$1 = startingPosition;
        // the returned instance is our new target for references
        target = targetProperties;
        referenceMap.set(id, {
          target
        });
        targetProperties = read();
      }
      return Object.assign(target, targetProperties);
    }
    refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one
    return targetProperties; // no cycle, can just use the returned read object
  };
  currentExtensions[28].handlesRead = true;
  currentExtensions[29] = id => {
    // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
    let refEntry = referenceMap.get(id);
    refEntry.used = true;
    return refEntry.target;
  };
  currentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  (currentExtensions[259] = read => {
    // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec
    // for decoding as a standard Map
    if (currentDecoder.mapsAsObjects) {
      currentDecoder.mapsAsObjects = false;
      restoreMapsAsObject = true;
    }
    return read();
  }).handlesRead = true;
  function combine(a, b) {
    if (typeof a === 'string') return a + b;
    if (a instanceof Array) return a.concat(b);
    return Object.assign({}, a, b);
  }
  function getPackedValues() {
    if (!packedValues) {
      if (currentDecoder.getShared) loadShared();else throw new Error('No packed values available');
    }
    return packedValues;
  }
  const SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'
  currentExtensionRanges.push((tag, input) => {
    if (tag >= 225 && tag <= 255) return combine(getPackedValues().prefixes[tag - 224], input);
    if (tag >= 28704 && tag <= 32767) return combine(getPackedValues().prefixes[tag - 28672], input);
    if (tag >= 1879052288 && tag <= 2147483647) return combine(getPackedValues().prefixes[tag - 1879048192], input);
    if (tag >= 216 && tag <= 223) return combine(input, getPackedValues().suffixes[tag - 216]);
    if (tag >= 27647 && tag <= 28671) return combine(input, getPackedValues().suffixes[tag - 27639]);
    if (tag >= 1811940352 && tag <= 1879048191) return combine(input, getPackedValues().suffixes[tag - 1811939328]);
    if (tag == SHARED_DATA_TAG_ID) {
      // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
      return {
        packedValues: packedValues,
        structures: currentStructures.slice(0),
        version: input
      };
    }
    if (tag == 55799)
      // self-descriptive CBOR tag, just return input value
      return input;
  });
  const isLittleEndianMachine$1 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
  const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == 'undefined' ? {
    name: 'BigUint64Array'
  } : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == 'undefined' ? {
    name: 'BigInt64Array'
  } : BigInt64Array, Float32Array, Float64Array];
  const typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
  for (let i = 0; i < typedArrays.length; i++) {
    registerTypedArray(typedArrays[i], typedArrayTags[i]);
  }
  function registerTypedArray(TypedArray, tag) {
    let dvMethod = 'get' + TypedArray.name.slice(0, -5);
    let bytesPerElement;
    if (typeof TypedArray === 'function') bytesPerElement = TypedArray.BYTES_PER_ELEMENT;else TypedArray = null;
    for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
      if (!littleEndian && bytesPerElement == 1) continue;
      let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0;
      currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine$1 ? buffer => {
        if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);
        if (!currentDecoder.copyBuffers) {
          // try provide a direct view, but will only work if we are byte-aligned
          if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer.byteOffset & 1) || bytesPerElement === 4 && !(buffer.byteOffset & 3) || bytesPerElement === 8 && !(buffer.byteOffset & 7)) return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);
        }
        // we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned
        return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
      } : buffer => {
        if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);
        let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        let elements = buffer.length >> sizeShift;
        let ta = new TypedArray(elements);
        let method = dv[dvMethod];
        for (let i = 0; i < elements; i++) {
          ta[i] = method.call(dv, i << sizeShift, littleEndian);
        }
        return ta;
      };
    }
  }
  function readBundleExt() {
    let length = readJustLength();
    let bundlePosition = position$1 + read();
    for (let i = 2; i < length; i++) {
      // skip past bundles that were already read
      let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards
      position$1 += bundleLength;
    }
    let dataPosition = position$1;
    position$1 = bundlePosition;
    bundledStrings$1 = [readStringJS(readJustLength()), readStringJS(readJustLength())];
    bundledStrings$1.position0 = 0;
    bundledStrings$1.position1 = 0;
    bundledStrings$1.postBundlePosition = position$1;
    position$1 = dataPosition;
    return read();
  }
  function readJustLength() {
    let token = src[position$1++] & 0x1f;
    if (token > 0x17) {
      switch (token) {
        case 0x18:
          token = src[position$1++];
          break;
        case 0x19:
          token = dataView.getUint16(position$1);
          position$1 += 2;
          break;
        case 0x1a:
          token = dataView.getUint32(position$1);
          position$1 += 4;
          break;
      }
    }
    return token;
  }
  function loadShared() {
    if (currentDecoder.getShared) {
      let sharedData = saveState(() => {
        // save the state in case getShared modifies our buffer
        src = null;
        return currentDecoder.getShared();
      }) || {};
      let updatedStructures = sharedData.structures || [];
      currentDecoder.sharedVersion = sharedData.version;
      packedValues = currentDecoder.sharedValues = sharedData.packedValues;
      if (currentStructures === true) currentDecoder.structures = currentStructures = updatedStructures;else currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
  function saveState(callback) {
    let savedSrcEnd = srcEnd;
    let savedPosition = position$1;
    let savedSrcStringStart = srcStringStart;
    let savedSrcStringEnd = srcStringEnd;
    let savedSrcString = srcString;
    let savedReferenceMap = referenceMap;
    let savedBundledStrings = bundledStrings$1;

    // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)
    let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed
    let savedStructures = currentStructures;
    let savedDecoder = currentDecoder;
    let savedSequentialMode = sequentialMode;
    let value = callback();
    srcEnd = savedSrcEnd;
    position$1 = savedPosition;
    srcStringStart = savedSrcStringStart;
    srcStringEnd = savedSrcStringEnd;
    srcString = savedSrcString;
    referenceMap = savedReferenceMap;
    bundledStrings$1 = savedBundledStrings;
    src = savedSrc;
    sequentialMode = savedSequentialMode;
    currentStructures = savedStructures;
    currentDecoder = savedDecoder;
    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
    return value;
  }
  function clearSource() {
    src = null;
    referenceMap = null;
    currentStructures = null;
  }
  function addExtension$1(extension) {
    currentExtensions[extension.tag] = extension.decode;
  }
  function setSizeLimits(limits) {
    if (limits.maxMapSize) maxMapSize = limits.maxMapSize;
    if (limits.maxArraySize) maxArraySize = limits.maxArraySize;
    if (limits.maxObjectSize) limits.maxObjectSize;
  }
  const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding
  for (let i = 0; i < 256; i++) {
    mult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103));
  }
  let defaultDecoder = new Decoder({
    useRecords: false
  });
  const decode = defaultDecoder.decode;
  const decodeMultiple = defaultDecoder.decodeMultiple;
  const FLOAT32_OPTIONS = {
    NEVER: 0,
    ALWAYS: 1,
    DECIMAL_ROUND: 3,
    DECIMAL_FIT: 4
  };
  function roundFloat32(float32Number) {
    f32Array[0] = float32Number;
    let multiplier = mult10[(u8Array[3] & 0x7f) << 1 | u8Array[2] >> 7];
    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
  }
  let textEncoder;
  try {
    textEncoder = new TextEncoder();
  } catch (error) {}
  let extensions, extensionClasses;
  const Buffer$1 = typeof globalThis === 'object' && globalThis.Buffer;
  const hasNodeBuffer = typeof Buffer$1 !== 'undefined';
  const ByteArrayAllocate = hasNodeBuffer ? Buffer$1.allocUnsafeSlow : Uint8Array;
  const ByteArray = hasNodeBuffer ? Buffer$1 : Uint8Array;
  const MAX_STRUCTURES = 0x100;
  const MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000;
  let throwOnIterable;
  let target;
  let targetView;
  let position = 0;
  let safeEnd;
  let bundledStrings = null;
  const MAX_BUNDLE_SIZE = 0xf000;
  const hasNonLatin = /[\u0080-\uFFFF]/;
  const RECORD_SYMBOL = Symbol('record-id');
  class Encoder extends Decoder {
    constructor(options) {
      super(options);
      this.offset = 0;
      let start;
      let sharedStructures;
      let hasSharedUpdate;
      let structures;
      let referenceMap;
      options = options || {};
      let encodeUtf8 = ByteArray.prototype.utf8Write ? function (string, position, maxBytes) {
        return target.utf8Write(string, position, maxBytes);
      } : textEncoder && textEncoder.encodeInto ? function (string, position) {
        return textEncoder.encodeInto(string, target.subarray(position)).written;
      } : false;
      let encoder = this;
      let hasSharedStructures = options.structures || options.saveStructures;
      let maxSharedStructures = options.maxSharedStructures;
      if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 128 : 0;
      if (maxSharedStructures > 8190) throw new Error('Maximum maxSharedStructure is 8190');
      let isSequential = options.sequential;
      if (isSequential) {
        maxSharedStructures = 0;
      }
      if (!this.structures) this.structures = [];
      if (this.saveStructures) this.saveShared = this.saveStructures;
      let samplingPackedValues,
        packedObjectMap,
        sharedValues = options.sharedValues;
      let sharedPackedObjectMap;
      if (sharedValues) {
        sharedPackedObjectMap = Object.create(null);
        for (let i = 0, l = sharedValues.length; i < l; i++) {
          sharedPackedObjectMap[sharedValues[i]] = i;
        }
      }
      let recordIdsToRemove = [];
      let transitionsCount = 0;
      let serializationsSinceTransitionRebuild = 0;
      this.mapEncode = function (value, encodeOptions) {
        // Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)
        if (this._keyMap && !this._mapped) {
          //console.log('encoding ', value)
          switch (value.constructor.name) {
            case 'Array':
              value = value.map(r => this.encodeKeys(r));
              break;
            //case 'Map': 
            //	value = this.encodeKeys(value)
            //	break
          }
          //this._mapped = true
        }
        return this.encode(value, encodeOptions);
      };
      this.encode = function (value, encodeOptions) {
        if (!target) {
          target = new ByteArrayAllocate(8192);
          targetView = new DataView(target.buffer, 0, 8192);
          position = 0;
        }
        safeEnd = target.length - 10;
        if (safeEnd - position < 0x800) {
          // don't start too close to the end, 
          target = new ByteArrayAllocate(target.length);
          targetView = new DataView(target.buffer, 0, target.length);
          safeEnd = target.length - 10;
          position = 0;
        } else if (encodeOptions === REUSE_BUFFER_MODE) position = position + 7 & 0x7ffffff8; // Word align to make any future copying of this buffer faster
        start = position;
        if (encoder.useSelfDescribedHeader) {
          targetView.setUint32(position, 0xd9d9f700); // tag two byte, then self-descriptive tag
          position += 3;
        }
        referenceMap = encoder.structuredClone ? new Map() : null;
        if (encoder.bundleStrings && typeof value !== 'string') {
          bundledStrings = [];
          bundledStrings.size = Infinity; // force a new bundle start on first string
        } else bundledStrings = null;
        sharedStructures = encoder.structures;
        if (sharedStructures) {
          if (sharedStructures.uninitialized) {
            let sharedData = encoder.getShared() || {};
            encoder.structures = sharedStructures = sharedData.structures || [];
            encoder.sharedVersion = sharedData.version;
            let sharedValues = encoder.sharedValues = sharedData.packedValues;
            if (sharedValues) {
              sharedPackedObjectMap = {};
              for (let i = 0, l = sharedValues.length; i < l; i++) sharedPackedObjectMap[sharedValues[i]] = i;
            }
          }
          let sharedStructuresLength = sharedStructures.length;
          if (sharedStructuresLength > maxSharedStructures && !isSequential) sharedStructuresLength = maxSharedStructures;
          if (!sharedStructures.transitions) {
            // rebuild our structure transitions
            sharedStructures.transitions = Object.create(null);
            for (let i = 0; i < sharedStructuresLength; i++) {
              let keys = sharedStructures[i];
              //console.log('shared struct keys:', keys)
              if (!keys) continue;
              let nextTransition,
                transition = sharedStructures.transitions;
              for (let j = 0, l = keys.length; j < l; j++) {
                if (transition[RECORD_SYMBOL] === undefined) transition[RECORD_SYMBOL] = i;
                let key = keys[j];
                nextTransition = transition[key];
                if (!nextTransition) {
                  nextTransition = transition[key] = Object.create(null);
                }
                transition = nextTransition;
              }
              transition[RECORD_SYMBOL] = i | 0x100000;
            }
          }
          if (!isSequential) sharedStructures.nextId = sharedStructuresLength;
        }
        if (hasSharedUpdate) hasSharedUpdate = false;
        structures = sharedStructures || [];
        packedObjectMap = sharedPackedObjectMap;
        if (options.pack) {
          let packedValues = new Map();
          packedValues.values = [];
          packedValues.encoder = encoder;
          packedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity);
          packedValues.objectMap = sharedPackedObjectMap || false;
          packedValues.samplingPackedValues = samplingPackedValues;
          findRepetitiveStrings(value, packedValues);
          if (packedValues.values.length > 0) {
            target[position++] = 0xd8; // one-byte tag
            target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
            writeArrayHeader(4);
            let valuesArray = packedValues.values;
            encode(valuesArray);
            writeArrayHeader(0); // prefixes
            writeArrayHeader(0); // suffixes
            packedObjectMap = Object.create(sharedPackedObjectMap || null);
            for (let i = 0, l = valuesArray.length; i < l; i++) {
              packedObjectMap[valuesArray[i]] = i;
            }
          }
        }
        throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
        try {
          if (throwOnIterable) return;
          encode(value);
          if (bundledStrings) {
            writeBundles(start, encode);
          }
          encoder.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
          if (referenceMap && referenceMap.idsToInsert) {
            position += referenceMap.idsToInsert.length * 2;
            if (position > safeEnd) makeRoom(position);
            encoder.offset = position;
            let serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert);
            referenceMap = null;
            return serialized;
          }
          if (encodeOptions & REUSE_BUFFER_MODE) {
            target.start = start;
            target.end = position;
            return target;
          }
          return target.subarray(start, position); // position can change if we call encode again in saveShared, so we get the buffer now
        } finally {
          if (sharedStructures) {
            if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;
            if (sharedStructures.length > maxSharedStructures) sharedStructures.length = maxSharedStructures;
            if (transitionsCount > 10000) {
              // force a rebuild occasionally after a lot of transitions so it can get cleaned up
              sharedStructures.transitions = null;
              serializationsSinceTransitionRebuild = 0;
              transitionsCount = 0;
              if (recordIdsToRemove.length > 0) recordIdsToRemove = [];
            } else if (recordIdsToRemove.length > 0 && !isSequential) {
              for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                recordIdsToRemove[i][RECORD_SYMBOL] = undefined;
              }
              recordIdsToRemove = [];
              //sharedStructures.nextId = maxSharedStructures
            }
          }
          if (hasSharedUpdate && encoder.saveShared) {
            if (encoder.structures.length > maxSharedStructures) {
              encoder.structures = encoder.structures.slice(0, maxSharedStructures);
            }
            // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
            let returnBuffer = target.subarray(start, position);
            if (encoder.updateSharedData() === false) return encoder.encode(value); // re-encode if it fails
            return returnBuffer;
          }
          if (encodeOptions & RESET_BUFFER_MODE) position = start;
        }
      };
      this.findCommonStringsToPack = () => {
        samplingPackedValues = new Map();
        if (!sharedPackedObjectMap) sharedPackedObjectMap = Object.create(null);
        return options => {
          let threshold = options && options.threshold || 4;
          let position = this.pack ? options.maxPrivatePackedValues || 16 : 0;
          if (!sharedValues) sharedValues = this.sharedValues = [];
          for (let [key, status] of samplingPackedValues) {
            if (status.count > threshold) {
              sharedPackedObjectMap[key] = position++;
              sharedValues.push(key);
              hasSharedUpdate = true;
            }
          }
          while (this.saveShared && this.updateSharedData() === false) {}
          samplingPackedValues = null;
        };
      };
      const encode = value => {
        if (position > safeEnd) target = makeRoom(position);
        var type = typeof value;
        var length;
        if (type === 'string') {
          if (packedObjectMap) {
            let packedPosition = packedObjectMap[value];
            if (packedPosition >= 0) {
              if (packedPosition < 16) target[position++] = packedPosition + 0xe0; // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
              else {
                target[position++] = 0xc6; // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
                if (packedPosition & 1) encode(15 - packedPosition >> 1);else encode(packedPosition - 16 >> 1);
              }
              return;
              /*						} else if (packedStatus.serializationId != serializationId) {
              							packedStatus.serializationId = serializationId
              							packedStatus.count = 1
              							if (options.sharedPack) {
              								let sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1
              								if (shareCount > (options.sharedPack.threshold || 5)) {
              									let sharedPosition = packedStatus.position = packedStatus.nextSharedPosition
              									hasSharedUpdate = true
              									if (sharedPosition < 16)
              										target[position++] = sharedPosition + 0xc0
              									}
              							}
              						} // else any in-doc incrementation?*/
            } else if (samplingPackedValues && !options.pack) {
              let status = samplingPackedValues.get(value);
              if (status) status.count++;else samplingPackedValues.set(value, {
                count: 1
              });
            }
          }
          let strLength = value.length;
          if (bundledStrings && strLength >= 4 && strLength < 0x400) {
            if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
              let extStart;
              let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
              if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);
              target[position++] = 0xd9; // tag 16-bit
              target[position++] = 0xdf; // tag 0xdff9
              target[position++] = 0xf9;
              // TODO: If we only have one bundle with any string data, only write one string bundle
              target[position++] = bundledStrings.position ? 0x84 : 0x82; // array of 4 or 2 elements depending on if we write bundles
              target[position++] = 0x1a; // 32-bit unsigned int
              extStart = position - start;
              position += 4; // reserve for writing bundle reference
              if (bundledStrings.position) {
                writeBundles(start, encode); // write the last bundles
              }
              bundledStrings = ['', '']; // create new ones
              bundledStrings.size = 0;
              bundledStrings.position = extStart;
            }
            let twoByte = hasNonLatin.test(value);
            bundledStrings[twoByte ? 0 : 1] += value;
            target[position++] = twoByte ? 0xce : 0xcf;
            encode(strLength);
            return;
          }
          let headerSize;
          // first we estimate the header size, so we can write to the correct location
          if (strLength < 0x20) {
            headerSize = 1;
          } else if (strLength < 0x100) {
            headerSize = 2;
          } else if (strLength < 0x10000) {
            headerSize = 3;
          } else {
            headerSize = 5;
          }
          let maxBytes = strLength * 3;
          if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);
          if (strLength < 0x40 || !encodeUtf8) {
            let i,
              c1,
              c2,
              strPosition = position + headerSize;
            for (i = 0; i < strLength; i++) {
              c1 = value.charCodeAt(i);
              if (c1 < 0x80) {
                target[strPosition++] = c1;
              } else if (c1 < 0x800) {
                target[strPosition++] = c1 >> 6 | 0xc0;
                target[strPosition++] = c1 & 0x3f | 0x80;
              } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {
                c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);
                i++;
                target[strPosition++] = c1 >> 18 | 0xf0;
                target[strPosition++] = c1 >> 12 & 0x3f | 0x80;
                target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
                target[strPosition++] = c1 & 0x3f | 0x80;
              } else {
                target[strPosition++] = c1 >> 12 | 0xe0;
                target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
                target[strPosition++] = c1 & 0x3f | 0x80;
              }
            }
            length = strPosition - position - headerSize;
          } else {
            length = encodeUtf8(value, position + headerSize, maxBytes);
          }
          if (length < 0x18) {
            target[position++] = 0x60 | length;
          } else if (length < 0x100) {
            if (headerSize < 2) {
              target.copyWithin(position + 2, position + 1, position + 1 + length);
            }
            target[position++] = 0x78;
            target[position++] = length;
          } else if (length < 0x10000) {
            if (headerSize < 3) {
              target.copyWithin(position + 3, position + 2, position + 2 + length);
            }
            target[position++] = 0x79;
            target[position++] = length >> 8;
            target[position++] = length & 0xff;
          } else {
            if (headerSize < 5) {
              target.copyWithin(position + 5, position + 3, position + 3 + length);
            }
            target[position++] = 0x7a;
            targetView.setUint32(position, length);
            position += 4;
          }
          position += length;
        } else if (type === 'number') {
          if (!this.alwaysUseFloat && value >>> 0 === value) {
            // positive integer, 32-bit or less
            // positive uint
            if (value < 0x18) {
              target[position++] = value;
            } else if (value < 0x100) {
              target[position++] = 0x18;
              target[position++] = value;
            } else if (value < 0x10000) {
              target[position++] = 0x19;
              target[position++] = value >> 8;
              target[position++] = value & 0xff;
            } else {
              target[position++] = 0x1a;
              targetView.setUint32(position, value);
              position += 4;
            }
          } else if (!this.alwaysUseFloat && value >> 0 === value) {
            // negative integer
            if (value >= -0x18) {
              target[position++] = 0x1f - value;
            } else if (value >= -0x100) {
              target[position++] = 0x38;
              target[position++] = ~value;
            } else if (value >= -0x10000) {
              target[position++] = 0x39;
              targetView.setUint16(position, ~value);
              position += 2;
            } else {
              target[position++] = 0x3a;
              targetView.setUint32(position, ~value);
              position += 4;
            }
          } else {
            let useFloat32;
            if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {
              target[position++] = 0xfa;
              targetView.setFloat32(position, value);
              let xShifted;
              if (useFloat32 < 4 ||
              // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
              (xShifted = value * mult10[(target[position] & 0x7f) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {
                position += 4;
                return;
              } else position--; // move back into position for writing a double
            }
            target[position++] = 0xfb;
            targetView.setFloat64(position, value);
            position += 8;
          }
        } else if (type === 'object') {
          if (!value) target[position++] = 0xf6;else {
            if (referenceMap) {
              let referee = referenceMap.get(value);
              if (referee) {
                target[position++] = 0xd8;
                target[position++] = 29; // http://cbor.schmorp.de/value-sharing
                target[position++] = 0x19; // 16-bit uint
                if (!referee.references) {
                  let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);
                  referee.references = [];
                  idsToInsert.push(referee);
                }
                referee.references.push(position - start);
                position += 2; // TODO: also support 32-bit
                return;
              } else referenceMap.set(value, {
                offset: position - start
              });
            }
            let constructor = value.constructor;
            if (constructor === Object) {
              writeObject(value);
            } else if (constructor === Array) {
              length = value.length;
              if (length < 0x18) {
                target[position++] = 0x80 | length;
              } else {
                writeArrayHeader(length);
              }
              for (let i = 0; i < length; i++) {
                encode(value[i]);
              }
            } else if (constructor === Map) {
              if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                // use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way
                target[position++] = 0xd9;
                target[position++] = 1;
                target[position++] = 3;
              }
              length = value.size;
              if (length < 0x18) {
                target[position++] = 0xa0 | length;
              } else if (length < 0x100) {
                target[position++] = 0xb8;
                target[position++] = length;
              } else if (length < 0x10000) {
                target[position++] = 0xb9;
                target[position++] = length >> 8;
                target[position++] = length & 0xff;
              } else {
                target[position++] = 0xba;
                targetView.setUint32(position, length);
                position += 4;
              }
              if (encoder.keyMap) {
                for (let [key, entryValue] of value) {
                  encode(encoder.encodeKey(key));
                  encode(entryValue);
                }
              } else {
                for (let [key, entryValue] of value) {
                  encode(key);
                  encode(entryValue);
                }
              }
            } else {
              for (let i = 0, l = extensions.length; i < l; i++) {
                let extensionClass = extensionClasses[i];
                if (value instanceof extensionClass) {
                  let extension = extensions[i];
                  let tag = extension.tag;
                  if (tag == undefined) tag = extension.getTag && extension.getTag.call(this, value);
                  if (tag < 0x18) {
                    target[position++] = 0xc0 | tag;
                  } else if (tag < 0x100) {
                    target[position++] = 0xd8;
                    target[position++] = tag;
                  } else if (tag < 0x10000) {
                    target[position++] = 0xd9;
                    target[position++] = tag >> 8;
                    target[position++] = tag & 0xff;
                  } else if (tag > -1) {
                    target[position++] = 0xda;
                    targetView.setUint32(position, tag);
                    position += 4;
                  } // else undefined, don't write tag
                  extension.encode.call(this, value, encode, makeRoom);
                  return;
                }
              }
              if (value[Symbol.iterator]) {
                if (throwOnIterable) {
                  let error = new Error('Iterable should be serialized as iterator');
                  error.iteratorNotHandled = true;
                  throw error;
                }
                target[position++] = 0x9f; // indefinite length array
                for (let entry of value) {
                  encode(entry);
                }
                target[position++] = 0xff; // stop-code
                return;
              }
              if (value[Symbol.asyncIterator] || isBlob(value)) {
                let error = new Error('Iterable/blob should be serialized as iterator');
                error.iteratorNotHandled = true;
                throw error;
              }
              if (this.useToJSON && value.toJSON) {
                const json = value.toJSON();
                // if for some reason value.toJSON returns itself it'll loop forever
                if (json !== value) return encode(json);
              }

              // no extension found, write as a plain object
              writeObject(value);
            }
          }
        } else if (type === 'boolean') {
          target[position++] = value ? 0xf5 : 0xf4;
        } else if (type === 'bigint') {
          if (value < BigInt(1) << BigInt(64) && value >= 0) {
            // use an unsigned int as long as it fits
            target[position++] = 0x1b;
            targetView.setBigUint64(position, value);
          } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
            // if we can fit an unsigned int, use that
            target[position++] = 0x3b;
            targetView.setBigUint64(position, -value - BigInt(1));
          } else {
            // overflow
            if (this.largeBigIntToFloat) {
              target[position++] = 0xfb;
              targetView.setFloat64(position, Number(value));
            } else {
              if (value >= BigInt(0)) target[position++] = 0xc2; // tag 2
              else {
                target[position++] = 0xc3; // tag 2
                value = BigInt(-1) - value;
              }
              let bytes = [];
              while (value) {
                bytes.push(Number(value & BigInt(0xff)));
                value >>= BigInt(8);
              }
              writeBuffer(new Uint8Array(bytes.reverse()), makeRoom);
              return;
            }
          }
          position += 8;
        } else if (type === 'undefined') {
          target[position++] = 0xf7;
        } else {
          throw new Error('Unknown type: ' + type);
        }
      };
      const writeObject = this.useRecords === false ? this.variableMapSize ? object => {
        // this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
        let keys = Object.keys(object);
        let vals = Object.values(object);
        let length = keys.length;
        if (length < 0x18) {
          target[position++] = 0xa0 | length;
        } else if (length < 0x100) {
          target[position++] = 0xb8;
          target[position++] = length;
        } else if (length < 0x10000) {
          target[position++] = 0xb9;
          target[position++] = length >> 8;
          target[position++] = length & 0xff;
        } else {
          target[position++] = 0xba;
          targetView.setUint32(position, length);
          position += 4;
        }
        if (encoder.keyMap) {
          for (let i = 0; i < length; i++) {
            encode(encoder.encodeKey(keys[i]));
            encode(vals[i]);
          }
        } else {
          for (let i = 0; i < length; i++) {
            encode(keys[i]);
            encode(vals[i]);
          }
        }
      } : object => {
        target[position++] = 0xb9; // always use map 16, so we can preallocate and set the length afterwards
        let objectOffset = position - start;
        position += 2;
        let size = 0;
        if (encoder.keyMap) {
          for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
            encode(encoder.encodeKey(key));
            encode(object[key]);
            size++;
          }
        } else {
          for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
            encode(key);
            encode(object[key]);
            size++;
          }
        }
        target[objectOffset++ + start] = size >> 8;
        target[objectOffset + start] = size & 0xff;
      } : (object, skipValues) => {
        let nextTransition,
          transition = structures.transitions || (structures.transitions = Object.create(null));
        let newTransitions = 0;
        let length = 0;
        let parentRecordId;
        let keys;
        if (this.keyMap) {
          keys = Object.keys(object).map(k => this.encodeKey(k));
          length = keys.length;
          for (let i = 0; i < length; i++) {
            let key = keys[i];
            nextTransition = transition[key];
            if (!nextTransition) {
              nextTransition = transition[key] = Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
          }
        } else {
          for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (!nextTransition) {
              if (transition[RECORD_SYMBOL] & 0x100000) {
                // this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it
                parentRecordId = transition[RECORD_SYMBOL] & 0xffff;
              }
              nextTransition = transition[key] = Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
            length++;
          }
        }
        let recordId = transition[RECORD_SYMBOL];
        if (recordId !== undefined) {
          recordId &= 0xffff;
          target[position++] = 0xd9;
          target[position++] = recordId >> 8 | 0xe0;
          target[position++] = recordId & 0xff;
        } else {
          if (!keys) keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
          if (parentRecordId === undefined) {
            recordId = structures.nextId++;
            if (!recordId) {
              recordId = 0;
              structures.nextId = 1;
            }
            if (recordId >= MAX_STRUCTURES) {
              // cycle back around
              structures.nextId = (recordId = maxSharedStructures) + 1;
            }
          } else {
            recordId = parentRecordId;
          }
          structures[recordId] = keys;
          if (recordId < maxSharedStructures) {
            target[position++] = 0xd9;
            target[position++] = recordId >> 8 | 0xe0;
            target[position++] = recordId & 0xff;
            transition = structures.transitions;
            for (let i = 0; i < length; i++) {
              if (transition[RECORD_SYMBOL] === undefined || transition[RECORD_SYMBOL] & 0x100000) transition[RECORD_SYMBOL] = recordId;
              transition = transition[keys[i]];
            }
            transition[RECORD_SYMBOL] = recordId | 0x100000; // indicates it is a extendable terminal
            hasSharedUpdate = true;
          } else {
            transition[RECORD_SYMBOL] = recordId;
            targetView.setUint32(position, 0xd9dfff00); // tag two byte, then record definition id
            position += 3;
            if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
            // record the removal of the id, we can maintain our shared structure
            if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures) recordIdsToRemove.shift()[RECORD_SYMBOL] = undefined; // we are cycling back through, and have to remove old ones
            recordIdsToRemove.push(transition);
            writeArrayHeader(length + 2);
            encode(0xe000 + recordId);
            encode(keys);
            if (skipValues) return; // special exit for iterator
            for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) encode(object[key]);
            return;
          }
        }
        if (length < 0x18) {
          // write the array header
          target[position++] = 0x80 | length;
        } else {
          writeArrayHeader(length);
        }
        if (skipValues) return; // special exit for iterator
        for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) encode(object[key]);
      };
      const makeRoom = end => {
        let newSize;
        if (end > 0x1000000) {
          // special handling for really large buffers
          if (end - start > MAX_BUFFER_SIZE) throw new Error('Encoded buffer would be larger than maximum buffer size');
          newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);
        } else
          // faster handling for smaller buffers
          newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
        let newBuffer = new ByteArrayAllocate(newSize);
        targetView = new DataView(newBuffer.buffer, 0, newSize);
        if (target.copy) target.copy(newBuffer, 0, start, end);else newBuffer.set(target.slice(start, end));
        position -= start;
        start = 0;
        safeEnd = newBuffer.length - 10;
        return target = newBuffer;
      };
      let chunkThreshold = 100;
      let continuedChunkThreshold = 1000;
      this.encodeAsIterable = function (value, options) {
        return startEncoding(value, options, encodeObjectAsIterable);
      };
      this.encodeAsAsyncIterable = function (value, options) {
        return startEncoding(value, options, encodeObjectAsAsyncIterable);
      };
      function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
        let constructor = object.constructor;
        if (constructor === Object) {
          let useRecords = encoder.useRecords !== false;
          if (useRecords) writeObject(object, true); // write the record identifier
          else writeEntityLength(Object.keys(object).length, 0xa0);
          for (let key in object) {
            let value = object[key];
            if (!useRecords) encode(key);
            if (value && typeof value === 'object') {
              if (iterateProperties[key]) yield* encodeObjectAsIterable(value, iterateProperties[key]);else yield* tryEncode(value, iterateProperties, key);
            } else encode(value);
          }
        } else if (constructor === Array) {
          let length = object.length;
          writeArrayHeader(length);
          for (let i = 0; i < length; i++) {
            let value = object[i];
            if (value && (typeof value === 'object' || position - start > chunkThreshold)) {
              if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);else yield* tryEncode(value, iterateProperties, 'element');
            } else encode(value);
          }
        } else if (object[Symbol.iterator] && !object.buffer) {
          // iterator, but exclude typed arrays
          target[position++] = 0x9f; // start indefinite array
          for (let value of object) {
            if (value && (typeof value === 'object' || position - start > chunkThreshold)) {
              if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);else yield* tryEncode(value, iterateProperties, 'element');
            } else encode(value);
          }
          target[position++] = 0xff; // stop byte
        } else if (isBlob(object)) {
          writeEntityLength(object.size, 0x40); // encode as binary data
          yield target.subarray(start, position);
          yield object; // directly return blobs, they have to be encoded asynchronously
          restartEncoding();
        } else if (object[Symbol.asyncIterator]) {
          target[position++] = 0x9f; // start indefinite array
          yield target.subarray(start, position);
          yield object; // directly return async iterators, they have to be encoded asynchronously
          restartEncoding();
          target[position++] = 0xff; // stop byte
        } else {
          encode(object);
        }
        if (finalIterable && position > start) yield target.subarray(start, position);else if (position - start > chunkThreshold) {
          yield target.subarray(start, position);
          restartEncoding();
        }
      }
      function* tryEncode(value, iterateProperties, key) {
        let restart = position - start;
        try {
          encode(value);
          if (position - start > chunkThreshold) {
            yield target.subarray(start, position);
            restartEncoding();
          }
        } catch (error) {
          if (error.iteratorNotHandled) {
            iterateProperties[key] = {};
            position = start + restart; // restart our position so we don't have partial data from last encode
            yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
          } else throw error;
        }
      }
      function restartEncoding() {
        chunkThreshold = continuedChunkThreshold;
        encoder.encode(null, THROW_ON_ITERABLE); // restart encoding
      }
      function startEncoding(value, options, encodeIterable) {
        if (options && options.chunkThreshold)
          // explicitly specified chunk sizes
          chunkThreshold = continuedChunkThreshold = options.chunkThreshold;else
          // we start with a smaller threshold to get initial bytes sent quickly
          chunkThreshold = 100;
        if (value && typeof value === 'object') {
          encoder.encode(null, THROW_ON_ITERABLE); // start encoding
          return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
        }
        return [encoder.encode(value)];
      }
      function encodeObjectAsAsyncIterable(_x, _x2) {
        return _encodeObjectAsAsyncIterable.apply(this, arguments);
      }
      function _encodeObjectAsAsyncIterable() {
        _encodeObjectAsAsyncIterable = _wrapAsyncGenerator(function* (value, iterateProperties) {
          for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
            let constructor = encodedValue.constructor;
            if (constructor === ByteArray || constructor === Uint8Array) yield encodedValue;else if (isBlob(encodedValue)) {
              let reader = encodedValue.stream().getReader();
              let next;
              while (!(next = yield _awaitAsyncGenerator(reader.read())).done) {
                yield next.value;
              }
            } else if (encodedValue[Symbol.asyncIterator]) {
              var _iteratorAbruptCompletion = false;
              var _didIteratorError = false;
              var _iteratorError;
              try {
                for (var _iterator = _asyncIterator(encodedValue), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {
                  let asyncValue = _step.value;
                  {
                    restartEncoding();
                    if (asyncValue) yield* _asyncGeneratorDelegate(_asyncIterator(encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}))), _awaitAsyncGenerator);else yield encoder.encode(asyncValue);
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (_iteratorAbruptCompletion && _iterator.return != null) {
                    yield _awaitAsyncGenerator(_iterator.return());
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            } else {
              yield encodedValue;
            }
          }
        });
        return _encodeObjectAsAsyncIterable.apply(this, arguments);
      }
    }
    useBuffer(buffer) {
      // this means we are finished using our own buffer and we can write over it safely
      target = buffer;
      targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
      position = 0;
    }
    clearSharedData() {
      if (this.structures) this.structures = [];
      if (this.sharedValues) this.sharedValues = undefined;
    }
    updateSharedData() {
      let lastVersion = this.sharedVersion || 0;
      this.sharedVersion = lastVersion + 1;
      let structuresCopy = this.structures.slice(0);
      let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
      let saveResults = this.saveShared(sharedData, existingShared => (existingShared && existingShared.version || 0) == lastVersion);
      if (saveResults === false) {
        // get updated structures and try again if the update failed
        sharedData = this.getShared() || {};
        this.structures = sharedData.structures || [];
        this.sharedValues = sharedData.packedValues;
        this.sharedVersion = sharedData.version;
        this.structures.nextId = this.structures.length;
      } else {
        // restore structures
        structuresCopy.forEach((structure, i) => this.structures[i] = structure);
      }
      // saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data
      return saveResults;
    }
  }
  function writeEntityLength(length, majorValue) {
    if (length < 0x18) target[position++] = majorValue | length;else if (length < 0x100) {
      target[position++] = majorValue | 0x18;
      target[position++] = length;
    } else if (length < 0x10000) {
      target[position++] = majorValue | 0x19;
      target[position++] = length >> 8;
      target[position++] = length & 0xff;
    } else {
      target[position++] = majorValue | 0x1a;
      targetView.setUint32(position, length);
      position += 4;
    }
  }
  class SharedData {
    constructor(structures, values, version) {
      this.structures = structures;
      this.packedValues = values;
      this.version = version;
    }
  }
  function writeArrayHeader(length) {
    if (length < 0x18) target[position++] = 0x80 | length;else if (length < 0x100) {
      target[position++] = 0x98;
      target[position++] = length;
    } else if (length < 0x10000) {
      target[position++] = 0x99;
      target[position++] = length >> 8;
      target[position++] = length & 0xff;
    } else {
      target[position++] = 0x9a;
      targetView.setUint32(position, length);
      position += 4;
    }
  }
  const BlobConstructor = typeof Blob === 'undefined' ? function () {} : Blob;
  function isBlob(object) {
    if (object instanceof BlobConstructor) return true;
    let tag = object[Symbol.toStringTag];
    return tag === 'Blob' || tag === 'File';
  }
  function findRepetitiveStrings(value, packedValues) {
    switch (typeof value) {
      case 'string':
        if (value.length > 3) {
          if (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues) return;
          let packedStatus = packedValues.get(value);
          if (packedStatus) {
            if (++packedStatus.count == 2) {
              packedValues.values.push(value);
            }
          } else {
            packedValues.set(value, {
              count: 1
            });
            if (packedValues.samplingPackedValues) {
              let status = packedValues.samplingPackedValues.get(value);
              if (status) status.count++;else packedValues.samplingPackedValues.set(value, {
                count: 1
              });
            }
          }
        }
        break;
      case 'object':
        if (value) {
          if (value instanceof Array) {
            for (let i = 0, l = value.length; i < l; i++) {
              findRepetitiveStrings(value[i], packedValues);
            }
          } else {
            let includeKeys = !packedValues.encoder.useRecords;
            for (var key in value) {
              if (value.hasOwnProperty(key)) {
                if (includeKeys) findRepetitiveStrings(key, packedValues);
                findRepetitiveStrings(value[key], packedValues);
              }
            }
          }
        }
        break;
      case 'function':
        console.log(value);
    }
  }
  const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
  extensionClasses = [Date, Set, Error, RegExp, Tag, ArrayBuffer, Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == 'undefined' ? function () {} : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == 'undefined' ? function () {} : BigInt64Array, Float32Array, Float64Array, SharedData];

  //Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/
  extensions = [{
    // Date
    tag: 1,
    encode(date, encode) {
      let seconds = date.getTime() / 1000;
      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {
        // Timestamp 32
        target[position++] = 0x1a;
        targetView.setUint32(position, seconds);
        position += 4;
      } else {
        // Timestamp float64
        target[position++] = 0xfb;
        targetView.setFloat64(position, seconds);
        position += 8;
      }
    }
  }, {
    // Set
    tag: 258,
    // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
    encode(set, encode) {
      let array = Array.from(set);
      encode(array);
    }
  }, {
    // Error
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(error, encode) {
      encode([error.name, error.message]);
    }
  }, {
    // RegExp
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(regex, encode) {
      encode(['RegExp', regex.source, regex.flags]);
    }
  }, {
    // Tag
    getTag(tag) {
      return tag.tag;
    },
    encode(tag, encode) {
      encode(tag.value);
    }
  }, {
    // ArrayBuffer
    encode(arrayBuffer, encode, makeRoom) {
      writeBuffer(arrayBuffer, makeRoom);
    }
  }, {
    // Uint8Array
    getTag(typedArray) {
      if (typedArray.constructor === Uint8Array) {
        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false) return 64;
      } // else no tag
    },
    encode(typedArray, encode, makeRoom) {
      writeBuffer(typedArray, makeRoom);
    }
  }, typedArrayEncoder(68, 1), typedArrayEncoder(69, 2), typedArrayEncoder(70, 4), typedArrayEncoder(71, 8), typedArrayEncoder(72, 1), typedArrayEncoder(77, 2), typedArrayEncoder(78, 4), typedArrayEncoder(79, 8), typedArrayEncoder(85, 4), typedArrayEncoder(86, 8), {
    encode(sharedData, encode) {
      // write SharedData
      let packedValues = sharedData.packedValues || [];
      let sharedStructures = sharedData.structures || [];
      if (packedValues.values.length > 0) {
        target[position++] = 0xd8; // one-byte tag
        target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
        writeArrayHeader(4);
        let valuesArray = packedValues.values;
        encode(valuesArray);
        writeArrayHeader(0); // prefixes
        writeArrayHeader(0); // suffixes
        packedObjectMap = Object.create(sharedPackedObjectMap || null);
        for (let i = 0, l = valuesArray.length; i < l; i++) {
          packedObjectMap[valuesArray[i]] = i;
        }
      }
      if (sharedStructures) {
        targetView.setUint32(position, 0xd9dffe00);
        position += 3;
        let definitions = sharedStructures.slice(0);
        definitions.unshift(0xe000);
        definitions.push(new Tag(sharedData.version, 0x53687264));
        encode(definitions);
      } else encode(new Tag(sharedData.version, 0x53687264));
    }
  }];
  function typedArrayEncoder(tag, size) {
    if (!isLittleEndianMachine && size > 1) tag -= 4; // the big endian equivalents are 4 less
    return {
      tag: tag,
      encode: function writeExtBuffer(typedArray, encode) {
        let length = typedArray.byteLength;
        let offset = typedArray.byteOffset || 0;
        let buffer = typedArray.buffer || typedArray;
        encode(hasNodeBuffer ? Buffer$1.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
      }
    };
  }
  function writeBuffer(buffer, makeRoom) {
    let length = buffer.byteLength;
    if (length < 0x18) {
      target[position++] = 0x40 + length;
    } else if (length < 0x100) {
      target[position++] = 0x58;
      target[position++] = length;
    } else if (length < 0x10000) {
      target[position++] = 0x59;
      target[position++] = length >> 8;
      target[position++] = length & 0xff;
    } else {
      target[position++] = 0x5a;
      targetView.setUint32(position, length);
      position += 4;
    }
    if (position + length >= target.length) {
      makeRoom(position + length);
    }
    // if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,
    // must wrap it to set it.
    target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position);
    position += length;
  }
  function insertIds(serialized, idsToInsert) {
    // insert the ids that need to be referenced for structured clones
    let nextId;
    let distanceToMove = idsToInsert.length * 2;
    let lastEnd = serialized.length - distanceToMove;
    idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
    for (let id = 0; id < idsToInsert.length; id++) {
      let referee = idsToInsert[id];
      referee.id = id;
      for (let position of referee.references) {
        serialized[position++] = id >> 8;
        serialized[position] = id & 0xff;
      }
    }
    while (nextId = idsToInsert.pop()) {
      let offset = nextId.offset;
      serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
      distanceToMove -= 2;
      let position = offset + distanceToMove;
      serialized[position++] = 0xd8;
      serialized[position++] = 28; // http://cbor.schmorp.de/value-sharing
      lastEnd = offset;
    }
    return serialized;
  }
  function writeBundles(start, encode) {
    targetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1); // the offset to bundle
    let writeStrings = bundledStrings;
    bundledStrings = null;
    encode(writeStrings[0]);
    encode(writeStrings[1]);
  }
  function addExtension(extension) {
    if (extension.Class) {
      if (!extension.encode) throw new Error('Extension has no encode function');
      extensionClasses.unshift(extension.Class);
      extensions.unshift(extension);
    }
    addExtension$1(extension);
  }
  let defaultEncoder = new Encoder({
    useRecords: false
  });
  const encode = defaultEncoder.encode;
  const encodeAsIterable = defaultEncoder.encodeAsIterable;
  const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
  const {
    NEVER,
    ALWAYS,
    DECIMAL_ROUND,
    DECIMAL_FIT
  } = FLOAT32_OPTIONS;
  const REUSE_BUFFER_MODE = 512;
  const RESET_BUFFER_MODE = 1024;
  const THROW_ON_ITERABLE = 2048;

  /**
   * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer
   * If the argument is only Async Iterable, the return value will be an Async Iterable.
   * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
   * @param {options} [options] - cbor-x Encoder options
   * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
   */
  function encodeIter(objectIterator) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!objectIterator || typeof objectIterator !== 'object') {
      throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable');
    } else if (typeof objectIterator[Symbol.iterator] === 'function') {
      return encodeIterSync(objectIterator, options);
    } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {
      return encodeIterAsync(objectIterator, options);
    } else {
      throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise');
    }
  }
  function* encodeIterSync(objectIterator, options) {
    const encoder = new Encoder(options);
    for (const value of objectIterator) {
      yield encoder.encode(value);
    }
  }
  function encodeIterAsync(_x3, _x4) {
    return _encodeIterAsync.apply(this, arguments);
  }
  /**
   * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
   * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
   * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
   * @param {object} [options] - Decoder options
   * @returns {IterableIterator|Promise.<AsyncIterableIterator}
   */
  function _encodeIterAsync() {
    _encodeIterAsync = _wrapAsyncGenerator(function* (objectIterator, options) {
      const encoder = new Encoder(options);
      var _iteratorAbruptCompletion2 = false;
      var _didIteratorError2 = false;
      var _iteratorError2;
      try {
        for (var _iterator2 = _asyncIterator(objectIterator), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {
          const value = _step2.value;
          {
            yield encoder.encode(value);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {
            yield _awaitAsyncGenerator(_iterator2.return());
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    });
    return _encodeIterAsync.apply(this, arguments);
  }
  function decodeIter(bufferIterator) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!bufferIterator || typeof bufferIterator !== 'object') {
      throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise');
    }
    const decoder = new Decoder(options);
    let incomplete;
    const parser = chunk => {
      let yields;
      // if there's incomplete data from previous chunk, concatinate and try again
      if (incomplete) {
        chunk = Buffer.concat([incomplete, chunk]);
        incomplete = undefined;
      }
      try {
        yields = decoder.decodeMultiple(chunk);
      } catch (err) {
        if (err.incomplete) {
          incomplete = chunk.slice(err.lastPosition);
          yields = err.values;
        } else {
          throw err;
        }
      }
      return yields;
    };
    if (typeof bufferIterator[Symbol.iterator] === 'function') {
      return function* iter() {
        for (const value of bufferIterator) {
          yield* parser(value);
        }
      }();
    } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {
      return function () {
        var _iter = _wrapAsyncGenerator(function* () {
          var _iteratorAbruptCompletion3 = false;
          var _didIteratorError3 = false;
          var _iteratorError3;
          try {
            for (var _iterator3 = _asyncIterator(bufferIterator), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _awaitAsyncGenerator(_iterator3.next())).done; _iteratorAbruptCompletion3 = false) {
              const value = _step3.value;
              {
                yield* _asyncGeneratorDelegate(_asyncIterator(parser(value)), _awaitAsyncGenerator);
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (_iteratorAbruptCompletion3 && _iterator3.return != null) {
                yield _awaitAsyncGenerator(_iterator3.return());
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        });
        function iter() {
          return _iter.apply(this, arguments);
        }
        return iter;
      }()();
    }
  }
  exports.ALWAYS = ALWAYS;
  exports.DECIMAL_FIT = DECIMAL_FIT;
  exports.DECIMAL_ROUND = DECIMAL_ROUND;
  exports.Decoder = Decoder;
  exports.Encoder = Encoder;
  exports.FLOAT32_OPTIONS = FLOAT32_OPTIONS;
  exports.NEVER = NEVER;
  exports.REUSE_BUFFER_MODE = REUSE_BUFFER_MODE;
  exports.Tag = Tag;
  exports.addExtension = addExtension;
  exports.clearSource = clearSource;
  exports.decode = decode;
  exports.decodeIter = decodeIter;
  exports.decodeMultiple = decodeMultiple;
  exports.encode = encode;
  exports.encodeAsAsyncIterable = encodeAsAsyncIterable;
  exports.encodeAsIterable = encodeAsIterable;
  exports.encodeIter = encodeIter;
  exports.isNativeAccelerationEnabled = isNativeAccelerationEnabled;
  exports.roundFloat32 = roundFloat32;
  exports.setSizeLimits = setSizeLimits;
});

/***/ }),

/***/ 5392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
var max_js_1 = __webpack_require__(1026);
Object.defineProperty(exports, "MAX", ({
  enumerable: true,
  get: function () {
    return max_js_1.default;
  }
}));
var nil_js_1 = __webpack_require__(2459);
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return nil_js_1.default;
  }
}));
var parse_js_1 = __webpack_require__(4243);
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return parse_js_1.default;
  }
}));
var stringify_js_1 = __webpack_require__(3149);
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return stringify_js_1.default;
  }
}));
var v1_js_1 = __webpack_require__(6431);
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return v1_js_1.default;
  }
}));
var v1ToV6_js_1 = __webpack_require__(2234);
Object.defineProperty(exports, "v1ToV6", ({
  enumerable: true,
  get: function () {
    return v1ToV6_js_1.default;
  }
}));
var v3_js_1 = __webpack_require__(481);
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return v3_js_1.default;
  }
}));
var v4_js_1 = __webpack_require__(356);
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return v4_js_1.default;
  }
}));
var v5_js_1 = __webpack_require__(6027);
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return v5_js_1.default;
  }
}));
var v6_js_1 = __webpack_require__(8926);
Object.defineProperty(exports, "v6", ({
  enumerable: true,
  get: function () {
    return v6_js_1.default;
  }
}));
var v6ToV1_js_1 = __webpack_require__(2022);
Object.defineProperty(exports, "v6ToV1", ({
  enumerable: true,
  get: function () {
    return v6ToV1_js_1.default;
  }
}));
var v7_js_1 = __webpack_require__(8237);
Object.defineProperty(exports, "v7", ({
  enumerable: true,
  get: function () {
    return v7_js_1.default;
  }
}));
var validate_js_1 = __webpack_require__(4184);
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return validate_js_1.default;
  }
}));
var version_js_1 = __webpack_require__(6732);
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return version_js_1.default;
  }
}));

/***/ }),

/***/ 1026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';

/***/ }),

/***/ 9448:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(8366);
__webpack_require__(9670);
__webpack_require__(98);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 0xff;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 0x80 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 0xff) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports["default"] = md5;

/***/ }),

/***/ 8045:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports["default"] = {
  randomUUID
};

/***/ }),

/***/ 2459:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = '00000000-0000-0000-0000-000000000000';

/***/ }),

/***/ 4243:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(98);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const validate_js_1 = __webpack_require__(4184);
function parse(uuid) {
  if (!(0, validate_js_1.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff, v / 0x100000000 & 0xff, v >>> 24 & 0xff, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff);
}
exports["default"] = parse;

/***/ }),

/***/ 2071:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

/***/ }),

/***/ 1357:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

/***/ }),

/***/ 4267:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(8366);
__webpack_require__(9670);
__webpack_require__(98);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 0x80;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
exports["default"] = sha1;

/***/ }),

/***/ 3149:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.unsafeStringify = unsafeStringify;
const validate_js_1 = __webpack_require__(4184);
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const uuid = unsafeStringify(arr, offset);
  if (!(0, validate_js_1.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
exports["default"] = stringify;

/***/ }),

/***/ 6431:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.updateV1State = updateV1State;
const rng_js_1 = __webpack_require__(1357);
const stringify_js_1 = __webpack_require__(3149);
const _state = {};
function v1(options, buf, offset) {
  var _options$_v, _options;
  let bytes;
  const isV6 = (_options$_v = (_options = options) === null || _options === void 0 ? void 0 : _options._v6) !== null && _options$_v !== void 0 ? _options$_v : false;
  if (options) {
    const optionsKeys = Object.keys(options);
    if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {
      options = undefined;
    }
  }
  if (options) {
    var _ref, _options$random, _options$rng, _options2;
    bytes = v1Bytes((_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = (_options2 = options).rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(_options2)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
  } else {
    const now = Date.now();
    const rnds = (0, rng_js_1.default)();
    updateV1State(_state, now, rnds);
    bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);
  }
  return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV1State(state, now, rnds) {
  var _state$msecs, _state$nsecs;
  (_state$msecs = state.msecs) !== null && _state$msecs !== void 0 ? _state$msecs : state.msecs = -Infinity;
  (_state$nsecs = state.nsecs) !== null && _state$nsecs !== void 0 ? _state$nsecs : state.nsecs = 0;
  if (now === state.msecs) {
    state.nsecs++;
    if (state.nsecs >= 10000) {
      state.node = undefined;
      state.nsecs = 0;
    }
  } else if (now > state.msecs) {
    state.nsecs = 0;
  } else if (now < state.msecs) {
    state.node = undefined;
  }
  if (!state.node) {
    state.node = rnds.slice(10, 16);
    state.node[0] |= 0x01;
    state.clockseq = (rnds[8] << 8 | rnds[9]) & 0x3fff;
  }
  state.msecs = now;
  return state;
}
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf) {
  var _msecs, _nsecs, _clockseq, _node;
  let offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
  }
  (_msecs = msecs) !== null && _msecs !== void 0 ? _msecs : msecs = Date.now();
  (_nsecs = nsecs) !== null && _nsecs !== void 0 ? _nsecs : nsecs = 0;
  (_clockseq = clockseq) !== null && _clockseq !== void 0 ? _clockseq : clockseq = (rnds[8] << 8 | rnds[9]) & 0x3fff;
  (_node = node) !== null && _node !== void 0 ? _node : node = rnds.slice(10, 16);
  msecs += 12219292800000;
  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  buf[offset++] = tl >>> 24 & 0xff;
  buf[offset++] = tl >>> 16 & 0xff;
  buf[offset++] = tl >>> 8 & 0xff;
  buf[offset++] = tl & 0xff;
  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  buf[offset++] = tmh >>> 8 & 0xff;
  buf[offset++] = tmh & 0xff;
  buf[offset++] = tmh >>> 24 & 0xf | 0x10;
  buf[offset++] = tmh >>> 16 & 0xff;
  buf[offset++] = clockseq >>> 8 | 0x80;
  buf[offset++] = clockseq & 0xff;
  for (let n = 0; n < 6; ++n) {
    buf[offset++] = node[n];
  }
  return buf;
}
exports["default"] = v1;

/***/ }),

/***/ 2234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(98);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = v1ToV6;
const parse_js_1 = __webpack_require__(4243);
const stringify_js_1 = __webpack_require__(3149);
function v1ToV6(uuid) {
  const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
  const v6Bytes = _v1ToV6(v1Bytes);
  return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
}
function _v1ToV6(v1Bytes) {
  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}

/***/ }),

/***/ 481:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
const md5_js_1 = __webpack_require__(9448);
const v35_js_1 = __webpack_require__(5042);
var v35_js_2 = __webpack_require__(5042);
Object.defineProperty(exports, "DNS", ({
  enumerable: true,
  get: function () {
    return v35_js_2.DNS;
  }
}));
Object.defineProperty(exports, "URL", ({
  enumerable: true,
  get: function () {
    return v35_js_2.URL;
  }
}));
function v3(value, namespace, buf, offset) {
  return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);
}
v3.DNS = v35_js_1.DNS;
v3.URL = v35_js_1.URL;
exports["default"] = v3;

/***/ }),

/***/ 5042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
exports.stringToBytes = stringToBytes;
exports["default"] = v35;
const parse_js_1 = __webpack_require__(4243);
const stringify_js_1 = __webpack_require__(3149);
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
exports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(version, hash, value, namespace, buf, offset) {
  var _namespace;
  const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;
  if (typeof namespace === 'string') {
    namespace = (0, parse_js_1.default)(namespace);
  }
  if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
    throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 0x0f | version;
  bytes[8] = bytes[8] & 0x3f | 0x80;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(bytes);
}

/***/ }),

/***/ 356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const native_js_1 = __webpack_require__(8045);
const rng_js_1 = __webpack_require__(1357);
const stringify_js_1 = __webpack_require__(3149);
function v4(options, buf, offset) {
  var _ref, _options$random, _options$rng, _options;
  if (native_js_1.default.randomUUID && !buf && !options) {
    return native_js_1.default.randomUUID();
  }
  options = options || {};
  const rnds = (_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = (_options = options).rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(_options)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1.default)();
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(rnds);
}
exports["default"] = v4;

/***/ }),

/***/ 6027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
const sha1_js_1 = __webpack_require__(4267);
const v35_js_1 = __webpack_require__(5042);
var v35_js_2 = __webpack_require__(5042);
Object.defineProperty(exports, "DNS", ({
  enumerable: true,
  get: function () {
    return v35_js_2.DNS;
  }
}));
Object.defineProperty(exports, "URL", ({
  enumerable: true,
  get: function () {
    return v35_js_2.URL;
  }
}));
function v5(value, namespace, buf, offset) {
  return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);
}
v5.DNS = v35_js_1.DNS;
v5.URL = v35_js_1.URL;
exports["default"] = v5;

/***/ }),

/***/ 8926:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const stringify_js_1 = __webpack_require__(3149);
const v1_js_1 = __webpack_require__(6431);
const v1ToV6_js_1 = __webpack_require__(2234);
function v6(options, buf, offset) {
  var _options, _offset;
  (_options = options) !== null && _options !== void 0 ? _options : options = {};
  (_offset = offset) !== null && _offset !== void 0 ? _offset : offset = 0;
  let bytes = (0, v1_js_1.default)(_objectSpread(_objectSpread({}, options), {}, {
    _v6: true
  }), new Uint8Array(16));
  bytes = (0, v1ToV6_js_1.default)(bytes);
  if (buf) {
    for (let i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v6;

/***/ }),

/***/ 2022:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(98);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = v6ToV1;
const parse_js_1 = __webpack_require__(4243);
const stringify_js_1 = __webpack_require__(3149);
function v6ToV1(uuid) {
  const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
  const v1Bytes = _v6ToV1(v6Bytes);
  return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
}
function _v6ToV1(v6Bytes) {
  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}

/***/ }),

/***/ 8237:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(8799);
__webpack_require__(5833);
__webpack_require__(1417);
__webpack_require__(9670);
__webpack_require__(973);
__webpack_require__(8213);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.updateV7State = updateV7State;
const rng_js_1 = __webpack_require__(1357);
const stringify_js_1 = __webpack_require__(3149);
const _state = {};
function v7(options, buf, offset) {
  let bytes;
  if (options) {
    var _ref, _options$random, _options$rng;
    bytes = v7Bytes((_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = options.rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(options)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
  } else {
    const now = Date.now();
    const rnds = (0, rng_js_1.default)();
    updateV7State(_state, now, rnds);
    bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
  }
  return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV7State(state, now, rnds) {
  var _state$msecs, _state$seq;
  (_state$msecs = state.msecs) !== null && _state$msecs !== void 0 ? _state$msecs : state.msecs = -Infinity;
  (_state$seq = state.seq) !== null && _state$seq !== void 0 ? _state$seq : state.seq = 0;
  if (now > state.msecs) {
    state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    state.msecs = now;
  } else {
    state.seq = state.seq + 1 | 0;
    if (state.seq === 0) {
      state.msecs++;
    }
  }
  return state;
}
function v7Bytes(rnds, msecs, seq, buf) {
  var _msecs, _seq;
  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
  }
  (_msecs = msecs) !== null && _msecs !== void 0 ? _msecs : msecs = Date.now();
  (_seq = seq) !== null && _seq !== void 0 ? _seq : seq = rnds[6] * 0x7f << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
  buf[offset++] = msecs / 0x10000000000 & 0xff;
  buf[offset++] = msecs / 0x100000000 & 0xff;
  buf[offset++] = msecs / 0x1000000 & 0xff;
  buf[offset++] = msecs / 0x10000 & 0xff;
  buf[offset++] = msecs / 0x100 & 0xff;
  buf[offset++] = msecs & 0xff;
  buf[offset++] = 0x70 | seq >>> 28 & 0x0f;
  buf[offset++] = seq >>> 20 & 0xff;
  buf[offset++] = 0x80 | seq >>> 14 & 0x3f;
  buf[offset++] = seq >>> 6 & 0xff;
  buf[offset++] = seq << 2 & 0xff | rnds[10] & 0x03;
  buf[offset++] = rnds[11];
  buf[offset++] = rnds[12];
  buf[offset++] = rnds[13];
  buf[offset++] = rnds[14];
  buf[offset++] = rnds[15];
  return buf;
}
exports["default"] = v7;

/***/ }),

/***/ 4184:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(9199);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const regex_js_1 = __webpack_require__(2071);
function validate(uuid) {
  return typeof uuid === 'string' && regex_js_1.default.test(uuid);
}
exports["default"] = validate;

/***/ }),

/***/ 6732:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const validate_js_1 = __webpack_require__(4184);
function version(uuid) {
  if (!(0, validate_js_1.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  return parseInt(uuid.slice(14, 15), 16);
}
exports["default"] = version;

/***/ }),

/***/ 5120:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":" ","CALLING_CAMERA_PERMISSION_DENIED":"    .       .","CALLING_CAMERA_PERMISSION_PROMPT":"   ","CALLING_CAMERA_STARTING":"  ","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":" ","CALLING_DISABLE_VIDEO":" ","CALLING_ENABLE_AUDIO":" ","CALLING_ENABLE_VIDEO":" ","CALLING_END":" ","CALLING_JOIN":"  ","CALLING_JOIN_PROMPT":"     .","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"    .      .","CALLING_MICROPHONE_PERMISSION_PROMPT":"   ","CALLING_NO_DEVICES":" ","CALLING_PERMISSION_NEEDED":" ","CALLING_REJECT":" ","CALLING_REJOIN_PROMPT":"     .     ","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"     ","CALLING_SAVE":"","CALLING_SELECT_CAMERA":" ","CALLING_SELECT_MICROPHONE":" ","CALLING_SELECT_SPEAKER":" ","CALLING_SHOW_CALL_SETTINGS":"  ","DENY":"","END_SESSION":"  Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"     .","FULL_DEVICE_REQUEST_TITLE":"   ","REMOTE_CONTROL_REQUEST_DESCRIPTION":"     .","REMOTE_CONTROL_REQUEST_TITLE":"   ","SESSION_REQUEST_DESCRIPTION":"         ","SESSION_REQUEST_TITLE":"  ","UNIVERSAL_PROXY_BLOCKED":"       ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"        .","UNIVERSAL_PROXY_REQUEST_TITLE":"  "}');

/***/ }),

/***/ 7337:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Povolit","CALLING_ACCEPT":"Pijmout","CALLING_CAMERA_OFF":"Kamera je vypnut","CALLING_CAMERA_PERMISSION_DENIED":"Pstup ke kamee odepen. Povolit jej v nastaven prohlee.","CALLING_CAMERA_PERMISSION_PROMPT":"Povolit pstup ke kamee","CALLING_CAMERA_STARTING":"Kamera se spout","CALLING_CANCEL":"Zruit","CALLING_DISABLE_AUDIO":"Zakzat zvuk","CALLING_DISABLE_VIDEO":"Zakzat video","CALLING_ENABLE_AUDIO":"Povolit zvuk","CALLING_ENABLE_VIDEO":"Povolit video","CALLING_END":"Ukonit hovor","CALLING_JOIN":"Pipojit se k hovoru","CALLING_JOIN_PROMPT":"Podpora by vs rda kontaktovala telefonicky.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"J","CALLING_MICROPHONE_PERMISSION_DENIED":"Pstup k mikrofonu odepen. Povolte jej v nastaven prohlee.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Povolit pstup k mikrofonu","CALLING_NO_DEVICES":"dn","CALLING_PERMISSION_NEEDED":"Vyadovno povolen","CALLING_REJECT":"Odmtnout hovor","CALLING_REJOIN_PROMPT":"Mte aktivn hovor s podprnm agentem. Chcete se znovu pipojit?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Vstoupit do videohovoru?","CALLING_SAVE":"Uloit","CALLING_SELECT_CAMERA":"Vyberte kameru","CALLING_SELECT_MICROPHONE":"Vybrat mikrofon","CALLING_SELECT_SPEAKER":"Vyberte reproduktor","CALLING_SHOW_CALL_SETTINGS":"Zobrazit nastaven hovoru","DENY":"Odmtnout","END_SESSION":"Zastavit sdlen","FULL_DEVICE_REQUEST_DESCRIPTION":"Podpora by si rda prohldla celou vai obrazovku.","FULL_DEVICE_REQUEST_TITLE":"Povolit pln snmn obrazovky?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Podpora by rda ovldala tuto strnku.","REMOTE_CONTROL_REQUEST_TITLE":"Povolit vzdlen ovldn?","SESSION_REQUEST_DESCRIPTION":"Podprn pracovnk by s vmi chtl doasn pouvat tuto webovou strnku.","SESSION_REQUEST_TITLE":"Povolit spolen prohlen?","UNIVERSAL_PROXY_BLOCKED":"Tuto webovou strnku nelze zobrazit s podprnm pracovnkem","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Agent podpory by vs rd sledoval na jin webov strnky.","UNIVERSAL_PROXY_REQUEST_TITLE":"Povolit pokraovn relace?"}');

/***/ }),

/***/ 1088:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Tillad","CALLING_ACCEPT":"Accepter","CALLING_CAMERA_OFF":"Kamera er slukket","CALLING_CAMERA_PERMISSION_DENIED":"Adgang til kamera ngtet. Aktivr det i dine browserindstillinger.","CALLING_CAMERA_PERMISSION_PROMPT":"Tillad adgang til kamera","CALLING_CAMERA_STARTING":"Kamera starter","CALLING_CANCEL":"Annuller","CALLING_DISABLE_AUDIO":"Deaktiver lyd","CALLING_DISABLE_VIDEO":"Deaktiver video","CALLING_ENABLE_AUDIO":"Aktiver lyd","CALLING_ENABLE_VIDEO":"Aktivr video","CALLING_END":"Afslut opkald","CALLING_JOIN":"Deltag i opkaldet","CALLING_JOIN_PROMPT":"En supportagent vil gerne ringe til dig.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Mig","CALLING_MICROPHONE_PERMISSION_DENIED":"Adgang til mikrofon ngtet. Aktivr det i dine browserindstillinger.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Tillad adgang til mikrofon","CALLING_NO_DEVICES":"Ingen","CALLING_PERMISSION_NEEDED":"Tilladelse ndvendig","CALLING_REJECT":"Afvis opkald","CALLING_REJOIN_PROMPT":"Du har en aktiv samtale med en supportagent. Vil du genoptage den?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Deltage i videoopkald?","CALLING_SAVE":"Gem </translateOnlyThis>","CALLING_SELECT_CAMERA":"Vlg kamera","CALLING_SELECT_MICROPHONE":"Vlg mikrofon","CALLING_SELECT_SPEAKER":"Vlg hjtaler","CALLING_SHOW_CALL_SETTINGS":"Vis opkaldsindstillinger","DENY":"Ngt","END_SESSION":"Stop deling","FULL_DEVICE_REQUEST_DESCRIPTION":"En supportagent nsker at se din hele skrm.","FULL_DEVICE_REQUEST_TITLE":"Tillad fuldskrmsoptagelse?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"En supportagent nsker at kontrollere denne side.","REMOTE_CONTROL_REQUEST_TITLE":"Tillad fjernbetjening?","SESSION_REQUEST_DESCRIPTION":"En supportagent nsker midlertidigt at bruge denne webside sammen med dig.","SESSION_REQUEST_TITLE":"Tillad cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Denne webside kan ikke vises sammen med en supportagent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"En supportagent vil gerne flge dig til andre websider.","UNIVERSAL_PROXY_REQUEST_TITLE":"Tillad fortsttelse af session?"}');

/***/ }),

/***/ 428:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Erlauben","CALLING_ACCEPT":"Akzeptieren","CALLING_CAMERA_OFF":"Kamera ist ausgeschaltet","CALLING_CAMERA_PERMISSION_DENIED":"Kamerazugriff verweigert. Aktivieren Sie ihn in den Browsereinstellungen.","CALLING_CAMERA_PERMISSION_PROMPT":"Zugriff auf die Kamera erlauben","CALLING_CAMERA_STARTING":"Kamera wird gestartet","CALLING_CANCEL":"Abbrechen","CALLING_DISABLE_AUDIO":"Audio deaktivieren","CALLING_DISABLE_VIDEO":"Video deaktivieren","CALLING_ENABLE_AUDIO":"Audio aktivieren","CALLING_ENABLE_VIDEO":"Video aktivieren","CALLING_END":"Anruf beenden","CALLING_JOIN":"Anruf beitreten","CALLING_JOIN_PROMPT":"Ein Support-Mitarbeiter mchte Sie anrufen.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ich","CALLING_MICROPHONE_PERMISSION_DENIED":"Zugriff auf Mikrofon verweigert. Aktivieren Sie diesen in den Browsereinstellungen.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Zugriff auf Mikrofon erlauben","CALLING_NO_DEVICES":"Keine","CALLING_PERMISSION_NEEDED":"Berechtigung erforderlich","CALLING_REJECT":"Anruf ablehnen","CALLING_REJOIN_PROMPT":"Sie sind in einem aktiven Gesprch mit einem Support-Mitarbeiter. Mchten Sie wieder beitreten?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Videoanruf starten?","CALLING_SAVE":"Speichern","CALLING_SELECT_CAMERA":"Kamera auswhlen","CALLING_SELECT_MICROPHONE":"Mikrofon auswhlen","CALLING_SELECT_SPEAKER":"Sprecher auswhlen","CALLING_SHOW_CALL_SETTINGS":"Anrufeinstellungen anzeigen","DENY":"Ablehnen","END_SESSION":"Cobrowse-Sitzung beenden","FULL_DEVICE_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter mchte Ihren gesamten Bildschirm anzeigen.","FULL_DEVICE_REQUEST_TITLE":"Vollstndige Bildschirmaufnahme erlauben?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter mchte diese Seite steuern.","REMOTE_CONTROL_REQUEST_TITLE":"Fernsteuerung erlauben?","SESSION_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter mchte diese Webseite vorbergehend mit Ihnen nutzen.","SESSION_REQUEST_TITLE":"Cobrowsing erlauben?","UNIVERSAL_PROXY_BLOCKED":"Diese Webseite kann nicht mit einem Support-Mitarbeiter angezeigt werden","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Ein Support-Mitarbeiter mchte Sie zu anderen Webseiten begleiten.","UNIVERSAL_PROXY_REQUEST_TITLE":"Sitzungsfortsetzung erlauben?"}');

/***/ }),

/***/ 5448:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Allow","CALLING_ACCEPT":"Accept","CALLING_CAMERA_OFF":"Camera is off","CALLING_CAMERA_PERMISSION_DENIED":"Camera access denied. Enable it in your browser settings.","CALLING_CAMERA_PERMISSION_PROMPT":"Allow access to camera","CALLING_CAMERA_STARTING":"Camera is starting","CALLING_CANCEL":"Cancel","CALLING_DISABLE_AUDIO":"Disable audio","CALLING_DISABLE_VIDEO":"Disable video","CALLING_ENABLE_AUDIO":"Enable audio","CALLING_ENABLE_VIDEO":"Enable video","CALLING_END":"End call","CALLING_JOIN":"Join call","CALLING_JOIN_PROMPT":"A support agent would like to call you.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Me","CALLING_MICROPHONE_PERMISSION_DENIED":"Microphone access denied. Enable it in your browser settings.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Allow access to microphone","CALLING_NO_DEVICES":"None","CALLING_PERMISSION_NEEDED":"Permission needed","CALLING_REJECT":"Reject call","CALLING_REJOIN_PROMPT":"You have an active call with a support agent. Do you want to rejoin?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Enter video call?","CALLING_SAVE":"Save","CALLING_SELECT_CAMERA":"Select camera","CALLING_SELECT_MICROPHONE":"Select microphone","CALLING_SELECT_SPEAKER":"Select speaker","CALLING_SHOW_CALL_SETTINGS":"Show call settings","DENY":"Deny","END_SESSION":"Stop Sharing","FULL_DEVICE_REQUEST_DESCRIPTION":"A support agent would like to view your entire screen.","FULL_DEVICE_REQUEST_TITLE":"Allow full screen capture?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"A support agent would like to control this page.","REMOTE_CONTROL_REQUEST_TITLE":"Allow remote control?","SESSION_REQUEST_DESCRIPTION":"A support agent would like to temporarily use this web page with you.","SESSION_REQUEST_TITLE":"Allow cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"This web page cannot be viewed with a support agent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"A support agent would like to follow you to other web pages.","UNIVERSAL_PROXY_REQUEST_TITLE":"Allow session continuation?"}');

/***/ }),

/***/ 9467:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceptar","CALLING_CAMERA_OFF":"La cmara est apagada","CALLING_CAMERA_PERMISSION_DENIED":"Acceso a la cmara denegado. Habiltelo en la configuracin de su navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acceso a la cmara","CALLING_CAMERA_STARTING":"La cmara se est iniciando","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desactivar audio","CALLING_DISABLE_VIDEO":"Desactivar video","CALLING_ENABLE_AUDIO":"Habilitar audio","CALLING_ENABLE_VIDEO":"Habilitar video","CALLING_END":"Finalizar llamada","CALLING_JOIN":"Unirse a la llamada","CALLING_JOIN_PROMPT":"Un agente de soporte desea llamarle.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Yo","CALLING_MICROPHONE_PERMISSION_DENIED":"Acceso al micrfono denegado. Habiltelo en la configuracin de su navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acceso al micrfono","CALLING_NO_DEVICES":"Ninguno","CALLING_PERMISSION_NEEDED":"Permiso necesario","CALLING_REJECT":"Rechazar llamada","CALLING_REJOIN_PROMPT":"Tienes una llamada activa con un agente de soporte. Deseas volver a unirte?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Ingresar a la videollamada?","CALLING_SAVE":"Guardar","CALLING_SELECT_CAMERA":"Seleccionar cmara","CALLING_SELECT_MICROPHONE":"Seleccionar micrfono","CALLING_SELECT_SPEAKER":"Seleccionar altavoz","CALLING_SHOW_CALL_SETTINGS":"Mostrar configuracin de llamada","DENY":"Denegar","END_SESSION":"Finalizar Sesin de Navegacin Conjunta","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agente de soporte quiere ver toda su pantalla.","FULL_DEVICE_REQUEST_TITLE":"Permitir captura completa de pantalla?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agente de soporte quiere controlar esta pgina.","REMOTE_CONTROL_REQUEST_TITLE":"Permitir control remoto?","SESSION_REQUEST_DESCRIPTION":"Un agente de soporte quiere usar temporalmente esta pgina web con usted.","SESSION_REQUEST_TITLE":"Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta pgina web no puede ser vista con un agente de soporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agente de soporte quiere seguirle a otras pginas web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permitir continuacin de sesin?"}');

/***/ }),

/***/ 831:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceptar","CALLING_CAMERA_OFF":"La cmara est apagada","CALLING_CAMERA_PERMISSION_DENIED":"Acceso a la cmara denegado. Habiltelo en la configuracin de su navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acceso a la cmara","CALLING_CAMERA_STARTING":"La cmara se est iniciando","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desactivar audio","CALLING_DISABLE_VIDEO":"Desactivar vdeo","CALLING_ENABLE_AUDIO":"Activar audio","CALLING_ENABLE_VIDEO":"Habilitar vdeo","CALLING_END":"Finalizar llamada","CALLING_JOIN":"Unirse a la llamada","CALLING_JOIN_PROMPT":"Un agente de soporte desea llamarle.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Yo","CALLING_MICROPHONE_PERMISSION_DENIED":"Acceso al micrfono denegado. Habiltelo en la configuracin de su navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acceso al micrfono","CALLING_NO_DEVICES":"Ninguno","CALLING_PERMISSION_NEEDED":"Permiso necesario","CALLING_REJECT":"Rechazar llamada","CALLING_REJOIN_PROMPT":"Tienes una llamada activa con un agente de soporte. Quieres volver a unirte?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Entrar a la videollamada?","CALLING_SAVE":"Guardar","CALLING_SELECT_CAMERA":"Seleccionar cmara","CALLING_SELECT_MICROPHONE":"Seleccionar micrfono","CALLING_SELECT_SPEAKER":"Seleccionar altavoz","CALLING_SHOW_CALL_SETTINGS":"Mostrar configuracin de llamadas","DENY":"Denegar","END_SESSION":"Finalizar Sesin","FULL_DEVICE_REQUEST_DESCRIPTION":"Un asistente de soporte solicita visualizar la totalidad de su pantalla.","FULL_DEVICE_REQUEST_TITLE":"Permitir captura completa de pantalla?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agente de soporte desea controlar esta pgina.","REMOTE_CONTROL_REQUEST_TITLE":"Permitir control remoto?","SESSION_REQUEST_DESCRIPTION":"Un agente de soporte quiere usar temporalmente esta pgina web con usted.","SESSION_REQUEST_TITLE":"Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta pgina web no puede ser vista con un agente de soporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agente de soporte desea seguirle a otras pginas web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permitir continuacin de sesin?"}');

/***/ }),

/***/ 3202:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Luba","CALLING_ACCEPT":"Nustu","CALLING_CAMERA_OFF":"Kaamera on vlja llitatud","CALLING_CAMERA_PERMISSION_DENIED":"Kaamera ligips keelatud. Luba see oma brauseri seadetes.","CALLING_CAMERA_PERMISSION_PROMPT":"Luba juurdeps kaamerale","CALLING_CAMERA_STARTING":"Kaamera kivitub","CALLING_CANCEL":"Thista","CALLING_DISABLE_AUDIO":"Llita heli vlja","CALLING_DISABLE_VIDEO":"Keela video","CALLING_ENABLE_AUDIO":"Luba heli","CALLING_ENABLE_VIDEO":"Luba video","CALLING_END":"Lpeta kne","CALLING_JOIN":"Liitu knega","CALLING_JOIN_PROMPT":"Toetusagend soovib teid helistada.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Mina","CALLING_MICROPHONE_PERMISSION_DENIED":"Mikrofoni ligips keelatud. Luba see oma brauseri seadetes.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Luba mikrofoni kasutamise igus","CALLING_NO_DEVICES":"Mitte kski","CALLING_PERMISSION_NEEDED":"Vaja luba","CALLING_REJECT":"Keela kne","CALLING_REJOIN_PROMPT":"Teilitate jooksval knel tugiteenuse esindajaga. Kas soovite uuesti hineda?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Esindaja","CALLING_REQUEST":"Sisene videoknesse?","CALLING_SAVE":"Salvesta","CALLING_SELECT_CAMERA":"Vali kaamera","CALLING_SELECT_MICROPHONE":"Vali mikrofon","CALLING_SELECT_SPEAKER":"Vali kneleja","CALLING_SHOW_CALL_SETTINGS":"Kuva kne seadeid","DENY":"Keeldu","END_SESSION":"Jaga jagamine lpetada","FULL_DEVICE_REQUEST_DESCRIPTION":"Tugiagendi soovib teie kogu ekraani vaadata.","FULL_DEVICE_REQUEST_TITLE":"Luba tisekraani salvestuse lubamine?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Tugiteenindaja soovib seda lehte juhtida.","REMOTE_CONTROL_REQUEST_TITLE":"Lubate kaugjuhtimist?","SESSION_REQUEST_DESCRIPTION":"Toetusagent soovib seda veebilehte teiega ajutiselt kasutada.","SESSION_REQUEST_TITLE":"Luba koosturundus?","UNIVERSAL_PROXY_BLOCKED":"Seda veebilehte ei saa vaadata koos tugiesindajaga","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Toetusagendi soovib teid teistele veebilehtedele jlgida.","UNIVERSAL_PROXY_REQUEST_TITLE":"Kas lubada seansi jtkamine?"}');

/***/ }),

/***/ 4818:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Salli","CALLING_ACCEPT":"Hyvksy","CALLING_CAMERA_OFF":"Kamera on pois plt","CALLING_CAMERA_PERMISSION_DENIED":"Kameran kytt estetty. Ota se kyttn selaimesi asetuksissa.","CALLING_CAMERA_PERMISSION_PROMPT":"Salli psy kameraan","CALLING_CAMERA_STARTING":"Kamera kynnistyy","CALLING_CANCEL":"Peruuta","CALLING_DISABLE_AUDIO":"Poista ni kytst","CALLING_DISABLE_VIDEO":"Poista video kytst","CALLING_ENABLE_AUDIO":"Ota ni kyttn","CALLING_ENABLE_VIDEO":"Ota video kyttn","CALLING_END":"Lopeta puhelu","CALLING_JOIN":"Liity puheluun","CALLING_JOIN_PROMPT":"Tukihenkil haluaisi soittaa sinulle.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Min","CALLING_MICROPHONE_PERMISSION_DENIED":"Mikrofonin kytt estetty. Ota se kyttn selaimesi asetuksissa.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Salli psy mikrofonille","CALLING_NO_DEVICES":"Ei mitn","CALLING_PERMISSION_NEEDED":"Lupa tarvitaan","CALLING_REJECT":"Hylk puhelu","CALLING_REJOIN_PROMPT":"Sinulla on aktiivinen puhelu tukiedustajan kanssa. Haluatko liitty uudelleen?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Asiakaspalvelija","CALLING_REQUEST":"Haluatko menn videopuheluun?","CALLING_SAVE":"Tallenna","CALLING_SELECT_CAMERA":"Valitse kamera","CALLING_SELECT_MICROPHONE":"Valitse mikrofoni","CALLING_SELECT_SPEAKER":"Valitse kaiutin","CALLING_SHOW_CALL_SETTINGS":"Nyt puheluasetukset","DENY":"Est","END_SESSION":"Lopeta jakaminen","FULL_DEVICE_REQUEST_DESCRIPTION":"Tukihenkil haluaa nhd koko nyttsi.","FULL_DEVICE_REQUEST_TITLE":"Sallitaanko kokoruudun tallennus?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Tukihenkil haluaisi ohjata tt sivua.","REMOTE_CONTROL_REQUEST_TITLE":"Sallitaanko etohjaus?","SESSION_REQUEST_DESCRIPTION":"Asiakaspalvelija haluaisi vliaikaisesti kytt tt verkkosivua kanssasi.","SESSION_REQUEST_TITLE":"Salli yhteisselaus?","UNIVERSAL_PROXY_BLOCKED":"Tt verkkosivua ei voi tarkastella tukihenkiln kanssa","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Tukihenkil haluaa seurata sinua muille verkkosivuille.","UNIVERSAL_PROXY_REQUEST_TITLE":"Sallitaanko istunnon jatkaminen?"}');

/***/ }),

/***/ 9867:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Autoriser","CALLING_ACCEPT":"Accepter","CALLING_CAMERA_OFF":"La camra est teinte","CALLING_CAMERA_PERMISSION_DENIED":"Accs  la camra refus. Activez-le dans les paramtres de votre navigateur.","CALLING_CAMERA_PERMISSION_PROMPT":"Autoriser l\'accs  la camra","CALLING_CAMERA_STARTING":"La camra dmarre","CALLING_CANCEL":"Annuler","CALLING_DISABLE_AUDIO":"Dsactiver l\'audio","CALLING_DISABLE_VIDEO":"Dsactiver la vido","CALLING_ENABLE_AUDIO":"Activer l\'audio","CALLING_ENABLE_VIDEO":"Activer la vido","CALLING_END":"Terminer l\'appel","CALLING_JOIN":"Rejoindre l\'appel","CALLING_JOIN_PROMPT":"Un agent de support souhaite vous appeler.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Moi","CALLING_MICROPHONE_PERMISSION_DENIED":"Accs au microphone refus. Activez-le dans les paramtres de votre navigateur.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Autoriser l\'accs au microphone","CALLING_NO_DEVICES":"Aucun","CALLING_PERMISSION_NEEDED":"Permission requise","CALLING_REJECT":"Rejeter l\'appel","CALLING_REJOIN_PROMPT":"Vous tes en communication avec un agent de support. Voulez-vous rejoindre  nouveau ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Entrer dans l\'appel vido ?","CALLING_SAVE":"Enregistrer","CALLING_SELECT_CAMERA":"Slectionner la camra","CALLING_SELECT_MICROPHONE":"Slectionner un microphone","CALLING_SELECT_SPEAKER":"Slectionner le haut-parleur","CALLING_SHOW_CALL_SETTINGS":"Afficher les paramtres d\'appel","DENY":"Refuser","END_SESSION":"Terminer la session de Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agent de soutien souhaiterait voir l\'intgralit de votre cran.","FULL_DEVICE_REQUEST_TITLE":"Autoriser la capture d\'cran complte ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agent du soutien souhaiterait avoir le contrle de cette page.","REMOTE_CONTROL_REQUEST_TITLE":"Autoriser le contrle  distance ?","SESSION_REQUEST_DESCRIPTION":"Un agent de soutien souhaiterait temporairement utiliser cette page Web avec vous.","SESSION_REQUEST_TITLE":"Autoriser le cobrowsing ?","UNIVERSAL_PROXY_BLOCKED":"Cette page Web ne peut pas tre vue avec un agent de soutien","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agent de soutien souhaiterait vous suivre vers d\'autres pages Web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Autoriser la continuation de session ?"}');

/***/ }),

/***/ 7876:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":" ","CALLING_ACCEPT":" ","CALLING_CAMERA_OFF":"  ","CALLING_CAMERA_PERMISSION_DENIED":"         ","CALLING_CAMERA_PERMISSION_PROMPT":"     ","CALLING_CAMERA_STARTING":"    ","CALLING_CANCEL":" ","CALLING_DISABLE_AUDIO":"  ","CALLING_DISABLE_VIDEO":"  ","CALLING_ENABLE_AUDIO":"  ","CALLING_ENABLE_VIDEO":"  ","CALLING_END":"  ","CALLING_JOIN":"   ","CALLING_JOIN_PROMPT":"       ","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"         ","CALLING_MICROPHONE_PERMISSION_PROMPT":"     ","CALLING_NO_DEVICES":" ","CALLING_PERMISSION_NEEDED":"  ","CALLING_REJECT":"  ","CALLING_REJOIN_PROMPT":"              ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"    ?","CALLING_SAVE":"","CALLING_SELECT_CAMERA":" ","CALLING_SELECT_MICROPHONE":" ","CALLING_SELECT_SPEAKER":" ","CALLING_SHOW_CALL_SETTINGS":"  ","DENY":" ","END_SESSION":"   ","FULL_DEVICE_REQUEST_DESCRIPTION":"       ","FULL_DEVICE_REQUEST_TITLE":"     ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"         ","REMOTE_CONTROL_REQUEST_TITLE":"    ?","SESSION_REQUEST_DESCRIPTION":"              ","SESSION_REQUEST_TITLE":"   ?","UNIVERSAL_PROXY_BLOCKED":"          ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"          ","UNIVERSAL_PROXY_REQUEST_TITLE":"    ?"}');

/***/ }),

/***/ 8038:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Consenti","CALLING_ACCEPT":"Accetta","CALLING_CAMERA_OFF":"La fotocamera  spenta","CALLING_CAMERA_PERMISSION_DENIED":"Accesso alla fotocamera negato. Attivalo nelle impostazioni del tuo browser.","CALLING_CAMERA_PERMISSION_PROMPT":"Consenti l\'accesso alla fotocamera","CALLING_CAMERA_STARTING":"La fotocamera si sta avviando","CALLING_CANCEL":"Annulla","CALLING_DISABLE_AUDIO":"Disabilita audio","CALLING_DISABLE_VIDEO":"Disabilita video","CALLING_ENABLE_AUDIO":"Abilita audio","CALLING_ENABLE_VIDEO":"Abilita video","CALLING_END":"Termina chiamata","CALLING_JOIN":"Partecipa alla chiamata","CALLING_JOIN_PROMPT":"Un agente di supporto desidera chiamarla.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Me","CALLING_MICROPHONE_PERMISSION_DENIED":"Accesso al microfono negato. Abilitalo nelle impostazioni del browser.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Consenti l\'accesso al microfono","CALLING_NO_DEVICES":"Nessuno","CALLING_PERMISSION_NEEDED":"Permesso necessario","CALLING_REJECT":"Rifiuta chiamata","CALLING_REJOIN_PROMPT":"Hai una chiamata attiva con un agente di supporto. Vuoi rientrare?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Avviare la videochiamata?","CALLING_SAVE":"Salva","CALLING_SELECT_CAMERA":"Seleziona la fotocamera","CALLING_SELECT_MICROPHONE":"Seleziona microfono","CALLING_SELECT_SPEAKER":"Seleziona altoparlante","CALLING_SHOW_CALL_SETTINGS":"Mostra impostazioni chiamata","DENY":"Nega","END_SESSION":"Termina la sessione di Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agente dell\'assistenza desidera visualizzare tutto il tuo schermo.","FULL_DEVICE_REQUEST_TITLE":"Consentire cattura schermo completa?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agente dell\'assistenza desidera controllare questa pagina.","REMOTE_CONTROL_REQUEST_TITLE":"Consentire controllo remoto?","SESSION_REQUEST_DESCRIPTION":"Un agente dell\'assistenza vorrebbe utilizzare temporaneamente questa pagina web con te.","SESSION_REQUEST_TITLE":"Consentire cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Questa pagina web non pu essere visualizzata con un agente dell\'assistenza","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agente dell\'assistenza vorrebbe seguirti su altre pagine web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Consentire continuazione sessione?"}');

/***/ }),

/***/ 6582:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":"","CALLING_CAMERA_PERMISSION_DENIED":"","CALLING_CAMERA_PERMISSION_PROMPT":"","CALLING_CAMERA_STARTING":"","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":"","CALLING_DISABLE_VIDEO":"","CALLING_ENABLE_AUDIO":"","CALLING_ENABLE_VIDEO":"","CALLING_END":"","CALLING_JOIN":"","CALLING_JOIN_PROMPT":"","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"","CALLING_MICROPHONE_PERMISSION_PROMPT":"","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":"","CALLING_REJECT":"","CALLING_REJOIN_PROMPT":"","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"","CALLING_SAVE":"","CALLING_SELECT_CAMERA":"","CALLING_SELECT_MICROPHONE":"","CALLING_SELECT_SPEAKER":"","CALLING_SHOW_CALL_SETTINGS":"","DENY":"","END_SESSION":"","FULL_DEVICE_REQUEST_DESCRIPTION":"","FULL_DEVICE_REQUEST_TITLE":"","REMOTE_CONTROL_REQUEST_DESCRIPTION":"","REMOTE_CONTROL_REQUEST_TITLE":"","SESSION_REQUEST_DESCRIPTION":"Web","SESSION_REQUEST_TITLE":"","UNIVERSAL_PROXY_BLOCKED":"Web","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Web","UNIVERSAL_PROXY_REQUEST_TITLE":""}');

/***/ }),

/***/ 1753:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":" ","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":" ","CALLING_CAMERA_PERMISSION_DENIED":"   .    .","CALLING_CAMERA_PERMISSION_PROMPT":"   ","CALLING_CAMERA_STARTING":"  ","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":" ","CALLING_DISABLE_VIDEO":" ","CALLING_ENABLE_AUDIO":" ","CALLING_ENABLE_VIDEO":" ","CALLING_END":" ","CALLING_JOIN":" ","CALLING_JOIN_PROMPT":"      .","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"   .    .","CALLING_MICROPHONE_PERMISSION_PROMPT":"  ","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":" ","CALLING_REJECT":" ","CALLING_REJOIN_PROMPT":"     .    ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"    ?","CALLING_SAVE":"","CALLING_SELECT_CAMERA":" ","CALLING_SELECT_MICROPHONE":" ","CALLING_SELECT_SPEAKER":" ","CALLING_SHOW_CALL_SETTINGS":"  ","DENY":" ","END_SESSION":"   ","FULL_DEVICE_REQUEST_DESCRIPTION":"     .","FULL_DEVICE_REQUEST_TITLE":"     ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"     .","REMOTE_CONTROL_REQUEST_TITLE":"    ?","SESSION_REQUEST_DESCRIPTION":"   -    .","SESSION_REQUEST_TITLE":"   ?","UNIVERSAL_PROXY_BLOCKED":" -      ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"    -     .","UNIVERSAL_PROXY_REQUEST_TITLE":"    ?"}');

/***/ }),

/***/ 5613:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":"  ","CALLING_CAMERA_PERMISSION_DENIED":"  .   .","CALLING_CAMERA_PERMISSION_PROMPT":"  ","CALLING_CAMERA_STARTING":"  ","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":" ","CALLING_DISABLE_VIDEO":" ","CALLING_ENABLE_AUDIO":" ","CALLING_ENABLE_VIDEO":" ","CALLING_END":" ","CALLING_JOIN":" ","CALLING_JOIN_PROMPT":"    .","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"  .   .","CALLING_MICROPHONE_PERMISSION_PROMPT":"  ","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":" ","CALLING_REJECT":" ","CALLING_REJOIN_PROMPT":"   .  ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"  ?","CALLING_SAVE":"","CALLING_SELECT_CAMERA":" ","CALLING_SELECT_MICROPHONE":" ","CALLING_SELECT_SPEAKER":" ","CALLING_SHOW_CALL_SETTINGS":"  ","DENY":"","END_SESSION":"Cobrowse  ","FULL_DEVICE_REQUEST_DESCRIPTION":"      .","FULL_DEVICE_REQUEST_TITLE":"   ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"     .","REMOTE_CONTROL_REQUEST_TITLE":"  ?","SESSION_REQUEST_DESCRIPTION":"         .","SESSION_REQUEST_TITLE":" ?","UNIVERSAL_PROXY_BLOCKED":"        ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"       .","UNIVERSAL_PROXY_REQUEST_TITLE":"  ?"}');

/***/ }),

/***/ 2391:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Leisti","CALLING_ACCEPT":"Priimti","CALLING_CAMERA_OFF":"Kamera ijungta","CALLING_CAMERA_PERMISSION_DENIED":"Prieiga prie kameros udrausta. galinkite j savo narykls nustatymuose.","CALLING_CAMERA_PERMISSION_PROMPT":"Leisti prieig prie kameros","CALLING_CAMERA_STARTING":"Kamera pradedama veikti","CALLING_CANCEL":"Ataukti","CALLING_DISABLE_AUDIO":"Ijungti gars","CALLING_DISABLE_VIDEO":"Ijungti vaizdo ra","CALLING_ENABLE_AUDIO":"jungti gars","CALLING_ENABLE_VIDEO":"jungti vaizdo ra","CALLING_END":"Baigti skambut","CALLING_JOIN":"Prisijungti prie skambuio","CALLING_JOIN_PROMPT":"Paramaus agentas nort jums paskambinti.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Mano","CALLING_MICROPHONE_PERMISSION_DENIED":"Prieiga prie mikrofono atmesta. galinkite j savo narykls nustatymuose.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Leisti prieig prie mikrofono","CALLING_NO_DEVICES":"Nra","CALLING_PERMISSION_NEEDED":"Reikalinga leidimas","CALLING_REJECT":"Atmesti skambut","CALLING_REJOIN_PROMPT":"Js turite aktyv skambut su palaikymo agentu. Ar norite vl prisijungti?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agentas","CALLING_REQUEST":"Pradti vaizdo skambut?","CALLING_SAVE":"Isaugoti","CALLING_SELECT_CAMERA":"Pasirinkite kamer","CALLING_SELECT_MICROPHONE":"Pasirinkite mikrofon","CALLING_SELECT_SPEAKER":"Pasirinkite kalbtoj","CALLING_SHOW_CALL_SETTINGS":"Rodyti skambuio nustatymus","DENY":"Atmesti","END_SESSION":"Nutraukti bendrinim","FULL_DEVICE_REQUEST_DESCRIPTION":"Pagalbos agentas nort perirti vis js ekran.","FULL_DEVICE_REQUEST_TITLE":"Leisti fiksuoti vis ekran?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Palaikymo agentas nort valdyti  puslap.","REMOTE_CONTROL_REQUEST_TITLE":"Leisti nuotolin kontrol?","SESSION_REQUEST_DESCRIPTION":"Pagalbos agentas nort laikinai naudotis iuo tinklapiu kartu su jumis.","SESSION_REQUEST_TITLE":"Leisti bendr narym?","UNIVERSAL_PROXY_BLOCKED":"io puslapio negalima perirti su palaikymo agentu","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Pagalbos agentas nort jus sekti  kitas interneto svetaines.","UNIVERSAL_PROXY_REQUEST_TITLE":"Leisti tsti sesij?"}');

/***/ }),

/***/ 9396:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":" ","CALLING_ACCEPT":" ","CALLING_CAMERA_OFF":"  ","CALLING_CAMERA_PERMISSION_DENIED":"   .      .","CALLING_CAMERA_PERMISSION_PROMPT":"  ","CALLING_CAMERA_STARTING":"   ","CALLING_CANCEL":" ","CALLING_DISABLE_AUDIO":"  ","CALLING_DISABLE_VIDEO":"  ","CALLING_ENABLE_AUDIO":"  ","CALLING_ENABLE_VIDEO":"  ","CALLING_END":" ","CALLING_JOIN":"  ","CALLING_JOIN_PROMPT":"     .","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"    .      .","CALLING_MICROPHONE_PERMISSION_PROMPT":"   ","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":"  ","CALLING_REJECT":" ","CALLING_REJOIN_PROMPT":"     .    ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"     ?","CALLING_SAVE":" ","CALLING_SELECT_CAMERA":" ","CALLING_SELECT_MICROPHONE":" ","CALLING_SELECT_SPEAKER":" ","CALLING_SHOW_CALL_SETTINGS":"  ","DENY":" ","END_SESSION":"   ","FULL_DEVICE_REQUEST_DESCRIPTION":"      .","FULL_DEVICE_REQUEST_TITLE":"    ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"       .","REMOTE_CONTROL_REQUEST_TITLE":"   ?","SESSION_REQUEST_DESCRIPTION":"        .","SESSION_REQUEST_TITLE":"  ?","UNIVERSAL_PROXY_BLOCKED":"        ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"         .","UNIVERSAL_PROXY_REQUEST_TITLE":"   ?"}');

/***/ }),

/***/ 8439:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Benarkan","CALLING_ACCEPT":"Terima","CALLING_CAMERA_OFF":"Kamera dimatikan","CALLING_CAMERA_PERMISSION_DENIED":"Akses kamera dinafi. Aktifkannya dalam tetapan pelayar anda.","CALLING_CAMERA_PERMISSION_PROMPT":"Benarkan akses ke kamera","CALLING_CAMERA_STARTING":"Kamera sedang dimulakan","CALLING_CANCEL":"Batal","CALLING_DISABLE_AUDIO":"Lumpuhkan audio","CALLING_DISABLE_VIDEO":"Lumpuhkan video","CALLING_ENABLE_AUDIO":"Dayakan audio","CALLING_ENABLE_VIDEO":"Dayakan video","CALLING_END":"Tamatkan panggilan","CALLING_JOIN":"Sertai panggilan","CALLING_JOIN_PROMPT":"Ejen sokongan ingin menghubungi anda.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Saya","CALLING_MICROPHONE_PERMISSION_DENIED":"Akses mikrofon ditolak. Aktifkan dalam tetapan pelayar anda.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Benarkan akses ke mikrofon","CALLING_NO_DEVICES":"Tiada","CALLING_PERMISSION_NEEDED":"Kebenaran diperlukan","CALLING_REJECT":"Tolak panggilan","CALLING_REJOIN_PROMPT":"Anda sedang dalam panggilan aktif dengan ejen sokongan. Adakah anda ingin menyertai semula?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Ejen","CALLING_REQUEST":"Masuk panggilan video?","CALLING_SAVE":"Simpan","CALLING_SELECT_CAMERA":"Pilih kamera","CALLING_SELECT_MICROPHONE":"Pilih mikrofon","CALLING_SELECT_SPEAKER":"Pilih pembesar suara","CALLING_SHOW_CALL_SETTINGS":"Tunjukkan tetapan panggilan","DENY":"Tolak","END_SESSION":"Berhenti Berkongsi","FULL_DEVICE_REQUEST_DESCRIPTION":"Ejen sokongan ingin melihat seluruh skrin anda.","FULL_DEVICE_REQUEST_TITLE":"Benarkan rakaman skrin penuh?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Ejen sokongan ingin mengawal halaman ini.","REMOTE_CONTROL_REQUEST_TITLE":"Benarkan kawalan jauh?","SESSION_REQUEST_DESCRIPTION":"Ejen sokongan ingin menggunakan halaman web ini dengan anda buat sementara waktu.","SESSION_REQUEST_TITLE":"Benarkan cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Halaman web ini tidak dapat dilihat bersama ejen sokongan","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Ejen sokongan ingin mengikuti anda ke halaman web lain.","UNIVERSAL_PROXY_REQUEST_TITLE":"Benarkan sambungan sesi?"}');

/***/ }),

/***/ 9121:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Toestaan","CALLING_ACCEPT":"Accepteren","CALLING_CAMERA_OFF":"Camera is uit","CALLING_CAMERA_PERMISSION_DENIED":"Toegang tot camera geweigerd. Schakel deze in de instellingen van uw browser in.","CALLING_CAMERA_PERMISSION_PROMPT":"Toegang tot camera toestaan","CALLING_CAMERA_STARTING":"Camera wordt gestart","CALLING_CANCEL":"Annuleren","CALLING_DISABLE_AUDIO":"Audio uitschakelen","CALLING_DISABLE_VIDEO":"Video uitschakelen","CALLING_ENABLE_AUDIO":"Audio inschakelen","CALLING_ENABLE_VIDEO":"Video inschakelen","CALLING_END":"Oproep beindigen","CALLING_JOIN":"Deelnemen aan oproep","CALLING_JOIN_PROMPT":"Een supportmedewerker wil u bellen.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ik","CALLING_MICROPHONE_PERMISSION_DENIED":"Microfoon toegang geweigerd. Schakel dit in uw browserinstellingen in.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Toegang tot microfoon toestaan","CALLING_NO_DEVICES":"Geen","CALLING_PERMISSION_NEEDED":"Toestemming vereist","CALLING_REJECT":"Oproep weigeren","CALLING_REJOIN_PROMPT":"U bent in gesprek met een supportmedewerker. Wilt u opnieuw deelnemen?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Video-oproep starten?","CALLING_SAVE":"Opslaan","CALLING_SELECT_CAMERA":"Selecteer camera","CALLING_SELECT_MICROPHONE":"Selecteer microfoon","CALLING_SELECT_SPEAKER":"Selecteer spreker","CALLING_SHOW_CALL_SETTINGS":"Toon oproepinstellingen","DENY":"Afwijzen","END_SESSION":"Cobrowse-sessie beindigen","FULL_DEVICE_REQUEST_DESCRIPTION":"Een support agent wilt jouw volledige scherm zien.","FULL_DEVICE_REQUEST_TITLE":"Volledige schermopname toestaan?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Een support agent wilt graag deze pagina bedienen.","REMOTE_CONTROL_REQUEST_TITLE":"Bediening op afstand toestaan?","SESSION_REQUEST_DESCRIPTION":"Een support agent wilt graag tijdelijk met u meekijken op deze webpagina.","SESSION_REQUEST_TITLE":"Cobrowsing toestaan?","UNIVERSAL_PROXY_BLOCKED":"Deze webpagina kan niet worden bekeken met een support agent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Een support agent wilt u graag volgen naar andere webpagina\'s.","UNIVERSAL_PROXY_REQUEST_TITLE":"Sessievoortzetting toestaan?"}');

/***/ }),

/***/ 5443:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Umoliwi","CALLING_ACCEPT":"Akceptuj","CALLING_CAMERA_OFF":"Kamera jest wyczona","CALLING_CAMERA_PERMISSION_DENIED":"Odmowa dostpu do kamery. Wcz j w ustawieniach przegldarki.","CALLING_CAMERA_PERMISSION_PROMPT":"Zezwl na dostp do kamery","CALLING_CAMERA_STARTING":"Kamera si uruchamia","CALLING_CANCEL":"Anuluj","CALLING_DISABLE_AUDIO":"Wycz dwik","CALLING_DISABLE_VIDEO":"Wycz wideo","CALLING_ENABLE_AUDIO":"Wcz dwik","CALLING_ENABLE_VIDEO":"Wcz wideo","CALLING_END":"Zakocz rozmow","CALLING_JOIN":"Docz do rozmowy","CALLING_JOIN_PROMPT":"Agent wsparcia chciaby do Ciebie zadzwoni.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ja","CALLING_MICROPHONE_PERMISSION_DENIED":"Dostp do mikrofonu zosta odmwiony. Wcz go w ustawieniach przegldarki.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Zezwl na dostp do mikrofonu","CALLING_NO_DEVICES":"Brak","CALLING_PERMISSION_NEEDED":"Wymagana zgoda","CALLING_REJECT":"Odrzu poczenie","CALLING_REJOIN_PROMPT":"Masz aktywne poczenie z agentem wsparcia. Czy chcesz doczy ponownie?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Rozpocz rozmow wideo?","CALLING_SAVE":"Zapisz","CALLING_SELECT_CAMERA":"Wybierz kamer","CALLING_SELECT_MICROPHONE":"Wybierz mikrofon","CALLING_SELECT_SPEAKER":"Wybierz gonik","CALLING_SHOW_CALL_SETTINGS":"Poka ustawienia poczenia","DENY":"Zaprzeczy","END_SESSION":"Zakocz sesj Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Pracownik dziau pomocy chciaby zobaczy cay Twj ekran.","FULL_DEVICE_REQUEST_TITLE":"Czy zezwoli na pene przechwycenie ekranu?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Pracownik dziau pomocy chciaby kontrolowa t stron.","REMOTE_CONTROL_REQUEST_TITLE":"Czy zezwoli na zdalne sterowanie?","SESSION_REQUEST_DESCRIPTION":"Pracownik dziau pomocy chciaby tymczasowo korzysta z tej strony internetowej razem z Tob.","SESSION_REQUEST_TITLE":"Czy zezwoli na cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Ta strona internetowa nie moe by ogldana z pracownikiem dziau pomocy","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Pracownik dziau pomocy chciaby poda za Tob na inne strony internetowe.","UNIVERSAL_PROXY_REQUEST_TITLE":"Czy zezwoli na kontynuacj sesji?"}');

/***/ }),

/***/ 4389:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceitar","CALLING_CAMERA_OFF":"Cmera est desligada","CALLING_CAMERA_PERMISSION_DENIED":"Acesso  cmera negado. Ative-o nas configuraes do seu navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acesso  cmera","CALLING_CAMERA_STARTING":"A cmera est iniciando","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desativar udio","CALLING_DISABLE_VIDEO":"Desativar vdeo","CALLING_ENABLE_AUDIO":"Ativar udio","CALLING_ENABLE_VIDEO":"Ativar vdeo","CALLING_END":"Encerrar chamada","CALLING_JOIN":"Entrar na chamada","CALLING_JOIN_PROMPT":"Um agente de suporte gostaria de ligar para voc.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Eu","CALLING_MICROPHONE_PERMISSION_DENIED":"Acesso ao microfone negado. Ative-o nas configuraes do seu navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acesso ao microfone","CALLING_NO_DEVICES":"Nenhum","CALLING_PERMISSION_NEEDED":"Permisso necessria","CALLING_REJECT":"Rejeitar chamada","CALLING_REJOIN_PROMPT":"Voc est em uma ligao ativa com um agente de suporte. Deseja retornar?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Entrar na chamada de vdeo?","CALLING_SAVE":"Salvar","CALLING_SELECT_CAMERA":"Selecionar cmera","CALLING_SELECT_MICROPHONE":"Selecionar microfone","CALLING_SELECT_SPEAKER":"Selecionar orador","CALLING_SHOW_CALL_SETTINGS":"Mostrar configuraes de chamada","DENY":"Negar","END_SESSION":"Terminar Sesso de Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de ver sua tela inteira.","FULL_DEVICE_REQUEST_TITLE":"Permitir captura completa de tela?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de controlar esta pgina.","REMOTE_CONTROL_REQUEST_TITLE":"Permitir controle remoto?","SESSION_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de usar temporariamente esta pgina da web com voc.","SESSION_REQUEST_TITLE":"Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta pgina da web no pode ser visualizada com um agente de suporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de segui-lo para outras pginas da web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permitir continuao da sesso?"}');

/***/ }),

/***/ 3851:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permitir","CALLING_ACCEPT":"Aceitar","CALLING_CAMERA_OFF":"Cmara desligada","CALLING_CAMERA_PERMISSION_DENIED":"Acesso  cmara negado. Ative-o nas definies do seu navegador.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitir acesso  cmara","CALLING_CAMERA_STARTING":"Cmara a iniciar-se","CALLING_CANCEL":"Cancelar","CALLING_DISABLE_AUDIO":"Desativar udio","CALLING_DISABLE_VIDEO":"Desativar vdeo","CALLING_ENABLE_AUDIO":"Ativar udio","CALLING_ENABLE_VIDEO":"Ativar vdeo","CALLING_END":"Terminar chamada","CALLING_JOIN":"Entrar na chamada","CALLING_JOIN_PROMPT":"Um agente de suporte gostaria de lhe telefonar.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Eu","CALLING_MICROPHONE_PERMISSION_DENIED":"Acesso ao microfone negado. Ative-o nas definies do seu navegador.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permitir acesso ao microfone","CALLING_NO_DEVICES":"Nenhum","CALLING_PERMISSION_NEEDED":"Permisso necessria","CALLING_REJECT":"Recusar chamada","CALLING_REJOIN_PROMPT":"Tem uma chamada ativa com um agente de suporte. Deseja voltar a participar?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agente","CALLING_REQUEST":"Entrar na chamada de vdeo?","CALLING_SAVE":"Guardar","CALLING_SELECT_CAMERA":"Selecionar cmara","CALLING_SELECT_MICROPHONE":"Selecionar microfone","CALLING_SELECT_SPEAKER":"Selecionar orador","CALLING_SHOW_CALL_SETTINGS":"Mostrar definies de chamada","DENY":"Negado","END_SESSION":"Terminar Sesso de Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de ver sua tela inteira.","FULL_DEVICE_REQUEST_TITLE":"Permitir captura completa de ecr?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de controlar esta pgina.","REMOTE_CONTROL_REQUEST_TITLE":"Permitir controlo remoto?","SESSION_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de usar temporariamente esta pgina da web com voc.","SESSION_REQUEST_TITLE":"Permitir cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Esta pgina da web no pode ser visualizada com um agente de suporte","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Um agente de suporte gostaria de segui-lo para outras pginas da web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permitir continuao da sesso?"}');

/***/ }),

/***/ 7304:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Permite","CALLING_ACCEPT":"Accept","CALLING_CAMERA_OFF":"Camera este oprit","CALLING_CAMERA_PERMISSION_DENIED":"Accesul la camer a fost refuzat. Activai-l n setrile browserului dvs.","CALLING_CAMERA_PERMISSION_PROMPT":"Permitei accesul la camer","CALLING_CAMERA_STARTING":"Camera pornete","CALLING_CANCEL":"Anuleaz","CALLING_DISABLE_AUDIO":"Dezactiveaz audio-ul","CALLING_DISABLE_VIDEO":"Dezactiveaz video-ul","CALLING_ENABLE_AUDIO":"Activeaz audio","CALLING_ENABLE_VIDEO":"Activeaz video-ul","CALLING_END":"ncheiere apel","CALLING_JOIN":"Alturai-v apelului","CALLING_JOIN_PROMPT":"Un agent de suport ar dori s v contacteze telefonic.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Eu","CALLING_MICROPHONE_PERMISSION_DENIED":"Accesul la microfon a fost refuzat. Activai-l n setrile browserului dumneavoastr.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Permite accesul la microfon","CALLING_NO_DEVICES":"Niciunul","CALLING_PERMISSION_NEEDED":"Permisiune necesar","CALLING_REJECT":"Respinge apelul","CALLING_REJOIN_PROMPT":"Avei un apel activ cu un agent de suport. Dorii s v reconectai?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Dorii s intrai n apelul video?","CALLING_SAVE":"Salveaz","CALLING_SELECT_CAMERA":"Selectai camera","CALLING_SELECT_MICROPHONE":"Selectai microfonul","CALLING_SELECT_SPEAKER":"Selectai difuzorul","CALLING_SHOW_CALL_SETTINGS":"Afiai setrile apelului","DENY":"Refuz","END_SESSION":"Oprii partajarea","FULL_DEVICE_REQUEST_DESCRIPTION":"Un agent de asisten dorete s vad ntreg ecranul dumneavoastr.","FULL_DEVICE_REQUEST_TITLE":"Permite capturarea ecranului complet?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Un agent de suport dorete s controleze aceast pagin.","REMOTE_CONTROL_REQUEST_TITLE":"Permite controlul de la distan?","SESSION_REQUEST_DESCRIPTION":"Un agent de asisten dorete s utilizeze temporar aceast pagin web mpreun cu dumneavoastr.","SESSION_REQUEST_TITLE":"Permitei cobrowsing-ul?","UNIVERSAL_PROXY_BLOCKED":"Aceast pagin web nu poate fi vizualizat mpreun cu un agent de asisten","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Un agent de suport dorete s v urmreasc pe alte pagini web.","UNIVERSAL_PROXY_REQUEST_TITLE":"Permitei continuarea sesiunii?"}');

/***/ }),

/***/ 6146:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":" ","CALLING_CAMERA_PERMISSION_DENIED":"   .      .","CALLING_CAMERA_PERMISSION_PROMPT":"   ","CALLING_CAMERA_STARTING":" ","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":" ","CALLING_DISABLE_VIDEO":" ","CALLING_ENABLE_AUDIO":" ","CALLING_ENABLE_VIDEO":" ","CALLING_END":" ","CALLING_JOIN":"  ","CALLING_JOIN_PROMPT":"    .","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"   .     .","CALLING_MICROPHONE_PERMISSION_PROMPT":"   ","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":" ","CALLING_REJECT":" ","CALLING_REJOIN_PROMPT":"      .   ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":" ?","CALLING_SAVE":"","CALLING_SELECT_CAMERA":" ","CALLING_SELECT_MICROPHONE":" ","CALLING_SELECT_SPEAKER":" ","CALLING_SHOW_CALL_SETTINGS":"  ","DENY":"","END_SESSION":"   ","FULL_DEVICE_REQUEST_DESCRIPTION":"       .","FULL_DEVICE_REQUEST_TITLE":"   ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"      .","REMOTE_CONTROL_REQUEST_TITLE":"  ?","SESSION_REQUEST_DESCRIPTION":"        -  .","SESSION_REQUEST_TITLE":" ?","UNIVERSAL_PROXY_BLOCKED":" -       ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"         -.","UNIVERSAL_PROXY_REQUEST_TITLE":"  ?"}');

/***/ }),

/***/ 5537:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Povoli","CALLING_ACCEPT":"Prija","CALLING_CAMERA_OFF":"Kamera je vypnut","CALLING_CAMERA_PERMISSION_DENIED":"Prstup ku kamere odmietnut. Povoli ho v nastaveniach prehliadaa.","CALLING_CAMERA_PERMISSION_PROMPT":"Povoli prstup ku kamere","CALLING_CAMERA_STARTING":"Kamera sa spa","CALLING_CANCEL":"Zrui","CALLING_DISABLE_AUDIO":"Vypn zvuk","CALLING_DISABLE_VIDEO":"Zakza video","CALLING_ENABLE_AUDIO":"Povoli zvuk","CALLING_ENABLE_VIDEO":"Povoli video","CALLING_END":"Ukoni hovor","CALLING_JOIN":"Pripoji sa k hovoru","CALLING_JOIN_PROMPT":"Podporn agent vs chce kontaktova telefonicky.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ja","CALLING_MICROPHONE_PERMISSION_DENIED":"Prstup k mikrofnu zamietnut. Povoli ho v nastaveniach prehliadaa.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Povoli prstup k mikrofnu","CALLING_NO_DEVICES":"iadne","CALLING_PERMISSION_NEEDED":"Vyaduje sa povolenie","CALLING_REJECT":"Zamietnu hovor","CALLING_REJOIN_PROMPT":"Mte aktvne volanie s podpornm agentom. Chcete sa znova pripoji?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Vstpi do videohovoru?","CALLING_SAVE":"Uloi","CALLING_SELECT_CAMERA":"Vyberte kameru","CALLING_SELECT_MICROPHONE":"Vyberte mikrofn","CALLING_SELECT_SPEAKER":"Vybra reproduktora","CALLING_SHOW_CALL_SETTINGS":"Zobrazi nastavenia hovoru","DENY":"Odmietnu","END_SESSION":"Zastavi zdieanie","FULL_DEVICE_REQUEST_DESCRIPTION":"Podporn agent si el zobrazi cel vau obrazovku.","FULL_DEVICE_REQUEST_TITLE":"Povoli pln snmanie obrazovky?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Podporn agent by chcel ovlda tto strnku.","REMOTE_CONTROL_REQUEST_TITLE":"Povoli vzdialen sprvu?","SESSION_REQUEST_DESCRIPTION":"Podporn agent by chcel doasne pouva tto webov strnku spolu s vami.","SESSION_REQUEST_TITLE":"Povoli spolusurfovanie?","UNIVERSAL_PROXY_BLOCKED":"Tto webov strnku nie je mon zobrazi so servisnm agentom","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Podporn agent by vs rd sledoval na alie webov strnky.","UNIVERSAL_PROXY_REQUEST_TITLE":"Povoli pokraovanie relcie?"}');

/***/ }),

/***/ 1224:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Dovoli","CALLING_ACCEPT":"Sprejmi","CALLING_CAMERA_OFF":"Kamera je izklopljena","CALLING_CAMERA_PERMISSION_DENIED":"Dostop do kamere zavrnjen. Omogoite ga v nastavitvah brskalnika.","CALLING_CAMERA_PERMISSION_PROMPT":"Dovoli dostop do kamere","CALLING_CAMERA_STARTING":"Kamera se zaenja","CALLING_CANCEL":"Preklii","CALLING_DISABLE_AUDIO":"Onemogoi zvok","CALLING_DISABLE_VIDEO":"Onemogoi video","CALLING_ENABLE_AUDIO":"Omogoi zvok","CALLING_ENABLE_VIDEO":"Omogoi video","CALLING_END":"Konaj klic","CALLING_JOIN":"Pridrui se klicu","CALLING_JOIN_PROMPT":"Podporni agent vas eli poklicati.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Jaz","CALLING_MICROPHONE_PERMISSION_DENIED":"Dostop do mikrofona zavrnjen. Omogoite ga v nastavitvah brskalnika.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Dovoli dostop do mikrofona","CALLING_NO_DEVICES":"Noben","CALLING_PERMISSION_NEEDED":"Potrebna dovoljenja","CALLING_REJECT":"Zavrni klic","CALLING_REJOIN_PROMPT":"Imate aktivni klic s podporo. elite ponovno pristopiti?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"elite vstopiti v video klic?","CALLING_SAVE":"Shrani","CALLING_SELECT_CAMERA":"Izberite kamero","CALLING_SELECT_MICROPHONE":"Izberite mikrofon","CALLING_SELECT_SPEAKER":"Izberite zvonika","CALLING_SHOW_CALL_SETTINGS":"Prikai nastavitve klica","DENY":"Zanikati","END_SESSION":"Konaj sejo Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Agent za podporo si eli ogledati va celoten zaslon.","FULL_DEVICE_REQUEST_TITLE":"Dovoliti zajemanje celotnega zaslona?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Podporni agent eli nadzorovati to stran.","REMOTE_CONTROL_REQUEST_TITLE":"Dovoliti daljinsko upravljanje?","SESSION_REQUEST_DESCRIPTION":"Agent za podporo eli zaasno uporabljati to spletno stran z vami.","SESSION_REQUEST_TITLE":"Dovoliti cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Ta spletna stran se ne more ogledovati z agentom za podporo","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Agent za podporo vas eli slediti na druge spletne strani.","UNIVERSAL_PROXY_REQUEST_TITLE":"Dovoliti nadaljevanje seje?"}');

/***/ }),

/***/ 8978:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Tillt","CALLING_ACCEPT":"Acceptera","CALLING_CAMERA_OFF":"Kameran r avstngd","CALLING_CAMERA_PERMISSION_DENIED":"Kameratillgng nekad. Aktivera den i dina webblsarinstllningar.","CALLING_CAMERA_PERMISSION_PROMPT":"Tillt tkomst till kamera","CALLING_CAMERA_STARTING":"Kameran startar","CALLING_CANCEL":"Avbryt","CALLING_DISABLE_AUDIO":"Inaktivera ljud","CALLING_DISABLE_VIDEO":"Inaktivera video","CALLING_ENABLE_AUDIO":"Aktivera ljud","CALLING_ENABLE_VIDEO":"Aktivera video","CALLING_END":"Avsluta samtal","CALLING_JOIN":"G med i samtal","CALLING_JOIN_PROMPT":"En supportagent vill ringa dig.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Jag","CALLING_MICROPHONE_PERMISSION_DENIED":"Mikrofontillgng nekad. Aktivera den i din webblsarinstllningar.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Tillt tkomst till mikrofonen","CALLING_NO_DEVICES":"Ingen","CALLING_PERMISSION_NEEDED":"Behrighet krvs","CALLING_REJECT":"Avvisa samtal","CALLING_REJOIN_PROMPT":"Du har ett aktivt samtal med en supportagent. Vill du ansluta igen?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"Agent","CALLING_REQUEST":"Starta videosamtal?","CALLING_SAVE":"Spara","CALLING_SELECT_CAMERA":"Vlj kamera","CALLING_SELECT_MICROPHONE":"Vlj mikrofon","CALLING_SELECT_SPEAKER":"Vlj talare","CALLING_SHOW_CALL_SETTINGS":"Visa samtalsinstllningar","DENY":"Neka","END_SESSION":"Sluta dela","FULL_DEVICE_REQUEST_DESCRIPTION":"En supportagent vill se hela din skrm.","FULL_DEVICE_REQUEST_TITLE":"Tillt fullskrmsinspelning?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"En supportagent vill kontrollera denna sida.","REMOTE_CONTROL_REQUEST_TITLE":"Tillt fjrrstyrning?","SESSION_REQUEST_DESCRIPTION":"En supportagent vill tillflligt anvnda denna webbsida tillsammans med dig.","SESSION_REQUEST_TITLE":"Tillt samvisning?","UNIVERSAL_PROXY_BLOCKED":"Den hr webbsidan kan inte visas tillsammans med en supportagent","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"En supportagent vill flja dig till andra webbsidor.","UNIVERSAL_PROXY_REQUEST_TITLE":"Tillt sessionens fortsttning?"}');

/***/ }),

/***/ 9250:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":"","CALLING_CAMERA_PERMISSION_DENIED":" ","CALLING_CAMERA_PERMISSION_PROMPT":"","CALLING_CAMERA_STARTING":"","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":"","CALLING_DISABLE_VIDEO":"","CALLING_ENABLE_AUDIO":"","CALLING_ENABLE_VIDEO":"","CALLING_END":"","CALLING_JOIN":"","CALLING_JOIN_PROMPT":"","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":" ","CALLING_MICROPHONE_PERMISSION_PROMPT":"","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":"","CALLING_REJECT":"","CALLING_REJOIN_PROMPT":" ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"?","CALLING_SAVE":"","CALLING_SELECT_CAMERA":"","CALLING_SELECT_MICROPHONE":"","CALLING_SELECT_SPEAKER":"","CALLING_SHOW_CALL_SETTINGS":"","DENY":"","END_SESSION":"","FULL_DEVICE_REQUEST_DESCRIPTION":"","FULL_DEVICE_REQUEST_TITLE":"?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"","REMOTE_CONTROL_REQUEST_TITLE":"?","SESSION_REQUEST_DESCRIPTION":"","SESSION_REQUEST_TITLE":"?","UNIVERSAL_PROXY_BLOCKED":"","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":" ","UNIVERSAL_PROXY_REQUEST_TITLE":"?"}');

/***/ }),

/***/ 747:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":"","CALLING_CAMERA_PERMISSION_DENIED":" ","CALLING_CAMERA_PERMISSION_PROMPT":"","CALLING_CAMERA_STARTING":"","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":"","CALLING_DISABLE_VIDEO":"","CALLING_ENABLE_AUDIO":"","CALLING_ENABLE_VIDEO":"","CALLING_END":"","CALLING_JOIN":"","CALLING_JOIN_PROMPT":"","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":" ","CALLING_MICROPHONE_PERMISSION_PROMPT":"","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":"","CALLING_REJECT":"","CALLING_REJOIN_PROMPT":" ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"?","CALLING_SAVE":"","CALLING_SELECT_CAMERA":"","CALLING_SELECT_MICROPHONE":"","CALLING_SELECT_SPEAKER":"","CALLING_SHOW_CALL_SETTINGS":"","DENY":"","END_SESSION":"","FULL_DEVICE_REQUEST_DESCRIPTION":"","FULL_DEVICE_REQUEST_TITLE":"?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"","REMOTE_CONTROL_REQUEST_TITLE":"?","SESSION_REQUEST_DESCRIPTION":"","SESSION_REQUEST_TITLE":"?","UNIVERSAL_PROXY_BLOCKED":"","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":" ","UNIVERSAL_PROXY_REQUEST_TITLE":"?"}');

/***/ }),

/***/ 1559:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":" ","CALLING_CAMERA_PERMISSION_DENIED":"   .     .","CALLING_CAMERA_PERMISSION_PROMPT":"   ","CALLING_CAMERA_STARTING":" ","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":" ","CALLING_DISABLE_VIDEO":" ","CALLING_ENABLE_AUDIO":" ","CALLING_ENABLE_VIDEO":" ","CALLING_END":" ","CALLING_JOIN":"  ","CALLING_JOIN_PROMPT":"    .","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"   .     .","CALLING_MICROPHONE_PERMISSION_PROMPT":"   ","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":" ","CALLING_REJECT":" ","CALLING_REJOIN_PROMPT":"      .   ?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":" ?","CALLING_SAVE":"","CALLING_SELECT_CAMERA":" ","CALLING_SELECT_MICROPHONE":" ","CALLING_SELECT_SPEAKER":" ","CALLING_SHOW_CALL_SETTINGS":"  ","DENY":"","END_SESSION":"  Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"       .","FULL_DEVICE_REQUEST_TITLE":"   ?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"      .","REMOTE_CONTROL_REQUEST_TITLE":"  ?","SESSION_REQUEST_DESCRIPTION":"        -   .","SESSION_REQUEST_TITLE":" ?","UNIVERSAL_PROXY_BLOCKED":" -       ","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"         -.","UNIVERSAL_PROXY_REQUEST_TITLE":"  ?"}');

/***/ }),

/***/ 7762:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"Cho php","CALLING_ACCEPT":"Chp nhn","CALLING_CAMERA_OFF":"Camera  tt","CALLING_CAMERA_PERMISSION_DENIED":"Truy cp camera b t chi. Hy bt n trong ci t trnh duyt ca bn.","CALLING_CAMERA_PERMISSION_PROMPT":"Cho php truy cp camera","CALLING_CAMERA_STARTING":"My nh ang khi ng","CALLING_CANCEL":"Hy b","CALLING_DISABLE_AUDIO":"Tt m thanh","CALLING_DISABLE_VIDEO":"V hiu ha video","CALLING_ENABLE_AUDIO":"Bt m thanh","CALLING_ENABLE_VIDEO":"Bt video","CALLING_END":"Kt thc cuc gi","CALLING_JOIN":"Tham gia cuc gi","CALLING_JOIN_PROMPT":"Mt nhn vin h tr mun gi cho bn.","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"Ti","CALLING_MICROPHONE_PERMISSION_DENIED":"Quyn truy cp micro b t chi. Vui lng bt trong ci t trnh duyt ca bn.","CALLING_MICROPHONE_PERMISSION_PROMPT":"Cho php truy cp micro","CALLING_NO_DEVICES":"Khng c g","CALLING_PERMISSION_NEEDED":"Cn quyn truy cp","CALLING_REJECT":"T chi cuc gi","CALLING_REJOIN_PROMPT":"Bn ang c mt cuc gi ang hot ng vi nhn vin h tr. Bn c mun tham gia li khng?","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"i l","CALLING_REQUEST":"Tham gia gi video?","CALLING_SAVE":"Lu","CALLING_SELECT_CAMERA":"Chn camera","CALLING_SELECT_MICROPHONE":"Chn micro","CALLING_SELECT_SPEAKER":"Chn ngi ni","CALLING_SHOW_CALL_SETTINGS":"Hin th ci t cuc gi","DENY":"T chi","END_SESSION":"Kt thc phin Cobrowse","FULL_DEVICE_REQUEST_DESCRIPTION":"Mt tng i vin h tr mun xem ton b mn hnh ca bn.","FULL_DEVICE_REQUEST_TITLE":"Cho php chp ton b mn hnh?","REMOTE_CONTROL_REQUEST_DESCRIPTION":"Mt tng i vin h tr mun kim sot trang ny.","REMOTE_CONTROL_REQUEST_TITLE":"Cho php iu khin t xa?","SESSION_REQUEST_DESCRIPTION":"Mt tng i vin mun tm thi s dng trang web ny vi bn.","SESSION_REQUEST_TITLE":"Cho php cobrowsing?","UNIVERSAL_PROXY_BLOCKED":"Trang web ny khng th c xem cng vi mt tng i vin h tr","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"Mt tng i vin h tr mun theo di bn n cc trang web khc.","UNIVERSAL_PROXY_REQUEST_TITLE":"Cho php tip tc phin?"}');

/***/ }),

/***/ 4181:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":"","CALLING_CAMERA_PERMISSION_DENIED":"","CALLING_CAMERA_PERMISSION_PROMPT":"","CALLING_CAMERA_STARTING":"","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":"","CALLING_DISABLE_VIDEO":"","CALLING_ENABLE_AUDIO":"","CALLING_ENABLE_VIDEO":"","CALLING_END":"","CALLING_JOIN":"","CALLING_JOIN_PROMPT":"","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"","CALLING_MICROPHONE_PERMISSION_PROMPT":"","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":"","CALLING_REJECT":"","CALLING_REJOIN_PROMPT":"","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"","CALLING_SAVE":"","CALLING_SELECT_CAMERA":"","CALLING_SELECT_MICROPHONE":"","CALLING_SELECT_SPEAKER":"","CALLING_SHOW_CALL_SETTINGS":"","DENY":"","END_SESSION":"","FULL_DEVICE_REQUEST_DESCRIPTION":"","FULL_DEVICE_REQUEST_TITLE":"","REMOTE_CONTROL_REQUEST_DESCRIPTION":"","REMOTE_CONTROL_REQUEST_TITLE":"","SESSION_REQUEST_DESCRIPTION":"","SESSION_REQUEST_TITLE":"","UNIVERSAL_PROXY_BLOCKED":"","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"","UNIVERSAL_PROXY_REQUEST_TITLE":""}');

/***/ }),

/***/ 9225:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ALLOW":"","CALLING_ACCEPT":"","CALLING_CAMERA_OFF":"","CALLING_CAMERA_PERMISSION_DENIED":"","CALLING_CAMERA_PERMISSION_PROMPT":"","CALLING_CAMERA_STARTING":"","CALLING_CANCEL":"","CALLING_DISABLE_AUDIO":"","CALLING_DISABLE_VIDEO":"","CALLING_ENABLE_AUDIO":"","CALLING_ENABLE_VIDEO":"","CALLING_END":"","CALLING_JOIN":"","CALLING_JOIN_PROMPT":"","CALLING_LOCAL_PARTICIPANT_DESCRIPTION":"","CALLING_MICROPHONE_PERMISSION_DENIED":"","CALLING_MICROPHONE_PERMISSION_PROMPT":"","CALLING_NO_DEVICES":"","CALLING_PERMISSION_NEEDED":"","CALLING_REJECT":"","CALLING_REJOIN_PROMPT":"","CALLING_REMOTE_PARTICIPANT_DESCRIPTION":"","CALLING_REQUEST":"","CALLING_SAVE":"","CALLING_SELECT_CAMERA":"","CALLING_SELECT_MICROPHONE":"","CALLING_SELECT_SPEAKER":"","CALLING_SHOW_CALL_SETTINGS":"","DENY":"","END_SESSION":"","FULL_DEVICE_REQUEST_DESCRIPTION":"","FULL_DEVICE_REQUEST_TITLE":"","REMOTE_CONTROL_REQUEST_DESCRIPTION":"","REMOTE_CONTROL_REQUEST_TITLE":"","SESSION_REQUEST_DESCRIPTION":"","SESSION_REQUEST_TITLE":"","UNIVERSAL_PROXY_BLOCKED":"","UNIVERSAL_PROXY_REQUEST_DESCRIPTION":"","UNIVERSAL_PROXY_REQUEST_TITLE":""}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + "elevenlabs" + ".chunk.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "CobrowseIO:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			792: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkCobrowseIO"] = self["webpackChunkCobrowseIO"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports["default"] = void 0;
__webpack_require__(132);
var _cocom = __webpack_require__(3439);
var _CobrowseIO = _interopRequireDefault(__webpack_require__(5620));
var _iframes = _interopRequireDefault(__webpack_require__(7966));
var _NativeSelect = _interopRequireDefault(__webpack_require__(1112));
var _Session = _interopRequireDefault(__webpack_require__(2404));
var _protected = _interopRequireDefault(__webpack_require__(7609));
var _redaction = __webpack_require__(6566);
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// normally we avoid polyfills, but some customer sites use a Promise
// polyfill that replaces the implementation and omits allSettled

const e = _CobrowseIO.default;
if (window.__cobrowse_io_loaded) {
  // eslint-disable-next-line no-import-assign
  _CobrowseIO.default = (null, function () {
    throw new Error('"' + "CobrowseIO" + '" is read-only.');
  }());
  throw new Error('CobrowseIO already loaded. This usually means you included the snippet multiple times.');
}
window.__cobrowse_io_loaded = true;
let hasIFrameSession = false;
const nativeSelect = new _NativeSelect.default({
  shouldShowSelect: () => {
    var _CobrowseIO$currentSe;
    return ((_CobrowseIO$currentSe = _CobrowseIO.default.currentSession) === null || _CobrowseIO$currentSe === void 0 ? void 0 : _CobrowseIO$currentSe.isActive()) || hasIFrameSession;
  },
  isRedacted: target => {
    var _RedactionIndexProvid;
    return (_RedactionIndexProvid = _redaction.RedactionIndexProvider.instance) === null || _RedactionIndexProvid === void 0 ? void 0 : _RedactionIndexProvid.isRedacted(target);
  }
});
nativeSelect.track(window);
_iframes.default.on('iframe_discovered', iframe => {
  if ((0, _cocom.isxdoc)(iframe)) return;
  nativeSelect.track(iframe.contentWindow);
});
_iframes.default.on('session', serializedSession => {
  const currentSession = new _Session.default(e);
  currentSession[_protected.default].deserialize(serializedSession);
  hasIFrameSession = currentSession.isActive();
});
var _default = exports["default"] = e;
})();

__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});
;window.__cbio_sdk_styles = ".HighlightOverlay-module__overlay___IwXTu{animation:HighlightOverlay-module__highlightOverlayFadeIn___gxAX9 .4s cubic-bezier(.25,.46,.45,.94) forwards,HighlightOverlay-module__highlightOverlayPulse___fW7eg 2.5s cubic-bezier(.25,.46,.45,.94) .4s infinite;box-shadow:var(--cbio-color-highlight-backdrop) 0 0 0 5000px;opacity:0;pointer-events:none;position:absolute;transform-origin:center;transition:all .3s ease-in-out;z-index:2147483646}.HighlightOverlay-module__disableAnimations___vQPvb{transition:none!important}@media (prefers-reduced-motion:reduce){.HighlightOverlay-module__overlay___IwXTu{animation:none;opacity:1;outline:3px solid #8481f8cc;transition:none}}@keyframes HighlightOverlay-module__highlightOverlayFadeIn___gxAX9{0%{opacity:0}to{opacity:1}}@keyframes HighlightOverlay-module__highlightOverlayPulse___fW7eg{0%,to{box-shadow:0 0 0 3px #8481f8cc,0 0 0 5000px var(--cbio-color-highlight-backdrop);transform:scaleX(1) scaleY(1)}50%{box-shadow:0 0 0 3px #8481f8,0 0 0 5000px var(--cbio-color-highlight-backdrop);transform:scaleX(var(--cbio-padded-x)) scaleY(var(--cbio-padded-y))}}.Tooltip-module__tooltip___IL4dx{background-color:var(--cbio-color-background-primary);border:1px solid var(--cbio-color-border);border-radius:var(--cbio-radius-md);box-sizing:border-box;left:0;max-width:400px;opacity:0;position:absolute;top:0;transition:opacity .4s ease-out,top .4s ease-out;width:max-content;z-index:2147483646}.Tooltip-module__tooltipVisible___a7Zvs{opacity:1}@media (prefers-reduced-motion:reduce){.Tooltip-module__tooltip___IL4dx{transition:none}}.Tooltip-module__tooltipTitle___gG75M{background-color:var(--cbio-color-background-primary);border-radius:var(--cbio-radius-md);color:var(--cbio-color-text-secondary);font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);line-height:var(--cbio-line-height-sm);padding:12px;position:relative;z-index:1}.Tooltip-module__tooltipArrow___kPSXv{background-color:var(--cbio-color-background-primary);border-bottom:1px solid var(--cbio-color-border);border-radius:2px;border-right:1px solid var(--cbio-color-border);height:12px;position:absolute;transform:rotate(45deg);width:12px}:host,:root{--cbio-font-family-base:Helvetica Neue,Helvetica,Arial,sans-serif;--cbio-font-size-sm:14px;--cbio-line-height-sm:20px;--cbio-font-size-md:18px;--cbio-line-height-md:130%;--cbio-font-size-lg:20px;--cbio-line-height-lg:24px;--cbio-radius-md:8px;--cbio-radius-lg:24px;--cbio-radius-pill:9999px;--cbio-color-text-primary:#26252c;--cbio-color-text-secondary:#6f6d82;--cbio-color-text-muted:#92909d;--cbio-color-text-strong:#0e0c26;--cbio-color-text-light:#f5f6fb;--cbio-color-text-white:#fff;--cbio-color-background-primary:#fff;--cbio-color-background-secondary:#36008e;--cbio-color-background-light:#eeeff1;--cbio-color-modal-backdrop:#00000059;--cbio-color-highlight-backdrop:#29284199;--cbio-color-accent-primary:#6556f0;--cbio-color-accent-primary-hover:#4126a7;--cbio-color-danger:#dc2626;--cbio-color-danger-hover:#b91c1c;--cbio-color-danger-hover-soft:#fca5a5;--cbio-color-border:#bcc1d4;--cbio-shadow-buttons:0px 4px 12px #00000059}.cbio-sr-only{height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;clip:rect(0,0,0,0);border-width:0;white-space:nowrap}.Button-module__base___PvaYv{appearance:none;border:none;border-radius:var(--cbio-radius-md);cursor:pointer;font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);line-height:var(--cbio-line-height-sm);padding:10px 16px;user-select:none;white-space:nowrap}.Button-module__primary___jyGbF{background-color:var(--cbio-color-accent-primary);color:var(--cbio-color-text-light);font-weight:700}.Button-module__primary___jyGbF:hover{background-color:var(--cbio-color-accent-primary-hover)}.Button-module__secondary___V1ksJ{background-color:var(--cbio-color-background-light);color:var(--cbio-color-text-strong)}.Button-module__secondary___V1ksJ:hover{background-color:initial}.IconButton-module__base___wAyLz{align-items:center;background:none;border:none;cursor:pointer;display:flex;justify-content:center;margin:0;padding:0}.Modal-module__container___G4Twz{align-items:center;background:var(--cbio-color-modal-backdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:2147483647}.Modal-module__content___tkuQp{border-radius:var(--cbio-radius-md);box-shadow:0 4px 4px #00000040;box-sizing:border-box;color:var(--cbio-color-text-secondary);margin:24px;padding:24px;position:fixed;z-index:2147483647}.Modal-module__content___tkuQp,.Select-module__base___YM7TJ{background-color:var(--cbio-color-background-primary);font-family:var(--cbio-font-family-base)}.Select-module__base___YM7TJ{appearance:none;background-repeat:no-repeat;background-size:16px;border:none;border-radius:var(--cbio-radius-md);color:#393842;cursor:pointer;font-size:var(--cbio-font-size-sm);overflow:hidden;text-overflow:ellipsis;text-wrap:nowrap;width:100%}.Select-module__base___YM7TJ:disabled{cursor:not-allowed}.Select-module__base___YM7TJ:not(:disabled):hover{box-shadow:inset 0 0 0 1px #c7cbfe}.Select-module__noIcon___nzh9A{background-position:right 4px center;padding:8px 16px 8px 8px}.SessionStateOverlay-module__sessionStateOverlay___pCowu{bottom:20px;display:flex;gap:12px;left:50%;position:fixed;transform:translateX(-50%);z-index:2147483647}.SessionStateOverlay-module__endSessionButton___pUtd7{align-items:center;appearance:none;background:var(--cbio-color-danger);border:none;border-radius:var(--cbio-radius-md);box-shadow:var(--cbio-shadow-buttons);color:var(--cbio-color-text-light);cursor:pointer;display:flex;font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);font-weight:700;gap:8px;line-height:var(--cbio-line-height-sm);padding:10px 16px;user-select:none;white-space:nowrap}.SessionStateOverlay-module__endSessionButton___pUtd7:hover{background:var(--cbio-color-danger-hover)}.SessionStateOverlay-module__endSessionIcon___vLhgE{height:24px;width:24px}.SessionStateOverlay-module__callingControlsContainer___UYdU1{border-radius:var(--cbio-radius-md);box-shadow:var(--cbio-shadow-buttons);color:var(--cbio-color-text-light);display:flex;overflow:hidden}.SessionStateOverlay-module__callingControlsToggleContainer___jmNM6{align-items:center;background-color:#292841;display:flex;gap:10px;padding:10px 12px}.SessionStateOverlay-module__callingControlsToggle___ry4m0{height:24px;width:24px}.SessionStateOverlay-module__callingControlsToggleOff___jxwB4{color:#ef4444}.SessionStateOverlay-module__callingControlsToggleOff___jxwB4:hover{color:var(--cbio-color-danger-hover-soft)}.SessionStateOverlay-module__callingControlsToggleOn___FUuRG{color:var(--cbio-color-text-light)}.SessionStateOverlay-module__callingControlsToggleOn___FUuRG:hover{color:var(--cbio-color-border)}.SessionStateOverlay-module__callingControlsIcon___OWYpc{height:24px;width:24px}.SessionStateOverlay-module__callingControlsEnd___t4Xky{background-color:var(--cbio-color-danger)!important;height:100%;width:44px}.SessionStateOverlay-module__callingControlsEnd___t4Xky:hover{background-color:var(--cbio-color-danger-hover)!important}.ConsentDialog-module__content___fUfL3{max-width:400px}.ConsentDialog-module__title___MTrAq{color:var(--cbio-color-text-primary);font-size:var(--cbio-font-size-lg);font-weight:700;line-height:var(--cbio-line-height-lg);margin-bottom:6px;margin-top:0}.ConsentDialog-module__body___FtS5W{color:var(--cbio-color-text-muted);display:flex;flex-direction:column;font-size:var(--cbio-font-size-md);line-height:var(--cbio-line-height-md)}.ConsentDialog-module__confirmation___v7fj3{color:var(--cbio-color-text-primary);margin:0}.ConsentDialog-module__description___eSwUl{margin:0}.ConsentDialog-module__buttons___nToO7{display:flex;gap:8px;justify-content:end;margin-top:32px}.CallParticipants-module__container___JHyh3{display:grid;gap:12px;grid-auto-rows:min-content;padding:12px;width:300px}.CallParticipants-module__participantContainer___WEeET{border-radius:var(--cbio-radius-md);box-shadow:0 0 8px #00000040;overflow:hidden;position:relative}.CallParticipants-module__participantSpeaking___aovg8{outline:2px solid var(--cbio-color-accent-primary);outline-offset:2px}.CallParticipants-module__videoContainer___cuUmK{aspect-ratio:16/9;height:100%;position:relative;width:100%}.CallParticipants-module__video___osVRK{background-color:var(--cbio-color-background-secondary);height:100%;transform:scaleX(-1);width:100%}.CallParticipants-module__videoOverlay___x1yb0{align-items:center;background-color:var(--cbio-color-background-secondary);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}.CallParticipants-module__statusContainer___Vrvvr{align-items:center;bottom:0;color:var(--cbio-color-text-white);display:flex;gap:8px;justify-content:center;padding:8px;position:absolute;user-select:none}.CallParticipants-module__statusTitle___puKch{font-family:var(--cbio-font-family-base);font-size:var(--cbio-font-size-sm);text-shadow:0 0 4px #000}.CallParticipants-module__statusIcon____w42b{filter:drop-shadow(0 0 4px black);height:20px;width:20px}.CallParticipants-module__videoOverlayIcon___Fph1m{color:var(--cbio-color-danger);height:24px;width:24px}.MediaPreview-module__content___4fxuk{display:flex;flex-direction:column;max-width:500px}.MediaPreview-module__header___E2CcH{display:flex;flex-direction:column;gap:35px}.MediaPreview-module__media___kmkmo{display:flex;flex-direction:column;gap:12px}.MediaPreview-module__body___VPagd{color:var(--cbio-color-text-muted);display:flex;flex-direction:column;font-size:var(--cbio-font-size-md);line-height:var(--cbio-line-height-md);margin-top:8px}.MediaPreview-module__title___uSKCr{color:var(--cbio-color-text-primary);font-size:var(--cbio-font-size-lg);font-weight:700;line-height:var(--cbio-line-height-lg);margin:0}.MediaPreview-module__description___IPolu{margin:0}.MediaPreview-module__previewContainer___hZF98{position:relative}.MediaPreview-module__videoContainer____O8KD{aspect-ratio:16/9;border-radius:var(--cbio-radius-md);height:100%;overflow:hidden;position:relative;width:100%}.MediaPreview-module__video___DnVpX{background-color:#000;height:100%;transform:scaleX(-1);width:100%}.MediaPreview-module__videoOverlay___Wy27K{align-items:center;bottom:0;color:var(--cbio-color-text-white);display:flex;font-size:var(--cbio-font-size-md);justify-content:center;left:0;position:absolute;right:0;top:0}.MediaPreview-module__videoOverlaySolid___Ifi1O{background-color:#000}.MediaPreview-module__videoOverlayTransparent___vPzQr{background-color:#0006}.MediaPreview-module__videoOverlayText___kzAHr{padding:0 12px;text-align:center}.MediaPreview-module__deviceContainer___MEdwh{display:flex;flex-direction:row;gap:12px}.MediaPreview-module__buttonContainer___aXcOQ{display:flex;gap:8px;justify-content:flex-end;margin-top:35px}@media (max-width:768px){.MediaPreview-module__deviceContainer___MEdwh{flex-direction:column}}.MediaPreview-module__voiceVideoControls___qTsRx{background-color:var(--cbio-color-background-primary);border-radius:var(--cbio-radius-lg);bottom:12px;display:flex;left:50%;position:absolute;transform:translateX(-50%)}.MediaPreview-module__voiceVideoControlsToggle___prGk3{border-radius:var(--cbio-radius-pill);height:36px;width:36px}.MediaPreview-module__voiceVideoControlsToggle___prGk3:disabled{cursor:not-allowed}.MediaPreview-module__voiceVideoControlsToggleOff___ql_2k{color:var(--cbio-color-danger)}.MediaPreview-module__voiceVideoControlsToggleOff___ql_2k:not(:disabled):hover{background-color:var(--cbio-color-background-light)}.MediaPreview-module__voiceVideoControlsToggleOn___URkye{color:var(--cbio-color-text-strong)}.MediaPreview-module__voiceVideoControlsToggleOn___URkye:not(:disabled):hover{background-color:var(--cbio-color-background-light)}.MediaPreview-module__voiceVideoControlsIcon___yrQoV{height:24px;width:24px}";